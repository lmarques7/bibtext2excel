% This file was created with JabRef 2.7.
% Encoding: MacRoman

@INBOOK{springerlink:10.1007/978-3-540-72901-3_1,
  pages = {1-16},
  title = {An Open Source Domain-Specific Tools Framework to Support Model Driven
	Development of OSS},
  publisher = {Springer Berlin / Heidelberg},
  year = {2007},
  editor = {Akehurst, David and Vogel, Régis and Paige, Richard},
  author = {Achilleos, Achilleas and Georgalas, Nektarios and Yang, Kun},
  volume = {4530},
  series = {Lecture Notes in Computer Science},
  note = {10.1007/978-3-540-72901-3_1},
  abstract = {Telecommunications companies undergo massive transformations which
	reflect onto exacting requirements for controlling the costs of new
	Operation Support Systems (OSS) development and integration. This
	calls for the adoption of new approaches, which improve agility and
	reusability. Model Drive Development (MDD), as specified by OMG,
	can drastically tackle these issues and has, therefore, attracted
	the interest of the telecommunications industry. Equally important
	is the Open Source paradigm. For MDD to gain wide industrial adoption,
	tools should be available to facilitate the OSS development process.
	In this paper, we specify requirements MDD tools should meet for
	effective application of the approach. An extensive survey is then
	carried out to evaluate existing meta-modelling frameworks over the
	identified tools requirements. Eventually, we present the Integrated
	Eclipse Model driven Environment (IEME), which comprises a unified
	environment of bundled Eclipse-based MDD facilities that also supports
	the automatic generation of domain-specific tools.},
  affiliation = {University of Essex, Dept. of Electronic Systems Engineering UK UK},
  booktitle = {Model Driven Architecture- Foundations and Applications},
  isbn = {978-3-540-72900-6},
  keyword = {Computer Science},
  owner = {daniel},
  timestamp = {2011.11.06},
  url = {http://dx.doi.org/10.1007/978-3-540-72901-3_1}
}

@INBOOK{springerlink:10.1007/11561347_6,
  pages = {63-77},
  title = {On Domain-Specific Languages Reengineering},
  publisher = {Springer Berlin / Heidelberg},
  year = {2005},
  editor = {Glück, Robert and Lowry, Michael},
  author = {Alias, Christophe and Barthou, Denis},
  volume = {3676},
  series = {Lecture Notes in Computer Science},
  note = {10.1007/11561347_6},
  abstract = {Domain-specific languages (DSL) provides high-level functions making
	applications easier to write, and to maintain. Unfortunately, many
	applications are written from scratch and poorly documented, which
	make them hard to maintain. An ideal solution should be to rewrite
	them in a appropriate DSL. In this paper, we present TeMa ( Te mplate
	Ma tcher), an automatic tool to recognize high-level functions in
	source code. Preliminary results show how TeMa can be used to reformulate
	Fortran code into Signal Processing Language (SPL) used in SPIRAL.
	This opens new possibilities for domain-specific languages.},
  affiliation = {Laboratoire PRiSM, Université de Versailles, France},
  booktitle = {Generative Programming and Component Engineering},
  isbn = {978-3-540-29138-1},
  keyword = {Computer Science},
  owner = {daniel},
  timestamp = {2011.11.06},
  url = {http://dx.doi.org/10.1007/11561347_6}
}

@INBOOK{springerlink:10.1007/978-3-540-68073-4_15,
  pages = {166-177},
  title = {Managing Large Scale Reuse Across Multiple Software Product Lines},
  publisher = {Springer Berlin / Heidelberg},
  year = {2008},
  editor = {Mei, Hong},
  author = {Altintas, N. and Cetin, Semih},
  volume = {5030},
  series = {Lecture Notes in Computer Science},
  note = {10.1007/978-3-540-68073-4_15},
  abstract = {For large scale applications in today’s competitive business environment,
	partial reuse at class, library, component or module level is still
	inadequate. Software product lines provide systematic reuse only
	within a product family. Better gains in productivity and high confidentiality
	can be achieved by large scale reuse across multiple product lines.
	This paper puts a methodical way, articulated as “Software Factory
	Automation”, which can manage reusable assets across distinct software
	product lines based on “domain specific kits” and “software
	asset meta model”. The approach is validated by analyzing the software
	asset reuse in two different product lines implemented in banking
	domain and practically used in real life. The results show that high
	level of reuse within and across multiple product lines can be achieved
	with the charted roadmap.},
  affiliation = {Cybersoft Information Technologies Ata Plaza 3/3, Kat:3 34758 Istanbul
	Turkey},
  booktitle = {High Confidence Software Reuse in Large Systems},
  isbn = {978-3-540-68062-8},
  keyword = {Computer Science},
  owner = {daniel},
  timestamp = {2011.11.06},
  url = {http://dx.doi.org/10.1007/978-3-540-68073-4_15}
}

@INBOOK{springerlink:10.1007/978-3-540-75912-6_5,
  pages = {54-68},
  title = {Industrializing Software Development: The “Factory Automation”
	Way},
  publisher = {Springer Berlin / Heidelberg},
  year = {2007},
  editor = {Draheim, Dirk and Weber, Gerald},
  author = {Altintas, N. and Cetin, Semih and Dogru, Ali},
  volume = {4473},
  series = {Lecture Notes in Computer Science},
  note = {10.1007/978-3-540-75912-6_5},
  abstract = {Improving the productivity by means of systematic reuse has been a
	major challenge particularly for the last decade in software industry.
	Following the individual techniques like Architecture-Based Development,
	Model-Driven Development and Software Product Lines, Software Factories
	have eventually come to the stage as an umbrella solution to software
	productivity problem by assembling the applications with frameworks,
	patterns, models and tools. While this theoretically seems quite
	suitable, it still needs practical guidance at certain points such
	as defining and orchestrating reusable assets for setting up distinct
	software factories. This paper proposes a methodical way for such
	difficulties in establishing software factories as the way other
	manufacturing industries have been doing for several decades, which
	is known to be “factory automation”. We articulate the “software
	factory automation” for managing reusable assets across distinct
	software product lines based on an architecture-driven software factory
	meta-model and tailoring them to form directly executable software
	assets.},
  affiliation = {Cybersoft Information Technologies, Ata Plaza 3/3, Kat:3, 34758, Istanbul
	Turkey},
  booktitle = {Trends in Enterprise Application Architecture},
  isbn = {978-3-540-75911-9},
  keyword = {Computer Science},
  owner = {daniel},
  timestamp = {2011.11.06},
  url = {http://dx.doi.org/10.1007/978-3-540-75912-6_5}
}

@INBOOK{springerlink:10.1007/11951148_12,
  pages = {183-197},
  title = {Evaluation of Development Tools for Domain-Specific Modeling Languages},
  publisher = {Springer Berlin / Heidelberg},
  year = {2006},
  editor = {Gotzhein, Reinhard and Reed, Rick},
  author = {Amyot, Daniel and Farah, Hanna and Roy, Jean-François},
  volume = {4320},
  series = {Lecture Notes in Computer Science},
  note = {10.1007/11951148_12},
  abstract = {Creating and maintaining tools for domain-specific modeling languages
	(DSML) demands time and efforts that often discourage potential developers.
	However, several tools are now available that promise to accelerate
	the development of DSML environments. In this paper, we evaluate
	five such tools (GME, Tau G2, RSA, XMF-Mosaic, and Eclipse with GEF
	and EMF) by observing how well they can be used to create graphical
	editors for the Goal-oriented Requirement Language (GRL), for which
	a simplified metamodel is provided. We discuss the evaluation criteria,
	results, and lessons learned during the creation of GRL editors with
	these technologies.},
  affiliation = {SITE, University of Ottawa, Ottawa, Canada},
  booktitle = {System Analysis and Modeling: Language Profiles},
  isbn = {978-3-540-68371-1},
  keyword = {Computer Science},
  owner = {daniel},
  timestamp = {2011.11.06},
  url = {http://dx.doi.org/10.1007/11951148_12}
}

@ARTICLE{springerlink:10.1007/s001650050027,
  author = {Anderson, Stuart and Tourlas, Konstantinos},
  title = {Design for Proof: An Approach to the Design of Domain-Specific Languages},
  journal = {Formal Aspects of Computing},
  year = {1998},
  volume = {10},
  pages = {452-468},
  note = {10.1007/s001650050027},
  abstract = {We propose that the domain of a Domain-Specific Language (DSL) can
	be characterised by: 1. the class of environments in which systems
	developed in the language are expected to operate; and 2. the class
	of properties which such systems are expected to possess. The design
	of DSLs should therefore include the development of a proof system
	that eases the task of proving the properties in the class identified
	for the anticipated operating environments. We develop these ideas
	in the context of industrial computing systems by presenting a semantics
	and proof system for a language based on IEC 1131-3, the international
	standard programming language for programmable controllers. Of particular
	significance in this example is the use of a diagrammatic representation
	and the development of a proof system for a class of invariance properties
	that requires only local knowledge of the structure of diagrams.},
  affiliation = {Laboratory for the Foundations of Computer Science, Division of Informatics,
	The University of Edinburgh, Edinburgh UK UK},
  issn = {0934-5043},
  issue = {5},
  keyword = {Computer Science},
  owner = {daniel},
  publisher = {Springer London},
  timestamp = {2011.11.06},
  url = {http://dx.doi.org/10.1007/s001650050027}
}

@INBOOK{springerlink:10.1007/978-3-540-31797-5_19,
  pages = {187-197},
  title = {Experiences in Modeling for a Domain Specific Language},
  publisher = {Springer Berlin / Heidelberg},
  year = {2005},
  editor = {Jardim Nunes, Nuno and Selic, Bran and Rodrigues da Silva, Alberto
	and Toval Alvarez, Ambrosio},
  author = {Anonsen, Steve},
  volume = {3297},
  series = {Lecture Notes in Computer Science},
  note = {10.1007/978-3-540-31797-5_19},
  abstract = {Building models with a domain specific language enables targeting
	specific platform and framework functionality. We built a domain
	specific language for use in modeling applications targeting our
	business application framework. Such models are used for tasks including
	generating C# code and producing object-relational mappings for business
	objects. The paper briefly describes the framework and its accompanying
	domain specific language and then describes issues we encountered
	in using an unconstrained UML tool to express our models, solutions
	we developed to deal with those issues and observations about the
	suitability of UML for application to such problems. We found that
	making a general-purpose, extensible modeling language serve the
	needs of a targeted domain specific language is a lot of work and
	is only partially successful. We conclude that what is needed is
	a more general purpose framework for creating domain specific languages
	and tools for them.},
  affiliation = {Microsoft Corporation},
  booktitle = {UML Modeling Languages and Applications},
  isbn = {978-3-540-25081-4},
  keyword = {Computer Science},
  owner = {daniel},
  timestamp = {2011.11.06},
  url = {http://dx.doi.org/10.1007/978-3-540-31797-5_19}
}

@INBOOK{springerlink:10.1007/11880240_48,
  pages = {692-706},
  title = {Framework-Specific Modeling Languages with Round-Trip Engineering},
  publisher = {Springer Berlin / Heidelberg},
  year = {2006},
  editor = {Nierstrasz, Oscar and Whittle, Jon and Harel, David and Reggio, Gianna},
  author = {Antkiewicz, Michał and Czarnecki, Krzysztof},
  volume = {4199},
  series = {Lecture Notes in Computer Science},
  note = {10.1007/11880240_48},
  abstract = {We propose Framework-Specific Modeling Languages (FSMLs) as a special
	category of Domain-Specific Modeling Languages that are defined on
	top of an object-oriented application framework. They are used to
	express models showing how framework-provided abstractions are used
	in framework-based application code. Such models may be connected
	with the application code through a forward and a reverse mapping
	enabling round-trip engineering. We also propose a lightweight and
	iterative approach to round-trip engineering. Furthermore, we present
	a proof-of-concept FSML for modeling the interaction of workbench
	parts within Eclipse. Finally, we identify a number of challenges,
	opportunities, and directions for future research on FSMLs.},
  affiliation = {University of Waterloo},
  booktitle = {Model Driven Engineering Languages and Systems},
  isbn = {978-3-540-45772-5},
  keyword = {Computer Science},
  owner = {daniel},
  timestamp = {2011.11.06},
  url = {http://dx.doi.org/10.1007/11880240_48}
}

@ARTICLE{springerlink:10.1007/s11227-010-0490-3,
  author = {Arora, Ritu and Bangalore, Purushotham and Mernik, Marjan},
  title = {Raising the level of abstraction for developing message passing applications},
  journal = {The Journal of Supercomputing},
  pages = {1-22},
  note = {10.1007/s11227-010-0490-3},
  abstract = {Message Passing Interface (MPI) is the most popular standard for writing
	portable and scalable parallel applications for distributed memory
	architectures. Writing efficient parallel applications using MPI
	is a complex task, mainly due to the extra burden on programmers
	to explicitly handle all the complexities of message-passing (viz.,
	inter-process communication, data distribution, load-balancing, and
	synchronization). The main goal of our research is to raise the level
	of abstraction of explicit parallelization using MPI such that the
	effort involved in developing parallel applications is significantly
	reduced in terms of the reduction in the amount of code written manually
	while avoiding intrusive changes to existing sequential programs.
	In this research, generative programming tools and techniques are
	combined with a domain-specific language, Hi-PaL (High-Level Parallelization
	Language), for automating the process of generating and inserting
	the required code for parallelization into the existing sequential
	applications. The results show that the performance of the generated
	applications is comparable to the manually written versions of the
	applications, while requiring no explicit changes to the existing
	sequential code.},
  affiliation = {Department of Computer and Information Sciences, The University of
	Alabama at Birmingham, 1300 University Boulevard, Birmingham, AL
	35294-1170, USA},
  issn = {0920-8542},
  keyword = {Computer Science},
  owner = {daniel},
  publisher = {Springer Netherlands},
  timestamp = {2011.11.06},
  url = {http://dx.doi.org/10.1007/s11227-010-0490-3}
}

@ARTICLE{springerlink:10.1007/s11227-010-0383-5,
  author = {Arora, Ritu and Bangalore, Purushotham and Mernik, Marjan},
  title = {A technique for non-invasive application-level checkpointing},
  journal = {The Journal of Supercomputing},
  year = {2011},
  volume = {57},
  pages = {227-255},
  note = {10.1007/s11227-010-0383-5},
  abstract = {One of the key elements required for writing self-healing applications
	for distributed and dynamic computing environments is checkpointing.
	Checkpointing is a mechanism by which an application is made resilient
	to failures by storing its state periodically to the disk. The main
	goal of this research is to enable non-invasive reengineering of
	existing applications to insert Application-Level Checkpointing (ALC)
	mechanism. The Domain-Specific Language (DSL) developed in this research
	serves as a perfect means towards this end and is used for obtaining
	the ALC-specifications from the end-users. These specifications are
	used for generating and inserting the actual checkpointing code into
	the existing application. The performance of the application having
	the generated checkpointing code is comparable to the performance
	of the application in which the checkpointing code was inserted manually.
	With slight modifications, the DSL developed in this research can
	be used for specifying the ALC mechanism in several base languages
	(e.g., C/C++, Java, and FORTRAN).},
  affiliation = {Dept. of Computer and Information Sciences, The University of Alabama
	at Birmingham, 1300 University Blvd., Birmingham, AL 35294-1170,
	USA},
  issn = {0920-8542},
  issue = {3},
  keyword = {Computer Science},
  owner = {daniel},
  publisher = {Springer Netherlands},
  timestamp = {2011.11.06},
  url = {http://dx.doi.org/10.1007/s11227-010-0383-5}
}

@INBOOK{springerlink:10.1007/978-3-540-89778-1_6,
  pages = {25-42},
  title = {Could an Agile Requirements Analysis Be Automated?—Lessons Learned
	from the Successful Overhauling of an Industrial Automation System},
  publisher = {Springer Berlin / Heidelberg},
  year = {2008},
  editor = {Paech, Barbara and Martell, Craig},
  author = {Aschauer, Thomas and Dauenhauer, Gerd and Derler, Patricia and Pree,
	Wolfgang and Steindl, Christoph},
  volume = {5320},
  series = {Lecture Notes in Computer Science},
  note = {10.1007/978-3-540-89778-1_6},
  abstract = {This paper sketches a recent successful requirements analysis of a
	complex industrial automation system that mainly required a talented
	expert, with a beginner’s mind, who has been willing to dig into
	the domain details together with a committed customer and a motivated
	team. With these key factors and the application of an appropriate
	combination of well-established and some newer methods and tools,
	we were able to efficiently elicit, refine, and validate requirements.
	From this specific context, we try to derive implications for innovative
	requirements analysis. We argue that in projects that go beyond simple,
	well defined, and well understood applications, automated requirements
	analysis is unlikely to lead to a successful specification of a system.},
  affiliation = {Univ. Salzburg C. Doppler Laboratory Embedded Software Systems Jakob-Haringer-Str.
	2 5020 Salzburg Austria},
  booktitle = {Innovations for Requirement Analysis. From Stakeholders’ Needs
	to Formal Designs},
  isbn = {978-3-540-89777-4},
  keyword = {Computer Science},
  owner = {daniel},
  timestamp = {2011.11.06},
  url = {http://dx.doi.org/10.1007/978-3-540-89778-1_6}
}

@INBOOK{springerlink:10.1007/11768012_23,
  pages = {213-222},
  title = {ASHDM – Model-Driven Adaptation and Meta-adaptation},
  publisher = {Springer Berlin / Heidelberg},
  year = {2006},
  editor = {Wade, Vincent and Ashman, Helen and Smyth, Barry},
  author = {de Assis, Patricia and Schwabe, Daniel and Nunes, Demetrius},
  volume = {4018},
  series = {Lecture Notes in Computer Science},
  note = {10.1007/11768012_23},
  abstract = {In this work we propose a general purpose architecture for adaptation
	and meta-adaptation in hypermedia systems, using the Adaptive Semantic
	Hypermedia Design Model together with the Hypermedia Development
	Environment, extended to include adaptation. This architecture is
	model-driven and ontology-based, so data and model may be handled
	in the same way.},
  affiliation = {Grupo ROCA / Instituto Politécnico, Campus Regional de Nova Friburgo,
	Universidade Estadual do Rio de Janeiro (UERJ), Caixa Postal 97282,
	28610-974 Friburgo, RJ Brazil},
  booktitle = {Adaptive Hypermedia and Adaptive Web-Based Systems},
  isbn = {978-3-540-34696-8},
  keyword = {Computer Science},
  owner = {daniel},
  timestamp = {2011.11.06},
  url = {http://dx.doi.org/10.1007/11768012_23}
}

@INBOOK{springerlink:10.1007/11557432_30,
  pages = {398-413},
  title = {Concepts for Comparing Modeling Tool Architectures},
  publisher = {Springer Berlin / Heidelberg},
  year = {2005},
  editor = {Briand, Lionel and Williams, Clay},
  author = {Atkinson, Colin and Kühne, Thomas},
  volume = {3713},
  series = {Lecture Notes in Computer Science},
  note = {10.1007/11557432_30},
  abstract = {As model-driven development techniques grow in importance so do the
	capabilities and features of the tools that support them, especially
	tools that allow users to customize their modeling language. Superficially,
	many modeling tools seem to offer similar functionality, but under
	the surface there are important differences that can have an impact
	on tool builders and users depending on the tool architecture chosen.
	At present, however, there is no established conceptual framework
	for characterizing and comparing different tool architectures. In
	this paper we address this problem by first introducing a conceptual
	framework for capturing tool architectures, and then — using this
	framework — discuss the choices available to designers of tools.
	We then compare and contrast the main canonical architectures in
	use today.},
  affiliation = {University of Mannheim},
  booktitle = {Model Driven Engineering Languages and Systems},
  isbn = {978-3-540-29010-0},
  keyword = {Computer Science},
  owner = {daniel},
  timestamp = {2011.11.06},
  url = {http://dx.doi.org/10.1007/11557432_30}
}

@INBOOK{springerlink:10.1007/978-3-540-75492-3_4,
  pages = {38-49},
  title = {A Language for Quality of Service Requirements Specification in Web
	Services Orchestrations},
  publisher = {Springer Berlin / Heidelberg},
  year = {2007},
  editor = {Georgakopoulos, Dimitrios and Ritter, Norbert and Benatallah, Boualem
	and Zirpins, Christian and Feuerlicht, George and Schoenherr, Marten
	and Motahari-Nezhad, Hamid},
  author = {Baligand, Fabien and Le Botlan, Didier and Ledoux, Thomas and Combes,
	Pierre},
  volume = {4652},
  series = {Lecture Notes in Computer Science},
  note = {10.1007/978-3-540-75492-3_4},
  abstract = {Service Oriented Architectures industry aims to deliver agile service
	infrastructures. In this context, solutions to specify service compositions
	(mostly BPEL language) and Quality of Service (QoS) of individual
	services have emerged. However, architects still lack adapted means
	to specify and implement QoS in service compositions. Typically,
	they use ad-hoc technical solutions that significantly reduce flexibility
	and require cost-effective development. Our approach aims to overcome
	this shortcoming by introducing both a new language and tool for
	QoS specification and implementation in service compositions. More
	specifically, our language is a declarative domain-specific language
	that allows the architect to specify QoS constraints and mechanisms
	in Web Service orchestrations. Our tool is responsible for the QoS
	constraints processing and for QoS mechanisms injection into the
	orchestration. A key property of our approach is to preserve compatibility
	with existing languages and standards. In this paper, we present
	our language and tool, as well as an illustrative scenario dealing
	with multiple QoS concerns.},
  affiliation = {France Telecom - R&D / MAPS / AMS, 38-40 rue du general Leclerc, 92794
	Issy les Moulineaux France},
  booktitle = {Service-Oriented Computing ICSOC 2006},
  isbn = {978-3-540-75491-6},
  keyword = {Computer Science},
  owner = {daniel},
  timestamp = {2011.11.06},
  url = {http://dx.doi.org/10.1007/978-3-540-75492-3_4}
}

@INBOOK{springerlink:10.1007/3-540-45821-2_6,
  pages = {93-109},
  title = {A Protocol Stack Development Tool Using Generative Programming},
  publisher = {Springer Berlin / Heidelberg},
  year = {2002},
  editor = {Batory, Don and Consel, Charles and Taha, Walid},
  author = {Barbeau, Michel and Bordeleau, Francis},
  volume = {2487},
  series = {Lecture Notes in Computer Science},
  note = {10.1007/3-540-45821-2_6},
  abstract = {Traditional protocol implementation approaches capture the structural
	aspects of protocols in a common base that can be used accross layers.
	However, they are usually not very good at capturing the behavioral
	aspects. Two important implementation problems result, namely, reprogramming
	similar behavior and configuration of crosscutting concerns. In this
	paper, we present an approach to solve the problems of reprogramming
	similar behavior and absence of systematic configuration mechanisms
	for crosscutting concerns in communication systems. Our approach
	is based on generative programming, has been implemented in C++ and
	has been validated with several protocols. We also sketch an approach
	for run-time reconfigurable protocol stacks.},
  affiliation = {Carleton University School of Computer Science 1125 Colonel By Drive
	Ottawa Ontario Canada K1S 5B6},
  booktitle = {Generative Programming and Component Engineering},
  isbn = {978-3-540-44284-4},
  keyword = {Computer Science},
  owner = {daniel},
  timestamp = {2011.11.06},
  url = {http://dx.doi.org/10.1007/3-540-45821-2_6}
}

@INBOOK{springerlink:10.1007/3-540-47853-1_11,
  pages = {61-88},
  title = {Generative Programming},
  publisher = {Springer Berlin / Heidelberg},
  year = {2002},
  editor = {Frohner, Ákos},
  author = {Barth, Barbara and Butler, Greg and Czarnecki, Krzysztof and Eisenecker,
	Ulrich},
  volume = {2323},
  series = {Lecture Notes in Computer Science},
  note = {10.1007/3-540-47853-1_11},
  abstract = {This report describes the results of a one-day workshop on Generative
	Programming (GP) at ECOOP’01. The goal of the workshop was to discuss
	the state-of-the-art of generative programming, share experience,
	consolidate successful techniques, discuss the relation of GP to
	object-oriented programming and other emerging approaches such as
	Aspect-Oriented Programming or Multidimensional Decomposition, and
	identify open issues for future work. This report gives a summary
	of the workshop contributions, debates, and the identified future
	directions.},
  affiliation = {University of Applied Sciences Kaiserslautern Zweibrücken Germany},
  booktitle = {Object-Oriented Technology},
  isbn = {978-3-540-43675-1},
  keyword = {Computer Science},
  owner = {daniel},
  timestamp = {2011.11.06},
  url = {http://dx.doi.org/10.1007/3-540-47853-1_11}
}

@INBOOK{springerlink:10.1007/978-3-540-71229-9_11,
  pages = {156-171},
  title = {Program Refactoring, Program Synthesis, and Model-Driven Development},
  publisher = {Springer Berlin / Heidelberg},
  year = {2007},
  editor = {Krishnamurthi, Shriram and Odersky, Martin},
  author = {Batory, Don},
  volume = {4420},
  series = {Lecture Notes in Computer Science},
  note = {10.1007/978-3-540-71229-9_11},
  abstract = {Program refactoring, feature-based and aspect-oriented software synthesis,
	and model-driven development are disjoint research areas. However,
	they are all architectural metaprogramming technologies as they treat
	programs as values and use functions (a.k.a. transformations ) to
	map programs to other programs. In this paper, I explore their underlying
	connections by reviewing recent advances in each area from an architectural
	metaprogramming perspective. I conjecture how these areas can converge
	and outline a theory that may unify them.},
  affiliation = {Department of Computer Sciences, University of Texas at Austin},
  booktitle = {Compiler Construction},
  isbn = {978-3-540-71228-2},
  keyword = {Computer Science},
  owner = {daniel},
  timestamp = {2011.11.06},
  url = {http://dx.doi.org/10.1007/978-3-540-71229-9_11}
}

@INBOOK{springerlink:10.1007/978-3-540-25935-0_1,
  pages = {211-250},
  title = {The Road to Utopia: A Future for Generative Programming},
  publisher = {Springer Berlin / Heidelberg},
  year = {2004},
  editor = {Lengauer, Christian and Batory, Don and Consel, Charles and Odersky,
	Martin},
  author = {Batory, Don},
  volume = {3016},
  series = {Lecture Notes in Computer Science},
  note = {10.1007/978-3-540-25935-0_1},
  abstract = {The future of software engineering lies in automation and will exploit
	the combined strengths of generative programming, domain-specific
	languages, and automatic programming. While each of these areas is
	still in its infancy, a spectacularly successful example of their
	combination was realized twenty-five years ago: relational query
	optimization. In this paper, I chart the successes and mindset used
	by database researchers to generate efficient query processing programs
	automatically. I argue that the road that they have so successfully
	followed is the same road that the generative programming, domain-specific
	languages, and automatic programming communities are now traversing.},
  affiliation = {Department of Computer Sciences, University of Texas at Austin, Austin,
	Texas 78712},
  booktitle = {Domain-Specific Program Generation},
  isbn = {978-3-540-22119-7},
  keyword = {Computer Science},
  owner = {daniel},
  timestamp = {2011.11.06},
  url = {http://dx.doi.org/10.1007/978-3-540-25935-0_1}
}

@INBOOK{springerlink:10.1007/11877028_1,
  pages = {3-35},
  title = {A Tutorial on Feature Oriented Programming and the AHEAD Tool Suite},
  publisher = {Springer Berlin / Heidelberg},
  year = {2006},
  editor = {Lämmel, Ralf and Saraiva, João and Visser, Joost},
  author = {Batory, Don},
  volume = {4143},
  series = {Lecture Notes in Computer Science},
  note = {10.1007/11877028_1},
  abstract = {Feature oriented programming (FOP) is the study of feature mod ularity
	and its use in program synthesis. AHEAD is a theory of FOP that is
	based on a fundamental concept of generative programming that functions
	map programs. This enables the design of programs to be expressed
	compo sitionally as algebraic expressions, which are suited for automated
	analysis, manipulation, and program synthesis. This paper is a tutorial
	on FOP and AHEAD. We review AHEAD’s theory and the tool set that
	implements it.},
  affiliation = {Department of Computer Sciences, University of Texas at Austin, Austin,
	Texas 78712, U.S.A.},
  booktitle = {Generative and Transformational Techniques in Software Engineering},
  isbn = {978-3-540-45778-7},
  keyword = {Computer Science},
  owner = {daniel},
  timestamp = {2011.11.06},
  url = {http://dx.doi.org/10.1007/11877028_1}
}

@INBOOK{springerlink:10.1007/978-3-540-27815-3_2,
  pages = {53-56},
  title = {A Science of Software Design},
  publisher = {Springer Berlin / Heidelberg},
  year = {2004},
  editor = {Rattray, Charles and Maharaj, Savitri and Shankland, Carron},
  author = {Batory, Don},
  volume = {3116},
  series = {Lecture Notes in Computer Science},
  note = {10.1007/978-3-540-27815-3_2},
  abstract = {Underlying large-scale software design and program synthesis are simple
	and powerful algebraic models. In this paper, I review the elementary
	ideas upon which these algebras rest and argue that they define the
	basis for a science of software design.},
  affiliation = {Department of Computer Sciences, University of Texas at Austin, Austin,
	Texas 78746},
  booktitle = {Algebraic Methodology and Software Technology},
  isbn = {978-3-540-22381-8},
  keyword = {Computer Science},
  owner = {daniel},
  timestamp = {2011.11.06},
  url = {http://dx.doi.org/10.1007/978-3-540-27815-3_2}
}

@INBOOK{springerlink:10.1007/978-3-540-87875-9_1,
  pages = {1-20},
  title = {The Objects and Arrows of Computational Design},
  publisher = {Springer Berlin / Heidelberg},
  year = {2008},
  editor = {Czarnecki, Krzysztof and Ober, Ileana and Bruel, Jean-Michel and
	Uhl, Axel and Völter, Markus},
  author = {Batory, Don and Azanza, Maider and Saraiva, João},
  volume = {5301},
  series = {Lecture Notes in Computer Science},
  note = {10.1007/978-3-540-87875-9_1},
  abstract = {Computational Design ( CD ) is a paradigm where both program design
	and program synthesis are computations. CD merges Model Driven Engineering
	(MDE) which synthesizes programs by transforming models, with Software
	Product Lines (SPL) where programs are synthesized by composing transforma
	tions called features. In this paper, basic relationships between
	MDE and SPL are explored using the language of modern mathematics.
	Note: Although jointly authored, this paper is written as presented
	by Batory in his MODELS 2008 keynote.},
  affiliation = {University of Texas at Austin, Austin, Texas USA},
  booktitle = {Model Driven Engineering Languages and Systems},
  isbn = {978-3-540-87874-2},
  keyword = {Computer Science},
  owner = {daniel},
  timestamp = {2011.11.06},
  url = {http://dx.doi.org/10.1007/978-3-540-87875-9_1}
}

@INBOOK{springerlink:10.1007/978-3-540-44995-9_8,
  pages = {83-153},
  title = {Achieving Extensibility through Product-Lines and Domain-Specific
	Languages: A Case Study},
  publisher = {Springer Berlin / Heidelberg},
  year = {2000},
  editor = {Frakes, William},
  author = {Batory, Don and Johnson, Clay and MacDonald, Bob and von Heeder,
	Dale},
  volume = {1844},
  series = {Lecture Notes in Computer Science},
  note = {10.1007/978-3-540-44995-9_8},
  abstract = {This is a case study in the use of product-line architectures (PLAs)
	and domain-specific languages (DSLs) to design an extensible command-and-control
	simulator for Army fire support. The reusable components of our PLA
	are layers or “aspects” whose addition or removal simultaneously
	impacts the source code of multiple objects in multiple, distributed
	programs. The complexity of our component specifications is substantially
	reduced by using a DSL for defining and refining state machines,
	abstractions that are fundamental to simulators. We present preliminary
	results that show how our PLA and DSL synergistically produce a more
	flexible way of implementing state-machine-based simulators than
	is possible with a pure Java implementation.},
  affiliation = {Department of Computer Sciences, University of Texas at Austin Austin,
	Texas 78712},
  booktitle = {Software Reuse: Advances in Software Reusability},
  isbn = {978-3-540-67696-6},
  keyword = {Computer Science},
  owner = {daniel},
  timestamp = {2011.11.06},
  url = {http://dx.doi.org/10.1007/978-3-540-44995-9_8}
}

@INBOOK{springerlink:10.1007/11581741_6,
  pages = {59-73},
  title = {MDA Components: A Flexible Way for Implementing the MDA Approach},
  publisher = {Springer Berlin / Heidelberg},
  year = {2005},
  editor = {Hartman, Alan and Kreische, David},
  author = {Bendraou, Reda and Desfray, Philippe and Gervais, Marie-Pierre},
  volume = {3748},
  series = {Lecture Notes in Computer Science},
  note = {10.1007/11581741_6},
  abstract = {As the Model Driven Development (MDD) and Product Line Engineering
	(PLE) appear as major trends for reducing software development complexity
	and costs, an important missing stone becomes more visible: there
	is no standard and reusable assets for packaging the know-how and
	artifacts required when applied these approaches. To overcome this
	limit, we introduce in this paper the notion of MDA Component, i.e.,
	a packaging unit for encapsulating business know-how and required
	resources in order to support specific operations on a certain kind
	of model. The aim of this work is to provide a standard way for representing
	this know-how packaging units. This is done by introducing a two-layer
	MOF-compliant metamodel. Whilst the first layer focuses on the definition
	of the structure and contents of the MDA Component, the second layer
	introduces a language independent way for describing its behavior.
	For a full specification, both layers can be merged using the UML2.0
	package merge facility.},
  affiliation = {Laboratoire d’Informatique de Paris 6, 8 rue du Capitaine Scott,
	F75015 Paris},
  booktitle = {Model Driven Architecture – Foundations and Applications},
  isbn = {978-3-540-30026-7},
  keyword = {Computer Science},
  owner = {daniel},
  timestamp = {2011.11.06},
  url = {http://dx.doi.org/10.1007/11581741_6}
}

@INBOOK{springerlink:10.1007/978-3-540-44995-9_3,
  pages = {1-32},
  title = {From Application Domains to Executable Domains: Achieving Reuse with
	a Domain Network},
  publisher = {Springer Berlin / Heidelberg},
  year = {2000},
  editor = {Frakes, William},
  author = {Bergmann, Ulf and Sampaio do Prado Leite, Julio},
  volume = {1844},
  series = {Lecture Notes in Computer Science},
  note = {10.1007/978-3-540-44995-9_3},
  abstract = {Software generators are among the most effective methods for achieving
	software reuse. Describing an application using a domain specific
	language and then performing a single refinement step to an executable
	language is the approach used by most generators. This paper shows
	how to use the Domain Network (DN) concept, a set of interconnected
	domains, as a way to improve reuse in the context of software generation.},
  affiliation = {Departamento de Engenharia de Sistemas - Instituto Militar de Engenharia
	Praça General Tibúrcio 80 - Rio de Janeiro, 22290-240, Brasil},
  booktitle = {Software Reuse: Advances in Software Reusability},
  isbn = {978-3-540-67696-6},
  keyword = {Computer Science},
  owner = {daniel},
  timestamp = {2011.11.06},
  url = {http://dx.doi.org/10.1007/978-3-540-44995-9_3}
}

@INBOOK{springerlink:10.1007/978-3-540-69489-2_20,
  pages = {159-168},
  title = {OCL-Based Validation of a Railway Domain Profile},
  publisher = {Springer Berlin / Heidelberg},
  year = {2007},
  editor = {Kühne, Thomas},
  author = {Berkenkötter, Kirsten},
  volume = {4364},
  series = {Lecture Notes in Computer Science},
  note = {10.1007/978-3-540-69489-2_20},
  abstract = {Domain-specific languages become more and more important these days
	as they facilitate the close collaboration of domain experts and
	software developers. One effect of this general tendency is the increasing
	number of UML profiles. UML itself as a popular modeling language
	is capable of modeling all kinds of systems but it is often inefficient
	due to its wide-spectrum approach. Profiles tailor the UML to a specific
	domain and can hence be seen as domain-specific dialects of UML.
	At the moment, they mainly introduce new terminology, often in combination
	with OCL constraints which describe the new constructs more precisely.
	As most tools do not support validation of OCL expressions let alone
	supplementing profiles with OCL constraints, it is difficult to check
	if models based on a profile comply to this profile. A related problem
	is checking whether constraints in the profile contradict constraints
	in the UML specification. In this paper, it is shown how to complete
	these tasks with the tool USE. As an example, a profile from the
	railway control systems domain is taken which describes the use of
	its modeling elements strictly my means of OCL. Models based on this
	profile serve as a foundation for automated code generation and require
	unambiguous meaning.},
  affiliation = {University of Bremen, P.O. Box 330 440, 28334 Bremen Germany},
  booktitle = {Models in Software Engineering},
  isbn = {978-3-540-69488-5},
  keyword = {Computer Science},
  owner = {daniel},
  timestamp = {2011.11.06},
  url = {http://dx.doi.org/10.1007/978-3-540-69489-2_20}
}

@INBOOK{springerlink:10.1007/3-540-44800-4_1,
  pages = {1-9},
  title = {A Characterization of Generator and Component Reuse Technologies},
  publisher = {Springer Berlin / Heidelberg},
  year = {2001},
  editor = {Bosch, Jan},
  author = {Biggerstaff, Ted},
  volume = {2186},
  series = {Lecture Notes in Computer Science},
  note = {10.1007/3-540-44800-4_1},
  abstract = {This paper characterizes various categories of reuse technologies
	in terms of their underlying architectures, the kinds of problems
	that they handle well, and the kinds of problems that they do not
	handle well. In the end, it describes their operational envelopes
	and niches. The emphasis is on generative reuse technologies.},
  booktitle = {Generative and Component-Based Software Engineering},
  isbn = {978-3-540-42546-5},
  keyword = {Computer Science},
  owner = {daniel},
  timestamp = {2011.11.06},
  url = {http://dx.doi.org/10.1007/3-540-44800-4_1}
}

@INBOOK{springerlink:10.1007/3-540-46020-9_11,
  pages = {309-329},
  title = {Control Localization in Domain Specific Translation},
  publisher = {Springer Berlin / Heidelberg},
  year = {2002},
  editor = {Gacek, Cristina},
  author = {Biggerstaff, Ted},
  volume = {2319},
  series = {Lecture Notes in Computer Science},
  note = {10.1007/3-540-46020-9_11},
  abstract = {Domain specific languages (DSLs) excel at programming productivity
	because they provide large-grain composite data structures (e.g.,
	a graphics image) and large-grain operators for composition (e.g.,
	image addition or convolution). As a result, extensive computations
	can be written as APL-like one-liners that are equivalent to tens
	or hundreds of lines of code (LOC) when written in a conventional
	language like Java. The problem with DSL specifications is that they
	de-localize the code components making un-optimized machine translations
	significantly slower than for the human optimized equivalent. Specifically,
	operations on DSL composites imply multiple control structures (e.g.,
	loops) that process the individual elements of large-grain composites
	and those multiple, implicit control structures are distributed (i.e.,
	de-localized) across the expression of operators and operands. Human
	programmers recognize the relation among these distributed control
	structures and merge them to minimize the redundancy of control.
	For example, merged control structures may perform several operations
	on several large-grain data structures in a single pass. This merging
	is the process of control localization . This paper discusses strategies
	for automating localization without large search spaces and outlines
	a domain specific example of transformation rules for localizing
	control. The example is based on the localization method in the Anticipatory
	Optimization Generator (AOG) system [3-8].},
  booktitle = {Software Reuse: Methods, Techniques, and Tools},
  isbn = {978-3-540-43483-2},
  keyword = {Computer Science},
  owner = {daniel},
  timestamp = {2011.11.06},
  url = {http://dx.doi.org/10.1007/3-540-46020-9_11}
}

@INBOOK{springerlink:10.1007/11589976_12,
  pages = {187-206},
  title = {Formal Methods Meet Domain Specific Languages},
  publisher = {Springer Berlin / Heidelberg},
  year = {2005},
  editor = {Romijn, Judi and Smith, Graeme and van de Pol, Jaco},
  author = {Bodeveix, Jean-Paul and Filali, Mamoun and Lawall, Julia and Muller,
	Gilles},
  volume = {3771},
  series = {Lecture Notes in Computer Science},
  note = {10.1007/11589976_12},
  abstract = {In this paper, we relate an experiment whose aim is to study how to
	combine two existing approaches for ensuring software correctness:
	Domain Specific Languages (DSLs) and formal methods. As examples,
	we consider the Bossa DSL and the B formal method. Bossa is dedicated
	to the development of process schedulers and has been used in the
	context of Linux and Chorus. B is a refinement based formal method
	which has especially been used in the domain of railway systems.
	In this paper, we use B to express the correctness of a Bossa specification.
	Furthermore, we show how B can be used as an alternative to the existing
	Bossa tools for the production of certified schedulers.},
  affiliation = {IRIT Université Paul Sabatier, 118 route de Narbonne, F-31062 Cedex
	Toulouse, France},
  booktitle = {Integrated Formal Methods},
  isbn = {978-3-540-30492-0},
  keyword = {Computer Science},
  owner = {daniel},
  timestamp = {2011.11.06},
  url = {http://dx.doi.org/10.1007/11589976_12}
}

@INBOOK{springerlink:10.1007/978-3-540-73230-3_9,
  pages = {114-127},
  title = {Correctness by Construction for High-Integrity Real-Time Systems:
	A Metamodel-Driven Approach},
  publisher = {Springer Berlin / Heidelberg},
  year = {2007},
  editor = {Abdennahder, Nabil and Kordon, Fabrice},
  author = {Bordin, Matteo and Vardanega, Tullio},
  volume = {4498},
  series = {Lecture Notes in Computer Science},
  note = {10.1007/978-3-540-73230-3_9},
  abstract = {Current trends in software engineering promote the contention that
	the use of model-driven approaches should prove as beneficial to
	high-integrity systems as they have to business applications. Unfortunately,
	model-driven approaches as they presently stand focus more on attaining
	greater extents of automation than on warranting absolute end-to-end
	correctness for the target development process. This paper presents
	some elements of a novel approach that centres on a correctness-by-construction
	philosophy rooted on a domain-specific metamodel designed to formally
	define and constrain the design space and prove the allowable model
	transformations down to automated code generation.},
  affiliation = {Department of Pure and Applied Mathematics, University of Padua, via
	Trieste 63, 35121 Padova Italy},
  booktitle = {Reliable Software Technologies – Ada Europe 2007},
  isbn = {978-3-540-73229-7},
  keyword = {Computer Science},
  owner = {daniel},
  timestamp = {2011.11.06},
  url = {http://dx.doi.org/10.1007/978-3-540-73230-3_9}
}

@ARTICLE{springerlink:10.1007/s10270-010-0171-y,
  author = {Bošković, Marko and Gašević, Dragan and Pahl, Claus and Schätz,
	Bernhard},
  title = {Guest editorial to the theme issue on non-functional system properties
	in domain specific modeling languages},
  journal = {Software and Systems Modeling},
  year = {2011},
  volume = {10},
  pages = {283-286},
  note = {10.1007/s10270-010-0171-y},
  affiliation = {School of Computing and Information Systems, Athabasca University,
	1 University Drive, Athabasca, AB T9S 3A3, Canada},
  issn = {1619-1366},
  issue = {3},
  keyword = {Computer Science},
  owner = {daniel},
  publisher = {Springer Berlin / Heidelberg},
  timestamp = {2011.11.06},
  url = {http://dx.doi.org/10.1007/s10270-010-0171-y}
}

@INBOOK{springerlink:10.1007/11787044_19,
  pages = {241-255},
  title = {Business Process Modeling: Defining Domain Specific Modeling Languages
	by Use of UML Profiles},
  publisher = {Springer Berlin / Heidelberg},
  year = {2006},
  editor = {Rensink, Arend and Warmer, Jos},
  author = {Brahe, Steen and Østerbye, Kasper},
  volume = {4066},
  series = {Lecture Notes in Computer Science},
  note = {10.1007/11787044_19},
  abstract = {General-purpose modeling languages are inadequate to model and visualize
	business processes precisely. An enterprise has its own vocabulary
	for modeling processes and its specific tasks may have attached data
	that define the tasks precisely. We propose using Domain Specific
	Modeling (DSM) languages to model business processes, such that an
	enterprise can define its own DSM language(s) capturing its vocabulary
	and data requirement. We suggest using UML profiles and UML activity
	diagrams as the semantic base for these DSM languages and present
	tools that are able to create a DSM language and tool support for
	a given domain. One tool, called ADSpecializer, can generate a UML
	profile and its tool support of a given application domain. The other
	tool, ADModeler, is used to create UML activity diagrams within such
	a domain-specific UML profile. The two tools enable an enterprise
	to efficiently define and utilize their own DSM language.},
  affiliation = {IT University of Copenhagen, Copenhagen, Denmark},
  booktitle = {Model Driven Architecture – Foundations and Applications},
  isbn = {978-3-540-35909-8},
  keyword = {Computer Science},
  owner = {daniel},
  timestamp = {2011.11.06},
  url = {http://dx.doi.org/10.1007/11787044_19}
}

@INBOOK{springerlink:10.1007/978-3-540-75492-3_15,
  pages = {166-177},
  title = {A Pattern-Based Approach to Business Process Modeling and Implementation
	in Web Services},
  publisher = {Springer Berlin / Heidelberg},
  year = {2007},
  editor = {Georgakopoulos, Dimitrios and Ritter, Norbert and Benatallah, Boualem
	and Zirpins, Christian and Feuerlicht, George and Schoenherr, Marten
	and Motahari-Nezhad, Hamid},
  author = {Brahe, Steen and Bordbar, Behzad},
  volume = {4652},
  series = {Lecture Notes in Computer Science},
  note = {10.1007/978-3-540-75492-3_15},
  abstract = {There are often three groups of experts involved in the design and
	implementation of business processes in a service oriented enterprise;
	business analysts , solution architects and system developers . They
	collaborate with each other to transform a high-level design created
	by a business analyst to a final executable workflow, based on a
	service composition language such as the Business Process Execution
	Language (BPEL). In this paper, we present a new approach to support
	and semi-automate this transformation process, thus producing applications
	of higher quality in shorter time. The idea is to capture existing
	knowledge in the enterprise, which is required for transforming models
	from one abstraction level to another, as reusable, parameterized
	patterns. These patterns are used for tool based model transformations
	of the business processes. To support our approach, we shall make
	use of Domain Specific Modeling Languages (DSMLs) designed for each
	enterprise to capture models of a business process at different levels
	of abstraction, each suitable for the use of one of the groups of
	experts. The presented approach bridges the gap between business
	and IT by providing customizable language-, tool- and transformation
	support for the different groups of experts within the enterprise
	and is illustrated by an example.},
  affiliation = {Danske Bank and IT University of Copenhagen Denmark},
  booktitle = {Service-Oriented Computing ICSOC 2006},
  isbn = {978-3-540-75491-6},
  keyword = {Computer Science},
  owner = {daniel},
  timestamp = {2011.11.06},
  url = {http://dx.doi.org/10.1007/978-3-540-75492-3_15}
}

@INBOOK{springerlink:10.1007/11877028_10,
  pages = {297-311},
  title = {MetaBorg in Action: Examples of Domain-Specific Language Embedding
	and Assimilation Using Stratego/XT},
  publisher = {Springer Berlin / Heidelberg},
  year = {2006},
  editor = {Lämmel, Ralf and Saraiva, João and Visser, Joost},
  author = {Bravenboer, Martin and de Groot, René and Visser, Eelco},
  volume = {4143},
  series = {Lecture Notes in Computer Science},
  note = {10.1007/11877028_10},
  abstract = {General-purpose programming languages provide limited facilities for
	expressing domain-specific concepts in a natural manner. All domain
	concepts need to be captured using the same generic syntactic and
	semantic constructs. Generative programming methods and program transformation
	techniques can be used to overcome this lack of abstraction in general-purpose
	languages. In this tutorial we describe the MetaBorg method for embedding
	domain-specific languages, tailored syntactically and semantically
	to the application domain at hand, in a general-purpose language.
	MetaBorg is based on Stratego/XT, a language and toolset for the
	implementation of program transformation systems, which is used for
	the definition of syntactic embeddings and assimilation of the embedded
	constructs into the surrounding code. We illustrate MetaBorg with
	three examples. JavaSwul is a custom designed language for implementing
	graphical user-interfaces, which provides high-level abstractions
	for component composition and event-handling. JavaRegex is a new
	embedding of regular expression matching and string rewriting. JavaJava
	is an embedding of Java in Java for generating Java code. For these
	cases we show how Java programs in these domains become dramatically
	more readable, and we give an impression of the implementation of
	the language embeddings.},
  affiliation = {Department of Information and Computing Sciences, Universiteit Utrecht,
	P.O. Box 80089, 3508 TB Utrecht, The Netherlands},
  booktitle = {Generative and Transformational Techniques in Software Engineering},
  isbn = {978-3-540-45778-7},
  keyword = {Computer Science},
  owner = {daniel},
  timestamp = {2011.11.06},
  url = {http://dx.doi.org/10.1007/11877028_10}
}

@INBOOK{springerlink:10.1007/978-3-540-69073-3_5,
  pages = {34-46},
  title = {Designing Syntax Embeddings and Assimilations for Language Libraries},
  publisher = {Springer Berlin / Heidelberg},
  year = {2008},
  editor = {Giese, Holger},
  author = {Bravenboer, Martin and Visser, Eelco},
  volume = {5002},
  series = {Lecture Notes in Computer Science},
  note = {10.1007/978-3-540-69073-3_5},
  abstract = {Language libraries extend regular libraries with domain-specific notation.
	More precisely, a language library is a combination of a domain-specific
	language embedded in the general-purpose host language, a regular
	library implementing the underlying functionality, and an assimilation
	transformation that maps embedded DSL fragments to host language
	code. While the basic architecture for realizing language libraries
	is the same for all applications, there are many design choices to
	be made in the design of a particular combination of library, guest
	language syntax, host language, and assimilation. In this paper,
	we give an overview of the design space for syntax embeddings and
	assimilations for the realization of language libraries.},
  affiliation = {Delft University of Technology Software Engineering Research Group
	The Netherlands},
  booktitle = {Models in Software Engineering},
  isbn = {978-3-540-69069-6},
  keyword = {Computer Science},
  owner = {daniel},
  timestamp = {2011.11.06},
  url = {http://dx.doi.org/10.1007/978-3-540-69073-3_5}
}

@INBOOK{springerlink:10.1007/978-3-540-74035-3_8,
  pages = {163-187},
  title = {Model-Centric Development of Highly Available Software Systems},
  publisher = {Springer Berlin / Heidelberg},
  year = {2007},
  editor = {de Lemos, Rogério and Gacek, Cristina and Romanovsky, Alexander},
  author = {Buskens, Rick and Gonzalez, Oscar},
  volume = {4615},
  series = {Lecture Notes in Computer Science},
  note = {10.1007/978-3-540-74035-3_8},
  abstract = {In today’s rapidly evolving marketplace, the ability to quickly
	build and deploy new systems is an increasingly critical factor in
	a company’s success. For certain domains, such as telecommunications,
	it is taken for granted that systems will be highly available, with
	expectations of “5 9s” or even higher availability, translating
	to five minutes or less downtime per year. However, building highly
	available systems is generally very challenging, and becoming even
	more challenging as the systems increase in complexity. High availability
	(HA) middleware solutions partially address this challenge by providing
	common HA services that system developers can use. However, developers
	still need to spend significant effort integrating their systems
	with the HA middleware. In this paper, we present the Aurora Management
	Workbench (AMW) as a solution to the integration problem. AMW is
	an HA middleware and tools for building highly available distributed
	software systems. It is unique in its approach for developing highly
	available systems: developers focus only on describing key architectural
	abstractions of their system as well as system high availability
	needs in the form of a model. Tools then use the model to generate
	much of the code needed to integrate the system with the AMW HA middleware,
	which also uses the model to coordinate and control HA services at
	run-time. This paper describes our approach and our initial successes
	using it to develop commercial telecom systems.},
  affiliation = {Lockheed Martin Advanced Technology Laboratories},
  booktitle = {Architecting Dependable Systems IV},
  isbn = {978-3-540-74033-9},
  keyword = {Computer Science},
  owner = {daniel},
  timestamp = {2011.11.06},
  url = {http://dx.doi.org/10.1007/978-3-540-74035-3_8}
}

@INBOOK{springerlink:10.1007/11663430_18,
  pages = {169-181},
  title = {sNets: A First Generation Model Engineering Platform},
  publisher = {Springer Berlin / Heidelberg},
  year = {2006},
  editor = {Bruel, Jean-Michel},
  author = {Bézivin, Jean},
  volume = {3844},
  series = {Lecture Notes in Computer Science},
  note = {10.1007/11663430_18},
  abstract = {As we are currently improving AMMA (the ATLAS Model Management Architecture),
	a second generation model engineering platform installed on top of
	the Eclipse Modeling Framework (EMF), we borrow inspiration from
	a previous work undertaken fifteen years ago at the University of
	Nantes. This initial model-engineering platform named sNets (for
	Semantic Networks) included several functional blocks like the sMachine
	, the sBrowser , the sQuery , the sAction system, etc. Several parts
	of these tools are still in use today. At a time when we are defining
	the main architectural style of the new platform, it may be helpful
	to come back on the initial learning of this project. This paper
	describes the sNets project and summarizes some lessons learnt in
	the course of the design and utilization of this first generation
	modeling framework.},
  affiliation = {Atlas Group, INRIA and LINA, University of Nantes, 2, rue de la Houssinière,
	BP92208, 44322 Cedex 3 Nantes, France},
  booktitle = {Satellite Events at the MoDELS 2005 Conference},
  isbn = {978-3-540-31780-7},
  keyword = {Computer Science},
  owner = {daniel},
  timestamp = {2011.11.06},
  url = {http://dx.doi.org/10.1007/11663430_18}
}

@INBOOK{springerlink:10.1007/11877028_2,
  pages = {36-64},
  title = {Model Driven Engineering: An Emerging Technical Space},
  publisher = {Springer Berlin / Heidelberg},
  year = {2006},
  editor = {Lämmel, Ralf and Saraiva, João and Visser, Joost},
  author = {Bézivin, Jean},
  volume = {4143},
  series = {Lecture Notes in Computer Science},
  note = {10.1007/11877028_2},
  abstract = {As an emerging solution to the handling of complex and evolving software
	systems, Model Driven Engineering (MDE) is still very much in evolution.
	The industrial demand is quite high while the research answer for
	a sound set of foundation principles is still far from being stabilized.
	Therefore it is important to provide a current state of the art in
	MDE, describing what its origins are, what its present state is,
	and where it seems to be presently leading. One important question
	is how MDE relates to other contemporary technologies. This tutorial
	proposes the ”technical space” concept to this purpose. The two
	main objectives are to present first the basic MDE principles and
	second how these principles may be mapped onto modern platform support.
	Other issues that will be discussed are the applicability of these
	ideas, concepts, and tools to solve current practical problems. Various
	organizations and companies (OMG, IBM, Microsoft, etc.) are currently
	proposing several environments claiming to support MDE. Among these,
	the OMG MDA TM (Model Driven Architecture) has a special place since
	it was historically one of the original proposals in this area. This
	work focuses on the identification of basic MDE principles, practical
	characteristics of MDE (direct representation, automation, and open
	standards), original MDE scenarios, and discussions of suitable tools
	and methods.},
  affiliation = {Atlas Group: INRIA, and LINA, University of Nantes, 2, rue de la Houssinière,
	BP92208, 44322 Nantes Cedex 3, France},
  booktitle = {Generative and Transformational Techniques in Software Engineering},
  isbn = {978-3-540-45778-7},
  keyword = {Computer Science},
  owner = {daniel},
  timestamp = {2011.11.06},
  url = {http://dx.doi.org/10.1007/11877028_2}
}

@ARTICLE{springerlink:10.1007/s10270-005-0079-0,
  author = {Bézivin, Jean},
  title = {On the unification power of models},
  journal = {Software and Systems Modeling},
  year = {2005},
  volume = {4},
  pages = {171-188},
  note = {10.1007/s10270-005-0079-0},
  abstract = {In November 2000, the OMG made public the MDA™initiative, a particular
	variant of a new global trend called MDE (Model Driven Engineering).
	The basic ideas of MDA are germane to many other approaches such
	as generative programming, domain specific languages, model-integrated
	computing, generic model management, software factories, etc. MDA
	may be defined as the realization of MDE principles around a set
	of OMG standards like MOF, XMI, OCL, UML, CWM, SPEM, etc. MDE is
	presently making several promises about the potential benefits that
	could be reaped from a move from code-centric to model-based practices.
	When we observe these claims, we may wonder when they may be satisfied:
	on the short, medium or long term or even never perhaps for some
	of them. This paper tries to propose a vision of the development
	of MDE based on some lessons learnt in the past 30 years in the development
	of object technology. The main message is that a basic principle
	(“ Everything is an object ”) was most helpful in driving the
	technology in the direction of simplicity, generality and power of
	integration. Similarly in MDE, the basic principle that “ Everything
	is a model ” has many interesting properties, among others the
	capacity to generate a realistic research agenda. We postulate here
	that two core relations ( representation and conformance ) are associated
	to this principle, as inheritance and instantiation were associated
	to the object unification principle in the class-based languages
	of the 80’s. We suggest that this may be most useful in understanding
	many questions about MDE in general and the MDA approach in particular.
	We provide some illustrative examples. The personal position taken
	in this paper would be useful if it could generate a critical debate
	on the research directions in MDE.},
  affiliation = {ATLAS Group (INRIA & LINA) University of Nantes 2, rue de la Houssinière
	92208 44322 Nantes Cedex 3 France},
  issn = {1619-1366},
  issue = {2},
  keyword = {Computer Science},
  owner = {daniel},
  publisher = {Springer Berlin / Heidelberg},
  timestamp = {2011.11.06},
  url = {http://dx.doi.org/10.1007/s10270-005-0079-0}
}

@INBOOK{springerlink:10.1007/978-3-540-27799-6_9,
  pages = {101-114},
  title = {XML-Based Feature Modelling},
  publisher = {Springer Berlin / Heidelberg},
  year = {2004},
  editor = {Bosch, Jan and Krueger, Charles},
  author = {Cechticky, V. and Pasetti, A. and Rohlik, O. and Schaufelberger,
	W.},
  volume = {3107},
  series = {Lecture Notes in Computer Science},
  note = {10.1007/978-3-540-27799-6_9},
  abstract = {This paper describes a feature modelling technique aimed at modelling
	the software assets behind a product family. The proposed technique
	is distinctive in five respects. First, it proposes a feature meta-model
	that avoids the need for model normalization found in other meta-models.
	Second, it uses an XSL-based mechanism to express complex composition
	rules for the features. Third, it offers a means to decompose large
	feature diagrams into extensible and self-contained modules. Fourth,
	it defines an XML-based approach to expressing the feature models
	that offers a low-cost path to the development of support tools for
	building the models. Fifth, it explicitly supports both the modelling
	of the product family and of the applications instantiated from it.
	The paper presents the feature modelling technique in the context
	of an on-going project to build a generative environment for family
	instantiation. The experience from two cases studies is also discussed.},
  affiliation = {Institut für Automatik, ETH-Zentrum, Physikstr. 3, CH-8092 Zürich,
	Switzerland},
  booktitle = {Software Reuse: Methods, Techniques, and Tools},
  isbn = {978-3-540-22335-1},
  keyword = {Computer Science},
  owner = {daniel},
  timestamp = {2011.11.06},
  url = {http://dx.doi.org/10.1007/978-3-540-27799-6_9}
}

@INBOOK{springerlink:10.1007/11581741_10,
  pages = {115-129},
  title = {Semantic Anchoring with Model Transformations},
  publisher = {Springer Berlin / Heidelberg},
  year = {2005},
  editor = {Hartman, Alan and Kreische, David},
  author = {Chen, Kai and Sztipanovits, Janos and Abdelwalhed, Sherif and Jackson,
	Ethan},
  volume = {3748},
  series = {Lecture Notes in Computer Science},
  note = {10.1007/11581741_10},
  abstract = {Model-Integrated Computing (MIC) is an approach to Model-Driven Architecture
	(MDA), which has been developed primarily for embedded systems. MIC
	places strong emphasis on the use of domain-specific modeling languages
	(DSML-s) and model transformations. A metamodeling process facilitated
	by the Generic Modeling Environment (GME) tool suite enables the
	rapid and inexpensive development of DSML-s. However, the specification
	of semantics for DSML-s is still a hard problem. In order to simplify
	the DSML semantics, this paper discusses semantic anchoring, which
	is based on the transformational specification of semantics. Using
	a mathematical model, Abstract State Machine (ASM), as a common semantic
	framework, we have developed formal operational semantics for a set
	of basic models of computations, called semantic units. Semantic
	anchoring of DSML-s means the specification of model transformations
	between DSML-s (or aspects of complex DSML-s) and selected semantic
	units. The paper describes the semantic anchoring process using the
	meta-programmable MIC tool suite.},
  affiliation = {Institute for Software Integrated Systems, Vanderbilt University,
	P.O. Box 1829 Sta. B., Nashville, TN 37235, USA},
  booktitle = {Model Driven Architecture – Foundations and Applications},
  isbn = {978-3-540-30026-7},
  keyword = {Computer Science},
  owner = {daniel},
  timestamp = {2011.11.06},
  url = {http://dx.doi.org/10.1007/11581741_10}
}

@INBOOK{springerlink:10.1007/11527800_27,
  pages = {97-97},
  title = {Generative Programming from a Post Object-Oriented Programming Viewpoint},
  publisher = {Springer Berlin / Heidelberg},
  year = {2005},
  editor = {Banâtre, Jean-Pierre and Fradet, Pascal and Giavitto, Jean-Louis
	and Michel, Olivier},
  author = {Chiba, Shigeru},
  volume = {3566},
  series = {Lecture Notes in Computer Science},
  note = {10.1007/11527800_27},
  abstract = {This paper presents an application of generative programming to reduce
	the complications of the protocol for using an application framework
	written in an object-oriented language. It proposes that a programmable
	program translator could allow framework users to write a simple
	program, which is automatically translated by the translator into
	a program that fits the framework protocol. Then it mentions the
	author’s experience with Javassist, which is a translator toolkit
	for Java, and discusses a research issue for applying this idea to
	real-world software development.},
  affiliation = {Dept. of Mathematical and Computing Sciences, Tokyo Institute of Technology},
  booktitle = {Unconventional Programming Paradigms},
  isbn = {978-3-540-27884-9},
  keyword = {Computer Science},
  owner = {daniel},
  timestamp = {2011.11.06},
  url = {http://dx.doi.org/10.1007/11527800_27}
}

@INBOOK{springerlink:10.1007/978-3-540-39815-8_22,
  pages = {364-376},
  title = {An Easy-to-Use Toolkit for Efficient Java Bytecode Translators},
  publisher = {Springer Berlin / Heidelberg},
  year = {2003},
  editor = {Pfenning, Frank and Smaragdakis, Yannis},
  author = {Chiba, Shigeru and Nishizawa, Muga},
  volume = {2830},
  series = {Lecture Notes in Computer Science},
  note = {10.1007/978-3-540-39815-8_22},
  abstract = {This paper presents our toolkit for developing a Java-bytecode translator.
	Bytecode translation is getting important in various domains such
	as generative programming and aspect-oriented programming. To help
	the users easily develop a translator, the design of our toolkit
	is based on the reflective architecture. However, the previous implementations
	of this architecture involved serious runtime penalties. To address
	this problem, our toolkit uses a custom compiler so that the runtime
	penalties are minimized. Since the previous version of our toolkit
	named Javassist has been presented in another paper, this paper focuses
	on this new compiler support for performance improvement. This feature
	was not included in the previous version.},
  affiliation = {Dept. of Mathematical and Computing Sciences, Tokyo Institute of Technology},
  booktitle = {Generative Programming and Component Engineering},
  isbn = {978-3-540-20102-1},
  keyword = {Computer Science},
  owner = {daniel},
  timestamp = {2011.11.06},
  url = {http://dx.doi.org/10.1007/978-3-540-39815-8_22}
}

@INBOOK{springerlink:10.1007/978-3-540-39815-8_15,
  pages = {245-264},
  title = {Component-Based DSL Development},
  publisher = {Springer Berlin / Heidelberg},
  year = {2003},
  editor = {Pfenning, Frank and Smaragdakis, Yannis},
  author = {Cleenewerck, Thomas},
  volume = {2830},
  series = {Lecture Notes in Computer Science},
  note = {10.1007/978-3-540-39815-8_15},
  abstract = {Domain specific languages (DSLs) have proven to be a very adequate
	mechanism to encapsulate and hide the complex implementation details
	of component-based software development. Since evolution lies at
	the heart of any software system the DSLs that were built around
	them must evolve as well. In this paper we identify important issues
	that cause a DSL implementation to be very rigid in which all phases
	are tightly coupled and highly dependent upon one another. To increase
	the poor evolvability of current day DSL development environments
	a new development environment Keyword based programming (KBP) is
	proposed where DSLs are built by using a language specification to
	compose and glue loosely coupled and independent language components
	(called keywords).},
  affiliation = {Programming Technology Lab, Vrije Universiteit Brussel, Pleinlaan
	2, 1050 Brussel, Belgium},
  booktitle = {Generative Programming and Component Engineering},
  isbn = {978-3-540-20102-1},
  keyword = {Computer Science},
  owner = {daniel},
  timestamp = {2011.11.06},
  url = {http://dx.doi.org/10.1007/978-3-540-39815-8_15}
}

@INBOOK{springerlink:10.1007/11527800_24,
  pages = {97-97},
  title = {Towards Generative Programming},
  publisher = {Springer Berlin / Heidelberg},
  year = {2005},
  editor = {Banâtre, Jean-Pierre and Fradet, Pascal and Giavitto, Jean-Louis
	and Michel, Olivier},
  author = {Cointe, Pierre},
  volume = {3566},
  series = {Lecture Notes in Computer Science},
  note = {10.1007/11527800_24},
  abstract = {Generative Programming (GP) is an attempt to manufacture software
	components in an automated way by developing programs that synthesize
	other programs. Our purpose is to introduce the what and the how
	of the GP approach from a programming language point of view. For
	the what we discuss the lessons learned from object-oriented languages
	seen as general purpose languages to develop software factories.
	For the how we compare a variety of approaches and techniques based
	on program transformation and generation. On the one hand, we present
	the evolution of open-ended languages from metalevel programming
	to aspect-oriented programming. On the other hand, we introduce domain-specific
	languages as a way to bridge the gap between conceptual models and
	programming languages.},
  affiliation = {OBASCO group, EMN-INRIA, LINA (CNRS FRE 2729), École des Mines de
	Nantes, 4 rue Alfred Kastler, La Chantrerie, 44307 Nantes Cedex 3,
	France},
  booktitle = {Unconventional Programming Paradigms},
  isbn = {978-3-540-27884-9},
  keyword = {Computer Science},
  owner = {daniel},
  timestamp = {2011.11.06},
  url = {http://dx.doi.org/10.1007/11527800_24}
}

@INBOOK{springerlink:10.1007/11821946_4,
  pages = {50-65},
  title = {Enforcing Different Contracts in Hierarchical Component-Based Systems},
  publisher = {Springer Berlin / Heidelberg},
  year = {2006},
  editor = {Löwe, Welf and Südholt, Mario},
  author = {Collet, Philippe and Ozanne, Alain and Rivierre, Nicolas},
  volume = {4089},
  series = {Lecture Notes in Computer Science},
  note = {10.1007/11821946_4},
  abstract = {Using different specification formalisms together is necessary to
	leverage better reliability on component-based systems. The ConFract
	system provides a contracting system for hierarchical software components,
	but currently, only executable assertions are supported. In this
	paper, we describe how TLA, taken as an instance of behavioral sequence-based
	formalism, was integrated in ConFract . A domain specific language
	is proposed in order to enable designers to describe the observations
	needed to appropriately verify their specifications. These observations
	are automatically generated for assertions and in the case of TLA,
	we show what kind of observations must be provided to link the specifications
	to the concrete application.},
  affiliation = {I3S Laboratory, University of Nice – Sophia Antipolis, France},
  booktitle = {Software Composition},
  isbn = {978-3-540-37657-6},
  keyword = {Computer Science},
  owner = {daniel},
  timestamp = {2011.11.06},
  url = {http://dx.doi.org/10.1007/11821946_4}
}

@INBOOK{springerlink:10.1007/978-3-540-25935-0_2,
  pages = {37-291},
  title = {From a Program Family to a Domain-Specific Language},
  publisher = {Springer Berlin / Heidelberg},
  year = {2004},
  editor = {Lengauer, Christian and Batory, Don and Consel, Charles and Odersky,
	Martin},
  author = {Consel, Charles},
  volume = {3016},
  series = {Lecture Notes in Computer Science},
  note = {10.1007/978-3-540-25935-0_2},
  abstract = {An increasing number of domain-specific languages (DSLs) are being
	developed and successfully used in a variety of areas including networking,
	telecommunications and financial products. Yet, the development of
	a DSL is still an obscure process and its assessment is often partial.
	This paper proposes to structure the development of a DSL on the
	notion of program family. We outline the main steps of such development.
	Furthermore, we argue that a program family provides a basis to assess
	a DSL. The ideas discussed in this paper are directly based on our
	experience in developing DSLs for various domains and studying existing
	ones. We illustrate these ideas with various examples of DSLs.},
  affiliation = {INRIA/LaBRI, ENSEIRB, 1, avenue du docteur Albert Schweitzer, Domaine
	universitaire, BP 99, 33402 Talence Cedex, France},
  booktitle = {Domain-Specific Program Generation},
  isbn = {978-3-540-22119-7},
  keyword = {Computer Science},
  owner = {daniel},
  timestamp = {2011.11.06},
  url = {http://dx.doi.org/10.1007/978-3-540-25935-0_2}
}

@INBOOK{springerlink:10.1007/978-3-540-39815-8_1,
  pages = {1-17},
  title = {Spidle: A DSL Approach to Specifying Streaming Applications},
  publisher = {Springer Berlin / Heidelberg},
  year = {2003},
  editor = {Pfenning, Frank and Smaragdakis, Yannis},
  author = {Consel, Charles and Hamdi, Hedi and Réveillère, Laurent and Singaravelu,
	Lenin and Yu, Haiyan and Pu, Calton},
  volume = {2830},
  series = {Lecture Notes in Computer Science},
  note = {10.1007/978-3-540-39815-8_1},
  abstract = {Multimedia stream processing is a rapidly evolving domain which requires
	much software development and expects high performance. Developing
	a streaming application often involves low-level programming, critical
	memory management, and finely tuned scheduling of processing steps.
	To address these problems, we present a domain-specific language
	(DSL) named Spidle , for specifying streaming applications. Spidle
	offers high-level and declarative constructs; compared to general-purpose
	languages (GPL), it improves robustness by enabling a variety of
	verifications to be performed. To assess the expressiveness of Spidle
	in practice, we have used it to specify a number of standardized
	and special-purpose streaming applications. These specifications
	are up to 2 times smaller than equivalent programs written in a GPL
	such as C. We have implemented a compiler for Spidle. Preliminary
	results show that compiled Spidle programs are roughly as efficient
	as the compiled, equivalent C programs.},
  affiliation = {INRIA/LaBRI, ENSEIRB, 1, avenue du docteur Albert Schweitzer, Domaine
	universitaire, BP 99, F-33402 Talence Cedex, France},
  booktitle = {Generative Programming and Component Engineering},
  isbn = {978-3-540-20102-1},
  keyword = {Computer Science},
  owner = {daniel},
  timestamp = {2011.11.06},
  url = {http://dx.doi.org/10.1007/978-3-540-39815-8_1}
}

@INBOOK{springerlink:10.1007/11561347_4,
  pages = {29-46},
  title = {A Generative Programming Approach to Developing DSL Compilers},
  publisher = {Springer Berlin / Heidelberg},
  year = {2005},
  editor = {Glück, Robert and Lowry, Michael},
  author = {Consel, Charles and Latry, Fabien and Réveillère, Laurent and Cointe,
	Pierre},
  volume = {3676},
  series = {Lecture Notes in Computer Science},
  note = {10.1007/11561347_4},
  abstract = {Domain-Specific Languages (DSLs) represent a proven approach to raising
	the abstraction level of programming. They offer high-level constructs
	and notations dedicated to a domain, structuring program design,
	easing program writing, masking the intricacies of underlying software
	layers, and guaranteeing critical properties. On the one hand, DSLs
	facilitate a straightforward mapping between a conceptual model and
	a solution expressed in a specific programming language. On the other
	hand, DSLs complicate the compilation process because of the gap
	in the abstraction level between the source and target language.
	The nature of DSLs make their compilation very different from the
	compilation of common General-Purpose Languages (GPLs). In fact,
	a DSL compiler generally produces code written in a GPL; low-level
	compilation is left to the compiler of the target GPL. In essence,
	a DSL compiler defines some mapping of the high-level information
	and features of a DSL into the target GPL and underlying layers (
	e.g., middleware, protocols, objects, ...). This paper presents a
	methodology to develop DSL compilers, centered around the use of
	generative programming tools. Our approach enables the development
	of a DSL compiler to be structured on facets that represent dimensions
	of compilation. Each facet can then be implemented in a modular way,
	using aspects, annotations and specialization. Because these tools
	are high level, they match the needs of a DSL, facilitating the development
	of the DSL compiler, and making it modular and re-targetable. We
	illustrate our approach with a DSL for telephony services. The structure
	of the DSL compiler is presented, as well as practical uses of generative
	tools for some compilation facets.},
  affiliation = {INRIA / LaBRI, F-33402 Talence, France},
  booktitle = {Generative Programming and Component Engineering},
  isbn = {978-3-540-29138-1},
  keyword = {Computer Science},
  owner = {daniel},
  timestamp = {2011.11.06},
  url = {http://dx.doi.org/10.1007/11561347_4}
}

@INBOOK{springerlink:10.1007/BFb0056614,
  pages = {170-194},
  title = {Architecture software using: A methodology for language development},
  publisher = {Springer Berlin / Heidelberg},
  year = {1998},
  editor = {Palamidessi, Catuscia and Glaser, Hugh and Meinke, Karl},
  author = {Consel, Charles and Marlet, Renaud},
  volume = {1490},
  series = {Lecture Notes in Computer Science},
  note = {10.1007/BFb0056614},
  affiliation = {University of Rennes 1 IRISA/INRIA Campus universitaire de Beaulieu
	35042 Rennes Cedex France Campus universitaire de Beaulieu 35042
	Rennes Cedex France},
  booktitle = {Principles of Declarative Programming},
  isbn = {978-3-540-65012-6},
  keyword = {Computer Science},
  owner = {daniel},
  timestamp = {2011.11.06},
  url = {http://dx.doi.org/10.1007/BFb0056614}
}

@INBOOK{springerlink:10.1007/978-3-540-25935-0_10,
  pages = {469-485},
  title = {A DSL Paradigm for Domains of Services: A Study of Communication
	Services},
  publisher = {Springer Berlin / Heidelberg},
  year = {2004},
  editor = {Lengauer, Christian and Batory, Don and Consel, Charles and Odersky,
	Martin},
  author = {Consel, Charles and Réveillère, Laurent},
  volume = {3016},
  series = {Lecture Notes in Computer Science},
  note = {10.1007/978-3-540-25935-0_10},
  abstract = {The domain of services for mobile communication terminals has long
	become a fast-moving target. Indeed, this domain has been affected
	by a continuous stream of technological advances on aspects ranging
	from physical infrastructures to mobile terminals. As a result, services
	for this domain are known to be very unpredictable and volatile.
	This situation is even worse when considering services relying heavily
	on multimedia activities ( e.g., games, audio and/or video messages,
	etc.). Such an application area is very sensitive to a large variety
	of aspects such as terminal capabilities (graphics, CPU, etc.), bandwidth,
	service provider’s billing policies, QoS, and user expectations.
	To address these issues, we present a paradigm based on domain-specific
	languages (DSLs) that enables networking and telecommunication experts
	to quickly develop robust communication services. Importantly, we
	propose implementation strategies to enable this paradigm to be supported
	by existing software infrastructures. Our DSL paradigm is uniformly
	used to develop a platform for communication services, named Nova.
	This platform addresses various domains of services including telephony
	services, e-mail processing, remote-document processing, stream processing,
	and HTTP resource adaption.},
  affiliation = {INRIA – LaBRI, ENSEIRB, 1, avenue du docteur Albert Schweitzer,
	Domaine universitaire, BP 99, F-33402 Talence Cedex, France},
  booktitle = {Domain-Specific Program Generation},
  isbn = {978-3-540-22119-7},
  keyword = {Computer Science},
  owner = {daniel},
  timestamp = {2011.11.06},
  url = {http://dx.doi.org/10.1007/978-3-540-25935-0_10}
}

@INBOOK{springerlink:10.1007/11860990_1,
  pages = {1-3},
  title = {Separating Concerns with Domain Specific Languages},
  publisher = {Springer Berlin / Heidelberg},
  year = {2006},
  editor = {Lightfoot, David and Szyperski, Clemens},
  author = {Cook, Steve},
  volume = {4228},
  series = {Lecture Notes in Computer Science},
  note = {10.1007/11860990_1},
  abstract = {I’ll talk about the separation of concerns in the development of
	large distributed enterprise systems, how to manage it using domain
	specific languages, and how to build these languages. This brief
	note outlines some of the topics I’ll cover.},
  affiliation = {Microsoft UK Ltd, Cambridge},
  booktitle = {Modular Programming Languages},
  isbn = {978-3-540-40927-4},
  keyword = {Computer Science},
  owner = {daniel},
  timestamp = {2011.11.06},
  url = {http://dx.doi.org/10.1007/11860990_1}
}

@INBOOK{springerlink:10.1007/3-540-36124-3_59,
  pages = {900-921},
  title = {The Design and Performance of the jRate Real-Time Java Implementation},
  publisher = {Springer Berlin / Heidelberg},
  year = {2002},
  editor = {Meersman, Robert and Tari, Zahir},
  author = {Corsaro, Angelo and Schmidt, Douglas},
  volume = {2519},
  series = {Lecture Notes in Computer Science},
  note = {10.1007/3-540-36124-3_59},
  abstract = {Over 90 percent of all microprocessors are now used for real-time
	and embedded applications. Since the behavior of these applications
	is often constrained by the physical world, it is important to devise
	higher-level programming languages and middleware that robustly and
	productively enforce real-time constraints, as well as meeting conventional
	functional requirements. This paper provides two contributions to
	the study of programming languages and middleware for real-time and
	embedded applications. We first present how we are applying generative
	programming techniques to develop jRate, which is an open-source
	ahead-of-time-compiled implementation of the Real-time Specification
	for Java (RTSJ). The goal of jRate is to provide developers the ability
	to generate RTSJ implementations that are customized for their needs.We
	then show performance results of jRate that illustrate how well it
	performs compared to the TimeSys RTSJ Reference Implementation (RI).},
  affiliation = {Electrical and Computer Engineering Department, University of California,
	92697 Irvine, CA},
  booktitle = {On the Move to Meaningful Internet Systems 2002: CoopIS, DOA, and
	ODBASE},
  isbn = {978-3-540-00106-5},
  keyword = {Computer Science},
  owner = {daniel},
  timestamp = {2011.11.06},
  url = {http://dx.doi.org/10.1007/3-540-36124-3_59}
}

@ARTICLE{springerlink:10.1007/s10550-006-0089-7,
  author = {Courbis, C. and Lesaint, D. and Mihailescu, P.},
  title = {Three applications of aspect technology},
  journal = {BT Technology Journal},
  year = {2006},
  volume = {24},
  pages = {170-174},
  note = {10.1007/s10550-006-0089-7},
  abstract = {The emergence of converged services is driving communication service
	providers to cut back on software engineering costs, shorten time-to-market
	and build personalisable services. As illustrated by BT’s 21CN
	architecture initiative, the industry is responding with the vision
	of next-generation service delivery platforms (SDPs). The move towards
	SDPs demands a principled approach to achieve reuse, modularity,
	and evolvability of software artefacts, ranging from business processes
	to application components. To this end, new proposals, such as generative
	programming, aspect-oriented programming, and model-driven engineering,
	are put forward to complement traditional object-oriented and component
	programming paradigms. Aspect-oriented programming — the focus
	of this paper — endorses the principle of separation of concerns.
	Originally devoted to the modularisation of crosscutting concerns
	(e.g. synchronisation, security, debugging, monitoring), it has grown
	from an aspect-oriented extension to Java (AspectJ) into a general
	approach for the development of adaptive software artefacts. The
	purpose of this paper is to introduce aspect technology and demonstrate
	its versatility across three different application domains. Specifically,
	we present an aspect-based extension to a process execution language
	(BPEL) for developing adaptable workflows, an AspectJ-based instrumentation
	of a field resource scheduling system, and a proposal to customise
	mobile services using aspects. While the technology is still maturing,
	we hope this paper will raise the level of awareness on the potential
	of aspects across BT.},
  issn = {1358-3948},
  issue = {3},
  keyword = {Engineering},
  owner = {daniel},
  publisher = {Springer Netherlands},
  timestamp = {2011.11.06},
  url = {http://dx.doi.org/10.1007/s10550-006-0089-7}
}

@INBOOK{springerlink:10.1007/11880240_24,
  pages = {336-350},
  title = {A Plugin-Based Language to Experiment with Model Transformation},
  publisher = {Springer Berlin / Heidelberg},
  year = {2006},
  editor = {Nierstrasz, Oscar and Whittle, Jon and Harel, David and Reggio, Gianna},
  author = {Cuadrado, Jesús and Molina, Jesús},
  volume = {4199},
  series = {Lecture Notes in Computer Science},
  note = {10.1007/11880240_24},
  abstract = {Model transformation is a key technology of model driven software
	development approaches. Several transformation languages have appeared
	in the last few years, but more research is still needed for an in-depth
	understanding of the nature of model transformations and to discover
	desirable features of transformation languages. Research interest
	is primarily focused on experimentation with languages by writing
	transformations for real problems. RubyTL is a hybrid transformation
	language defined as a Ruby internal domain specific language, and
	is designed as an extensible language: a plugin mechanism allows
	new features to be added to core features. In this paper, we describe
	this plugin mechanism, devised to facilitate the experimentation
	with possible features of RubyTL. Through an example, we show how
	to add a new language feature, specifically we will develop a plugin
	to organize a transformation in several phases. Finally, we discuss
	the advantages of this extensible language design.},
  affiliation = {University of Murcia, Spain},
  booktitle = {Model Driven Engineering Languages and Systems},
  isbn = {978-3-540-45772-5},
  keyword = {Computer Science},
  owner = {daniel},
  timestamp = {2011.11.06},
  url = {http://dx.doi.org/10.1007/11880240_24}
}

@INBOOK{springerlink:10.1007/11787044_13,
  pages = {158-172},
  title = {RubyTL: A Practical, Extensible Transformation Language},
  publisher = {Springer Berlin / Heidelberg},
  year = {2006},
  editor = {Rensink, Arend and Warmer, Jos},
  author = {Cuadrado, Jesús and Molina, Jesús and Tortosa, Marcos},
  volume = {4066},
  series = {Lecture Notes in Computer Science},
  note = {10.1007/11787044_13},
  abstract = {Model transformation is a key technology of model driven development
	approaches. A lot of research therefore is being carried out to understand
	the nature of model transformations and find out desirable characteristics
	of transformation languages. In recent years, several transformation
	languages have been proposed. We present the RubyTL transformation
	language which has been designed as an extensible language–a set
	of core features along with an extension mechanism. RubyTL provides
	a framework for experimenting with features of hybrid transformation
	languages. In addition, RubyTL has been created as a domain specific
	language embedded in the Ruby programming language. In this paper
	we show the core features of the language through a simple example
	and explain how the language can be extended to provide more features.},
  affiliation = {University of Murcia, Spain},
  booktitle = {Model Driven Architecture – Foundations and Applications},
  isbn = {978-3-540-35909-8},
  keyword = {Computer Science},
  owner = {daniel},
  timestamp = {2011.11.06},
  url = {http://dx.doi.org/10.1007/11787044_13}
}

@INBOOK{springerlink:10.1007/11527800_25,
  pages = {97-97},
  title = {Overview of Generative Software Development},
  publisher = {Springer Berlin / Heidelberg},
  year = {2005},
  editor = {Banâtre, Jean-Pierre and Fradet, Pascal and Giavitto, Jean-Louis
	and Michel, Olivier},
  author = {Czarnecki, Krzysztof},
  volume = {3566},
  series = {Lecture Notes in Computer Science},
  note = {10.1007/11527800_25},
  abstract = {System family engineering seeks to exploit the commonalities among
	systems from a given problem domain while managing the variabilities
	among them in a systematic way. In system family engineering, new
	system variants can be rapidly created based on a set of reusable
	assets (such as a common architecture, components, models, etc.).
	Generative software development aims at modeling and implementing
	system families in such a way that a given system can be automatically
	generated from a specification written in one or more textual or
	graphical domain-specific languages. This paper gives an overview
	of the basic concepts and ideas of generative software development
	including DSLs, domain and application engineering, generative domain
	models, networks of domains, and technology projections. The paper
	also discusses the relationship of generative software development
	to other emerging areas such as Model Driven Development and Aspect-Oriented
	Software Development.},
  affiliation = {University of Waterloo, Canada},
  booktitle = {Unconventional Programming Paradigms},
  isbn = {978-3-540-27884-9},
  keyword = {Computer Science},
  owner = {daniel},
  timestamp = {2011.11.06},
  url = {http://dx.doi.org/10.1007/11527800_25}
}

@INBOOK{springerlink:10.1007/3-540-36208-8_2,
  pages = {15-29},
  title = {Generative Programming},
  publisher = {Springer Berlin / Heidelberg},
  year = {2002},
  editor = {Hernández, Juan and Moreira, Ana},
  author = {Czarnecki, Krzysztof and Østerbye, Kasper and Völter, Markus},
  volume = {2548},
  series = {Lecture Notes in Computer Science},
  note = {10.1007/3-540-36208-8_2},
  abstract = {This report describes the results of a one-day workshop on Generative
	Programming (GP) at ECOOP’02. The goal of the workshop was to discuss
	the state-of-the-art of generative techniques, share experience,
	consolidate successful techniques, and identify open issues for future
	work. This report gives a summary of the workshop contributions,
	debates, and the identified future directions.},
  affiliation = {DaimlerChrysler Research and Technology Germany},
  booktitle = {Object-Oriented Technology ECOOP 2002 Workshop Reader},
  isbn = {978-3-540-00233-8},
  keyword = {Computer Science},
  owner = {daniel},
  timestamp = {2011.11.06},
  url = {http://dx.doi.org/10.1007/3-540-36208-8_2}
}

@INBOOK{springerlink:10.1007/3-540-45821-2_10,
  pages = {156-172},
  title = {Generative Programming for Embedded Software: An Industrial Experience
	Report},
  publisher = {Springer Berlin / Heidelberg},
  year = {2002},
  editor = {Batory, Don and Consel, Charles and Taha, Walid},
  author = {Czarnecki, Krzysztof and Bednasch, Thomas and Unger, Peter and Eisenecker,
	Ulrich},
  volume = {2487},
  series = {Lecture Notes in Computer Science},
  note = {10.1007/3-540-45821-2_10},
  abstract = {Physical products come in many variants, and so does the software
	embedded in them. The software embedded in a product variant usually
	has to be optimized to fit its limited memory and computing power.
	Generative programming is well suited for developing embedded software
	since it allows us to automatically produce variants of embedded
	software optimized for specific products. This paper reports on our
	experience in applying generative programming in the embedded domain.
	We propose an extended feature modeling notation, discuss tool support
	for feature modeling, describe a domain-independent system configuration
	editor, and comment on the applicability of static configuration
	in the area of embedded systems.},
  affiliation = {DaimlerChrysler AG Research and Technology Ulm Germany},
  booktitle = {Generative Programming and Component Engineering},
  isbn = {978-3-540-44284-4},
  keyword = {Computer Science},
  owner = {daniel},
  timestamp = {2011.11.06},
  url = {http://dx.doi.org/10.1007/3-540-45821-2_10}
}

@INBOOK{springerlink:10.1007/3-540-48166-4_2,
  pages = {2-19},
  title = {Components and Generative Programming},
  publisher = {Springer Berlin / Heidelberg},
  year = {1999},
  editor = {Nierstrasz, Oscar and Lemoine, Michel},
  author = {Czarnecki, Krzysztof and Eisenecker, Ulrich},
  volume = {1687},
  series = {Lecture Notes in Computer Science},
  note = {10.1007/3-540-48166-4_2},
  abstract = {This paper is about a paradigm shift from the current practice of
	manually searching for and adapting components and their manual assembly
	to Generative Programming, which is the automatic selection and assembly
	of components on demand. First, we argue that the current OO technology
	does not support reuse and configurability in an effective way. Then
	we show how a system family approach can aid in defining reusable
	components. Finally, we describe how automate the assembly of components
	based on configuration knowledge. We compare this paradigm shift
	to the introduction of interchangeable parts and automated assembly
	lines in the automobile industry. We also illustrate the steps necessary
	to develop a product line using a simple example of a car product
	line. We present the feature model of the product line, develop a
	layered architecture for it, and automate the assembly of the components
	using a generator. We also discuss some design issues, applicability
	of the approach, and future development.},
  affiliation = {DaimlerChrysler AG Research and Technology Ulm Germany},
  booktitle = {Software Engineering — ESEC/FSE ’99},
  isbn = {978-3-540-66538-0},
  keyword = {Computer Science},
  owner = {daniel},
  timestamp = {2011.11.06},
  url = {http://dx.doi.org/10.1007/3-540-48166-4_2}
}

@INBOOK{springerlink:10.1007/3-540-39953-4_3,
  pages = {25-39},
  title = {Generative Programming and Active Libraries},
  publisher = {Springer Berlin / Heidelberg},
  year = {2000},
  editor = {Jazayeri, Mehdi and Loos, Rüdiger and Musser, David},
  author = {Czarnecki, Krzysztof and Eisenecker, Ulrich and Glück, Robert and
	Vandevoorde, David and Veldhuizen, Todd},
  volume = {1766},
  series = {Lecture Notes in Computer Science},
  note = {10.1007/3-540-39953-4_3},
  abstract = {We describe generative programming , an approach to generating customized
	programming components or systems, and active libraries , which are
	based on this approach. In contrast to conventional libraries, active
	libraries may contain metaprograms that implement domain-specific
	code generation, optimizations, debugging, profiling and testing.
	Several working examples (Blitz++, GMCL, Xroma) are presented to
	illustrate the potential of active libraries. We discuss relevant
	implementation technologies.},
  affiliation = {DaimlerChrysler AG Research and Technology Ulm},
  booktitle = {Generic Programming},
  isbn = {978-3-540-41090-4},
  keyword = {Computer Science},
  owner = {daniel},
  timestamp = {2011.11.06},
  url = {http://dx.doi.org/10.1007/3-540-39953-4_3}
}

@INBOOK{springerlink:10.1007/978-3-540-25935-0_4,
  pages = {51-72},
  title = {DSL Implementation in MetaOCaml, Template Haskell, and C++},
  publisher = {Springer Berlin / Heidelberg},
  year = {2004},
  editor = {Lengauer, Christian and Batory, Don and Consel, Charles and Odersky,
	Martin},
  author = {Czarnecki, Krzysztof and O’Donnell, John and Striegnitz, Jörg
	and Taha, Walid},
  volume = {3016},
  series = {Lecture Notes in Computer Science},
  note = {10.1007/978-3-540-25935-0_4},
  abstract = {A wide range of domain-specific languages (DSLs) has been implemented
	successfully by embedding them in general purpose languages. This
	paper reviews embedding, and summarizes how two alternative techniques
	– staged interpreters and templates – can be used to overcome
	the limitations of embedding. Both techniques involve a form of generative
	programming. The paper reviews and compares three programming languages
	that have special support for generative programming. Two of these
	languages (MetaOCaml and Template Haskell) are research languages,
	while the third (C++) is already in wide industrial use. The paper
	identifies several dimensions that can serve as a basis for comparing
	generative languages.},
  affiliation = {University of Waterloo, Canada},
  booktitle = {Domain-Specific Program Generation},
  isbn = {978-3-540-22119-7},
  keyword = {Computer Science},
  owner = {daniel},
  timestamp = {2011.11.06},
  url = {http://dx.doi.org/10.1007/978-3-540-25935-0_4}
}

@INBOOK{springerlink:10.1007/3-540-46589-8_7,
  pages = {791-791},
  title = {9th Workshop for PhD Students in Object Oriented Systems},
  publisher = {Springer Berlin / Heidelberg},
  year = {1999},
  author = {Demeyer, Serge and Rashid, Awais and Parsons, David and Telea, Alexandru},
  volume = {1743},
  series = {Lecture Notes in Computer Science},
  note = {10.1007/3-540-46589-8_7},
  abstract = {The PhDOOS workshop covered a wide scope, as its over 20 participants
	were PhD students in all areas of object orientation. The presentations
	covered topics such as databases, languages, software engineering
	and artificial intelligence, components and generative programming,
	analysis and design, frameworks and patterns, aspected oriented programming,
	distribution, and middleware. Several topics of shared interest were
	identified and targeted in separate discussion groups on metainformation,
	the success or failure of OODBMS, and a general theme on the future
	of object orientation. As the participants had various research interests
	covering practically all the OO spectrum, we can confidently state
	that these topics reflect actually the concerns and needs of the
	OO community, and emerge from its concrete needs. This document is
	to be complemented by a workshop proceedings document which will
	publish the full versions of the presented papers.},
  affiliation = {Lancaster University Computing Department UK},
  booktitle = {Object-Oriented Technology ECOOP’99 Workshop Reader},
  isbn = {978-3-540-66954-8},
  keyword = {Computer Science},
  owner = {daniel},
  timestamp = {2011.11.06},
  url = {http://dx.doi.org/10.1007/3-540-46589-8_7}
}

@INBOOK{springerlink:10.1007/11663430_26,
  pages = {247-261},
  title = {Addressing Domain Evolution Challenges in Software Product Lines},
  publisher = {Springer Berlin / Heidelberg},
  year = {2006},
  editor = {Bruel, Jean-Michel},
  author = {Deng, Gan and Lenz, Gunther and Schmidt, Douglas},
  volume = {3844},
  series = {Lecture Notes in Computer Science},
  note = {10.1007/11663430_26},
  abstract = {It is hard to develop and evolve software product-line architectures
	(PLAs) for large-scale distributed real-time and embedded (DRE) systems.
	Although certain challenges of PLAs can be addressed by combining
	model-driven development (MDD) techniques with component frameworks,
	domain evolution problems remain largely unresolved. In particular,
	extending or refactoring existing software product-lines to handle
	unanticipated requirements or better satisfy current requirements
	requires significant effort. This paper describes techniques for
	minimizing such impacts on MDD-based PLAs for DRE systems through
	a case study that shows how a layered architecture and model-to-model
	transformation tool support can re duce the effort of PLA evolution.},
  affiliation = {Department of EECS, Vanderbilt University, Nashville, Tennessee 37203,
	USA},
  booktitle = {Satellite Events at the MoDELS 2005 Conference},
  isbn = {978-3-540-31780-7},
  keyword = {Computer Science},
  owner = {daniel},
  timestamp = {2011.11.06},
  url = {http://dx.doi.org/10.1007/11663430_26}
}

@INBOOK{springerlink:10.1007/978-3-540-87875-9_10,
  pages = {143-157},
  title = {NAOMI – An Experimental Platform for Multi–modeling},
  publisher = {Springer Berlin / Heidelberg},
  year = {2008},
  editor = {Czarnecki, Krzysztof and Ober, Ileana and Bruel, Jean-Michel and
	Uhl, Axel and Völter, Markus},
  author = {Denton, Trip and Jones, Edward and Srinivasan, Srini and Owens, Ken
	and Buskens, Richard},
  volume = {5301},
  series = {Lecture Notes in Computer Science},
  note = {10.1007/978-3-540-87875-9_10},
  abstract = {Domain-specific modeling languages (DSMLs) are designed to provide
	precise abstractions of domain-specific constructs. However, models
	for complex systems typically do not fit neatly within a single domain
	and capturing all important aspects of such a system requires developing
	multiple models using different DSMLs. Combining these models into
	multi-models presents difficult challenges, most importantly those
	of integrating the various models and keeping both the models and
	their associated data synchronized. To this end, we present NAOMI,
	an experimental platform for enabling multiple models, developed
	in different DSMLs, to work together. NAOMI analyzes model dependencies
	to determine the impact of changes to one model on other dependent
	models and coordinates the propagation of necessary model changes.
	NAOMI also serves as a useful testbed for exploring how diverse modeling
	paradigms can be combined.},
  affiliation = {Lockheed Martin Advanced Technology Laboratories, Cherry Hill, NJ
	08002},
  booktitle = {Model Driven Engineering Languages and Systems},
  isbn = {978-3-540-87874-2},
  keyword = {Computer Science},
  owner = {daniel},
  timestamp = {2011.11.06},
  url = {http://dx.doi.org/10.1007/978-3-540-87875-9_10}
}

@INBOOK{springerlink:10.1007/978-3-540-78139-4_21,
  pages = {230-241},
  title = {Transformational Techniques for Model-Driven Authoring of Learning
	Designs},
  publisher = {Springer Berlin / Heidelberg},
  year = {2008},
  editor = {Leung, Howard and Li, Frederick and Lau, Rynson and Li, Qing},
  author = {Dodero, Juan and Tattersall, Colin and Burgos, Daniel and Koper,
	Rob},
  volume = {4823},
  series = {Lecture Notes in Computer Science},
  note = {10.1007/978-3-540-78139-4_21},
  abstract = {Diverse authoring approaches and tools have been designed to assist
	the creation of units of learning compliant to current learning technology
	specifications. Although visual and pattern-based editors of Learning
	Designs (LD) can help to abstract the learning designer from the
	details of the specifications, they are still far from a high-level,
	integrated authoring environment. This paper analyzes the major approaches
	used to transform an abstract LD into a concrete unit of learning
	(UoL), according to three desired features: the use of patterns and
	other design techniques to abstract the specific representational
	details; the difference between the abstract source LD model and
	the concrete target UoL model; and the possibility of combining multiple
	models into a single environment. A classification is proposed for
	the LD techniques commonly found in the analyzed approaches, in order
	to underline its abstraction from the details of the underlying specifications.
	We have integrated such LD techniques in a unified Model-Driven Learning
	Design (MDLD) meta-modeling environment, which has been used to generate
	UoLs from a number of meta-models. The model-driven development process
	was studied on the creation of a IMS LD UoL for the Learning Networks’
	knowledge base.},
  affiliation = {Universidad Carlos III de Madrid Av. Universidad 30 28911 Leganés
	Madrid Spain},
  booktitle = {Advances in Web Based Learning – ICWL 2007},
  isbn = {978-3-540-78138-7},
  keyword = {Computer Science},
  owner = {daniel},
  timestamp = {2011.11.06},
  url = {http://dx.doi.org/10.1007/978-3-540-78139-4_21}
}

@INBOOK{springerlink:10.1007/978-3-540-69330-7_10,
  pages = {136-151},
  title = {A Language for the Compact Representation of Multiple Program Versions},
  publisher = {Springer Berlin / Heidelberg},
  year = {2006},
  editor = {Ayguadé, Eduard and Baumgartner, Gerald and Ramanujam, J. and Sadayappan,
	P.},
  author = {Donadio, Sebastien and Brodman, James and Roeder, Thomas and Yotov,
	Kamen and Barthou, Denis and Cohen, Albert and Garzarán, María
	and Padua, David and Pingali, Keshav},
  volume = {4339},
  series = {Lecture Notes in Computer Science},
  note = {10.1007/978-3-540-69330-7_10},
  abstract = {As processor complexity increases compilers tend to deliver suboptimal
	performance. Library generators such as ATLAS, FFTW and SPIRALz overcome
	this issue by empirically searching in the space of possible program
	versions for the one that performs the best. Empirical search can
	also be applied by programmers, but because they lack a tool to automate
	the process, programmers need to manually re-write the application
	in terms of several parameters whose best value will be determined
	by the empirical search in the target machine. In this paper, we
	present the design of an annotation language, meant to be used either
	as an intermediate representation within library generators or directly
	by the programmer. This language that we call X represents parameterized
	programs in a compact and natural way. It provides an powerful optimization
	framework for high performance computing.},
  affiliation = {BULL SA},
  booktitle = {Languages and Compilers for Parallel Computing},
  isbn = {978-3-540-69329-1},
  keyword = {Computer Science},
  owner = {daniel},
  timestamp = {2011.11.06},
  url = {http://dx.doi.org/10.1007/978-3-540-69330-7_10}
}

@INBOOK{springerlink:10.1007/978-3-540-72035-5_36,
  pages = {464-477},
  title = {Model-Driven Architecture for Mobile Applications},
  publisher = {Springer Berlin / Heidelberg},
  year = {2007},
  editor = {Abramowicz, Witold},
  author = {Dunkel, Jürgen and Bruns, Ralf},
  volume = {4439},
  series = {Lecture Notes in Computer Science},
  note = {10.1007/978-3-540-72035-5_36},
  abstract = {Although significant improvements in the development of business applications
	for mobile devices have been made in recent years, the software development
	in this area is still not as mature as it is for desktop computers.
	Therefore, declarative and code generation approaches should be preferred
	instead of manually coding. In the BAMOS project an architecture
	has been designed and implemented for the generic and flexible development
	of mobile applications. The architecture is based on the declarative
	description of the available services. In this paper we present a
	model-driven approach for generating almost the complete source code
	of mobile services. By applying model-driven development within the
	proposed approach, a new service can be conveniently modeled with
	a graphical modeling tool and the graphical models are then used
	to generate the corresponding XML descriptions of the mobile user
	interface and the workflow specification. In order to use such a
	service no specific source code has to be implemented on the mobile
	device.},
  affiliation = {Hannover University of Applied Sciences and Arts, Department of Computer
	Science, Ricklinger Stadtweg 120, 30459 Hannover Germany},
  booktitle = {Business Information Systems},
  isbn = {978-3-540-72034-8},
  keyword = {Computer Science},
  owner = {daniel},
  timestamp = {2011.11.06},
  url = {http://dx.doi.org/10.1007/978-3-540-72035-5_36}
}

@INBOOK{springerlink:10.1007/978-3-540-71289-3_12,
  pages = {125-139},
  title = {Scenario-Driven Dynamic Analysis of Distributed Architectures},
  publisher = {Springer Berlin / Heidelberg},
  year = {2007},
  editor = {Dwyer, Matthew and Lopes, Antónia},
  author = {Edwards, George and Malek, Sam and Medvidovic, Nenad},
  volume = {4422},
  series = {Lecture Notes in Computer Science},
  note = {10.1007/978-3-540-71289-3_12},
  abstract = {Software architecture constitutes a promising approach to the development
	of large-scale distributed systems, but architecture description
	languages (ADLs) and their associated architectural analysis techniques
	suffer from several important shortcomings. This paper presents a
	novel approach that reconceptualizes ADLs within the model-driven
	engineering (MDE) paradigm to address their shortcomings. Our approach
	combines extensible modeling languages based on architectural constructs
	with a model interpreter framework that enables rapid implementation
	of customized dynamic analyses at the architectural level. Our approach
	is demonstrated in XTEAM, a suite of ADL extensions and model transformation
	engines targeted specifically for highly distributed, resource-constrained,
	and mobile computing environments. XTEAM model transformations generate
	system simulations that provide a dynamic, scenario- and risk-driven
	view of the executing system. This information allows an architect
	to compare architectural alternatives and weigh trade-offs between
	multiple design goals, such as system performance, reliability, and
	resource consumption. XTEAM provides the extensibility to easily
	accommodate both new modeling language features and new architectural
	analyses.},
  affiliation = {Computer Science Department, University of Southern California, Los
	Angeles, CA 90089-0781},
  booktitle = {Fundamental Approaches to Software Engineering},
  isbn = {978-3-540-71288-6},
  keyword = {Computer Science},
  owner = {daniel},
  timestamp = {2011.11.06},
  url = {http://dx.doi.org/10.1007/978-3-540-71289-3_12}
}

@INBOOK{springerlink:10.1007/3-540-62599-2_51,
  pages = {351-365},
  title = {Generative programming (GP) with C++},
  publisher = {Springer Berlin / Heidelberg},
  year = {1997},
  editor = {Mössenböck, Hanspeter},
  author = {Eisenecker, Ulrich},
  volume = {1204},
  series = {Lecture Notes in Computer Science},
  note = {10.1007/3-540-62599-2_51},
  affiliation = {Fachhochschule Heidelberg Fachbereich Informatik Bonhoefferstraße
	1 D-69123 Heidelberg Germany Bonhoefferstraße 1 D-69123 Heidelberg
	Germany},
  booktitle = {Modular Programming Languages},
  isbn = {978-3-540-62599-5},
  keyword = {Computer Science},
  owner = {daniel},
  timestamp = {2011.11.06},
  url = {http://dx.doi.org/10.1007/3-540-62599-2_51}
}

@INBOOK{springerlink:10.1007/11880240_34,
  pages = {484-498},
  title = {A Metamodeling Approach to Pattern Specification},
  publisher = {Springer Berlin / Heidelberg},
  year = {2006},
  editor = {Nierstrasz, Oscar and Whittle, Jon and Harel, David and Reggio, Gianna},
  author = {Elaasar, Maged and Briand, Lionel and Labiche, Yvan},
  volume = {4199},
  series = {Lecture Notes in Computer Science},
  note = {10.1007/11880240_34},
  abstract = {This paper presents the Pattern Modeling Framework (PMF), a new metamodeling
	approach to pattern specification for MOF-compliant modeling frameworks
	and languages. Patterns need to be precisely specified before a tool
	can manipulate them, and though several approaches to pattern specification
	have been proposed, they do not provide the scalability and flexibility
	required in practice. PMF provides a pattern specification language
	called Epattern, which is capable of precisely specifying patterns
	in MOF-compliant metamodels. The language is defined as an extension
	to MOF by adding semantics inspired from the UML composite structure
	diagram. The language also comes with a graphical notation and a
	recommended iterative specification process. It also contains features
	to manage the complexity of specifying patterns and simplify their
	application and detection in user models. Most importantly, the language
	is implemented using state-of-the-art technologies that are heavily
	used by major modeling tool vendors, thus facilitating its adoption.},
  affiliation = {Software Quality Engineering Laboratory (SQUALL), Department of Systems
	and Computer Engineering, Carleton University, 1125 Colonel By Drive,
	Ottawa, ON K1S 5B6 Canada},
  booktitle = {Model Driven Engineering Languages and Systems},
  isbn = {978-3-540-45772-5},
  keyword = {Computer Science},
  owner = {daniel},
  timestamp = {2011.11.06},
  url = {http://dx.doi.org/10.1007/11880240_34}
}

@INBOOK{springerlink:10.1007/978-3-540-74974-5_56,
  pages = {606-617},
  title = {Service Design Process for Reusable Services: Financial Services
	Case Study},
  publisher = {Springer Berlin / Heidelberg},
  year = {2007},
  editor = {Krämer, Bernd and Lin, Kwei-Jay and Narasimhan, Priya},
  author = {Erradi, Abdelkarim and Kulkarni, Naveen and Maheshwari, Piyush},
  volume = {4749},
  series = {Lecture Notes in Computer Science},
  note = {10.1007/978-3-540-74974-5_56},
  abstract = {Service-oriented Architecture (SOA) is an approach for building distributed
	systems that deliver application functionality as a set of business-aligned
	services with well-defined and discoverable contracts. This paper
	presents typical a service design process along with a set of service
	design principles and guidelines for systematically identifying services,
	designing them and deciding the service granularity and layering.
	The advocated principles stem from our experiences in designing services
	for a realistic Securities Trading application. Best practices and
	lessons learned during this exercise are also discussed.},
  affiliation = {School of Computer Sc. and Eng. University of New South Wales, Sydney,
	Australia},
  booktitle = {Service-Oriented Computing – ICSOC 2007},
  isbn = {978-3-540-74973-8},
  keyword = {Computer Science},
  owner = {daniel},
  timestamp = {2011.11.06},
  url = {http://dx.doi.org/10.1007/978-3-540-74974-5_56}
}

@INBOOK{springerlink:10.1007/978-3-540-69100-6_13,
  pages = {185-199},
  title = {Metamodel Syntactic Sheets: An Approach for Defining Textual Concrete
	Syntaxes},
  publisher = {Springer Berlin / Heidelberg},
  year = {2008},
  editor = {Schieferdecker, Ina and Hartman, Alan},
  author = {Espinazo-Pagán, Javier and Menárguez, Marcos and García-Molina,
	Jesús},
  volume = {5095},
  series = {Lecture Notes in Computer Science},
  note = {10.1007/978-3-540-69100-6_13},
  abstract = {The development process of Domain Specific Languages (DSL) can be
	tackled from different technical spaces such as XML, Grammarware
	or Model Driven Engineering (MDE). In the case of using MDE, the
	definition of a concrete syntax for a textual DSL requires commonly
	building a bridge between this technical space and Grammarware. Several
	bridging approaches have been recently proposed in which the existing
	coupling between concrete and abstract syntaxes causes information
	duplication in the development process of DSLs. Moreover, reusability
	of concrete syntaxes has received no attention in these approaches.
	In this paper we present the MSS (Metamodel Syntactic Sheets) approach
	for defining textual concrete syntaxes. MSS is intended to promote
	the reuse of textual concrete syntaxes and to avoid information duplication.
	In MSS, metamodels are annotated with syntactic properties and a
	propagation mechanism reduces the number of annotations required
	as well as the coupling between concrete and abstract syntaxes. Textual
	concrete syntaxes can be reused by annotating syntactically the metamodeling
	language. This reuse makes possible to share syntactic idioms (textual
	conventions) among different DSLs.},
  affiliation = {University of Murcia, Spain},
  booktitle = {Model Driven Architecture – Foundations and Applications},
  isbn = {978-3-540-69095-5},
  keyword = {Computer Science},
  owner = {daniel},
  timestamp = {2011.11.06},
  url = {http://dx.doi.org/10.1007/978-3-540-69100-6_13}
}

@INBOOK{springerlink:10.1007/11557432_6,
  pages = {69-83},
  title = {Composing Domain-Specific Languages for Wide-Scope Software Engineering
	Applications},
  publisher = {Springer Berlin / Heidelberg},
  year = {2005},
  editor = {Briand, Lionel and Williams, Clay},
  author = {Estublier, Jacky and Vega, German and Ionita, Anca},
  volume = {3713},
  series = {Lecture Notes in Computer Science},
  note = {10.1007/11557432_6},
  abstract = {Domain-Specific Languages (DSL) offer many advantages over general
	languages, but their narrow scope makes them really effective only
	in very focused domains, for example Product Lines. The recent Model
	Driven Engineering (MDE) approach seeks to provide a technology to
	compose and combine models coming from different metamodels. Adapted
	to DSL, it means that it should be possible to compose ”programs”
	written in different DSLs, which will enable the use of the DSL approach
	to build applications spanning different domains. The paper presents
	the Mélusine environment, where such a composition technology has
	been developed and experimented.},
  affiliation = {LSR-IMAG, 220, rue de la Chimie, BP5338041, Grenoble Cedex 9, France},
  booktitle = {Model Driven Engineering Languages and Systems},
  isbn = {978-3-540-29010-0},
  keyword = {Computer Science},
  owner = {daniel},
  timestamp = {2011.11.06},
  url = {http://dx.doi.org/10.1007/11557432_6}
}

@INBOOK{springerlink:10.1007/978-3-540-69073-3_4,
  pages = {28-33},
  title = {4th International Workshop on Language Engineering (ATEM 2007)},
  publisher = {Springer Berlin / Heidelberg},
  year = {2008},
  editor = {Giese, Holger},
  author = {Favre, Jean-Marie and Gašević, Dragan and Lämmel, Ralf and Winter,
	Andreas},
  volume = {5002},
  series = {Lecture Notes in Computer Science},
  note = {10.1007/978-3-540-69073-3_4},
  abstract = {Following the great success of previous editions, ATEM2007 is the
	4 th edition of the ATEM workshop series. The first two editions
	were held with WCRE in 2003 and 2004, while the 3 rd one was held
	with MoDELS 2006. ATEM has always been focused on engineering of
	language descriptions. In order to cover as many aspects of language
	descriptions important for greater success and adoption of model-driven
	engineering, ATEM has been evolving so as its scope: • The first
	edition was about metamodels and schemas. • The second about was
	metamodels, schemas and grammars. • The third edition was about
	metamodels, schemas, grammars and ontologies.},
  affiliation = {University of Grenoble France},
  booktitle = {Models in Software Engineering},
  isbn = {978-3-540-69069-6},
  keyword = {Computer Science},
  owner = {daniel},
  timestamp = {2011.11.06},
  url = {http://dx.doi.org/10.1007/978-3-540-69073-3_4}
}

@INBOOK{springerlink:10.1007/978-3-540-76856-2_75,
  pages = {760-769},
  title = {Easying MR Development with Eclipse and InTml},
  publisher = {Springer Berlin / Heidelberg},
  year = {2007},
  editor = {Bebis, George and Boyle, Richard and Parvin, Bahram and Koracin,
	Darko and Paragios, Nikos and Tanveer, Syeda-Mahmood and Ju, Tao
	and Liu, Zicheng and Coquillart, Sabine and Cruz-Neira, Carolina
	and Müller, Torsten and Malzbender, Tom},
  author = {Figueroa, Pablo and Florez, Camilo},
  volume = {4842},
  series = {Lecture Notes in Computer Science},
  note = {10.1007/978-3-540-76856-2_75},
  abstract = {This paper shows our work in progress towards an easy to use development
	environment for Mixed Reality (MR) Applications. We argue that development
	of MR applications is a collaboration between interaction designers
	who know about user requirements, and expert developers who know
	the intricacies of MR development. This collaboration should be supported
	by tools that aid both roles and ease their communication. We also
	argue that real MR development should allow easy migration from one
	hardware setup to another, since hardware greatly varies in these
	type of applications, and it is important to fit a solution to the
	particular user’s requirements and context. We show the foundational
	concepts in our work and current Integrated Development Environment
	(IDE) implementation. This work is based on InTml, a domain specific
	language for MR applications, and Eclipse, an open source, general
	purpose IDE.},
  affiliation = {Universidad de los Andes Colombia},
  booktitle = {Advances in Visual Computing},
  isbn = {978-3-540-76855-5},
  keyword = {Computer Science},
  owner = {daniel},
  timestamp = {2011.11.06},
  url = {http://dx.doi.org/10.1007/978-3-540-76856-2_75}
}

@INBOOK{springerlink:10.1007/978-3-540-73345-4_4,
  pages = {31-39},
  title = {Model Based HMI Specification in an Automotive Context},
  publisher = {Springer Berlin / Heidelberg},
  year = {2007},
  editor = {Smith, Michael and Salvendy, Gavriel},
  author = {Fleischmann, Thomas},
  volume = {4557},
  series = {Lecture Notes in Computer Science},
  note = {10.1007/978-3-540-73345-4_4},
  abstract = {An overview of how a model based specification approach can be used
	in the domain of automotive human machine interface (HMI) development
	is presented. The common paper based specification approach is compared
	to a model based, tool supported process. Requirements from different
	stakeholders for such an approach are outlined. Intended audiences
	are all stakeholders involved in the creation of graphical user interfaces
	ranging from design, usability engineering, and prototyping to specification
	and final product realization.},
  affiliation = {Elektrobit, Frauenweiherstr. 14, 91058 Erlangen Germany},
  booktitle = {Human Interface and the Management of Information. Methods, Techniques
	and Tools in Information Design},
  isbn = {978-3-540-73344-7},
  keyword = {Computer Science},
  owner = {daniel},
  timestamp = {2011.11.06},
  url = {http://dx.doi.org/10.1007/978-3-540-73345-4_4}
}

@INBOOK{springerlink:10.1007/11914952_26,
  pages = {1402-1411},
  title = {A Generic Deployment Framework for Grid Computing and Distributed
	Applications},
  publisher = {Springer Berlin / Heidelberg},
  year = {2006},
  editor = {Meersman, Robert and Tari, Zahir},
  author = {Flissi, Areski and Merle, Philippe},
  volume = {4276},
  series = {Lecture Notes in Computer Science},
  note = {10.1007/11914952_26},
  abstract = {Deployment of distributed applications on large systems, and especially
	on grid infrastructures, becomes a more and more complex task. Grid
	users spend a lot of time to prepare, install and configure middleware
	and application binaries on nodes, and eventually start their applications.
	The problem is that the deployment process is composed of many heterogeneous
	tasks that have to be orchestrated in a specific correct order. As
	a consequence, the automatization of the deployment process is currently
	very difficult to reach. To address this problem, we propose in this
	paper a generic deployment framework allowing to automatize the execution
	of heterogeneous tasks composing the whole deployment process. Our
	approach is based on a reification as software components of all
	required deployment mechanisms or existing tools. Grid users only
	have to describe the configuration to deploy in a simple natural
	language instead of programming or scripting how the deployment process
	is executed. As a toy example, this framework is used to deploy CORBA
	component-based applications and OpenCCM middleware on one thousand
	nodes of the French Grid5000 infrastructure.},
  affiliation = {LIFL / CNRS, Université des Sciences et Technologies de Lille, 59655
	Villeneuve d’Ascq, Lille, France},
  booktitle = {On the Move to Meaningful Internet Systems 2006: CoopIS, DOA, GADA,
	and ODBASE},
  isbn = {978-3-540-48274-1},
  keyword = {Computer Science},
  owner = {daniel},
  timestamp = {2011.11.06},
  url = {http://dx.doi.org/10.1007/11914952_26}
}

@INBOOK{springerlink:10.1007/978-3-540-69100-6_14,
  pages = {200-214},
  title = {Graphical Concrete Syntax Rendering with SVG},
  publisher = {Springer Berlin / Heidelberg},
  year = {2008},
  editor = {Schieferdecker, Ina and Hartman, Alan},
  author = {Fondement, Frédéric},
  volume = {5095},
  series = {Lecture Notes in Computer Science},
  note = {10.1007/978-3-540-69100-6_14},
  abstract = {Model-based techniques place modeling at the cornerstone of software
	development. Because of the large number of domains and levels of
	abstraction one can find in software systems, a large number of modeling
	languages is necessary. Modeling languages need to be properly defined
	regarding concrete syntax in addition to abstract syntax and semantics.
	Most modeling languages use a graphical concrete syntax, and solutions
	to model those syntaxes appeared. If those solutions are convincing
	to support the rapid development of graphical modeling tools, they
	are often restrictive in the range of possible concrete syntaxes
	for a given abstract syntax, and rely on dedicated technologies.
	In previous works, we proposed such a solution based on a representation
	model which was more flexible in that it abstracted away purely graphical
	concerns. Those concerns include actual design for representation
	icons, how the design reacts to representation variations within
	the icons, possible interactions with an icon, and synchronization
	between the graphical representation and the graphical model. In
	this paper, we show how to solve those four last points using the
	SVG open standard for vector graphics. We propose to define representation
	icons by SVG templates complemented by layout constraints, a predefined
	and extensible library of possible user interactions using DOM, and
	a specific approach based on events to synchronize the graphical
	representation with the graphical model. Thus, our solution solves
	the concrete realization of an modeling environment cumulating advantages
	of a clear separation between abstract and concrete syntaxes at the
	modeling level, while benefiting from the expertise of the vector
	graphics community.},
  affiliation = {ENSISA, MIPS, Université de Haute Alsace, 12, rue des frères Lumière,
	F-68093 Mulhouse, France},
  booktitle = {Model Driven Architecture – Foundations and Applications},
  isbn = {978-3-540-69095-5},
  keyword = {Computer Science},
  owner = {daniel},
  timestamp = {2011.11.06},
  url = {http://dx.doi.org/10.1007/978-3-540-69100-6_14}
}

@INBOOK{springerlink:10.1007/11581741_15,
  pages = {190-204},
  title = {Making Metamodels Aware of Concrete Syntax},
  publisher = {Springer Berlin / Heidelberg},
  year = {2005},
  editor = {Hartman, Alan and Kreische, David},
  author = {Fondement, Frédéric and Baar, Thomas},
  volume = {3748},
  series = {Lecture Notes in Computer Science},
  note = {10.1007/11581741_15},
  abstract = {Language-centric methodologies, triggered by the success of Domain
	Specific Languages, rely on precise specifications of modeling languages.
	While the definition of the abstract syntax is standardized by the
	4-layer metamodel architecture of the OMG, most language specifications
	are held informally for the description of the semantics and the
	(graphical) concrete syntax. This paper is tackling the problem of
	specifying the concrete syntax of a language in a formal and non-ambiguous
	way. We propose to define the concrete syntax by an extension of
	the already existing metamodel of the abstract syntax, which describes
	the concepts of the language, with a second layer describing the
	graphical representation of concepts by visual elements. In addition,
	an intermediate layer defines how elements of both layers are related
	to each other. Unlike similar approaches that became the basis of
	some CASE tools, the intermediate layer is not a pure mapping from
	abstract to concrete syntax but connects both layers in a flexible,
	declarative way. We illustrate our approach with a simplified form
	of statecharts.},
  affiliation = {School of Computer and Communication Sciences, École Polytechnique
	Fédérale de Lausanne (EPFL), CH-1015 Lausanne, Switzerland},
  booktitle = {Model Driven Architecture – Foundations and Applications},
  isbn = {978-3-540-30026-7},
  keyword = {Computer Science},
  owner = {daniel},
  timestamp = {2011.11.06},
  url = {http://dx.doi.org/10.1007/11581741_15}
}

@INBOOK{springerlink:10.1007/978-3-540-87991-6_34,
  pages = {282-291},
  title = {Integrating Business Domain Ontologies with Early Requirements Modelling},
  publisher = {Springer Berlin / Heidelberg},
  year = {2008},
  editor = {Song, Il-Yeol and Piattini, Mario and Chen, Yi-Ping and Hartmann,
	Sven and Grandi, Fabio and Trujillo, Juan and Opdahl, Andreas and
	Ferri, Fernando and Grifoni, Patrizia and Caschera, Maria and Rolland,
	Colette and Woo, Carson and Salinesi, Camille and Zimányi, Esteban
	and Claramunt, Christophe and Frasincar, Flavius and Houben, Geert-Jan
	and Thiran, Philippe},
  author = {Gailly, Frederik and España, Sergio and Poels, Geert and Pastor,
	Oscar},
  volume = {5232},
  series = {Lecture Notes in Computer Science},
  note = {10.1007/978-3-540-87991-6_34},
  abstract = {Requirements engineering is an important and complex phase during
	systems development because it combines the description of the system’s
	domain with the elicitation, specification and validation of application-specific
	requirements. In this paper we propose an ontology-based requirements
	engineering approach that integrates the use of domain ontologies
	to capture domain knowledge into early requirements modelling techniques,
	which primarily aim at eliciting and representing the organisational
	and intentional context of the system. The proposed approach can
	be used with different types of domain ontologies and different requirements
	engineering techniques. The approach is illustrated using the REA
	enterprise ontology, the E 3 -value ontology and the i* requirements
	modelling framework.},
  affiliation = {Ghent University Faculty of Economics and Business Administration},
  booktitle = {Advances in Conceptual Modeling – Challenges and Opportunities},
  isbn = {978-3-540-87990-9},
  keyword = {Computer Science},
  owner = {daniel},
  timestamp = {2011.11.06},
  url = {http://dx.doi.org/10.1007/978-3-540-87991-6_34}
}

@INBOOK{springerlink:10.1007/11752660_18,
  pages = {231-247},
  title = {Aspects in Agent-Oriented Software Engineering: Lessons Learned},
  publisher = {Springer Berlin / Heidelberg},
  year = {2006},
  editor = {Müller, Jörg and Zambonelli, Franco},
  author = {Garcia, Alessandro and Kulesza, Uirá and Sant’Anna, Cláudio and
	Chavez, Christina and de Lucena, Carlos},
  volume = {3950},
  series = {Lecture Notes in Computer Science},
  note = {10.1007/11752660_18},
  abstract = {Several concerns in the development of multi-agent systems (MASs)
	cannot be represented in a modular fashion. In general, they inherently
	affect several system modules and cannot be explicitly captured based
	on existing software engineering abstractions. These crosscutting
	concerns encompass internal agent properties and systemic properties,
	such as learning, code mobility, error handling, and context-awareness.
	In this context, it is important to systematically verify whether
	emerging development paradigms support improved modularization of
	the crosscutting concerns relative to MASs. This paper reports some
	lessons learned based on our experience in using aspect-oriented
	techniques and methods to address these problems. In the light of
	these lessons, related work and a set of future research directions
	are also discussed.},
  affiliation = {Computing Department, InfoLab 21, Lancaster University, Lancaster,
	United Kingdom},
  booktitle = {Agent-Oriented Software Engineering VI},
  isbn = {978-3-540-34097-3},
  keyword = {Computer Science},
  owner = {daniel},
  timestamp = {2011.11.06},
  url = {http://dx.doi.org/10.1007/11752660_18}
}

@INBOOK{springerlink:10.1007/978-3-540-69073-3_8,
  pages = {65-76},
  title = {Domain-Specific Methods and Tools for the Design of Advanced Interactive
	Techniques},
  publisher = {Springer Berlin / Heidelberg},
  year = {2008},
  editor = {Giese, Holger},
  author = {Gauffre, Guillaume and Dubois, Emmanuel and Bastide, Remi},
  volume = {5002},
  series = {Lecture Notes in Computer Science},
  note = {10.1007/978-3-540-69073-3_8},
  abstract = {Novel interactive systems such as Augmented Reality are promising
	tools considering the possibilities they offer, but no real development
	methods exist at the moment to help designers in their work. We present
	in this paper a design method for tightly coupling early interaction
	design choices and software design solutions. Based on an existing
	model used for abstract UI design, our work introduces a second model
	dedicated to the software UI specification and the model-based process
	used to derive one from the other. To achieve this, we present here
	a framework based on domain-specific models and transformations to
	link them and thus support the development process.},
  affiliation = {IRIT – University of Toulouse 118, route de Narbonne 31062 Toulouse
	Cedex 9 France},
  booktitle = {Models in Software Engineering},
  isbn = {978-3-540-69069-6},
  keyword = {Computer Science},
  owner = {daniel},
  timestamp = {2011.11.06},
  url = {http://dx.doi.org/10.1007/978-3-540-69073-3_8}
}

@INBOOK{springerlink:10.1007/11841883_27,
  pages = {383-397},
  title = {GrGen: A Fast SPO-Based Graph Rewriting Tool},
  publisher = {Springer Berlin / Heidelberg},
  year = {2006},
  editor = {Corradini, Andrea and Ehrig, Hartmut and Montanari, Ugo and Ribeiro,
	Leila and Rozenberg, Grzegorz},
  author = {Geiß, Rubino and Batz, Gernot and Grund, Daniel and Hack, Sebastian
	and Szalkowski, Adam},
  volume = {4178},
  series = {Lecture Notes in Computer Science},
  note = {10.1007/11841883_27},
  abstract = {Graph rewriting is a powerful technique that requires graph pattern
	matching, which is an NP-complete problem. We present GrGen , a generative
	programming system for graph rewriting, which applies heuristic optimizations.
	According to Varró’s benchmark it is at least one order of magnitude
	faster than any other tool known to us. Our graph rewriting tool
	implements the well-founded single-pushout approach. We define the
	notion of search plans to represent different matching strategies
	and equip these search plans with a cost model, taking the present
	host graph into account. The task of selecting a good search plan
	is then viewed as an optimization problem. For the ease of use, GrGen
	features an expressive specification language and generates program
	code with a convenient interface.},
  affiliation = {Universität Karlsruhe (TH), 76131 Karlsruhe, Germany},
  booktitle = {Graph Transformations},
  isbn = {978-3-540-38870-8},
  keyword = {Computer Science},
  owner = {daniel},
  timestamp = {2011.11.06},
  url = {http://dx.doi.org/10.1007/11841883_27}
}

@INBOOK{springerlink:10.1007/978-3-540-69489-2_4,
  pages = {27-31},
  title = {Critical Systems Development Using Modeling Languages – CSDUML
	2006 Workshop Report},
  publisher = {Springer Berlin / Heidelberg},
  year = {2007},
  editor = {Kühne, Thomas},
  author = {Georg, Geri and Houmb, Siv and France, Robert and Zschaler, Steffen
	and Petriu, Dorina and Jürjens, Jan},
  volume = {4364},
  series = {Lecture Notes in Computer Science},
  note = {10.1007/978-3-540-69489-2_4},
  abstract = {The CSDUML 2006 workshop is a continuation of the series regarding
	development of critical systems using modeling languages. The report
	summarizes papers presented and discussion at the workshop.},
  affiliation = {Colorado State University, Computer Science Department},
  booktitle = {Models in Software Engineering},
  isbn = {978-3-540-69488-5},
  keyword = {Computer Science},
  owner = {daniel},
  timestamp = {2011.11.06},
  url = {http://dx.doi.org/10.1007/978-3-540-69489-2_4}
}

@INBOOK{springerlink:10.1007/978-3-540-85893-5_3,
  pages = {32-47},
  title = {On Practical Information Flow Policies for Java-Enabled Multiapplication
	Smart Cards},
  publisher = {Springer Berlin / Heidelberg},
  year = {2008},
  editor = {Grimaud, Gilles and Standaert, François-Xavier},
  author = {Ghindici, Dorina and Simplot-Ryl, Isabelle},
  volume = {5189},
  series = {Lecture Notes in Computer Science},
  note = {10.1007/978-3-540-85893-5_3},
  abstract = {In the multiapplicative context of smart cards, a strict control of
	underlying information flow between applications is highly desired.
	In this paper we propose a model to improve information flow usability
	in such systems by limiting the overhead for adding information flow
	security to a Java Virtual Machine. We define a domain specific language
	for defining security policies describing the allowed information
	flow inside the card. The applications are certified at loading time
	with respect to information flow security policies. We illustrate
	our approach on the LoyaltyCard, a multiapplicative smart card involving
	four loyalty applications sharing fidelity points.},
  affiliation = {CNRS UMR 8022, Univ. Lille 1, INRIA Lille IRCICA/LIFL Nord Europe
	France},
  booktitle = {Smart Card Research and Advanced Applications},
  isbn = {978-3-540-85892-8},
  keyword = {Computer Science},
  owner = {daniel},
  timestamp = {2011.11.06},
  url = {http://dx.doi.org/10.1007/978-3-540-85893-5_3}
}

@INBOOK{springerlink:10.1007/978-3-540-87875-9_66,
  pages = {916-917},
  title = {Panels at MODELS 2008},
  publisher = {Springer Berlin / Heidelberg},
  year = {2008},
  editor = {Czarnecki, Krzysztof and Ober, Ileana and Bruel, Jean-Michel and
	Uhl, Axel and Völter, Markus},
  author = {Ghosh, Sudipto},
  volume = {5301},
  series = {Lecture Notes in Computer Science},
  note = {10.1007/978-3-540-87875-9_66},
  abstract = {Domain-specific modeling languages (DSMLs) are designed to provide
	precise abstractions of domain-specific constructs. Models for complex
	systems typically do not fit neatly within a single domain, however.
	Moreover, capturing all important aspects of such a system requires
	developing multiple models using different DSMLs. This panel will
	explore key challenges and promising solutions associated with combining
	DSML models into multi-models.},
  affiliation = {Department of Computer Sience, Colorado State University Fort Collins
	CO 80523},
  booktitle = {Model Driven Engineering Languages and Systems},
  isbn = {978-3-540-87874-2},
  keyword = {Computer Science},
  owner = {daniel},
  timestamp = {2011.11.06},
  url = {http://dx.doi.org/10.1007/978-3-540-87875-9_66}
}

@INBOOK{springerlink:10.1007/978-3-540-87991-6_16,
  pages = {113-122},
  title = {Improving Automatic UML2 Profile Generation for MDA Industrial Development},
  publisher = {Springer Berlin / Heidelberg},
  year = {2008},
  editor = {Song, Il-Yeol and Piattini, Mario and Chen, Yi-Ping and Hartmann,
	Sven and Grandi, Fabio and Trujillo, Juan and Opdahl, Andreas and
	Ferri, Fernando and Grifoni, Patrizia and Caschera, Maria and Rolland,
	Colette and Woo, Carson and Salinesi, Camille and Zimányi, Esteban
	and Claramunt, Christophe and Frasincar, Flavius and Houben, Geert-Jan
	and Thiran, Philippe},
  author = {Giachetti, Giovanni and Valverde, Francisco and Pastor, Oscar},
  volume = {5232},
  series = {Lecture Notes in Computer Science},
  note = {10.1007/978-3-540-87991-6_16},
  abstract = {In the context of MDA-oriented solutions, a modeling language with
	a precise semantics is a mandatory requirement. Even though MDA encourages
	the use of UML, there are several MDA approaches that define their
	own Domain Specific Modeling Languages (DSML) in order to obtain
	the needed semantic precision. However, the high acceptance of UML
	in the software industry has led different MDA-approaches to integrate
	their DSMLs semantics into UML by means of UML profiles. Certain
	approaches provide alternatives to elaborate a UML profile from the
	DSML metamodel, but generally speaking, the resultant profile does
	not include all the semantic expressiveness of the original DSML.
	This paper provides a solution that is focused on the MDA industrial
	development. This solution is based on a systematic approach to generate
	a DSML metamodel that is used to automatically obtain a UML profile
	that has all the expressiveness of the original DSML.},
  affiliation = {Universidad Politécnica de Valencia Departamento de Sistemas Informáticos
	y Computación Camino de Vera s/n 46022 Valencia España},
  booktitle = {Advances in Conceptual Modeling – Challenges and Opportunities},
  isbn = {978-3-540-87990-9},
  keyword = {Computer Science},
  owner = {daniel},
  timestamp = {2011.11.06},
  url = {http://dx.doi.org/10.1007/978-3-540-87991-6_16}
}

@INBOOK{springerlink:10.1007/978-3-540-92831-7_27,
  pages = {324-339},
  title = {A Model Based Approach for GUI Development in Groupware Systems},
  publisher = {Springer Berlin / Heidelberg},
  year = {2008},
  editor = {Briggs, Robert and Antunes, Pedro and de Vreede, Gert-Jan and Read,
	Aaron},
  author = {Giraldo, William and Molina, Ana and Collazos, César and Ortega,
	Manuel and Redondo, Miguel},
  volume = {5411},
  series = {Lecture Notes in Computer Science},
  note = {10.1007/978-3-540-92831-7_27},
  abstract = {This paper proposes a methodological approach for Model Based User
	Interface Development of Collaborative Applications. This proposal
	is based on the use of several models for representing collaborative
	and interactive issues. Therefore, several techniques and notations
	are used. We describe the integration process of two notations: CIAN,
	which involves collaboration and human-computer interaction aspects;
	and UML, which specifies groupware systems functionality. In addition,
	we describe how this model is integrated into the Software Engineering
	Process. Both integration processes are developed by using software
	tools like CIAT and EPFC.},
  affiliation = {University of Quindío System and Computer Engineering Quindío Colombia},
  booktitle = {Groupware: Design, Implementation, and Use},
  isbn = {978-3-540-92830-0},
  keyword = {Computer Science},
  owner = {daniel},
  timestamp = {2011.11.06},
  url = {http://dx.doi.org/10.1007/978-3-540-92831-7_27}
}

@INBOOK{springerlink:10.1007/978-3-540-74035-3_11,
  pages = {237-261},
  title = {Architecting Dynamic Reconfiguration in Dependable Systems},
  publisher = {Springer Berlin / Heidelberg},
  year = {2007},
  editor = {de Lemos, Rogério and Gacek, Cristina and Romanovsky, Alexander},
  author = {Gomes, Antônio and Batista, Thais and Joolia, Ackbar and Coulson,
	Geoff},
  volume = {4615},
  series = {Lecture Notes in Computer Science},
  note = {10.1007/978-3-540-74035-3_11},
  abstract = {The need for dynamic reconfiguration is a complicating factor in the
	design of dependable systems, as it demands from software architects
	both rigour and planning. Although recent research has shown that
	systematic and integrated “specification-to-deployment” environments
	are promising approaches to architecting dependable systems, few
	proposals have yet considered dynamic reconfiguration, and then only
	in specific situations. In this paper, we propose a generic approach
	to supporting dynamic reconfiguration in dependable systems. The
	proposed approach is built on our view that dynamic reconfiguration
	in such systems needs to be causally connected at runtime to a corresponding
	high-level software architecture specification. In more detail, we
	propose two causally-connected models: an architecture-level model
	and a runtime-level model. Dynamic reconfiguration can be applied
	either through an architecture specification at the architecture
	level, or through reconfiguration primitives at the runtime level.
	Both foreseen and unforeseen reconfigurations are supported. We discuss
	the issues involved in handling these two types of reconfiguration
	at both levels and the mapping between them. We also discuss an implementation
	of our approach that evaluates its main benefits.},
  affiliation = {Laboratório Nacional de Computação Científica (LNCC), Av. Getúlio
	Vargas 333, 25651-075 Petrópolis-RJ Brazil},
  booktitle = {Architecting Dependable Systems IV},
  isbn = {978-3-540-74033-9},
  keyword = {Computer Science},
  owner = {daniel},
  timestamp = {2011.11.06},
  url = {http://dx.doi.org/10.1007/978-3-540-74035-3_11}
}

@INBOOK{springerlink:10.1007/978-3-540-89856-6_8,
  pages = {144-163},
  title = {\&lt;i\&gt;DeXteR\&lt;/i\&gt; – An Extensible Framework for Declarative
	Parameter Passing in Distributed Object Systems},
  publisher = {Springer Berlin / Heidelberg},
  year = {2008},
  editor = {Issarny, Valérie and Schantz, Richard},
  author = {Gopal, Sriram and Tansey, Wesley and Kannan, Gokulnath and Tilevich,
	Eli},
  volume = {5346},
  series = {Lecture Notes in Computer Science},
  note = {10.1007/978-3-540-89856-6_8},
  abstract = {In modern distributed object systems, reference parameters are passed
	to a remote method based on their runtime type. We argue that such
	type-based parameter passing is limiting with respect to expressiveness,
	readability, and maintainability, and that parameter passing semantics
	should be decoupled from parameter types. We present declarative
	parameter passing , an approach that fully decouples parameter passing
	semantics from parameter types in distributed object systems. In
	addition, we describe DeXteR, an extensible framework for transforming
	a type-based remote parameter passing model to a declaration-based
	model transparently. Our framework leverages aspect-oriented and
	generative programming techniques to enable adding new remote parameter
	passing semantics, without requiring detailed understanding of the
	underlying middleware implementation. Our approach is applicable
	to both application and library code and incurs negligible performance
	overhead. We validate the expressive power of our framework by adding
	several non-trivial remote parameter passing semantics (i.e., copy-restore,
	lazy, streaming) to Java RMI.},
  affiliation = {Virginia Tech Department of Computer Science Blacksburg VA 24061 USA},
  booktitle = {Middleware 2008},
  isbn = {978-3-540-89855-9},
  keyword = {Computer Science},
  owner = {daniel},
  timestamp = {2011.11.06},
  url = {http://dx.doi.org/10.1007/978-3-540-89856-6_8}
}

@INBOOK{springerlink:10.1007/978-3-540-75209-7_47,
  pages = {691-694},
  title = {Tutorials at MODELS 2007},
  publisher = {Springer Berlin / Heidelberg},
  year = {2007},
  editor = {Engels, Gregor and Opdyke, Bill and Schmidt, Douglas and Weil, Frank},
  author = {Gray, Jeff},
  volume = {4735},
  series = {Lecture Notes in Computer Science},
  note = {10.1007/978-3-540-75209-7_47},
  abstract = {The MODELS 2007 conference offered four high-quality tutorials from
	leading experts in the area of model-driven engineering. Each tutorial
	was presented as a half-day event that was organized during the first
	two days of the conference. This short overview provides an introduction
	to the tutorials program and a summary of each tutorial as submitted
	by the presenters.},
  affiliation = {Department of Computer and Information Sciences, University of Alabama
	at Birmingham 1300 University Boulevard, Birmingham, Alabama 35294
	USA},
  booktitle = {Model Driven Engineering Languages and Systems},
  isbn = {978-3-540-75208-0},
  keyword = {Computer Science},
  owner = {daniel},
  timestamp = {2011.11.06},
  url = {http://dx.doi.org/10.1007/978-3-540-75209-7_47}
}

@INBOOK{springerlink:10.1007/11557432_22,
  pages = {295-308},
  title = {Replicators: Transformations to Address Model Scalability},
  publisher = {Springer Berlin / Heidelberg},
  year = {2005},
  editor = {Briand, Lionel and Williams, Clay},
  author = {Gray, Jeff and Lin, Yuehua and Zhang, Jing and Nordstrom, Steve and
	Gokhale, Aniruddha and Neema, Sandeep and Gokhale, Swapna},
  volume = {3713},
  series = {Lecture Notes in Computer Science},
  note = {10.1007/11557432_22},
  abstract = {In Model Integrated Computing, it is desirable to evaluate different
	design alternatives as they relate to issues of scalability. A typical
	approach to address scalability is to create a base model that captures
	the key interactions of various components (i.e., the essential properties
	and connections among modeling entities). A collection of base models
	can be adorned with necessary information to characterize their replication.
	In current practice, replication is accomplished by scaling the base
	model manually. This is a time-consuming process that represents
	a source of error, especially when there are deep interactions between
	model components. As an alternative to the manual process, this paper
	presents the idea of a replicator, which is a model transformation
	that expands the number of elements from the base model and makes
	the correct connections among the generated modeling elements. The
	paper motivates the need for replicators through case studies taken
	from models supporting different domains.},
  affiliation = {Dept. of Computer and Information Sciences, University of Alabama
	at Birmingham, Birmingham, AL 35294-1170, USA},
  booktitle = {Model Driven Engineering Languages and Systems},
  isbn = {978-3-540-29010-0},
  keyword = {Computer Science},
  owner = {daniel},
  timestamp = {2011.11.06},
  url = {http://dx.doi.org/10.1007/11557432_22}
}

@INBOOK{springerlink:10.1007/978-3-540-25935-0_12,
  pages = {196-215},
  title = {A Language and Tool for Generating Efficient Virtual Machine Interpreters},
  publisher = {Springer Berlin / Heidelberg},
  year = {2004},
  editor = {Lengauer, Christian and Batory, Don and Consel, Charles and Odersky,
	Martin},
  author = {Gregg, David and Ertl, M.},
  volume = {3016},
  series = {Lecture Notes in Computer Science},
  note = {10.1007/978-3-540-25935-0_12},
  abstract = {Stack-based virtual machines (VMs) are a popular representation for
	implementing programming languages, and for distributing programs
	in a target neutral form. VMs can be implemented with an interpreter
	to be simple, portable, quick to start and have low memory requirements.
	These advantages make VM interpreters especially useful for minority-use
	and domain-specific languages. VM interpreters contain large amounts
	of repeated or similar code. Furthermore, interpreter optimisations
	usually involve a large number of similar changes to many parts of
	the interpreter source code. We present a domain-specific language
	for describing the instruction set architecture of a VM. Our generator
	takes the instruction definition and produces C code for processing
	the instructions in several ways: execution, VM code generation and
	optimisation, disassembly, tracing and profiling. The generator can
	apply optimisations to the generated C code for each VM instruction,
	and across instructions. Using profile-directed feedback and experimentation
	the programmer can rapidly optimise the interpreter for new architectures,
	environments and applications.},
  affiliation = {Department of Computer Science, Trinity College, Dublin 2, Ireland},
  booktitle = {Domain-Specific Program Generation},
  isbn = {978-3-540-22119-7},
  keyword = {Computer Science},
  owner = {daniel},
  timestamp = {2011.11.06},
  url = {http://dx.doi.org/10.1007/978-3-540-25935-0_12}
}

@ARTICLE{springerlink:10.1007/s10270-010-0173-9,
  author = {Groenewegen, Danny and Visser, Eelco},
  title = {Integration of data validation and user interface concerns in a DSL
	for web applications},
  journal = {Software and Systems Modeling},
  pages = {1-18},
  note = {10.1007/s10270-010-0173-9},
  abstract = {Data validation rules constitute the constraints that data input and
	processing must adhere to in addition to the structural constraints
	imposed by a data model. Web modeling tools do not make all types
	of data validation explicit in their models, hampering full code
	generation and model expressivity. Web application frameworks do
	not offer a consistent interface for data validation. In this paper,
	we present a solution for the integration of declarative data validation
	rules with user interface models in the domain of web applications,
	unifying syntax, mechanisms for error handling, and semantics of
	validation checks, and covering value well-formedness, data invariants,
	input assertions, and action assertions. We have implemented the
	approach in WebDSL, a domain-specific language for the definition
	of web applications.},
  affiliation = {Software Engineering Research Group, Delft University of Technology,
	Delft, The Netherlands},
  issn = {1619-1366},
  keyword = {Computer Science},
  owner = {daniel},
  publisher = {Springer Berlin / Heidelberg},
  timestamp = {2011.11.06},
  url = {http://dx.doi.org/10.1007/s10270-010-0173-9}
}

@INBOOK{springerlink:10.1007/978-3-540-71774-4_3,
  pages = {21-25},
  title = {Models and Aspects - Handling Crosscutting Concerns in MDSD},
  publisher = {Springer Berlin / Heidelberg},
  year = {2007},
  editor = {Südholt, Mario and Consel, Charles},
  author = {Groher, Iris and Jackson, Andrew and Schwanninger, Christa and Völter,
	Markus},
  volume = {4379},
  series = {Lecture Notes in Computer Science},
  note = {10.1007/978-3-540-71774-4_3},
  abstract = {This report summarizes the presentations and discussions of the Second
	Workshop on Models and Aspects – Handling Crosscutting Concerns
	in MDSD, held in conjunction with the 20th European Conference on
	Object-Oriented Programming (ECOOP) in Nantes, France on July, 3,
	2006. This workshop was motivated by the fact that both Model-Driven
	Software Development (MDSD) and Aspect-Oriented Software Development
	(AOSD) are important new paradigms that both promise to change the
	way software is developed. While the two approaches are different
	in many ways – MDSD adds domain-specific abstractions, while AOSD
	is currently primarily seen as domain independent (de)composition
	mechanism – they also have many things in common – for example
	both approaches integrate models on different levels of abstraction
	and in this transformation step both have a query phase followed
	by a construction phase. There are many ways that these emerging
	paradigms may be integrated to achieve the complementary benefits
	of both AOSD and MDSD. This workshop aimed at exploring new approaches
	of using both paradigms together to investigate their differences,
	commonalities and possible interworking to bring new triggers to
	both technologies.},
  affiliation = {Siemens AG, Corporate Technology, Munich Germany},
  booktitle = {Object-Oriented Technology. ECOOP 2006 Workshop Reader},
  isbn = {978-3-540-71772-0},
  keyword = {Computer Science},
  owner = {daniel},
  timestamp = {2011.11.06},
  url = {http://dx.doi.org/10.1007/978-3-540-71774-4_3}
}

@INBOOK{springerlink:10.1007/978-3-540-73597-7_22,
  pages = {269-284},
  title = {A Transformation-Driven Approach to the Verification of Security
	Policies in Web Designs},
  publisher = {Springer Berlin / Heidelberg},
  year = {2007},
  editor = {Baresi, Luciano and Fraternali, Piero and Houben, Geert-Jan},
  author = {Guerra, Esther and Sanz, Daniel and Díaz, Paloma and Aedo, Ignacio},
  volume = {4607},
  series = {Lecture Notes in Computer Science},
  note = {10.1007/978-3-540-73597-7_22},
  abstract = {In this paper, we present a verification framework for security policies
	of Web designs. The framework is based on the transformation of the
	models that conform the system design into a formalism where further
	analysis can be performed. The transformation is specified as a triple
	graph transformation system, which in addition creates mappings between
	the elements in the source and target models. This allows the back-annotation
	of the analysis results to the original model by means of triple
	graphical patterns. The verification mechanisms are provided by the
	designer of the Web design language, together with the language specification.
	However, the complexities of the formalisms are hidden to the developer
	who uses the language. As case study, we apply these ideas to Labyrinth,
	a domain specific language oriented to the design of Web applications.
	The analysis is done by a transformation into the Petri nets formalism,
	and then performing model checking on the coverability graph. The
	framework is supported by the meta-modelling tool AToM 3 .},
  affiliation = {Computer Science Department, Universidad Carlos III de Madrid (Spain)},
  booktitle = {Web Engineering},
  isbn = {978-3-540-73596-0},
  keyword = {Computer Science},
  owner = {daniel},
  timestamp = {2011.11.06},
  url = {http://dx.doi.org/10.1007/978-3-540-73597-7_22}
}

@INBOOK{springerlink:10.1007/3-540-45628-7_10,
  pages = {1-3},
  title = {Specification, Implementation, and Verification of Domain Specific
	Languages: A Logic Programming-Based Approach},
  publisher = {Springer Berlin / Heidelberg},
  year = {2002},
  editor = {Kakas, Antonis and Sadri, Fariba},
  author = {Gupta, Gopal and Pontelli, Enrico},
  volume = {2407},
  series = {Lecture Notes in Computer Science},
  note = {10.1007/3-540-45628-7_10},
  abstract = {Domain Specific Languages (DSLs) are high level languages designed
	for solving problems in a particular domain, and have been suggested
	as means for developing reliable software systems. We present a (constraint)
	logic programming-based framework for specification, efficient implementation,
	and automatic verification of domain specific languages (DSLs). Our
	framework is based on using Horn logic (or pure Prolog), and eventually
	constraints, to specify denotational semantics of domain specific
	languages. Both the syntax as well as the semantic specification
	of the DSL in question are directly executable in our framework:
	the specification itself serves as an interpreter for the DSL. More
	efficient implementations of this DSL—a compiler—can be automatically
	derived via partial evaluation. Additionally, the executable specification
	can be used for automatic or semi-automatic verification of programs
	written in the DSL as well as for automatically obtaining traditional
	debuggers and profilers. The ability to verify DSL programs is a
	distinct advantage of our approach. In this paper we give a general
	outline of our approach, and illustrate it with practical examples.},
  affiliation = {University of Texas at Dallas Applied Logic, Programming Languages
	and Systems Lab Department of Computer Science Richardson TX USA
	95083},
  booktitle = {Computational Logic: Logic Programming and Beyond},
  isbn = {978-3-540-43959-2},
  keyword = {Computer Science},
  owner = {daniel},
  timestamp = {2011.11.06},
  url = {http://dx.doi.org/10.1007/3-540-45628-7_10}
}

@INBOOK{springerlink:10.1007/11751595_101,
  pages = {964-973},
  title = {An Alternative Approach to the Standard Enterprise Resource Planning
	Life Cycle: Enterprise Reference Metamodeling},
  publisher = {Springer Berlin / Heidelberg},
  year = {2006},
  editor = {Gavrilova, Marina and Gervasi, Osvaldo and Kumar, Vipin and Tan,
	C. and Taniar, David and Laganá, Antonio and Mun, Youngsong and
	Choo, Hyunseung},
  author = {Gutiérrez, Miguel and Durán, Alfonso and Cocho, Pedro},
  volume = {3982},
  series = {Lecture Notes in Computer Science},
  note = {10.1007/11751595_101},
  abstract = {The Enterprise Resource Planning (ERP) systems development is based
	on the initial definition of an enterprise reference model, whose
	richness and generality will basically determine the flexibility
	of the resulting software package to accommodate specific requirements.
	The desired accommodation is rarely accomplished without costly customization
	processes, which are frequently unaffordable for the small and medium
	enterprises. In this paper, an alternative ERP development approach,
	stemming from the implementation of an enterprise reference metamodel,
	is proposed. We present an analysis of the resulting alternative
	ERP life cycle, particularly focusing on the metamodel that constitutes
	the core of the proposal. The results obtained in a complete enterprise
	software development project, encompassing software package development,
	tailored implementation and some post-implementation customization,
	show that the proposed approach facilitates the identification and
	fulfillment of the customer’s specific requests at a reduced cost,
	even if they arise after the implementation.},
  affiliation = {Departamento de Ingeniería Mecánica, Universidad Carlos III de Madrid,
	Av. de la Universidad 30, 28911 Leganés (Madrid), Spain},
  booktitle = {Computational Science and Its Applications - ICCSA 2006},
  isbn = {978-3-540-34075-1},
  keyword = {Computer Science},
  owner = {daniel},
  timestamp = {2011.11.06},
  url = {http://dx.doi.org/10.1007/11751595_101}
}

@INBOOK{springerlink:10.1007/978-3-540-69073-3_15,
  pages = {132-144},
  title = {Modeling and Enforcing Advanced Access Control Policies in Healthcare
	Systems with \&lt;span style="font-variant:small-caps"\&gt;\&lt;small\&gt;Sectet\&lt;/small\&gt;\&lt;/span\&gt;},
  publisher = {Springer Berlin / Heidelberg},
  year = {2008},
  editor = {Giese, Holger},
  author = {Hafner, Michael and Memon, Mukhtiar and Alam, Muhammad},
  volume = {5002},
  series = {Lecture Notes in Computer Science},
  note = {10.1007/978-3-540-69073-3_15},
  abstract = {This contribution gives an overview of various access control strategies
	in use in healthcare scenarios and shows how a variety of policies
	can be modeled based on a single security policy model for usage
	control, UCON. The core of this contribution consists of the specialization
	of the Sectet -Framework for Model Driven Security for complex healthcare
	scenarios based on UCON. The resulting Domain Architecture comprises
	a Domain Specific Language for the modeling of policies with advanced
	security requirements, a target architecture for the enforcement
	of these policies and model-to-code transformations.},
  affiliation = {University of Innsbruck Austria},
  booktitle = {Models in Software Engineering},
  isbn = {978-3-540-69069-6},
  keyword = {Computer Science},
  owner = {daniel},
  timestamp = {2011.11.06},
  url = {http://dx.doi.org/10.1007/978-3-540-69073-3_15}
}

@INBOOK{springerlink:10.1007/978-3-540-88808-6_24,
  pages = {227-235},
  title = {Please Pass the Rules: A Rule Interchange Demonstration},
  publisher = {Springer Berlin / Heidelberg},
  year = {2008},
  editor = {Bassiliades, Nick and Governatori, Guido and Paschke, Adrian},
  author = {Hallmark, Gary and de Sainte Marie, Christian and Didonet Del Fabro,
	Marcos and Albert, Patrick and Paschke, Adrian},
  volume = {5321},
  series = {Lecture Notes in Computer Science},
  note = {10.1007/978-3-540-88808-6_24},
  abstract = {It is commonly accepted that separating the declarative rules from
	the procedural code of an application makes that application easier
	to understand and easier to modify. What has been lacking is a standard
	representation for rules – until now. Using the W3C’s Rule Interchange
	Format [1], rules will be exchanged and revised among three different
	rule systems: ILOG JRules [2], Oracle [3], and Prova [4].},
  affiliation = {Oracle},
  booktitle = {Rule Representation, Interchange and Reasoning on the Web},
  isbn = {978-3-540-88807-9},
  keyword = {Computer Science},
  owner = {daniel},
  timestamp = {2011.11.06},
  url = {http://dx.doi.org/10.1007/978-3-540-88808-6_24}
}

@INBOOK{springerlink:10.1007/11498094_18,
  pages = {1071-1072},
  title = {An Architecture for Implementing Application Interoperation with
	Heterogeneous Systems},
  publisher = {Springer Berlin / Heidelberg},
  year = {2005},
  editor = {Kutvonen, Lea and Alonistioti, Nancy},
  author = {Hatzisymeon, George and Houssos, Nikos and Andreadis, Dimitris and
	Samoladas, Vasilis},
  volume = {3543},
  series = {Lecture Notes in Computer Science},
  note = {10.1007/11498094_18},
  abstract = {We are concerned with the issues faced by software developers with
	a certain family of distributed applications; those that connect
	to and interoperate with a heterogeneous infrastructure, i.e., a
	large heterogeneous collection of external systems (databases, embedded
	devices, network equipment, internet servers etc.) using different
	communication protocols. This product family includes applications
	such as e-commerce systems, network management applications and Grid-based
	collaborations. For such applications, implementing the interoperation
	logic is both challenging and expensive. We discuss the major concerns
	that contribute to the problem, such as transaction support, security
	and management, as well as integration with workflow or component
	frameworks. We propose an architecture and related development methodology,
	based on generative programming, to reduce implementation complexity,
	allow for rapid application development, ease deployment and manageability.},
  affiliation = {Tech. U. of Crete},
  booktitle = {Distributed Applications and Interoperable Systems},
  isbn = {978-3-540-26262-6},
  keyword = {Computer Science},
  owner = {daniel},
  timestamp = {2011.11.06},
  url = {http://dx.doi.org/10.1007/11498094_18}
}

@INBOOK{springerlink:10.1007/11554844_12,
  pages = {102-112},
  title = {Comparison of System Family Modeling Approaches},
  publisher = {Springer Berlin / Heidelberg},
  year = {2005},
  editor = {Obbink, Henk and Pohl, Klaus},
  author = {Haugen, Øystein and Møller-Pedersen, Birger and Oldevik, Jon},
  volume = {3714},
  series = {Lecture Notes in Computer Science},
  note = {10.1007/11554844_12},
  abstract = {A reference model for the comparison of system family modeling approaches
	is presented. Three main approaches to system family modeling are
	illustrated with a simple example and compared relative to the reference
	model.},
  affiliation = {Department of Informatics, University of Oslo, Norway},
  booktitle = {Software Product Lines},
  isbn = {978-3-540-28936-4},
  keyword = {Computer Science},
  owner = {daniel},
  timestamp = {2011.11.06},
  url = {http://dx.doi.org/10.1007/11554844_12}
}

@INBOOK{springerlink:10.1007/978-3-540-75221-9_14,
  pages = {320-348},
  title = {A Domain-Oriented, Model-Based Approach for Construction and Verification
	of Railway Control Systems},
  publisher = {Springer Berlin / Heidelberg},
  year = {2007},
  editor = {Jones, Cliff and Liu, Zhiming and Woodcock, Jim},
  author = {Haxthausen, Anne and Peleska, Jan},
  volume = {4700},
  series = {Lecture Notes in Computer Science},
  note = {10.1007/978-3-540-75221-9_14},
  abstract = {This paper describes a complete model-based development and verification
	approach for railway control systems. For each control system to
	be generated, the user makes a description of the application-specific
	parameters in a domain-specific language. This description is automatically
	transformed into an executable control system model expressed in
	SystemC. This model is then compiled into object code. Verification
	is performed using four main methods applied to different levels:
	(0) The domain-specific description is validated wrt. internal consistency
	by static analysis. (1) The crucial safety properties are verified
	for the SystemC model by means of bounded model checking. (2) The
	object code is verified to be I/O behavioural equivalent to the SystemC
	model from which it was compiled. (3) The correctness of the hardware/software
	integration is checked by automated testing.},
  affiliation = {Informatics and Mathematical Modelling, Technical University of Denmark,
	Lyngby Denmark},
  booktitle = {Formal Methods and Hybrid Real-Time Systems},
  isbn = {978-3-540-75220-2},
  keyword = {Computer Science},
  owner = {daniel},
  timestamp = {2011.11.06},
  url = {http://dx.doi.org/10.1007/978-3-540-75221-9_14}
}

@ARTICLE{springerlink:10.1007/s00165-009-0143-6,
  author = {Haxthausen, Anne and Peleska, Jan and Kinder, Sebastian},
  title = {A formal approach for the construction and verification of railway
	control systems},
  journal = {Formal Aspects of Computing},
  year = {2011},
  volume = {23},
  pages = {191-219},
  note = {10.1007/s00165-009-0143-6},
  abstract = {This paper describes a complete model-based development and verification
	approach for railway control systems. For each control system to
	be generated, the user makes a description of the application-specific
	parameters in a domain-specific language. This description is automatically
	transformed into an executable control system model expressed in
	SystemC. This model is then compiled into object code. Verification
	is performed using three main methods applied to different levels.
	(0) The domain-specific description is validated wrt. internal consistency
	by static analysis. (1) The crucial safety properties are verified
	for the SystemC model by means of bounded model checking. (2) The
	object code is verified to be I/O behaviourally equivalent to the
	SystemC model from which it was compiled.},
  affiliation = {Department of Informatics and Mathematical Modelling, Technical University
	of Denmark, bld 321, 2800 Lyngby, Denmark},
  issn = {0934-5043},
  issue = {2},
  keyword = {Computer Science},
  owner = {daniel},
  publisher = {Springer London},
  timestamp = {2011.11.06},
  url = {http://dx.doi.org/10.1007/s00165-009-0143-6}
}

@ARTICLE{springerlink:10.1007/s10270-009-0136-1,
  author = {Hemel, Zef and Kats, Lennart and Groenewegen, Danny and Visser, Eelco},
  title = {Code generation by model transformation: a case study in transformation
	modularity},
  journal = {Software and Systems Modeling},
  year = {2010},
  volume = {9},
  pages = {375-402},
  note = {10.1007/s10270-009-0136-1},
  abstract = {The realization of model-driven software development requires effective
	techniques for implementing code generators for domain-specific languages.
	This paper identifies techniques for improving separation of concerns
	in the implementation of generators. The core technique is code generation
	by model transformation , that is, the generation of a structured
	representation (model) of the target program instead of plain text.
	This approach enables the transformation of code after generation,
	which in turn enables the extension of the target language with features
	that allow better modularity in code generation rules. The technique
	can also be applied to ‘internal code generation’ for the translation
	of high-level extensions of a DSL to lower-level constructs within
	the same DSL using model-to-model transformations. This paper refines
	our earlier description of code generation by model transformation
	with an improved architecture for the composition of model-to-model
	normalization rules, solving the problem of combining type analysis
	and transformation. Instead of coarse-grained stages that alternate
	between normalization and type analysis, we have developed a new
	style of type analysis that can be integrated with normalizing transformations
	in a fine-grained manner. The normalization strategy has a simple
	extension interface and integrates non-local, context-sensitive transformation
	rules. We have applied the techniques in a realistic case study of
	domain-specific language engineering, i.e. the code generator for
	WebDSL, using Stratego, a high-level transformation language that
	integrates model-to-model, model-to-code, and code-to-code transformations.},
  affiliation = {Delft University of Technology Software Engineering Research Group
	Delft The Netherlands},
  issn = {1619-1366},
  issue = {3},
  keyword = {Computer Science},
  owner = {daniel},
  publisher = {Springer Berlin / Heidelberg},
  timestamp = {2011.11.06},
  url = {http://dx.doi.org/10.1007/s10270-009-0136-1}
}

@INBOOK{springerlink:10.1007/978-3-540-69927-9_13,
  pages = {183-198},
  title = {Code Generation by Model Transformation},
  publisher = {Springer Berlin / Heidelberg},
  year = {2008},
  editor = {Vallecillo, Antonio and Gray, Jeff and Pierantonio, Alfonso},
  author = {Hemel, Zef and Kats, Lennart and Visser, Eelco},
  volume = {5063},
  series = {Lecture Notes in Computer Science},
  note = {10.1007/978-3-540-69927-9_13},
  abstract = {The realization of model-driven software development requires effective
	techniques for implementing code generators. In this paper, we present
	a case study of code generation by model transformation with Stratego,
	a high-level transformation language based on the paradigm of rewrite
	rules with programmable strategies that integrates model-to-model,
	model-to-code, and code-to-code transformations. The use of concrete
	object syntax guarantees syntactic correctness of code patterns,
	and enables the subsequent transformation of generated code. The
	composability of strategies supports two dimensions of transformation
	modularity . Vertical modularity is achieved by designing a generator
	as a pipeline of model-to-model transformations that gradually transforms
	a high-level input model to an implementation. Horizontal modularity
	is achieved by supporting the definition of plugins which implement
	all aspects of a language feature. We discuss the application of
	these techniques in the implementation of WebDSL, a domain-specific
	language for dynamic web applications with a rich data model.},
  affiliation = {Delft University of Technology Software Engineering Research Group
	The Netherlands},
  booktitle = {Theory and Practice of Model Transformations},
  isbn = {978-3-540-69926-2},
  keyword = {Computer Science},
  owner = {daniel},
  timestamp = {2011.11.06},
  url = {http://dx.doi.org/10.1007/978-3-540-69927-9_13}
}

@ARTICLE{springerlink:10.1007/s10664-011-9162-z,
  author = {Herbold, Steffen and Grabowski, Jens and Waack, Stephan},
  title = {Calculation and optimization of thresholds for sets of software metrics},
  journal = {Empirical Software Engineering},
  year = {2011},
  volume = {16},
  pages = {812-841},
  note = {10.1007/s10664-011-9162-z},
  abstract = {In this article, we present a novel algorithmic method for the calculation
	of thresholds for a metric set. To this aim, machine learning and
	data mining techniques are utilized. We define a data-driven methodology
	that can be used for efficiency optimization of existing metric sets,
	for the simplification of complex classification models, and for
	the calculation of thresholds for a metric set in an environment
	where no metric set yet exists. The methodology is independent of
	the metric set and therefore also independent of any language, paradigm
	or abstraction level. In four case studies performed on large-scale
	open-source software metric sets for C functions, C+ +, C# methods
	and Java classes are optimized and the methodology is validated.},
  affiliation = {Institute of Computer Science, University of Göttingen, Goldschmidtstr.
	7, 37077 Göttingen, Germany},
  issn = {1382-3256},
  issue = {6},
  keyword = {Computer Science},
  owner = {daniel},
  publisher = {Springer Netherlands},
  timestamp = {2011.11.06},
  url = {http://dx.doi.org/10.1007/s10664-011-9162-z}
}

@INBOOK{springerlink:10.1007/978-3-540-75209-7_4,
  pages = {46-60},
  title = {Guided Development with Multiple Domain-Specific Languages},
  publisher = {Springer Berlin / Heidelberg},
  year = {2007},
  editor = {Engels, Gregor and Opdyke, Bill and Schmidt, Douglas and Weil, Frank},
  author = {Hessellund, Anders and Czarnecki, Krzysztof and Wąsowski, Andrzej},
  volume = {4735},
  series = {Lecture Notes in Computer Science},
  note = {10.1007/978-3-540-75209-7_4},
  abstract = {We study the Apache Open for Business (OFBiz), an industrial-strength
	platform for enterprise applications. OFBiz is an example of a substantial
	project using model-driven development with multiple domain-specific
	languages (DSLs). We identify consistency management as one of its
	key challenges. To address this challenge, we present SmartEMF, which
	is an extension of the Eclipse Modeling Framework that provides support
	for representing, checking, and maintaining constraints in the context
	of multiple loosely-coupled DSLs. SmartEMF provides a simple form
	of user guidance by computing the valid set of editing operations
	that are available in a given context. We evaluate the prototype
	by applying it to the OFBiz project.},
  affiliation = {IT University of Copenhagen Denmark},
  booktitle = {Model Driven Engineering Languages and Systems},
  isbn = {978-3-540-75208-0},
  keyword = {Computer Science},
  owner = {daniel},
  timestamp = {2011.11.06},
  url = {http://dx.doi.org/10.1007/978-3-540-75209-7_4}
}

@INBOOK{springerlink:10.1007/978-3-540-88871-0_38,
  pages = {515-534},
  title = {DQML: A Modeling Language for Configuring Distributed Publish/Subscribe
	Quality of Service Policies},
  publisher = {Springer Berlin / Heidelberg},
  year = {2008},
  editor = {Meersman, Robert and Tari, Zahir},
  author = {Hoffert, Joe and Schmidt, Douglas and Gokhale, Aniruddha},
  volume = {5331},
  series = {Lecture Notes in Computer Science},
  note = {10.1007/978-3-540-88871-0_38},
  abstract = {Many publish/subscribe (pub/sub) middleware platforms provide flexibility
	in configuring policies that affect end-to-end quality of service
	(QoS). While the functionality and tunability of pub/sub middleware
	has increased, so has the complexity of creating semantically compatible
	QoS policy configurations. This paper makes two contributions to
	addressing these challenges. First, it describes how a domain-specific
	modeling language (DSML) can automate the analysis and synthesis
	of semantically compatible QoS policy configurations. Second, it
	empirically evaluates how this DSML increases productivity when generating
	valid QoS policy configurations. Our experimental results show a
	54% reduction in development effort using DQML over manual methods.},
  affiliation = {Vanderbilt University Institute for Software Integrated Systems, Dept.
	of EECS Nashville TN USA 37203},
  booktitle = {On the Move to Meaningful Internet Systems: OTM 2008},
  isbn = {978-3-540-88870-3},
  keyword = {Computer Science},
  owner = {daniel},
  timestamp = {2011.11.06},
  url = {http://dx.doi.org/10.1007/978-3-540-88871-0_38}
}

@ARTICLE{springerlink:10.1007/s10619-011-7079-6,
  author = {Hummer, Waldemar and Leitner, Philipp and Dustdar, Schahram},
  title = {SEPL—a domain-specific language and execution environment for protocols
	of stateful Web services},
  journal = {Distributed and Parallel Databases},
  year = {2011},
  volume = {29},
  pages = {277-307},
  note = {10.1007/s10619-011-7079-6},
  abstract = {In order to interact with stateful Web services, clients need to obtain
	information about the intra-service protocol, which contains valid
	operation sequences and the expected input-output transformation
	across invocations. While the community has widely agreed on WSDL
	as the standard for functional service description (the “static”
	service interface), there is still an evident lack of languages to
	describe the dynamic, behavioral interface of services. In this paper
	we introduce SEPL ( SErvice Protocol Language ), a domain-specific
	language (DSL) for defining executable intra-service protocols. Notable
	features of the DSL include support for WS-Addressing and simple
	creation of new Web service instances, synchronous and asynchronous
	service invocation facilities and easy access to WSRF-style service
	resource properties. Service providers use SEPL to define the procedure
	that clients must adhere to in order to achieve a certain higher-level
	functionality. Clients use the combined information of the SEPL document
	and the WSDL definitions to execute an intra-service protocol. We
	provide a graphical representation of SEPL the form of UML Activity
	Diagrams, and tools to generate executable code from these models.
	We further present a solution to host and execute SEPL protocols
	in a server application based on Web services technology.},
  affiliation = {Distributed Systems Group, Vienna University of Technology, Argentinierstrasse
	8/184-1, 1040 Vienna, Austria},
  issn = {0926-8782},
  issue = {4},
  keyword = {Computer Science},
  owner = {daniel},
  publisher = {Springer Netherlands},
  timestamp = {2011.11.06},
  url = {http://dx.doi.org/10.1007/s10619-011-7079-6}
}

@INBOOK{springerlink:10.1007/3-540-49255-0_36,
  pages = {583-583},
  title = {Applying a Domain Specific Language Approach to Component Oriented
	Programming},
  publisher = {Springer Berlin / Heidelberg},
  year = {1998},
  editor = {Demeyer, Serge and Bosch, Jan},
  author = {Ingham, James and Munro, Malcolm},
  volume = {1543},
  series = {Lecture Notes in Computer Science},
  note = {10.1007/3-540-49255-0_36},
  abstract = {A number of methods have been suggested to deal with component specification
	(e.g. Buichi and Sekerinski [ 1 ]), re-use (e.g Lalanda [ 2 ]) and
	fault-management (e.g Baggiolini and Harms [ 3 ]). At Durham we propose
	the use of a Domain Oriented method in order to specify the semantic
	and syntactic properties of components, to provide a framework in
	which to re-use and re-configure the components and to provide additional
	optimisation and fault-tolerant behaviour. We are currently developing
	a prototype Domain Specific Language (DSL) which describes a “model”
	domain of cost-accounting. In order to implement this prototype we
	are using Java, CORBA and JESS (Java Expert System Shell [ 4 ]) and
	a distributed component model. Different categories of component
	types (e.g. persistent components) are being identified and guidelines
	for their use documented. By developing many little languages (as
	per Deursen and Klint [ 5 ]) it is claimed that the maintenance effort
	will be reduced. After the implementation and evaluation of this
	“toy domain”, we propose to apply these techniques to an industrial
	software system by working closely with a large telecommunications
	company. This paper identifies a number of issues which the authors
	feel are important for Component Oriented Programming to succeed.
	Then we define DSL’ s and outline how and why we are using them,
	first in general terms and then in terms of the issues outlined earlier.
	In order to promote component re-use we are advocating automating
	some methods of error detection which will be encoded into the DSL.
	This will enable a current configuration of components to detect
	certain error conditions and, with the help of extra domain knowledge
	and the underlying system architecture, attempt to remedy the situation.
	This is followed by a brief overview of the supporting architecture
	which has been developed to allow the mapping of DSL constructs to
	component code and to automatically insert test code where applicable.
	This architecture is currently being implemented in Java and CORBA
	at the University of Durham. We have also included an outline of
	the “toy domain” DSL language. Although this architecture addresses
	many important aspects of re-use, it is acknowledged that it is still
	based on the assumption of “as is” re-use or human intervention
	at times of component development. However it is argued that for
	this approach these are not unreasonable assumptions.},
  affiliation = {University Of Durham Centre for Software Maintenance UK},
  booktitle = {Object-Oriented Technology: ECOOP’98 Workshop Reader},
  isbn = {978-3-540-65460-5},
  keyword = {Computer Science},
  owner = {daniel},
  timestamp = {2011.11.06},
  url = {http://dx.doi.org/10.1007/3-540-49255-0_36}
}

@ARTICLE{springerlink:10.1007/s10270-008-0105-0,
  author = {Jackson, Ethan and Sztipanovits, Janos},
  title = {Formalizing the structural semantics of domain-specific modeling
	languages},
  journal = {Software and Systems Modeling},
  year = {2009},
  volume = {8},
  pages = {451-478},
  note = {10.1007/s10270-008-0105-0},
  abstract = {Model-based approaches to system design are now widespread and successful.
	These approaches make extensive use of model structure to describe
	systems using domain-specific abstractions, to specify and implement
	model transformations, and to analyze structural properties of models.
	In spite of its general importance the structural semantics of modeling
	languages are not well-understood. In this paper we develop the formal
	foundations for the structural semantics of domain-specific modeling
	languages (DSML), including the mechanisms by which metamodels specify
	the structural semantics of DSMLs. Additionally, we show how our
	formalization can complement existing tools, and how it yields algorithms
	for the analysis of DSMLs and model transformations.},
  affiliation = {Microsoft Research Foundations of Software Engineering Redmond WA
	USA},
  issn = {1619-1366},
  issue = {4},
  keyword = {Computer Science},
  owner = {daniel},
  publisher = {Springer Berlin / Heidelberg},
  timestamp = {2011.11.06},
  url = {http://dx.doi.org/10.1007/s10270-008-0105-0}
}

@ARTICLE{springerlink:10.1007/s10009-010-0148-8,
  author = {Jakumeit, Edgar and Buchwald, Sebastian and Kroll, Moritz},
  title = {GrGen.NET},
  journal = {International Journal on Software Tools for Technology Transfer (STTT)},
  year = {2010},
  volume = {12},
  pages = {263-271},
  note = {10.1007/s10009-010-0148-8},
  abstract = {GrGen.NET is a generative programming system for graph rewriting,
	transforming intuitive and expressive rewrite rule specifications
	into highly efficient .NET code. The user is supported by a convenient
	environment consisting of a graph viewer, an interactive shell with
	integrated debugging support, and an elegant domain-specific language
	for the combination of rewrite rules. After rapid prototyping with
	these tools, the resulting graph transformation programmes can be
	easily integrated into arbitrary .NET applications to serve as the
	algorithmic kernel. Expressiveness, convenience, and speed are exemplified
	by GrGen-solutions to the case studies AntWorld, Refactoring, and
	Conference Scheduling—besides others.},
  affiliation = {Universität Karlsruhe Institut für Programmstrukturen und Datenorganisation
	Karlsruhe Germany},
  issn = {1433-2779},
  issue = {3},
  keyword = {Computer Science},
  owner = {daniel},
  publisher = {Springer Berlin / Heidelberg},
  timestamp = {2011.11.06},
  url = {http://dx.doi.org/10.1007/s10009-010-0148-8}
}

@INBOOK{springerlink:10.1007/11763864_32,
  pages = {399-402},
  title = {GENMADEM: A Methodology for Generative Multi-agent Domain Engineering},
  publisher = {Springer Berlin / Heidelberg},
  year = {2006},
  editor = {Morisio, Maurizio},
  author = {Jansen, Mauro and Girardi, Rosario},
  volume = {4039},
  series = {Lecture Notes in Computer Science},
  note = {10.1007/11763864_32},
  abstract = {The generative approach is one of the most productive ways to promote
	the automatic reuse in software product lines. Multi-Agent Domain
	Engineering is a process to build multi-agent system families. This
	paper describes GENMADEM, an ontology-based methodology for generative
	multi-agent domain engineering whose main products are ontology-based
	domain models, domain specific languages and application generators.},
  affiliation = {Federal University of Maranhão (UFMA), Av. dos Portugueses, s/n,
	Campus do Bacanga, CEP 65080-040 São Luís, MA Brasil},
  booktitle = {Reuse of Off-the-Shelf Components},
  isbn = {978-3-540-34606-7},
  keyword = {Computer Science},
  owner = {daniel},
  timestamp = {2011.11.06},
  url = {http://dx.doi.org/10.1007/11763864_32}
}

@INBOOK{springerlink:10.1007/3-540-46020-9_2,
  pages = {261-282},
  title = {Source Tree Composition},
  publisher = {Springer Berlin / Heidelberg},
  year = {2002},
  editor = {Gacek, Cristina},
  author = {de Jonge, Merijn},
  volume = {2319},
  series = {Lecture Notes in Computer Science},
  note = {10.1007/3-540-46020-9_2},
  abstract = {Dividing software systems in components improves software reusability
	as well as software maintainability. Components live at several levels,
	we concentrate on the implementation level where components are formed
	by source files, divided over directory structures. Such source code
	components are usually strongly coupled in the directory structure
	of a software system. Their compilation is usually controlled by
	a single global build process. This entangling of source trees and
	build processes often makes reuse of source code components in different
	software systems difficult. It also makes software systems inflexible
	because integration of additional source code components in source
	trees and build processes is difficult. This paper’s subject is
	to increase software reuse by decreasing coupling of source code
	components. It is achieved by automized assembly of software systems
	from reusable source code components and involves integration of
	source trees, build processes, and configuration processes. Application
	domains include generative programming, product-line architectures
	, and commercial off-the-shelf (COTS) software engineering.},
  affiliation = {CWI P.O. Box 94079 1090 GB Amsterdam The Netherlands},
  booktitle = {Software Reuse: Methods, Techniques, and Tools},
  isbn = {978-3-540-43483-2},
  keyword = {Computer Science},
  owner = {daniel},
  timestamp = {2011.11.06},
  url = {http://dx.doi.org/10.1007/3-540-46020-9_2}
}

@INBOOK{springerlink:10.1007/3-540-46020-9_27,
  pages = {79-98},
  title = {Workshop on Generative Programming 2002 (GP2002)},
  publisher = {Springer Berlin / Heidelberg},
  year = {2002},
  editor = {Gacek, Cristina},
  author = {de Jonge, Merijn and Visser, Joost},
  volume = {2319},
  series = {Lecture Notes in Computer Science},
  note = {10.1007/3-540-46020-9_27},
  abstract = {Background . The goal of generative programming is to replace manual
	search, adaptation, and assembly of components with the automatic
	generation of needed components on demand. Generative technology
	has been in practical use for decades (e.g., compiler development,
	application generation, automatic configuration management, preprocessing,
	and meta-programming). However, developing new domain-specific languages
	(DSLs), application generators, and component generators has been
	extremely hard, as it requires being knowledgeable and experienced
	both in language design and compiler development. Recent developments
	such as XML technologies and template meta-programming revived the
	interest in generative programming by making it more accessible to
	developers.},
  booktitle = {Software Reuse: Methods, Techniques, and Tools},
  isbn = {978-3-540-43483-2},
  keyword = {Computer Science},
  owner = {daniel},
  timestamp = {2011.11.06},
  url = {http://dx.doi.org/10.1007/3-540-46020-9_27}
}

@INBOOK{springerlink:10.1007/11768869_14,
  pages = {171-185},
  title = {KM3: A DSL for Metamodel Specification},
  publisher = {Springer Berlin / Heidelberg},
  year = {2006},
  editor = {Gorrieri, Roberto and Wehrheim, Heike},
  author = {Jouault, Frédéric and Bézivin, Jean},
  volume = {4037},
  series = {Lecture Notes in Computer Science},
  note = {10.1007/11768869_14},
  abstract = {We consider in this paper that a DSL (Domain Specific Language) may
	be defined by a set of models. A typical DSL is the ATLAS Transformation
	Language (ATL). An ATL program transforms a source model (conforming
	to a source metamodel) into a target model (conforming to a target
	metamodel). Being itself a model, the transformation program conforms
	to the ATL metamodel. The notion of metamodel is thus used to define
	the source DSL, the target DSL and the transformation DSL itself.
	As a consequence we can see that agility to define metamodels and
	precision of these definitions is of paramount importance in any
	model engineering activity. In order to fullfill the goals of agility
	and precision in the definition of our metamodels, we have been using
	a notation called KM3 (Kernel MetaMetaModel). KM3 may itself be considered
	as a DSL for describing metamodels. This paper presents the rationale
	for using KM3, some examples of its use and a precise definition
	of the language.},
  affiliation = {ATLAS team, INRIA and LINA},
  booktitle = {Formal Methods for Open Object-Based Distributed Systems},
  isbn = {978-3-540-34893-1},
  keyword = {Computer Science},
  owner = {daniel},
  timestamp = {2011.11.06},
  url = {http://dx.doi.org/10.1007/11768869_14}
}

@INBOOK{springerlink:10.1007/11561347_17,
  pages = {237-255},
  title = {Applying a Generative Technique for Enhanced Genericity and Maintainability
	on the J2EE Platform},
  publisher = {Springer Berlin / Heidelberg},
  year = {2005},
  editor = {Glück, Robert and Lowry, Michael},
  author = {Jun, Yang and Jarzabek, Stan},
  volume = {3676},
  series = {Lecture Notes in Computer Science},
  note = {10.1007/11561347_17},
  abstract = {One of the themes in building reusable and maintainable software is
	identifying similarities and designing generic solutions to unify
	similarity patterns. In this paper, we analyze capabilities of J2EE
	to effectively unify similarity patterns found in Web Portals (WP).
	Our experimentation involved a family of WPs to support information
	sharing and team collaboration, built by our industry partner. While
	J2EE provides useful mechanisms for reuse of common services across
	components, we found its limitations in systematic across-the-board
	reuse in application domain-specific areas. To solve these problems,
	we applied a generative programming (GP) technique of XVCL on top
	of J2EE. By unifying similarity patterns, we increased the clarity
	of portal’s conceptual structure as perceived by developers, reducing
	also the size of the original J2EE WP by 61%. Our solution enhanced
	traceability of information that mattered during changes. Based on
	that we hypothesized that XVCL-enhanced J2EE WP would be easier to
	maintain than the original J2EE WP. In the paper, we describe our
	solution and evaluate its engineering merits in both quantitative
	and qualitative ways.},
  affiliation = {Department of Computer Science, School of Computing, National University
	of Singapore, Lower Kent Ridge Road, 117543 Singapore},
  booktitle = {Generative Programming and Component Engineering},
  isbn = {978-3-540-29138-1},
  keyword = {Computer Science},
  owner = {daniel},
  timestamp = {2011.11.06},
  url = {http://dx.doi.org/10.1007/11561347_17}
}

@INBOOK{springerlink:10.1007/11823063_8,
  pages = {103-115},
  title = {Automotive Software: A Challenge and Opportunity for Model-Based
	Software Development},
  publisher = {Springer Berlin / Heidelberg},
  year = {2006},
  editor = {Broy, Manfred and Krüger, Ingolf and Meisinger, Michael},
  author = {Karsai, Gabor},
  volume = {4147},
  series = {Lecture Notes in Computer Science},
  note = {10.1007/11823063_8},
  abstract = {Embedded software development for automotive applications is widely
	considered as a significant source of innovation and improvements
	in cars. However, software development processes do not address well
	the needs of large-scale distributed real-time systems, like the
	ones automobiles do (or soon will) contain. The paper introduces
	a vision for the model-based development of embedded software, which
	is based on the broad-spectrum modeling of the applications in the
	context of a larger system, formal (and computer-supported) analysis
	of models, and automatic synthesis of the application(s). The paper
	also describes some initial steps taken to build the infrastructure
	for supporting such a process in the form of modeling and model transformation
	tools. The paper concludes with a list of challenging research problems.},
  affiliation = {Institute for Software Integrated Systems Vanderbilt University, P.O.
	Box 1829 Sta. B., Nashville, TN 37235, USA},
  booktitle = {Automotive Software – Connected Services in Mobile Networks},
  isbn = {978-3-540-37677-4},
  keyword = {Computer Science},
  owner = {daniel},
  timestamp = {2011.11.06},
  url = {http://dx.doi.org/10.1007/11823063_8}
}

@INBOOK{springerlink:10.1007/978-3-540-25959-6_18,
  pages = {243-259},
  title = {Graph Transformations in OMG’s Model-Driven Architecture},
  publisher = {Springer Berlin / Heidelberg},
  year = {2004},
  editor = {Pfaltz, John and Nagl, Manfred and Böhlen, Boris},
  author = {Karsai, Gabor and Agrawal, Aditya},
  volume = {3062},
  series = {Lecture Notes in Computer Science},
  note = {10.1007/978-3-540-25959-6_18},
  abstract = {The Model-Driven Architecture (MDA) vision of the Object Management
	Group offers a unique opportunity for introducing Graph Transformation
	(GT) technology to the software industry. The paper proposes a domain-specific
	refinement of MDA, and describes a practical manifestation of MDA
	called Model-Integrated Computing (MIC). MIC extends MDA towards
	domain-specific modeling languages, and it is well supported by various
	generic tools that include model transformation tools based on graph
	transformations. The MIC tools are metaprogrammable, i.e. they can
	be tailored for specific domains using metamodels that include metamodels
	of transformations. The paper describes the development process and
	the supporting tools of MIC, and it raises a number of issues for
	future research on GT in MDA.},
  affiliation = {Institute for Software Integrated Systems (ISIS), Vanderbilt University,
	Nashville, TN, USA},
  booktitle = {Applications of Graph Transformations with Industrial Relevance},
  isbn = {978-3-540-22120-3},
  keyword = {Computer Science},
  owner = {daniel},
  timestamp = {2011.11.06},
  url = {http://dx.doi.org/10.1007/978-3-540-25959-6_18}
}

@INBOOK{springerlink:10.1007/978-3-540-77442-6_9,
  pages = {116-132},
  title = {Specialising Simulator Generators for High-Performance Monte-Carlo
	Methods},
  publisher = {Springer Berlin / Heidelberg},
  year = {2008},
  editor = {Hudak, Paul and Warren, David},
  author = {Keller, Gabriele and Chaffey-Millar, Hugh and Chakravarty, Manuel
	and Stewart, Don and Barner-Kowollik, Christopher},
  volume = {4902},
  series = {Lecture Notes in Computer Science},
  note = {10.1007/978-3-540-77442-6_9},
  abstract = {We address the tension between software generality and performance
	in the domain of simulations based on Monte-Carlo methods. We simultaneously
	achieve generality and high performance by a novel development methodology
	and software architecture centred around the concept of a specialising
	simulator generator. Our approach combines and extends methods from
	functional programming, generative programming, partial evaluation,
	and runtime code generation. We also show how to generate parallelised
	simulators. We evaluated our approach by implementing a simulator
	for advanced forms of polymerisation kinetics. We achieved unprecedented
	performance, making Monte-Carlo methods practically useful in an
	area that was previously dominated by deterministic PDE solvers.
	This is of high practical relevance, as Monte-Carlo simulations can
	provide detailed microscopic information that cannot be obtained
	with deterministic solvers.},
  affiliation = {University of New South Wales Programming Languages and Systems, School
	of Computer Science and Engineering},
  booktitle = {Practical Aspects of Declarative Languages},
  isbn = {978-3-540-77441-9},
  keyword = {Computer Science},
  owner = {daniel},
  timestamp = {2011.11.06},
  url = {http://dx.doi.org/10.1007/978-3-540-77442-6_9}
}

@INBOOK{springerlink:10.1007/11590019_6,
  pages = {60-69},
  title = {Efficient Implementation of Intelligent Office Appliances with Software
	Product Lines},
  publisher = {Springer Berlin / Heidelberg},
  year = {2005},
  editor = {Althoff, Klaus-Dieter and Dengel, Andreas and Bergmann, Ralph and
	Nick, Markus and Roth-Berghofer, Thomas},
  author = {Keuler, Thorsten and Lehner, Theresa and Decker, Björn and Muthig,
	Dirk},
  volume = {3782},
  series = {Lecture Notes in Computer Science},
  note = {10.1007/11590019_6},
  abstract = {To support the handling of documents in organizations, office appliances
	have to adapt to the work processes of that organization. To efficiently
	handle changes in the software imposed by these adaptations, we present
	an approach to use business process models to compose the basic features
	of an office appliance into customer-oriented, process-specific services
	offered by office devices. Software product lines shape the key concepts
	that enable cost-effective and therefore realistic implementations
	of the ideas presented.},
  affiliation = {Fraunhofer Institute for Experimental Software Engineering, 67661
	Kaiserslautern, Germany},
  booktitle = {Professional Knowledge Management},
  isbn = {978-3-540-30465-4},
  keyword = {Computer Science},
  owner = {daniel},
  timestamp = {2011.11.06},
  url = {http://dx.doi.org/10.1007/11590019_6}
}

@INBOOK{springerlink:10.1007/3-540-45350-4_1,
  pages = {1-2},
  title = {Implementing Closed Domain-Specific Languages},
  publisher = {Springer Berlin / Heidelberg},
  year = {2000},
  editor = {Taha, Walid},
  author = {Kieburtz, Richard},
  volume = {1924},
  series = {Lecture Notes in Computer Science},
  note = {10.1007/3-540-45350-4_1},
  abstract = {A closed domain-specific language (DSL) is a stand-alone, declarative
	language designed to provide powerful and flexible software solutions
	specialized to a particular application domain. The users of a closed
	DSL are expected to be engineers or designers expert in the the-
	ory and techniques of their application domain, but who may be naive
	as programmers and who may not have the expertise, time, or inclina-
	tion to design their own software. A good DSL will capture both the
	nomenclature and the semantics of the application domain. We contrast
	closed DSL’s with open DSL’s, which are also useful, but for
	a different community of users. An open DSL denotes crucial abstractions
	of an application domain directly in the notation of a wide-spectrum
	programming language, possibly enriched with syntactic extensions.
	It supports the semantics of the application domain through a specialized
	library of combinators, usually written in the host language, although
	they may also be provided by linkage to a foreign-language library.
	Open DSL’s are popular with computer scientists, for whom the ability
	to extend the DSL by writing new combinators has a high value, and
	for whom the syntactic quirks of the host language and the nuances
	of its type system present little difficulty. For domain experts
	who are not computer scientists, the benefits of programming “under
	the hood” have less attraction and an invitation to interpret an
	obfuscatory error message can be daunting. Hence, interest in techniques
	by which closed DSL’s can be easily implemented remains high. We
	advocate defining the semantics of a closed DSL in terms of a uni-
	versal set of semantics combinators which form a structure algebra
	over a suitable domain. The combinator set may include constructors
	and destructors of algebraic data types. By exchanging the domain
	of the combinator algebra for a domain of abstract machine states,
	one auto- matically derives an implementation of the DSL in terms
	of byte code instructions for an abstract machine. The correctness
	of this implementa- tion is proved by showing coherence of the operational,
	abstract machine semantics with the denotational semantics. Advantages
	of this approach are that the “library” of semantics combina-
	tors is independent of the particular DSL to be implemented. The
	effort required to implement a semantics combinator library and to
	prove its coherence with respect to a denotational semantics can
	be amortized over multiple uses to implement a variety of DSL’s.
	A combinator-based im- plementation is also amenable to improvement
	by aggressive, automatic program transformation. Furthermore, the
	underlying abstract machine can easily be implemented on a new host
	architecture or via a platform- independent assembly language such
	as ‘C’. We compare this approach with several other approaches
	that have been taken to implement DSL’s. The design of suitable
	type systems and in- telligible error reporting remains a challenging
	issue. Users of a DSL are less interested in a programmer’s notion
	of types, which abstract the underlying computational semantics of
	the DSL, than in types that characterize the crucial abstractions
	of their application domain.},
  affiliation = {Oregon Graduate Institute 20000 NW Walker Road Beaverton OR 97006
	USA},
  booktitle = {Semantics, Applications, and Implementation of Program Generation},
  isbn = {978-3-540-41054-6},
  keyword = {Computer Science},
  owner = {daniel},
  timestamp = {2011.11.06},
  url = {http://dx.doi.org/10.1007/3-540-45350-4_1}
}

@INBOOK{springerlink:10.1007/978-3-540-72901-3_9,
  pages = {114-129},
  title = {Towards the Generation of a Text-Based IDE from a Language Metamodel},
  publisher = {Springer Berlin / Heidelberg},
  year = {2007},
  editor = {Akehurst, David and Vogel, Régis and Paige, Richard},
  author = {Kleppe, Anneke},
  volume = {4530},
  series = {Lecture Notes in Computer Science},
  note = {10.1007/978-3-540-72901-3_9},
  abstract = {In the model driven world languages are usually specified by a (meta)
	model of their abstract syntax. For textual languages this is different
	from the traditional approach, where the language is specified by
	a (E)BNF grammar. Support for the designer of textual languages,
	e.g. a parser generator, is therefore normally based on grammars.
	This paper shows that similar support for language design based on
	metamodels is not only possible, but is even more powerful than the
	support based on grammars. In this paper we describe how an integrated
	development environment for a language can be generated from the
	language’s abstract syntax metamodel, thus providing the language
	designer with the possibility to quickly, and with little effort,
	create not only a new language but also the tooling necessary for
	using this language.},
  affiliation = {University Twente Netherlands Netherlands},
  booktitle = {Model Driven Architecture- Foundations and Applications},
  isbn = {978-3-540-72900-6},
  keyword = {Computer Science},
  owner = {daniel},
  timestamp = {2011.11.06},
  url = {http://dx.doi.org/10.1007/978-3-540-72901-3_9}
}

@INBOOK{springerlink:10.1007/11581741_17,
  pages = {220-238},
  title = {Towards General Purpose, High Level, Software Languages},
  publisher = {Springer Berlin / Heidelberg},
  year = {2005},
  editor = {Hartman, Alan and Kreische, David},
  author = {Kleppe, Anneke},
  volume = {3748},
  series = {Lecture Notes in Computer Science},
  note = {10.1007/11581741_17},
  abstract = {A highly significant benefit of MDA is that it raises the level of
	abstraction at which the soft-ware developer is able to work. However,
	the languages available to the developer have not seen much change
	in the last decade. Modeling languages offer high level concepts,
	but the pre-dominant modeling language (UML) offers too little expressive
	power to be able to specify a system completely. Meanwhile, the level
	of abstraction of most programming language con-cepts is the same
	as 10 to 15 years ago. Although transformation tools may to some
	extent bridge the gap between modeling and programming languages,
	in practice the developer still needs to do both modeling and programming.
	This means switching between the two levels of abstractions, which
	is difficult for most people. We argue that a general purpose, high
	level, software language is necessary to get MDA adopted. This language
	will enable any developer to focus on the problem at hand while the
	supporting tools – transformation tools or generators- take care
	of the nitty gritty details. This paper introduces an early version
	of such a language, which brings together a number of powerful concepts
	from various sources: UML, OCL, design patterns, existing programming
	languages, and eventually aspect-oriented languages.},
  affiliation = {Klasse Objecten, Netherlands},
  booktitle = {Model Driven Architecture – Foundations and Applications},
  isbn = {978-3-540-30026-7},
  keyword = {Computer Science},
  owner = {daniel},
  timestamp = {2011.11.06},
  url = {http://dx.doi.org/10.1007/11581741_17}
}

@ARTICLE{springerlink:10.1007/s10664-011-9172-x,
  author = {Kosar, Tomaž and Mernik, Marjan and Carver, Jeffrey},
  title = {Program comprehension of domain-specific and general-purpose languages:
	comparison using a family of experiments},
  journal = {Empirical Software Engineering},
  pages = {1-29},
  note = {10.1007/s10664-011-9172-x},
  abstract = {Domain-specific languages (DSLs) are often argued to have a simpler
	notation than general-purpose languages (GPLs), since the notation
	is adapted to the specific problem domain. Consequently, the impact
	of domain relevance on the creation of the problem representation
	is believed to improve programmers’ efficiency and accuracy when
	using DSLs compared with using similar solutions like application
	libraries in GPLs. Most of the common beliefs have been based upon
	qualitative conclusions drawn by developers. Rather than implementing
	the same problem in a DSL and in a GPL and comparing the efficiency
	and accuracy of each approach, developers often compare the implementation
	of a new program in a DSL to their previous experiences implementing
	similar programs in GPLs. Such a conclusion may or may not be valid.
	This paper takes a more skeptical approach to acceptance of those
	beliefs. By reporting on a family of three empirical studies comparing
	DSLs and GPLs in different domains. The results of the studies showed
	that when using a DSL, developers are more accurate and more efficient
	in program comprehension than when using a GPL. These results validate
	some of the long- held beliefs of the DSL community that until now
	were only supported by anecdotal evidence.},
  affiliation = {Faculty of Electrical Engineering and Computer Science, University
	of Maribor, Smetanova ulica 17, 2000 Maribor, Slovenia},
  issn = {1382-3256},
  keyword = {Computer Science},
  owner = {daniel},
  publisher = {Springer Netherlands},
  timestamp = {2011.11.06},
  url = {http://dx.doi.org/10.1007/s10664-011-9172-x}
}

@INBOOK{springerlink:10.1007/978-3-540-30175-2_21,
  pages = {245-292},
  title = {VS-Gen: A Case Study of a Product Line for Versioning Systems},
  publisher = {Springer Berlin / Heidelberg},
  year = {2004},
  editor = {Karsai, Gabor and Visser, Eelco},
  author = {Kovse, Jernej and Gebauer, Christian},
  volume = {3286},
  series = {Lecture Notes in Computer Science},
  note = {10.1007/978-3-540-30175-2_21},
  abstract = {This paper describes our experience with developing a product line
	for middleware-based versioning systems. We perform a detailed domain
	analysis and define a DSL for configuring individual systems. Afterwards,
	we present a template-based approach for generating versioning systems
	from UML models. The presented approach is evaluated from two perspectives.
	We first use diverse measures to determine the properties of code
	templates used by the generator. Afterwards, we compare the performance
	of a generated versioning system to a system that has been developed
	by means of a framework and thus has to rely on a set of generic
	implementation components.},
  affiliation = {Department of Computer Science, Kaiserslautern University of Technology,
	P.O. Box 3049, D-67653 Kaiserslautern, Germany},
  booktitle = {Generative Programming and Component Engineering},
  isbn = {978-3-540-23580-4},
  keyword = {Computer Science},
  owner = {daniel},
  timestamp = {2011.11.06},
  url = {http://dx.doi.org/10.1007/978-3-540-30175-2_21}
}

@INBOOK{springerlink:10.1007/978-3-540-45242-3_31,
  pages = {304-310},
  title = {DSL-DIA – An Environment for Domain-Specific Languages for Database-Intensive
	Applications},
  publisher = {Springer Berlin / Heidelberg},
  year = {2003},
  editor = {Konstantas, Dimitri and Léonard, Michel and Pigneur, Yves and Patel,
	Shusma},
  author = {Kovse, Jernej and Härder, Theo},
  volume = {2817},
  series = {Lecture Notes in Computer Science},
  note = {10.1007/978-3-540-45242-3_31},
  abstract = {This paper presents DSL-DIA, an environment that lets a system-family
	vendor define a metamodel for a custom domain-specific language used
	by customers for specifying properties of family members. Once the
	metamodel is imported in the environment, the environment allows
	the customer a flexible way to program in the domain-specific language
	and translates obtained programs to implementations of family members.
	In our case, family members are always database-intensive applications
	with application logic executed in the database server.},
  affiliation = {Department of Computer Science, University of Kaiserslautern, P.O.
	Box 3049, D-67653 Kaiserslautern, Germany},
  booktitle = {Object-Oriented Information Systems},
  isbn = {978-3-540-40860-4},
  keyword = {Computer Science},
  owner = {daniel},
  timestamp = {2011.11.06},
  url = {http://dx.doi.org/10.1007/978-3-540-45242-3_31}
}

@INBOOK{springerlink:10.1007/978-3-540-25975-6_13,
  pages = {373-405},
  title = {MT-Flow – An Environment for Workflow-Supported Model Transformations
	in MDA},
  publisher = {Springer Berlin / Heidelberg},
  year = {2004},
  editor = {Persson, Anne and Stirna, Janis},
  author = {Kovse, Jernej and Härder, Theo},
  volume = {3084},
  series = {Lecture Notes in Computer Science},
  note = {10.1007/978-3-540-25975-6_13},
  abstract = {Specification of systems in a software product line (product-line
	members) is often supported by domain-specific languages (DSLs) that
	provide powerful language abstractions for selecting the features
	of the desired system. In this paper, we show that efficient composition
	of system specifications (which, in our case, are expressed as models)
	is also possible using (i) a domain-specific workflow model that
	guides the composition and (ii) a set of domain-specific templates
	for model transformations. We illustrate the entire approach on a
	product line for versioning systems, define a metamodel for workflow
	models and postulate a measure for estimating the benefits of the
	proposed approach.},
  affiliation = {Department of Computer Science, Kaiserslautern University of Technology,
	P.O. Box 3049, D-67653 Kaiserslautern, Germany},
  booktitle = {Advanced Information Systems Engineering},
  isbn = {978-3-540-22151-7},
  keyword = {Computer Science},
  owner = {daniel},
  timestamp = {2011.11.06},
  url = {http://dx.doi.org/10.1007/978-3-540-25975-6_13}
}

@INBOOK{springerlink:10.1007/978-3-540-30464-7_49,
  pages = {654-667},
  title = {Metaprogramming for Relational Databases},
  publisher = {Springer Berlin / Heidelberg},
  year = {2004},
  editor = {Atzeni, Paolo and Chu, Wesley and Lu, Hongjun and Zhou, Shuigeng
	and Ling, Tok-Wang},
  author = {Kovse, Jernej and Weber, Christian and Härder, Theo},
  volume = {3288},
  series = {Lecture Notes in Computer Science},
  note = {10.1007/978-3-540-30464-7_49},
  abstract = {For systems that share enough structural and functional commonalities,
	reuse in schema development and data manipulation can be achieved
	by defining problem-oriented languages. Such languages are often
	called domainspecific, because they introduce powerful abstractions
	meaningful only within the domain of observed systems. In order to
	use domain-specific languages for database applications, a mapping
	to SQL is required. In this paper, we deal with metaprogramming concepts
	required for easy definition of such mappings. Using an example domain-specific
	language, we provide an evaluation of mapping performance.},
  affiliation = {Department of Computer Science, Kaiserslautern University of Technology,
	P.O. Box 3049, D-67653 Kaiserslautern, Germany},
  booktitle = {Conceptual Modeling – ER 2004},
  isbn = {978-3-540-23723-5},
  keyword = {Computer Science},
  owner = {daniel},
  timestamp = {2011.11.06},
  url = {http://dx.doi.org/10.1007/978-3-540-30464-7_49}
}

@INBOOK{springerlink:10.1007/978-3-540-69824-1_17,
  pages = {297-315},
  title = {MontiCore: Modular Development of Textual Domain Specific Languages},
  publisher = {Springer Berlin Heidelberg},
  year = {2008},
  editor = {Paige, Richard F. and Meyer, Bertrand and Aalst, Wil and Mylopoulos,
	John and Rosemann, Michael and Shaw, Michael J. and Szyperski, Clemens},
  author = {Krahn, Holger and Rumpe, Bernhard and Völkel, Steven},
  volume = {11},
  series = {Lecture Notes in Business Information Processing},
  note = {10.1007/978-3-540-69824-1_17},
  abstract = {Reuse is a key technique for a more efficient development and ensures
	the quality of the results. In object technology explicit encapsulation,
	interfaces, and inheritance are well-known principles for independent
	development that enable combination and reuse of developed artifacts.
	In this paper we apply modularity concepts for domain specific languages
	(DSLs) and discuss how they help to design new languages by extending
	existing ones and composing fragments to new DSLs. We use an extended
	grammar format with appropriate tool support that avoids redefinition
	of existing functionalities by introducing language inheritance and
	embedding as first class artifacts in a DSL definition. Language
	embedding and inheritance is not only assisted by the parser, but
	also by the editor, and algorithms based on tree traversal like context
	checkers, pretty printers, and code generators. We demonstrate that
	compositional engineering of new languages becomes a useful concept
	when starting to define project-individual DSLs using appropriate
	tool support.},
  affiliation = {Technische Universität Braunschweig Institute for Software Systems
	Engineering Braunschweig Germany},
  booktitle = {Objects, Components, Models and Patterns},
  isbn = {978-3-540-69824-1},
  keyword = {Computer Science},
  owner = {daniel},
  timestamp = {2011.11.06},
  url = {http://dx.doi.org/10.1007/978-3-540-69824-1_17}
}

@ARTICLE{springerlink:10.1007/s10009-010-0142-1,
  author = {Krahn, Holger and Rumpe, Bernhard and Völkel, Steven},
  title = {MontiCore: a framework for compositional development of domain specific
	languages},
  journal = {International Journal on Software Tools for Technology Transfer (STTT)},
  year = {2010},
  volume = {12},
  pages = {353-372},
  note = {10.1007/s10009-010-0142-1},
  abstract = {Domain specific languages (DSLs) are increasingly used today. Coping
	with complex language definitions, evolving them in a structured
	way, and ensuring their error freeness are the main challenges of
	DSL design and implementation. The use of modular language definitions
	and composition operators are therefore inevitable in the independent
	development of language components. In this article, we discuss these
	arising issues by describing a framework for the compositional development
	of textual DSLs and their supporting tools. We use a redundance-free
	definition of a readable concrete syntax and a comprehensible abstract
	syntax as both representations significantly overlap in their structure.
	For enhancing the usability of the abstract syntax, we added concepts
	like associations and inheritance to a grammar-based definition in
	order to build up arbitrary graphs (as known from metamodeling).
	Two modularity concepts, grammar inheritance and embedding, are discussed.
	They permit compositional language definition and thus simplify the
	extension of languages based on already existing ones. We demonstrate
	that compositional engineering of new languages is a useful concept
	when project-individual DSLs with appropriate tool support are defined.},
  affiliation = {RWTH Aachen University Software Engineering Group, Department of Computer
	Science 3 Aachen Germany},
  issn = {1433-2779},
  issue = {5},
  keyword = {Computer Science},
  owner = {daniel},
  publisher = {Springer Berlin / Heidelberg},
  timestamp = {2011.11.06},
  url = {http://dx.doi.org/10.1007/s10009-010-0142-1}
}

@INBOOK{springerlink:10.1007/3-540-40048-6_9,
  pages = {105-120},
  title = {From Macros to Reusable Generative Programming},
  publisher = {Springer Berlin / Heidelberg},
  year = {2000},
  editor = {Czarnecki, Krzysztof and Eisenecker, Ulrich},
  author = {Krishnamurthi, Shriram and Felleisen, Matthias and Duba, Bruce},
  volume = {1799},
  series = {Lecture Notes in Computer Science},
  note = {10.1007/3-540-40048-6_9},
  abstract = {Generative programming is widely used both to develop new programming
	languages and to extend existing ones with domain-specific sub-languages.
	This paper describes M c M ic M ac, a framework for generative programming.
	M c M ic M ac uses tree-transforming macros as language specifications,
	and enhances them with inherited and synthesized attributes. The
	enhanced transformers can describe general compilation tasks. Families
	of these specifications are grouped into mixin-like collections called
	vocabularies. Programmers can define new languages by composing these
	vocabularies. We have implemented M c M ic M ac for Scheme and used
	it to build several systems, including the DrScheme programming environment.
	The principles of M c M ic M ac carry over to other languages and
	environments.},
  affiliation = {Rice University Department of Computer Science Houston TX 77005-1892
	USA},
  booktitle = {Generative and Component-Based Software Engineering},
  isbn = {978-3-540-41172-7},
  keyword = {Computer Science},
  owner = {daniel},
  timestamp = {2011.11.06},
  url = {http://dx.doi.org/10.1007/3-540-40048-6_9}
}

@INBOOK{springerlink:10.1007/978-3-540-31846-0_4,
  pages = {52-69},
  title = {A Generative Approach for Multi-agent System Development},
  publisher = {Springer Berlin / Heidelberg},
  year = {2005},
  editor = {Choren, Ricardo and Garcia, Alessandro and Lucena, Carlos and Romanovsky,
	Alexander},
  author = {Kulesza, Uirá and Garcia, Alessandro and Lucena, Carlos and Alencar,
	Paulo},
  volume = {3390},
  series = {Lecture Notes in Computer Science},
  note = {10.1007/978-3-540-31846-0_4},
  abstract = {The development of Multi-Agent Systems (MASs) involves special concerns,
	such as interaction, adaptation, autonomy, among others. Many of
	these concerns are overlapping, crosscut each other and the agent’s
	basic functionality. Over the last few years, several methodologies
	and implementation frameworks have been proposed to support agent-oriented
	software engineering. Although these approaches have brought some
	benefits to improve the productivity and quality on the MAS development,
	they present some restrictions. First, agent-oriented methodologies
	are too high level and do not indicate how to master the complexity
	of MAS concerns based on the object-oriented abstractions. Second,
	implementation frameworks provide object-oriented APIs for MAS development
	without providing guidelines for the modularization of agent concerns.
	Moreover, neither of the proposed agent oriented-approaches deals
	with the modeling and implementation of agent crosscutting concerns.
	This paper presents a generative approach for the development of
	MASs that addresses these restrictions. The proposed approach explores
	the MAS domain to enable the code generation of heterogeneous agent
	architectures. Aspect-oriented techniques are used to allow the modeling
	of crosscutting agent features. The generative approach brings several
	benefits to the code generation and modeling of agent crosscutting
	features since early development stages.},
  affiliation = {PUC-Rio, Computer Science Department, LES, SoC+Agents Group, Rua Marques
	de São Vicente, 225, 22453-900 Rio de Janeiro, RJ, Brazil},
  booktitle = {Software Engineering for Multi-Agent Systems III},
  isbn = {978-3-540-24843-9},
  keyword = {Computer Science},
  owner = {daniel},
  timestamp = {2011.11.06},
  url = {http://dx.doi.org/10.1007/978-3-540-31846-0_4}
}

@INBOOK{springerlink:10.1007/3-540-48257-1_12,
  pages = {196-212},
  title = {Integrating Domain Specific Language Design in the Software Life
	Cycle},
  publisher = {Springer Berlin / Heidelberg},
  year = {1999},
  editor = {Hutter, Dieter and Stephan, Werner and Traverso, Paolo and Ullmann,
	Markus},
  author = {Kutter, Philipp and Schweizer, Daniel and Thiele, Lothar},
  volume = {1641},
  series = {Lecture Notes in Computer Science},
  note = {10.1007/3-540-48257-1_12},
  abstract = {Domain Specific Languages help to split the software live cycle in
	different independent cycles. While the use of the newly created
	language is just an additional tool in the established cycle, the
	language live cycle is independent and opens the doors for the application
	of formal methods. We report on an industrial case study, where a
	driver specification language has been designed, formally specified,
	and finally an implementation has been generated from the specification.
	Using Abstract State Machines and Montages for the language specification,
	it was possible that the industrial partners learned how to maintain
	and extend the language specification. On the other hand the formal
	semantics of the method allows to apply different verification-oriented
	methods to the artifacts.},
  affiliation = {Federal Institute of Technology CH-8092 Zürich},
  booktitle = {Applied Formal Methods — FM-Trends 98},
  isbn = {978-3-540-66462-8},
  keyword = {Computer Science},
  owner = {daniel},
  timestamp = {2011.11.06},
  url = {http://dx.doi.org/10.1007/3-540-48257-1_12}
}

@INBOOK{springerlink:10.1007/978-3-540-87605-2_21,
  pages = {185-196},
  title = {A Domain-Specific-Modeling Approach to Support Scenarios-Based Instructional
	Design},
  publisher = {Springer Berlin / Heidelberg},
  year = {2008},
  editor = {Dillenbourg, Pierre and Specht, Marcus},
  author = {Laforcade, Pierre and Zendagui, Boubekeur and Barré, Vincent},
  volume = {5192},
  series = {Lecture Notes in Computer Science},
  note = {10.1007/978-3-540-87605-2_21},
  abstract = {Over recent years, Model-Driven-Engineering has attracted growing
	interest as much as a research domain as an industrial process that
	can be applied to various educational domains. This article aims
	to discuss and propose such an application for learning-scenario-centered
	instructional design processes. Our proposition is based on a 3-domain
	categorization for learning scenarios. We also discuss and explain
	why we think Domain-Specific Modeling techniques are the future new
	trend in order to support the emergence of communities of practices
	for scenario-based instructional design. The originality resides
	in the support we propose to help communities of practitioners in
	building specific Visual Instructional Design Languages with dedicated
	editors instead of providing them with yet another language or editor.},
  affiliation = {Maine University - LIUM IUT de Laval 52 rue des Docteurs Calmette
	et Guérin 53020 Laval Cedex 9 France},
  booktitle = {Times of Convergence. Technologies Across Learning Contexts},
  isbn = {978-3-540-87604-5},
  keyword = {Computer Science},
  owner = {daniel},
  timestamp = {2011.11.06},
  url = {http://dx.doi.org/10.1007/978-3-540-87605-2_21}
}

@INBOOK{springerlink:10.1007/978-3-540-78743-3_10,
  pages = {116-130},
  title = {Leveraging Patterns on Domain Models to Improve UML Profile Definition},
  publisher = {Springer Berlin / Heidelberg},
  year = {2008},
  editor = {Fiadeiro, José and Inverardi, Paola},
  author = {Lagarde, François and Espinoza, Huáscar and Terrier, François
	and André, Charles and Gérard, Sébastien},
  volume = {4961},
  series = {Lecture Notes in Computer Science},
  note = {10.1007/978-3-540-78743-3_10},
  abstract = {Building a reliable UML profile is a difficult activity that requires
	the use of complex mechanisms -stereotypes and their attributes,
	OCL enforcement- to define a domain-specific modeling language (
	DSML ). Despite the ever increasing number of profiles being built
	in many domains, there is a little published literature available
	to help DSML designers. Without a clear design process, most such
	profiles are inaccurate and jeopardize subsequent model transformations
	or model analyses. We believe that a suitable approach to building
	UML based domain specific languages should include systematic transformation
	of domain representations into profiles. This article therefore proposes
	a clearly-defined process geared to helping the designer throughout
	this design activity. Starting from the conceptual domain model,
	we identify a set of design patterns for which we detail several
	profile implementations. We illustrate our approach by creating a
	simplified profile that depicts elements belonging to a real-time
	system domain. The prototype tool supporting our approach is also
	described.},
  affiliation = {CEA, LIST, Gif-sur-Yvette F-91191 France},
  booktitle = {Fundamental Approaches to Software Engineering},
  isbn = {978-3-540-78742-6},
  keyword = {Computer Science},
  owner = {daniel},
  timestamp = {2011.11.06},
  url = {http://dx.doi.org/10.1007/978-3-540-78743-3_10}
}

@INBOOK{springerlink:10.1007/11686699_60,
  pages = {596-605},
  title = {Study on Unified Metamodeling Framework Based on Down-Up Mechanism},
  publisher = {Springer Berlin / Heidelberg},
  year = {2006},
  editor = {Shen, Wei-ming and Chao, Kuo-Ming and Lin, Zongkai and Barthès,
	Jean-Paul and James, Anne},
  author = {Lan, Qingguo and Liu, Shufen and Li, Bing and Han, Lu},
  volume = {3865},
  series = {Lecture Notes in Computer Science},
  note = {10.1007/11686699_60},
  abstract = {In order to capture and relate different aspects of a problem domain,
	we often require different languages or models. A metamodeling approach
	can be used to define these languages and models in a rich semantic
	way. However, current tools or frameworks cannot satisfy the multilayer
	metamodeling requirement. We suggests a reusable MOF (Meta-Object
	Facility) metamodeling framework through the Down-up mechanism between
	the meta-layer model and model-layer model, and this mechanism supports
	multilayer metamodeling and is compatible with MOF. This paper also
	suggests a MOF’s Bootstrap model by which the framework constructs
	models in a unified way. In addition, this paper gives a model shift
	synchronization pruning algorithm in order to keep the relationship
	consistent between the meta-layer model and the model-level model.
	As an example, we use the framework to model an agent-based workflow
	system, and this practice proves the framework can satisfy multilayer
	modeling requirements in different aspects of a problem domain.},
  affiliation = {Beihua University, Jilin, 132013 P.R. China},
  booktitle = {Computer Supported Cooperative Work in Design II},
  isbn = {978-3-540-32969-5},
  keyword = {Computer Science},
  owner = {daniel},
  timestamp = {2011.11.06},
  url = {http://dx.doi.org/10.1007/11686699_60}
}

@INBOOK{springerlink:10.1007/11561347_7,
  pages = {78-93},
  title = {Bossa Nova: Introducing Modularity into the Bossa Domain-Specific
	Language},
  publisher = {Springer Berlin / Heidelberg},
  year = {2005},
  editor = {Glück, Robert and Lowry, Michael},
  author = {Lawall, Julia and Duchesne, Hervé and Muller, Gilles and Le Meur,
	Anne-Françoise},
  volume = {3676},
  series = {Lecture Notes in Computer Science},
  note = {10.1007/11561347_7},
  abstract = {Domain-specific languages (DSLs) have been proposed as a solution
	to ease the development of programs within a program family. Sometimes,
	however, experience with the use of a DSL reveals the presence of
	subfamilies within the family targeted by the language. We are then
	faced with the question of how to capture these subfamilies in DSL
	abstractions. A solution should retain features of the original DSL
	to leverage existing expertise and support tools. The Bossa DSL is
	a language targeted towards the development of kernel process scheduling
	policies. We have encountered the issue of program subfamilies in
	using this language to implement an encyclopedic, multi-OS library
	of scheduling policies. In this paper, we propose that introducing
	certain kinds of modularity into the language can furnish abstractions
	appropriate for implementing scheduling policy subfamilies. We present
	the design of our modular language, Bossa Nova, and assess the language
	quantitatively and qualitatively.},
  affiliation = {DIKU, University of Copenhagen, Denmark},
  booktitle = {Generative Programming and Component Engineering},
  isbn = {978-3-540-29138-1},
  keyword = {Computer Science},
  owner = {daniel},
  timestamp = {2011.11.06},
  url = {http://dx.doi.org/10.1007/11561347_7}
}

@INBOOK{springerlink:10.1007/978-3-540-30175-2_23,
  pages = {333-343},
  title = {On Designing a Target-Independent DSL for Safe OS Process-Scheduling
	Components},
  publisher = {Springer Berlin / Heidelberg},
  year = {2004},
  editor = {Karsai, Gabor and Visser, Eelco},
  author = {Lawall, Julia and Le Meur, Anne-Françoise and Muller, Gilles},
  volume = {3286},
  series = {Lecture Notes in Computer Science},
  note = {10.1007/978-3-540-30175-2_23},
  abstract = {Developing new process-scheduling components for multiple OSes is
	challenging because of the tight interdependence between an OS and
	its scheduler and because of the stringent safety requirements that
	OS code must satisfy. In this context, a domain-specific language
	(DSL), designed by a scheduling expert, can encapsulate scheduling
	expertise and thus facilitate scheduler programming and verification.
	Nevertheless, designing a DSL that is target-independent and provides
	safety guarantees requires expertise not only in scheduling but also
	in the structure of various OSes. To address these issues, we propose
	the introduction of an OS expert into the DSL design process and
	the use of a type system to enable the OS expert to express relevant
	OS properties. This paper instantiates our approach in the context
	of the Bossa process-scheduling framework and describes how the types
	provided by an OS expert are used to ensure that Bossa scheduling
	components are safe.},
  affiliation = {DIKU, University of Copenhagen, 2100 Copenhagen Ø, Denmark},
  booktitle = {Generative Programming and Component Engineering},
  isbn = {978-3-540-23580-4},
  keyword = {Computer Science},
  owner = {daniel},
  timestamp = {2011.11.06},
  url = {http://dx.doi.org/10.1007/978-3-540-30175-2_23}
}

@INBOOK{springerlink:10.1007/978-3-540-89020-1_45,
  pages = {587-592},
  title = {Introducing the VMTS Mobile Toolkit},
  publisher = {Springer Berlin / Heidelberg},
  year = {2008},
  editor = {Schürr, Andy and Nagl, Manfred and Zündorf, Albert},
  author = {Levendovszky, Tihamér and Lengyel, László and Mezei, Gergely and
	Mészáros, Tamás},
  volume = {5088},
  series = {Lecture Notes in Computer Science},
  note = {10.1007/978-3-540-89020-1_45},
  abstract = {Developing software for mobile devices requires special attention,
	and it is still a larger effort compared to the development for desktop
	computers and servers. With the introduction and the popularity of
	wireless devices, the diversity of the platforms has also been increased.
	There are different platforms and tools from different vendors such
	as Microsoft, Sun, Nokia, SonyEricsson and many more. Therefore,
	generative techniques underpinned by model-driven development can
	be applied extensively in this field. This paper introduces the Mobile
	Toolkit for the tool Visual Modeling and Transformation System (VMTS).
	This toolkit provides a bridge between the different mobile platforms
	with respect to the user interface and network communication development.},
  affiliation = {Budapest University of Technology and Economics Goldmann György tér
	3. 1111 Budapest Hungary},
  booktitle = {Applications of Graph Transformations with Industrial Relevance},
  isbn = {978-3-540-89019-5},
  keyword = {Computer Science},
  owner = {daniel},
  timestamp = {2011.11.06},
  url = {http://dx.doi.org/10.1007/978-3-540-89020-1_45}
}

@ARTICLE{springerlink:10.1007/s10270-009-0118-3,
  author = {Levendovszky, Tihamér and Lengyel, László and Mészáros, Tamás},
  title = {Supporting domain-specific model patterns with metamodeling},
  journal = {Software and Systems Modeling},
  year = {2009},
  volume = {8},
  pages = {501-520},
  note = {10.1007/s10270-009-0118-3},
  abstract = {Metamodeling is a widely applied technique in the field of graphical
	languages to create highly configurable modeling environments. These
	environments support the rapid development of domain-specific modeling
	languages (DSMLs). Design patterns are efficient solutions for recurring
	problems. With the proliferation of DSMLs, there is a need for domain-specific
	design patterns to offer solutions to problems recurring in different
	domains. The aim of this paper is to provide theoretical and practical
	foundations to support domain-specific model patterns in metamodeling
	environments. In order to support the treatment of premature model
	parts, we weaken the instantiation relationship. We provide constructs
	relaxing the instantiation rules, and we show that these constructs
	are appropriate and sufficient to express patterns. We provide the
	necessary modifications in metamodeling tools for supporting patterns.
	With the contributed results, a well-founded domain-specific model
	pattern support can be realized in metamodeling tools.},
  affiliation = {Budapest University of Technology and Economics Budapest Hungary},
  issn = {1619-1366},
  issue = {4},
  keyword = {Computer Science},
  owner = {daniel},
  publisher = {Springer Berlin / Heidelberg},
  timestamp = {2011.11.06},
  url = {http://dx.doi.org/10.1007/s10270-009-0118-3}
}

@INBOOK{springerlink:10.1007/978-3-540-79416-5_12,
  pages = {359-386},
  title = {Scientific Foundations of AKM Technology},
  publisher = {Springer Berlin Heidelberg},
  year = {2008},
  author = {Lillehagen, Frank and Krogstie, John},
  note = {10.1007/978-3-540-79416-5_12},
  abstract = {In Chap. 3, we claimed the following: “The variations in knowledge
	from one enterprise to another are mostly changes in semantics, complexity
	in structural layers, visual representations and type-hierarchies
	of the four main enterprise knowledge dimensions, in particular of
	process and product aspects. So in order to model for solutions with
	coherence, consistency and reuse in evolving extended enterprises
	we must be able to separate business, knowledge and IT architectures
	and solutions.”},
  booktitle = {Active Knowledge Modeling of Enterprises},
  isbn = {978-3-540-79416-5},
  keyword = {Computer Science},
  owner = {daniel},
  timestamp = {2011.11.06},
  url = {http://dx.doi.org/10.1007/978-3-540-79416-5_12}
}

@INBOOK{springerlink:10.1007/978-3-540-73589-2_15,
  pages = {299-322},
  title = {DirectFlow: A Domain-Specific Language for Information-Flow Systems},
  publisher = {Springer Berlin / Heidelberg},
  year = {2007},
  editor = {Ernst, Erik},
  author = {Lin, Chuan-kai and Black, Andrew},
  volume = {4609},
  series = {Lecture Notes in Computer Science},
  note = {10.1007/978-3-540-73589-2_15},
  abstract = {Programs that process streams of information are commonly built by
	assembling reusable information-flow components . In some systems
	the components must be chosen from a pre-defined set of primitives;
	in others the programmer can create new custom components using a
	general-purpose programming language. Neither approach is ideal:
	restricting programmers to a set of primitive components limits the
	expressivity of the system, while allowing programmers to define
	new components in a general-purpose language makes it difficult or
	impossible to reason about the composite system. We advocate defining
	information-flow components in a domain-specific language (DSL) that
	enables us to infer the properties of the components and of the composed
	system; this provides us with a good compromise between analysability
	and expressivity. This paper presents DirectFlow, which comprises
	a DSL, a compiler and a runtime system. The language allows programmers
	to define objects that implement information-flow components without
	specifying how messages are sent and received. The compiler generates
	Java classes by inferring the message sends and methods, while the
	run-time library constructs information-flow networks by composition
	of DSL-defined components with standard components.},
  affiliation = {Department of Computer Science, Portland State University},
  booktitle = {ECOOP 2007 – Object-Oriented Programming},
  isbn = {978-3-540-73588-5},
  keyword = {Computer Science},
  owner = {daniel},
  timestamp = {2011.11.06},
  url = {http://dx.doi.org/10.1007/978-3-540-73589-2_15}
}

@INBOOK{springerlink:10.1007/3-540-36103-0_27,
  pages = {237-248},
  title = {On Concept-Based Definition of Domain-Specific Languages},
  publisher = {Springer Berlin / Heidelberg},
  year = {2002},
  editor = {George, Chris and Miao, Huaikou},
  author = {Liu, Ying and Zhang, Naixiao},
  volume = {2495},
  series = {Lecture Notes in Computer Science},
  note = {10.1007/3-540-36103-0_27},
  abstract = {This paper provides a new method of developing domain-specific languages(DSLs).
	A DSL is composed of concepts, including common language concepts
	and domain concepts. From the functionality point of view, concepts
	can be divided into two kinds: element concepts and complement concepts.
	Element concepts capture the basic functions of a DSL, and complement
	concepts define some auxiliary functions for a DSL. Because extended
	attribute grammar and evolving algebra are used to specify the semantics
	of element concepts, the descriptions are formal, yet easily understood.
	Transformation rules are used to specify the semantics of complement
	concepts. In order to improve the reusability, element and complement
	concepts are defined at a high abstract level, and they are defined
	as some independent components. The definition of a new DSL follows
	two steps: defining element and complement concepts separately; instantiating
	concepts and assembling them. Based on the above idea, a DSLs development
	language ( DD ) is defined.},
  affiliation = {Peking University Department of Informatics School of Mathematical
	Sciences China},
  booktitle = {Formal Methods and Software Engineering},
  isbn = {978-3-540-00029-7},
  keyword = {Computer Science},
  owner = {daniel},
  timestamp = {2011.11.06},
  url = {http://dx.doi.org/10.1007/3-540-36103-0_27}
}

@INBOOK{springerlink:10.1007/978-3-540-30175-2_4,
  pages = {345-368},
  title = {Generic Advice: On the Combination of AOP with Generative Programming
	in AspectC++},
  publisher = {Springer Berlin / Heidelberg},
  year = {2004},
  editor = {Karsai, Gabor and Visser, Eelco},
  author = {Lohmann, Daniel and Blaschke, Georg and Spinczyk, Olaf},
  volume = {3286},
  series = {Lecture Notes in Computer Science},
  note = {10.1007/978-3-540-30175-2_4},
  abstract = {Besides object-orientation, generic types or templates and aspect-oriented
	programming (AOP) gain increasing popularity as they provide additional
	dimensions of decomposition. Most modern programming languages like
	Ada, Eiffel, and C++ already have built-in support for templates.
	For Java and C# similar extensions will be available in the near
	future. Even though promising, the combination of aspects with generic
	and generative programming is still a widely unexplored field. This
	paper presents our extensions to the AspectC++ language, an aspect-oriented
	C++ derivate. By these extensions aspects can now affect generic
	code and exploit the potentials of generic code and template metaprogramming
	in their implementations. This allows aspects to inject template
	metaprograms transparently into the component code. A case study
	demonstrates that this feature enables the development of highly
	expressive and efficient generic aspect implementations in AspectC++.
	A discussion whether these concepts are applicable in the context
	of other aspect-oriented language extensions like AspectJ rounds
	up our contribution.},
  affiliation = {Friedrich-Alexander-University Erlangen-Nuremberg, Germany},
  booktitle = {Generative Programming and Component Engineering},
  isbn = {978-3-540-23580-4},
  keyword = {Computer Science},
  owner = {daniel},
  timestamp = {2011.11.06},
  url = {http://dx.doi.org/10.1007/978-3-540-30175-2_4}
}

@INBOOK{springerlink:10.1007/978-3-540-75132-8_15,
  pages = {179-194},
  title = {Wireless Sensor Network Application Development: An Architecture-Centric
	MDE Approach},
  publisher = {Springer Berlin / Heidelberg},
  year = {2007},
  editor = {Oquendo, Flavio},
  author = {Losilla, Fernando and Vicente-Chicote, Cristina and Álvarez, Bárbara
	and Iborra, Andrés and Sánchez, Pedro},
  volume = {4758},
  series = {Lecture Notes in Computer Science},
  note = {10.1007/978-3-540-75132-8_15},
  abstract = {Nowadays, Wireless Sensor Networks (WSN) are a very promising research
	field since they find application in many different areas. Current
	proposals for WSN system development are mainly focused on implementation
	issues and they rarely rely on a Software Engineering methodology
	which supports their entire development life-cycle. The Model-Driven
	Engineering (MDE) approach can contribute to solve this problem by
	allowing designers to model their systems at different abstraction
	levels, providing them with automatic model transformations to incrementally
	refine abstract models into more concrete ones. In this vein, this
	paper presents a MDE approach to WSN application development. Three
	levels of abstraction have been defined which allow designers to
	build: (1) domain-specific models, (2) component-based architecture
	descriptions, and (3) platform-specific models. Automatic model transformations
	between these three abstraction levels have been designed and, in
	order to demonstrate the viability of the proposal, a real WSN application
	has been developed using the implemented tools.},
  affiliation = {División de Sistemas e Ingeniería Electrónica (DSIE), Universidad
	Politécnica de Cartagena, 30202 Cartagena Spain},
  booktitle = {Software Architecture},
  isbn = {978-3-540-75131-1},
  keyword = {Computer Science},
  owner = {daniel},
  timestamp = {2011.11.06},
  url = {http://dx.doi.org/10.1007/978-3-540-75132-8_15}
}

@ARTICLE{springerlink:10.1007/s11219-010-9116-5,
  author = {Lämmel, Ralf and Zaytsev, Vadim},
  title = {Recovering grammar relationships for the Java Language Specification},
  journal = {Software Quality Journal},
  year = {2011},
  volume = {19},
  pages = {333-378},
  note = {10.1007/s11219-010-9116-5},
  abstract = {Grammar convergence is a method that helps in discovering relationships
	between different grammars of the same language or different language
	versions. The key element of the method is the operational, transformation-based
	representation of those relationships. Given input grammars for convergence,
	they are transformed until they are structurally equal. The transformations
	are composed from primitive operators; properties of these operators
	and the composed chains provide quantitative and qualitative insight
	into the relationships between the grammars at hand. We describe
	a refined method for grammar convergence, and we use it in a major
	study, where we recover the relationships between all the grammars
	that occur in the different versions of the Java Language Specification
	(JLS). The relationships are represented as grammar transformation
	chains that capture all accidental or intended differences between
	the JLS grammars. This method is mechanized and driven by nominal
	and structural differences between pairs of grammars that are subject
	to asymmetric, binary convergence steps. We present the underlying
	operator suite for grammar transformation in detail, and we illustrate
	the suite with many examples of transformations on the JLS grammars.
	We also describe the extraction effort, which was needed to make
	the JLS grammars amenable to automated processing. We include substantial
	metadata about the convergence process for the JLS so that the effort
	becomes reproducible and transparent.},
  affiliation = {Software Languages Team, The University of Koblenz-Landau, Koblenz,
	Germany},
  issn = {0963-9314},
  issue = {2},
  keyword = {Computer Science},
  owner = {daniel},
  publisher = {Springer Netherlands},
  timestamp = {2011.11.06},
  url = {http://dx.doi.org/10.1007/s11219-010-9116-5}
}

@INBOOK{springerlink:10.1007/11796435_8,
  pages = {59-68},
  title = {Domain-Specific Modeling of Power Aware Distributed Real-Time Embedded
	Systems},
  publisher = {Springer Berlin / Heidelberg},
  year = {2006},
  editor = {Vassiliadis, Stamatis and Wong, Stephan and Hämäläinen, Timo},
  author = {Madl, Gabor and Dutt, Nikil},
  volume = {4017},
  series = {Lecture Notes in Computer Science},
  note = {10.1007/11796435_8},
  abstract = {This paper provides two contributions to the research on applying
	domain-specific modeling languages to distributed real-time embedded
	(DRE) systems. First, we present the Alderis platform-independent
	visual language for component-based system development. Second, we
	demonstrate the use of the Alderis language on a helicopter autopilot
	DRE design. The Alderis language is based on the concept of platform-based
	design, and explicitly captures asynchronous event-driven component
	interactions as well as the underlying platform for the computation.
	Unlike most modeling languages, Alderis has formally defined semantics
	providing a way for the formal verification of dense real-time properties
	and energy consumption.},
  affiliation = {Center for Embedded Computer Systems, University of California, Irvine,
	CA 92697, USA},
  booktitle = {Embedded Computer Systems: Architectures, Modeling, and Simulation},
  isbn = {978-3-540-36410-8},
  keyword = {Computer Science},
  owner = {daniel},
  timestamp = {2011.11.06},
  url = {http://dx.doi.org/10.1007/11796435_8}
}

@INBOOK{springerlink:10.1007/978-3-540-77395-5_13,
  pages = {151-163},
  title = {Instrumentation of Open-Source Software for Intrusion Detection},
  publisher = {Springer Berlin / Heidelberg},
  year = {2007},
  editor = {Sokolsky, Oleg and Tasiran, Serdar},
  author = {Mahoney, William and Sousan, William},
  volume = {4839},
  series = {Lecture Notes in Computer Science},
  note = {10.1007/978-3-540-77395-5_13},
  abstract = {A significant number of cyber assaults and intrusion attempts are
	made against open source software written in C, C++, or Java. Detecting
	all flaws in a large system is still a daunting, unrealistic task.
	The information assurance area known as ”intrusion detection”
	(ID) senses unauthorized access attempts by monitoring key pieces
	of system data. There is a desire to at least detect intrusion attempts
	in order to stop them while in progress, or repair the damage at
	a later date. Most ID systems examine system log files, or monitor
	network traffic. This research presents a new approach to generating
	records for intrusion detection by means of instrumentation. Open
	source code such as a web server can be compiled and the execution
	path of the server can be observed externally in near real-time.
	This method thus creates a new data source for ID which can be incorporated
	into a discovery system.},
  affiliation = {University of Nebraska at Omaha 282F PKI 6001 Dodge Street, Omaha
	Nebraska 68182-0500},
  booktitle = {Runtime Verification},
  isbn = {978-3-540-77394-8},
  keyword = {Computer Science},
  owner = {daniel},
  timestamp = {2011.11.06},
  url = {http://dx.doi.org/10.1007/978-3-540-77395-5_13}
}

@INBOOK{springerlink:10.1007/978-3-540-75132-8_31,
  pages = {308-312},
  title = {Managing Separation of Concerns in Grid Applications Through Architectural
	Model Transformations},
  publisher = {Springer Berlin / Heidelberg},
  year = {2007},
  editor = {Oquendo, Flavio},
  author = {Manset, David and Verjus, Hervé and McClatchey, Richard},
  volume = {4758},
  series = {Lecture Notes in Computer Science},
  note = {10.1007/978-3-540-75132-8_31},
  abstract = {Grids enable the aggregation, virtualization and sharing of massive
	heterogeneous and geographically dispersed resources, using files,
	applications and storage devices, to solve computation and data intensive
	problems, across institutions and countries via temporary collaborations
	called virtual organizations (VO) as described in [1]. Most implementations
	result in complex superposition of software layers, often delivering
	low quality of service and quality of applications. As a consequence,
	Grid-based applications design and development is increasingly complex,
	and the use of most classical engineering practices is unsuccessful.
	Not only is the development of such applications a time-consuming,
	error prone and expensive task, but also the resulting applications
	are often hard-coded for specific Grid configurations, platforms
	and infrastructures. Having neither guidelines nor rules in the design
	of a Grid-based application is a paradox since there are many existing
	architectural approaches for distributed computing, which could ease
	and promote rigorous engineering methods based on the re-use of software
	components. It is our belief that ad-hoc and semiformal engineering
	approaches, in current use, are insufficient to tackle tomorrow’s
	Grid developments requirements. Because Grid-based applications address
	multidisciplinary and complex domains (health, military, scientific
	computation), their engineering requires rigor and control. This
	paper therefore advocates a formal model-driven engineering process
	and corresponding design framework and tools for building the next
	generation of Grids. To achieve these objectives, two approaches
	are combined: (1) a formal semantic is used to model and check Grid
	applications; (2) a model-driven approach is adopted to promote model
	re-use, through separation of concerns, to model transformations,
	to hide the platform complexity and to refine abstract software descriptions
	into concrete usable ones.},
  affiliation = {University of Savoie – Polytech’ Savoie – LISTIC/LS},
  booktitle = {Software Architecture},
  isbn = {978-3-540-75131-1},
  keyword = {Computer Science},
  owner = {daniel},
  timestamp = {2011.11.06},
  url = {http://dx.doi.org/10.1007/978-3-540-75132-8_31}
}

@INBOOK{springerlink:10.1007/978-3-540-74974-5_2,
  pages = {13-26},
  title = {A Domain-Specific Language for Web APIs and Services Mashups},
  publisher = {Springer Berlin / Heidelberg},
  year = {2007},
  editor = {Krämer, Bernd and Lin, Kwei-Jay and Narasimhan, Priya},
  author = {Maximilien, E. and Wilkinson, Hernan and Desai, Nirmit and Tai, Stefan},
  volume = {4749},
  series = {Lecture Notes in Computer Science},
  note = {10.1007/978-3-540-74974-5_2},
  abstract = {Distributed programming has shifted from private networks to the public
	Internet and from using private and controlled services to increasingly
	using publicly available heterogeneous Web services (e.g., REST,
	SOAP, RSS, and Atom). This move enables the creation of innovative
	end-user-oriented composed services with user interfaces. These services
	mashups are typically point solutions to specific (specialized) problems;
	however, what is missing is a programming model that facilitates
	and accelerates creation and deployment of mashups of diverse services.
	In this paper we describe a domain-specific language that unifies
	the most common service models and facilitates service composition
	and integration into end-user-oriented Web applications. We demonstrate
	our approach with an implementation that leverages the Ruby on Rails
	framework.},
  affiliation = {IBM Research},
  booktitle = {Service-Oriented Computing – ICSOC 2007},
  isbn = {978-3-540-74973-8},
  keyword = {Computer Science},
  owner = {daniel},
  timestamp = {2011.11.06},
  url = {http://dx.doi.org/10.1007/978-3-540-74974-5_2}
}

@INBOOK{springerlink:10.1007/978-3-540-24667-1_8,
  pages = {98-110},
  title = {Managing Component Variability within Embedded Software Product Lines
	via Transformational Code Generation},
  publisher = {Springer Berlin / Heidelberg},
  year = {2004},
  editor = {van der Linden, Frank},
  author = {McRitchie, Ian and Brown, T. and Spence, Ivor},
  volume = {3014},
  series = {Lecture Notes in Computer Science},
  note = {10.1007/978-3-540-24667-1_8},
  abstract = {This paper presents a transformative code generation technique for
	the static optimization and customization of embedded software. The
	approach supports the development of product families by separating
	core functionality from variable facets. The implementation technique
	utilizes generative programming techniques in order to minimize runtime
	memory requirements and maximize performance within an embedded environment.},
  affiliation = {School of Computer Science, The Queen’s University of Belfast, Belfast,
	N.I., UK},
  booktitle = {Software Product-Family Engineering},
  isbn = {978-3-540-21941-5},
  keyword = {Computer Science},
  owner = {daniel},
  timestamp = {2011.11.06},
  url = {http://dx.doi.org/10.1007/978-3-540-24667-1_8}
}

@ARTICLE{springerlink:10.1360/02yf9014,
  author = {Mei, Hong and Yang, Fuqing},
  title = {Building enterprise reuse program},
  journal = {Science in China Series F: Information Sciences},
  year = {2002},
  volume = {45},
  pages = {161-173},
  note = {10.1360/02yf9014},
  abstract = {Reuse is viewed as a realistically effective approach to solving software
	crisis. For an organization that wants to build a reuse program,
	technical and non-technical issues must be considered in parallel.
	In this paper, a model-based approach to building systematic reuse
	program is presented. Component-based reuse is currently a dominant
	approach to software reuse. In this approach, building the right
	reusable component model is the first important step. In order to
	achieve systematic reuse, a set of component models should be built
	from different perspectives. Each of these models will give a specific
	view of the components so as to satisfy different needs of different
	persons involved in the enterprise reuse program. There already exist
	some component models for reuse from technical perspectives. But
	less attention is paid to the reusable components from a non-technical
	view, especially from the view of process and management. In our
	approach, a reusable component model—FLP model for reusable component—is
	introduced. This model describes components from three dimensions
	(Form, Level, and Presentation) and views components and their relationships
	from the perspective of process and management. It determines the
	sphere of reusable components, the time points of reusing components
	in the development process, and the needed means to present components
	in terms of the abstraction level, logic granularity and presentation
	media. Being the basis on which the management and technical decisions
	are made, our model will be used as the kernel model to initialize
	and normalize a systematic enterprise reuse program.},
  affiliation = {Peking University Department of Computer Science and Technology 100871
	Beijing China},
  issn = {1009-2757},
  issue = {3},
  keyword = {Computer Science},
  owner = {daniel},
  publisher = {Science China Press, co-published with Springer},
  timestamp = {2011.11.06},
  url = {http://dx.doi.org/10.1360/02yf9014}
}

@INBOOK{springerlink:10.1007/978-3-540-92698-6_10,
  pages = {158-174},
  title = {Model-Driven Prototyping for Corporate Software Specification},
  publisher = {Springer Berlin / Heidelberg},
  year = {2008},
  editor = {Gulliksen, Jan and Harning, Morton and Palanque, Philippe and van
	der Veer, Gerrit and Wesson, Janet},
  author = {Memmel, Thomas and Bock, Carsten and Reiterer, Harald},
  volume = {4940},
  series = {Lecture Notes in Computer Science},
  note = {10.1007/978-3-540-92698-6_10},
  abstract = {Corporate software development faces very demanding challenges, especially
	concerning the design of user interfaces. Collaborative design with
	stakeholders demands modeling methods that everybody can understand
	and apply. But when using traditional, paper-based methods to gather
	and document requirements, an IT organization often experiences frustrating
	communication issues between the business and development teams.
	We present ways of implementing model-driven prototyping for corporate
	software development. Without harming agile principles and practice,
	detailed prototypes can be employed for collaborative design. Model-driven
	prototyping beats a new path towards visual specifications and the
	substitution of paper-based artifacts.},
  affiliation = {University of Konstanz Human-Computer Interaction Lab Germany},
  booktitle = {Engineering Interactive Systems},
  isbn = {978-3-540-92697-9},
  keyword = {Computer Science},
  owner = {daniel},
  timestamp = {2011.11.06},
  url = {http://dx.doi.org/10.1007/978-3-540-92698-6_10}
}

@INBOOK{springerlink:10.1007/978-3-540-30587-3_13,
  pages = {25-35},
  title = {Business Process Definition Languages Versus Traditional Methods
	Towards Interoperability},
  publisher = {Springer Berlin / Heidelberg},
  year = {2005},
  editor = {Franch, Xavier and Port, Daniel},
  author = {Merino, Leire and Elguezabal, Gorka},
  volume = {3412},
  series = {Lecture Notes in Computer Science},
  note = {10.1007/978-3-540-30587-3_13},
  abstract = {A business process is a collection of activities that are required
	to achieve a business goal and it is represented with an activity
	flow that specifies the orchestration needed to complete the goal.
	The definition of these processes allows business people to easily
	integrate the functionalities of the COTS in the company to support
	the business objectives. This activity flow can be implemented in
	two ways, using traditional methods or using a Business Process Definition
	Language (BPDL). Traditional methods encode the activity flow using
	state of the art programming languages such as Java, C#, etc. BPDLs
	describe the activity flow with a specific language that is directly
	interpreted by a BPDL engine. This paper analyses the use of BPDLs
	and traditional methods to develop solutions for services-based architectures.
	It presents a case study where the results obtained using a BPDL
	and a traditional method are compared.},
  affiliation = {European Software Institute, Parque Tecnológico de Zamudio, 204 E-48170
	Zamudio, Spain},
  booktitle = {COTS-Based Software Systems},
  isbn = {978-3-540-24548-3},
  keyword = {Computer Science},
  owner = {daniel},
  timestamp = {2011.11.06},
  url = {http://dx.doi.org/10.1007/978-3-540-30587-3_13}
}

@INBOOK{springerlink:10.1007/11527800_26,
  pages = {97-97},
  title = {A Comparison of Program Generation with Aspect-Oriented Programming},
  publisher = {Springer Berlin / Heidelberg},
  year = {2005},
  editor = {Banâtre, Jean-Pierre and Fradet, Pascal and Giavitto, Jean-Louis
	and Michel, Olivier},
  author = {Mezini, Mira and Ostermann, Klaus},
  volume = {3566},
  series = {Lecture Notes in Computer Science},
  note = {10.1007/11527800_26},
  abstract = {Program generation and transformation techniques have gained considerable
	attention in the context of domain-specific languages (DSLs) and
	model-driven architecture (MDA). In this paper we compare domain-specific
	program generators with general-purpose aspect-oriented languages.
	We argue that program generation techniques have severe disadvantages
	with respect to composability, scalability, understandability, and
	other important software engineering issues. Finally, we advocate
	general-purpose aspect-oriented languages as an alternative for the
	implementation of domain-specific languages.},
  affiliation = {Darmstadt University of Technology, Germany},
  booktitle = {Unconventional Programming Paradigms},
  isbn = {978-3-540-27884-9},
  keyword = {Computer Science},
  owner = {daniel},
  timestamp = {2011.11.06},
  url = {http://dx.doi.org/10.1007/11527800_26}
}

@INBOOK{springerlink:10.1007/978-3-540-87605-2_32,
  pages = {284-289},
  title = {Bridging the Gap between Practitioners and E-Learning Standards:
	A Domain-Specific Modeling Approach},
  publisher = {Springer Berlin / Heidelberg},
  year = {2008},
  editor = {Dillenbourg, Pierre and Specht, Marcus},
  author = {Miao, Yongwu and Sodhi, Tim and Brouns, Francis and Sloep, Peter
	and Koper, Rob},
  volume = {5192},
  series = {Lecture Notes in Computer Science},
  note = {10.1007/978-3-540-87605-2_32},
  abstract = {Developing a learning design using IMS Learning Design (LD) is difficult
	for average practitioners because a high overhead of pedagogical
	knowledge and technical knowledge is required. Through using peer
	assessment as an exemplary pedagogy, this paper presents a domain-specific
	modeling (DSM) approach to a new generation of LD authoring tools,
	for enabling practitioners to create learning designs. Adopting a
	DSM approach, on the one hand, pedagogic experts develop a pedagogy-specific
	modeling language, in which notations are directly chosen from the
	concepts and rules used to describe pedagogic approaches. On the
	other hand, technical experts develop transformation algorithms,
	which will map the models represented in the pedagogy-specific modeling
	language into machine-interpretable code represented in LD. This
	technical approach to a new generation of LD authoring tools has
	been illustrated through presenting the whole procedure of the development
	of a peer assessment authoring tool.},
  affiliation = {Open University of the Netherlands Educational Technology Expertise
	Center},
  booktitle = {Times of Convergence. Technologies Across Learning Contexts},
  isbn = {978-3-540-87604-5},
  keyword = {Computer Science},
  owner = {daniel},
  timestamp = {2011.11.06},
  url = {http://dx.doi.org/10.1007/978-3-540-87605-2_32}
}

@INBOOK{springerlink:10.1007/978-3-540-78743-3_20,
  pages = {276-291},
  title = {A Domain Analysis to Specify Design Defects and Generate Detection
	Algorithms},
  publisher = {Springer Berlin / Heidelberg},
  year = {2008},
  editor = {Fiadeiro, José and Inverardi, Paola},
  author = {Moha, Naouel and Guéhéneuc, Yann-Gaël and Le Meur, Anne-Françoise
	and Duchien, Laurence},
  volume = {4961},
  series = {Lecture Notes in Computer Science},
  note = {10.1007/978-3-540-78743-3_20},
  abstract = {Quality experts often need to identify in software systems design
	defects, which are recurring design problems, that hinder development
	and maintenance. Consequently, several defect detection approaches
	and tools have been proposed in the literature. However, we are not
	aware of any approach that defines and reifies the process of generating
	detection algorithms from the existing textual descriptions of defects.
	In this paper, we introduce an approach to automate the generation
	of detection algorithms from specifications written using a domain-specific
	language. The domain-specific is defined from a thorough domain analysis.
	We specify several design defects, generate automatically detection
	algorithms using templates, and validate the generated detection
	algorithms in terms of precision and recall on Xerces v2.7.0, an
	open-source object-oriented system.},
  affiliation = {University of Montreal Ptidej Team – GEODES, DIRO Quebec Canada},
  booktitle = {Fundamental Approaches to Software Engineering},
  isbn = {978-3-540-78742-6},
  keyword = {Computer Science},
  owner = {daniel},
  timestamp = {2011.11.06},
  url = {http://dx.doi.org/10.1007/978-3-540-78743-3_20}
}

@ARTICLE{springerlink:10.1007/s00165-009-0115-x,
  author = {Moha, Naouel and Guéhéneuc, Yann-Gaël and Meur, Anne-Françoise
	and Duchien, Laurence and Tiberghien, Alban},
  title = {From a domain analysis to the specification and detection of code
	and design smells},
  journal = {Formal Aspects of Computing},
  year = {2010},
  volume = {22},
  pages = {345-361},
  note = {10.1007/s00165-009-0115-x},
  abstract = {Code and design smells are recurring design problems in software systems
	that must be identified to avoid their possible negative consequences
	on development and maintenance. Consequently, several smell detection
	approaches and tools have been proposed in the literature. However,
	so far, they allow the detection of predefined smells but the detection
	of new smells or smells adapted to the context of the analysed systems
	is possible only by implementing new detection algorithms manually.
	Moreover, previous approaches do not explain the transition from
	specifications of smells to their detection. Finally, the validation
	of the existing approaches and tools has been limited on few proprietary
	systems and on a reduced number of smells. In this paper, we introduce
	an approach to automate the generation of detection algorithms from
	specifications written using a domain-specific language. This language
	is defined from a thorough domain analysis. It allows the specification
	of smells using high-level domain-related abstractions. It allows
	the adaptation of the specifications of smells to the context of
	the analysed systems. We specify 10 smells, generate automatically
	their detection algorithms using templates, and validate the algorithms
	in terms of precision and recall on Xerces v2.7.0 and GanttProject
	v1.10.2, two open-source object-oriented systems. We also compare
	the detection results with those of a previous approach, iPlasma
	.},
  affiliation = {Université de Montréal Ptidej Team, GEODES, DIRO Montreal QC Canada},
  issn = {0934-5043},
  issue = {3},
  keyword = {Computer Science},
  owner = {daniel},
  publisher = {Springer London},
  timestamp = {2011.11.06},
  url = {http://dx.doi.org/10.1007/s00165-009-0115-x}
}

@INBOOK{springerlink:10.1007/978-3-540-69073-3_29,
  pages = {275-286},
  title = {Developing a Quality Framework for Model-Driven Engineering},
  publisher = {Springer Berlin / Heidelberg},
  year = {2008},
  editor = {Giese, Holger},
  author = {Mohagheghi, Parastoo and Dehlen, Vegard},
  volume = {5002},
  series = {Lecture Notes in Computer Science},
  note = {10.1007/978-3-540-69073-3_29},
  abstract = {This paper presents some related work on quality frameworks and requirements
	for evaluating them. It also discusses characteristics of model-driven
	engineering that are important when building a quality framework,
	such as its use of models in several stages of development and maintenance,
	generation of other artifacts from models and its multi-abstraction
	level approach that requires consistency and traceability. We present
	a 7-step process on how to define a quality framework that is adapted
	to model-driven engineering, and which integrates quality engineering
	with quality evaluation. As an example, the framework is applied
	on transformation quality. We maintain that the transformation process
	and transformation mapping should be discussed separately, as they
	require different approaches, and suggest quality goals, quality-carrying
	properties to achieve the quality goals and methods for evaluating
	these properties.},
  affiliation = {SINTEF P.O. Box 124 Blindern N-0314 Oslo Norway},
  booktitle = {Models in Software Engineering},
  isbn = {978-3-540-69069-6},
  keyword = {Computer Science},
  owner = {daniel},
  timestamp = {2011.11.06},
  url = {http://dx.doi.org/10.1007/978-3-540-69073-3_29}
}

@ARTICLE{springerlink:10.1007/s10270-011-0219-7,
  author = {Mohagheghi, Parastoo and Gilani, Wasif and Stefanescu, Alin and Fernandez,
	Miguel and Nordmoen, Bjørn and Fritzsche, Mathias},
  title = {Where does model-driven engineering help? Experiences from three
	industrial cases},
  journal = {Software and Systems Modeling},
  pages = {1-21},
  note = {10.1007/s10270-011-0219-7},
  abstract = {There have been few experience reports from industry on how Model-Driven
	Engineering (MDE) is applied and what the benefits are. This paper
	summarizes the experiences of three large industrial participants
	in a European research project with the objective of developing techniques
	and tools for applying MDE on the development of large and complex
	software systems. The participants had varying degrees of previous
	experience with MDE. They found MDE to be particularly useful for
	providing abstractions of complex systems at multiple levels or from
	different viewpoints, for the development of domain-specific models
	that facilitate communication with non-technical experts, for the
	purposes of simulation and testing, and for the consumption of models
	for analysis, such as performance-related decision support and system
	design improvements. From the industrial perspective, a methodology
	is considered to be useful and cost-efficient if it is possible to
	reuse solutions in multiple projects or products. However, developing
	reusable solutions required extra effort and sometimes had a negative
	impact on the performance of tools. While the companies identified
	several benefits of MDE, merging different tools with one another
	in a seamless development environment required several transformations,
	which increased the required implementation effort and complexity.
	Additionally, user-friendliness of tools and the provision of features
	for managing models of complex systems were identified as crucial
	for a wider industrial adoption of MDE.},
  affiliation = {SINTEF, and Norwegian University of Science and Technology, Oslo,
	Norway},
  issn = {1619-1366},
  keyword = {Computer Science},
  owner = {daniel},
  publisher = {Springer Berlin / Heidelberg},
  timestamp = {2011.11.06},
  url = {http://dx.doi.org/10.1007/s10270-011-0219-7}
}

@ARTICLE{springerlink:10.1007/s10270-010-0165-9,
  author = {Monperrus, Martin and Jézéquel, Jean-Marc and Baudry, Benoit and
	Champeau, Joël and Hoeltzener, Brigitte},
  title = {Model-driven generative development of measurement software},
  journal = {Software and Systems Modeling},
  year = {2011},
  volume = {10},
  pages = {537-552},
  note = {10.1007/s10270-010-0165-9},
  abstract = {Metrics offer a practical approach to evaluate properties of domain-specific
	models. However, it is costly to develop and maintain measurement
	software for each domain-specific modeling language. In this paper,
	we present a model-driven and generative approach to measuring models.
	The approach is completely domain-independent and operationalized
	through a prototype that synthesizes a measurement infrastructure
	for a domain-specific modeling language. This model-driven measurement
	approach is model-driven from two viewpoints: (1) it measures models
	of a domain-specific modeling language; (2) it uses models as unique
	and consistent metric specifications, with respect to a metric specification
	metamodel which captures all the necessary concepts for model-driven
	specifications of metrics. The benefit from applying the approach
	is evaluated by four case studies. They indicate that this approach
	significantly eases the measurement activities of model-driven development
	processes.},
  affiliation = {Technische Uniersität Darmstadt, Darmstadt, Germany},
  issn = {1619-1366},
  issue = {4},
  keyword = {Computer Science},
  owner = {daniel},
  publisher = {Springer Berlin / Heidelberg},
  timestamp = {2011.11.06},
  url = {http://dx.doi.org/10.1007/s10270-010-0165-9}
}

@INBOOK{springerlink:10.1007/978-3-540-87875-9_36,
  pages = {505-519},
  title = {A Model-Driven Measurement Approach},
  publisher = {Springer Berlin / Heidelberg},
  year = {2008},
  editor = {Czarnecki, Krzysztof and Ober, Ileana and Bruel, Jean-Michel and
	Uhl, Axel and Völter, Markus},
  author = {Monperrus, Martin and Jézéquel, Jean-Marc and Champeau, Joël and
	Hoeltzener, Brigitte},
  volume = {5301},
  series = {Lecture Notes in Computer Science},
  note = {10.1007/978-3-540-87875-9_36},
  abstract = {Companies using domain specific languages in a model-driven development
	process need to measure their models. However, developing and maintaining
	a measurement software for each domain specific modeling language
	is costly. Our contribution is a model-driven measurement approach.
	This measurement approach is model-driven from two viewpoints: 1)
	it measures models of a model-driven development process; 2) it uses
	models as unique and consistent metric specifications, w.r.t a metric
	specification metamodel. This declarative specification of metrics
	is then used to generate a fully fledged implementation. The benefit
	from applying the approach is evaluated by two applications. They
	indicate that this approach reduces the domain-specific measurement
	software development cost.},
  affiliation = {ENSIETA - Brest (Fr)},
  booktitle = {Model Driven Engineering Languages and Systems},
  isbn = {978-3-540-87874-2},
  keyword = {Computer Science},
  owner = {daniel},
  timestamp = {2011.11.06},
  url = {http://dx.doi.org/10.1007/978-3-540-87875-9_36}
}

@ARTICLE{springerlink:10.1007/s11219-010-9111-x,
  author = {Mora, B. and García, F. and Ruiz, F. and Piattini, M.},
  title = {Graphical versus textual software measurement modelling: an empirical
	study},
  journal = {Software Quality Journal},
  year = {2011},
  volume = {19},
  pages = {201-233},
  note = {10.1007/s11219-010-9111-x},
  abstract = {Model-driven Engineering (MDE) has attained great importance in both
	the Software Engineering industry and the research community, where
	it is now widely used to provide a suitable approach with which to
	improve productivity when developing software artefacts. In this
	scenario, measurement models (software artefacts) have become a fundamental
	point in improvement of productivity, where MDE and Software Measurement
	can reap mutual benefits. MDE principles and techniques can be used
	in software measurement to build more automatic and generic solutions,
	and to achieve this, it is fundamental to be able to develop software
	measurement models. To facilitate this task, a domain-specific language
	named “Software Measurement Modelling Language” (SMML) has been
	developed. This paper tackles the question of whether the use of
	SMML can assist in the definition of software measurement models.
	An empirical study was conducted, with the aim of verifying whether
	SMML makes it easier to construct measurement models which are more
	usable and maintainable as regards textual notation. The results
	show that models which do not use the language are more difficult—in
	terms of effort, correctness and efficiency—to understand and modify
	than those represented with SMML. Additional feedback was also obtained,
	to verify the suitability of the graphical representation of each
	symbol (element or relationship) of SMML.},
  affiliation = {Indra Software Labs, Information Technology Company, Ciudad Real,
	Spain},
  issn = {0963-9314},
  issue = {1},
  keyword = {Computer Science},
  owner = {daniel},
  publisher = {Springer Netherlands},
  timestamp = {2011.11.06},
  url = {http://dx.doi.org/10.1007/s11219-010-9111-x}
}

@INBOOK{springerlink:10.1007/978-1-84628-923-1_12,
  pages = {353-382},
  title = {An Overview Of Model-Driven Web Engineering and the Mda},
  publisher = {Springer London},
  year = {2008},
  editor = {Rossi, Gustavo and Pastor, Oscar and Schwabe, Daniel and Olsina,
	Luis},
  author = {Moreno, Nathalie and Romero, José Raúl and Vallecillo, Antonio},
  series = {Human-Computer Interaction Series},
  note = {10.1007/978-1-84628-923-1_12},
  affiliation = {University of Málaga Dept. Lenguajes y Ciencias de la Computación
	Spain},
  booktitle = {Web Engineering: Modelling and Implementing Web Applications},
  isbn = {978-1-84628-923-1},
  keyword = {Computer Science},
  owner = {daniel},
  timestamp = {2011.11.06},
  url = {http://dx.doi.org/10.1007/978-1-84628-923-1_12}
}

@INBOOK{springerlink:10.1007/11561347_5,
  pages = {47-62},
  title = {Efficient Code Generation for a Domain Specific Language},
  publisher = {Springer Berlin / Heidelberg},
  year = {2005},
  editor = {Glück, Robert and Lowry, Michael},
  author = {Moss, Andrew and Muller, Henk},
  volume = {3676},
  series = {Lecture Notes in Computer Science},
  note = {10.1007/11561347_5},
  abstract = {We present a domain-specific-language (DSL) for writing instances
	of a class of filter programs. The values in the language are symbolic
	and independent of a concrete precision. Efficient code generation
	is required to fit the program onto a target device limited in both
	memory and processing power. We construct an interpreter for the
	DSL in a language specific to the device which contains the semantics
	of the target instruction set embedded within a declarative meta-language.
	The compiler is automatically generated from the interpreter through
	specialisation. This extension of the instruction set allows the
	construction of an interpreter for the DSL that is both simple and
	clear. In particular it allows us to declare static representations
	of the symbolic values, and have the specialisation of the code produce
	operate upon these values in the instruction set of the target device.},
  affiliation = {Department of Computer Science, University of Bristol},
  booktitle = {Generative Programming and Component Engineering},
  isbn = {978-3-540-29138-1},
  keyword = {Computer Science},
  owner = {daniel},
  timestamp = {2011.11.06},
  url = {http://dx.doi.org/10.1007/11561347_5}
}

@INBOOK{springerlink:10.1007/978-3-540-87875-9_38,
  pages = {537-552},
  title = {A Model-Based Framework for Security Policy Specification, Deployment
	and Testing},
  publisher = {Springer Berlin / Heidelberg},
  year = {2008},
  editor = {Czarnecki, Krzysztof and Ober, Ileana and Bruel, Jean-Michel and
	Uhl, Axel and Völter, Markus},
  author = {Mouelhi, Tejeddine and Fleurey, Franck and Baudry, Benoit and Le
	Traon, Yves},
  volume = {5301},
  series = {Lecture Notes in Computer Science},
  note = {10.1007/978-3-540-87875-9_38},
  abstract = {In this paper, we propose a model-driven approach for specifying,
	deploying and testing security policies in Java applications. First,
	a security policy is specified independently of the underlying access
	control language (OrBAC, RBAC). It is based on a generic security
	meta-model which can be used for early consistency checks in the
	security policy. This model is then automatically transformed into
	security policy for the XACML platform and integrated in the application
	using aspect-oriented programming. To qualify test cases that validate
	the security policy in the application, we inject faults into the
	policy. The fault model and the fault injection process are defined
	at the meta-model level, making the qualification process language-independent.
	Empirical results on 3 case studies explore both the feasibility
	of the approach and the efficiency of a full design & test MDE process.},
  affiliation = {IT- Telecom Bretagne, France},
  booktitle = {Model Driven Engineering Languages and Systems},
  isbn = {978-3-540-87874-2},
  keyword = {Computer Science},
  owner = {daniel},
  timestamp = {2011.11.06},
  url = {http://dx.doi.org/10.1007/978-3-540-87875-9_38}
}

@INBOOK{springerlink:10.1007/11880240_8,
  pages = {98-110},
  title = {Model-Driven Analysis and Synthesis of Concrete Syntax},
  publisher = {Springer Berlin / Heidelberg},
  year = {2006},
  editor = {Nierstrasz, Oscar and Whittle, Jon and Harel, David and Reggio, Gianna},
  author = {Muller, Pierre-Alain and Fleurey, Franck and Fondement, Frédéric
	and Hassenforder, Michel and Schneckenburger, Rémi and Gérard,
	Sébastien and Jézéquel, Jean-Marc},
  volume = {4199},
  series = {Lecture Notes in Computer Science},
  note = {10.1007/11880240_8},
  abstract = {Metamodeling is raising more and more interest in the field of language
	engineering. While this approach is now well understood for defining
	abstract syntaxes, formally defining concrete syntaxes with metamodels
	is still a challenge. Concrete syntaxes are traditionally expressed
	with rules, conforming to EBNF-like grammars, which can be processed
	by compiler compilers to generate parsers. Unfortunately, these generated
	parsers produce concrete syntax trees, leaving a gap with the abstract
	syntax defined by metamodels, and further ad-hoc hand-coding is required.
	In this paper we propose a new kind of specification for concrete
	syntaxes, which takes advantage of metamodels to generate fully operational
	tools (such as parsers or text generators). The principle is to map
	abstract syntaxes to concrete syntaxes via bidirectional mapping-models
	with support for both model-to-text, and text-to-model transformations.},
  affiliation = {IRISA / INRIA Rennes, Rennes, France},
  booktitle = {Model Driven Engineering Languages and Systems},
  isbn = {978-3-540-45772-5},
  keyword = {Computer Science},
  owner = {daniel},
  timestamp = {2011.11.06},
  url = {http://dx.doi.org/10.1007/11880240_8}
}

@INBOOK{springerlink:10.1007/978-3-540-30570-5_2,
  pages = {17-36},
  title = {The Design Space of Type Checkers for XML Transformation Languages},
  publisher = {Springer Berlin / Heidelberg},
  year = {2005},
  editor = {Eiter, Thomas and Libkin, Leonid},
  author = {Møller, Anders and Schwartzbach, Michael},
  volume = {3363},
  series = {Lecture Notes in Computer Science},
  note = {10.1007/978-3-540-30570-5_2},
  abstract = {We survey work on statically type checking XML transformations, covering
	a wide range of notations and ambitions. The concept of type may
	vary from idealizations of DTD to full-blown XML Schema or even more
	expressive formalisms. The notion of transformation may vary from
	clean and simple transductions to domain-specific languages or integration
	of XML in general-purpose programming languages. Type annotations
	can be either explicit or implicit, and type checking ranges from
	exact decidability to pragmatic approximations. We characterize and
	evaluate existing tools in this design space, including a recent
	result of the authors providing practical type checking of full unannotated
	XSLT 1.0 stylesheets given general DTDs that describe the input and
	output languages.},
  affiliation = {BRICS, University of Aarhus},
  booktitle = {Database Theory - ICDT 2005},
  isbn = {978-3-540-24288-8},
  keyword = {Computer Science},
  owner = {daniel},
  timestamp = {2011.11.06},
  url = {http://dx.doi.org/10.1007/978-3-540-30570-5_2}
}

@INBOOK{springerlink:10.1007/978-3-540-87603-8_41,
  pages = {354-354},
  title = {Using ASM to Achieve Executability within a Family of DSL},
  publisher = {Springer Berlin / Heidelberg},
  year = {2008},
  editor = {Börger, Egon and Butler, Michael and Bowen, Jonathan and Boca, Paul},
  author = {Ober, Ileana and Abou Dib, Ali},
  volume = {5238},
  series = {Lecture Notes in Computer Science},
  note = {10.1007/978-3-540-87603-8_41},
  abstract = {We propose an approach to achieve interoperability in a family of
	domain specific language based on the use of their ASM semantics
	and of the category theory. The approach is based on the construction
	of a unifying language of the family, by using categorical colimits.
	Since the unifying language is obtained by construction, translators
	to this one are obtained easily. These are the premises for using
	ASM tools for symbolically executing systems made of components specified
	in domain specific languages of a same family.},
  affiliation = {IRIT – Université Paul Sabatier Toulouse 118, route de Narbonne
	3 1062 Toulouse France},
  booktitle = {Abstract State Machines, B and Z},
  isbn = {978-3-540-87602-1},
  keyword = {Computer Science},
  owner = {daniel},
  timestamp = {2011.11.06},
  url = {http://dx.doi.org/10.1007/978-3-540-87603-8_41}
}

@INBOOK{springerlink:10.1007/978-3-540-88030-1_12,
  pages = {148-163},
  title = {Towards Interoperability in Component Based Development with a Family
	of DSLs},
  publisher = {Springer Berlin / Heidelberg},
  year = {2008},
  editor = {Morrison, Ron and Balasubramaniam, Dharini and Falkner, Katrina},
  author = {Ober, Ileana and Abou Dib, Ali and Féraud, Louis and Percebois,
	Christian},
  volume = {5292},
  series = {Lecture Notes in Computer Science},
  note = {10.1007/978-3-540-88030-1_12},
  abstract = {In this paper we address interoperability between components specified
	using various languages within a same family of DSLs. Our approach
	consists in applying results of the category theory in order to merge
	the languages into a unification one, automatically obtained. For
	this, we use the category of formal specifications of each DSL in
	the family. Using colimits on the category of algebraic specifications
	that implements the semantics of the DSLs in the family, we construct
	a language that unifies the family. Additionally we obtain translation
	morphisms from individual DSLs to the resulting unified one. By application
	of the translation morphisms, one can translate each component specifications
	into a specification written in the unification language. Moreover,
	properties established in the context of a DSL are transferred to
	the unifying language. In this paper, we illustrate the unification
	and the preservation of a property on an example.},
  affiliation = {Université Paul Sabatier Toulouse IRIT 118, route de Narbonne 31062
	Toulouse France},
  booktitle = {Software Architecture},
  isbn = {978-3-540-88029-5},
  keyword = {Computer Science},
  owner = {daniel},
  timestamp = {2011.11.06},
  url = {http://dx.doi.org/10.1007/978-3-540-88030-1_12}
}

@ARTICLE{springerlink:10.1007/s11334-009-0117-0,
  author = {Ober, Ileana and Féraud, Louis and Percebois, Christian},
  title = {Dealing with variability within a family of domain-specific languages:
	comparative analysis of different techniques},
  journal = {Innovations in Systems and Software Engineering},
  year = {2010},
  volume = {6},
  pages = {21-28},
  note = {10.1007/s11334-009-0117-0},
  abstract = {Almost a decade has passed since the OMG has issued the Model Driven
	Architecture (MDA) initiative. It soon became obvious that raising
	the level of abstraction in development and reasoning at the model
	level would help in asking the right questions at the right time.
	Based on a concrete problem, we discuss four alternative solutions
	to a multi-language system design problem. These solutions use a
	traditional approach, a technique based on modeling, a domain-specific
	approach, and a mix of modeling and domain-specific techniques, respectively.
	The solutions depend on the problem, but they are representative
	for the situations we encounter in practice, therefore giving us
	a good basis for a larger discussion on the appropriateness of using
	modeling techniques and on the place of MDA in current software engineering
	practice and design.},
  affiliation = {IRIT, Université de Toulouse 118, route de Narbonne 31062 Toulouse
	France},
  issn = {1614-5046},
  issue = {1},
  keyword = {Computer Science},
  owner = {daniel},
  publisher = {Springer London},
  timestamp = {2011.11.06},
  url = {http://dx.doi.org/10.1007/s11334-009-0117-0}
}

@INBOOK{springerlink:10.1007/978-3-540-89897-9_14,
  pages = {159-170},
  title = {Domain-Specific Languages for Service-Oriented Architectures: An
	Explorative Study},
  publisher = {Springer Berlin / Heidelberg},
  year = {2008},
  editor = {Mähönen, Petri and Pohl, Klaus and Priol, Thierry},
  author = {Oberortner, Ernst and Zdun, Uwe and Dustdar, Schahram},
  volume = {5377},
  series = {Lecture Notes in Computer Science},
  note = {10.1007/978-3-540-89897-9_14},
  abstract = {Domain-specific languages (DSLs) are an important software development
	approach for many service-oriented architectures (SOAs). They promise
	to model the various SOA concerns in a suitable way for the various
	technical and non-technical stakeholders of a SOA. However, so far
	the research on SOA DSLs concentrates on novel technical contributions,
	and not much evidence or counter-evidence for the claims associated
	to SOA DSLs has been provided. In this paper, we present a qualitative,
	explorative study that provides an initial analysis of a number of
	such claims through a series of three prototyping experiments in
	which each experiment has developed, analyzed, and compared a set
	of DSLs for process-driven SOAs. Our result is to provide initial
	evidence for a number of popular claims about SOA DSLs which follow
	the model-driven software development (MDSD) approach, as well as
	a list of design trade-offs to be considered in the design decisions
	that must be made when developing a SOA DSL.},
  affiliation = {Vienna University of Technology Distributed Systems Group, Information
	Systems Institute Vienna Austria},
  booktitle = {Towards a Service-Based Internet},
  isbn = {978-3-540-89896-2},
  keyword = {Computer Science},
  owner = {daniel},
  timestamp = {2011.11.06},
  url = {http://dx.doi.org/10.1007/978-3-540-89897-9_14}
}

@INBOOK{springerlink:10.1007/978-3-540-25935-0_9,
  pages = {195-265},
  title = {Embedding a Hardware Description Language in Template Haskell},
  publisher = {Springer Berlin / Heidelberg},
  year = {2004},
  editor = {Lengauer, Christian and Batory, Don and Consel, Charles and Odersky,
	Martin},
  author = {O’Donnell, John},
  volume = {3016},
  series = {Lecture Notes in Computer Science},
  note = {10.1007/978-3-540-25935-0_9},
  abstract = {Hydra is a domain-specific language for designing digital circuits,
	which is implemented by embedding within Haskell. Many features required
	for hardware specification fit well within functional languages,
	leading in many cases to a perfect embedding. There are some situations,
	including netlist generation and software logic probes, where the
	DSL does not fit exactly within the host functional language. A new
	solution to these problems is based on program transformations performed
	automatically by metaprograms in Template Haskell.},
  affiliation = {University of Glasgow, United Kingdom},
  booktitle = {Domain-Specific Program Generation},
  isbn = {978-3-540-22119-7},
  keyword = {Computer Science},
  owner = {daniel},
  timestamp = {2011.11.06},
  url = {http://dx.doi.org/10.1007/978-3-540-25935-0_9}
}

@INBOOK{springerlink:10.1007/11493402_6,
  pages = {309-311},
  title = {Construction of an Agent-Based Framework for Evolutionary Biology:
	A Progress Report},
  publisher = {Springer Berlin / Heidelberg},
  year = {2005},
  editor = {Leite, João and Omicini, Andrea and Torroni, Paolo and Yolum, pInar},
  author = {Pan, Yu and Tu, Phan and Pontelli, Enrico and Son, Tran},
  volume = {3476},
  series = {Lecture Notes in Computer Science},
  note = {10.1007/11493402_6},
  abstract = {We report on the development of an agent-based system, called ΦLOG,
	for the specification and execution of phylogenetic inference applications.
	We detail the implementation of the main components of the system.
	In the process, we discuss how advanced techniques developed in different
	research areas such as domain-specific languages, planning, Web Services
	discovery and invocation, and Web Service compositions can be applied
	in the building of the ΦLOG system.},
  affiliation = {Department of Computer Science, New Mexico State University},
  booktitle = {Declarative Agent Languages and Technologies II},
  isbn = {978-3-540-26172-8},
  keyword = {Computer Science},
  owner = {daniel},
  timestamp = {2011.11.06},
  url = {http://dx.doi.org/10.1007/11493402_6}
}

@INBOOK{springerlink:10.1007/11751113_13,
  pages = {174-189},
  title = {Prototyping Domain Specific Languages with COOPN},
  publisher = {Springer Berlin / Heidelberg},
  year = {2006},
  editor = {Guelfi, Nicolas and Savidis, Anthony},
  author = {Pedro, Luis and Lucio, Levi and Buchs, Didier},
  volume = {3943},
  series = {Lecture Notes in Computer Science},
  note = {10.1007/11751113_13},
  abstract = {The work described in this article presents how we use COOPN in the
	context of the MDA (Model Driven Architecture) philosophy for prototyping
	Domain Specific Languages. With this principle we increase the abstraction
	of COOPN language representation enabling standard data interchange
	with other applications that use the same approach. In particular
	we will present the architecture of the transformation from Domain
	Specific Languages; its advantages concerning the ability to have
	COOPN models as a standard format for representing the semantics
	of Domain Specific Languages and to reuse software prototyping and
	testing techniques developped for this formalism. As example we will
	show how our work is proceeding towards transformation from UML to
	COOPN. We also argue how our approach can be easily used in order
	to produce rapid system prototyping and verification for Domain Specific
	Languages (DSLs).},
  affiliation = {Centre Universitaire d’Informatique, University of Geneva, 24, rue
	du Général-Dufour, CH 1211 Genève, Switzerland},
  booktitle = {Rapid Integration of Software Engineering Techniques},
  isbn = {978-3-540-34063-8},
  keyword = {Computer Science},
  owner = {daniel},
  timestamp = {2011.11.06},
  url = {http://dx.doi.org/10.1007/11751113_13}
}

@INBOOK{springerlink:10.1007/978-3-540-70621-2_11,
  pages = {127-135},
  title = {MDE for BPM: A Systematic Review},
  publisher = {Springer Berlin Heidelberg},
  year = {2008},
  editor = {Filipe, Joaquim and Shishkov, Boris and Helfert, Markus},
  author = {Perez, Jose Manuel and Ruiz, Francisco and Piattini, Mario},
  volume = {10},
  series = {Communications in Computer and Information Science},
  note = {10.1007/978-3-540-70621-2_11},
  abstract = {Due to the rapid change in the business processes of organizations,
	Business Process Management (BPM) has come into being. BPM helps
	business analysts to manage all concerns related to business processes,
	but the gap between these analysts and people who build the applications
	is still large. The organization’s value chain changes very rapidly;
	to modify simultaneously the systems that support the business management
	process is impossible. MDE (Model Driven Engineering) is a good support
	for transferring these business process changes to the systems that
	implement these processes. Thus, by using any MDE approach, such
	as MDA, the alignment between business people and software engineering
	should be improved. To discover the different proposals that exist
	in this area, a systematic review was performed. As a result, the
	OMG’s Business Process Definition Metamodel (BPDM) has been identified
	as the standard that will be the key for the application of MDA for
	BPM.},
  affiliation = {University of Castilla-La Mancha Alarcos Research Group Paseo de la
	Universidad, 4 13071 Ciudad Real Spain},
  booktitle = {Software and Data Technologies},
  isbn = {978-3-540-70621-2},
  keyword = {Computer Science},
  owner = {daniel},
  timestamp = {2011.11.06},
  url = {http://dx.doi.org/10.1007/978-3-540-70621-2_11}
}

@ARTICLE{springerlink:10.1007/s10270-010-0186-4,
  author = {Perrouin, Gilles and Vanwormhoudt, Gilles and Morin, Brice and Lahire,
	Philippe and Barais, Olivier and Jézéquel, Jean-Marc},
  title = {Weaving variability into domain metamodels},
  journal = {Software and Systems Modeling},
  pages = {1-23},
  note = {10.1007/s10270-010-0186-4},
  abstract = {Domain-specific modeling languages (DSMLs) are the essence of MDE.
	A DSML describes the concepts of a particular domain in a metamodel,
	as well as their relationships. Using a DSML, it is possible to describe
	a wide range of different models that often share a common base and
	vary on some parts. On the one hand, some current approaches tend
	to distinguish the variability language from the DSMLs themselves,
	implying greater learning curve for DSMLs stakeholders and a significant
	overhead in product line engineering. On the other hand, approaches
	integrating variability in DSMLs lack generality and tool support.
	We argue that aspect-oriented modeling techniques enabling flexible
	metamodel composition and results obtained by the software product
	line community to manage and resolve variability form the pillars
	for a solution for integrating variability into DSMLs. In this article,
	we consider variability as an independent and generic aspect to be
	woven into the DSML. In particular, we detail how variability is
	woven and how to perform product line derivation. We validate our
	approach through the weaving of variability into two different metamodels:
	Ecore—widely used for DSML definition—and S mart A dapters ,
	our aspect model weaver. These results emphasize how new abilities
	of the language can be provided by this means.},
  affiliation = {PReCISE, University of Namur, 5000 Namur, Belgium},
  issn = {1619-1366},
  keyword = {Computer Science},
  owner = {daniel},
  publisher = {Springer Berlin / Heidelberg},
  timestamp = {2011.11.06},
  url = {http://dx.doi.org/10.1007/s10270-010-0186-4}
}

@INBOOK{springerlink:10.1007/11561347_15,
  pages = {205-220},
  title = {A Generative Programming Approach to Interactive Information Retrieval:Insights
	and Experiences},
  publisher = {Springer Berlin / Heidelberg},
  year = {2005},
  editor = {Glück, Robert and Lowry, Michael},
  author = {Perugini, Saverio and Ramakrishnan, Naren},
  volume = {3676},
  series = {Lecture Notes in Computer Science},
  note = {10.1007/11561347_15},
  abstract = {We describe the application of generative programming to a problem
	in interactive information retrieval. The particular interactive
	information retrieval problem we study is the support for ‘out
	of turn interaction’ with a website – how a user can communicate
	input to a website when the site is not soliciting such information
	on the current page, but will do so on a subsequent page. Our solution
	approach makes generous use of program transformations (partial evaluation,
	currying, and slicing) to delay the site’s current solicitation
	for input until after the user’s out-of-turn input is processed.
	We illustrate how studying out-of-turn interaction through a generative
	lens leads to several valuable insights: (i) the concept of a web
	dialog, (ii) an improved understanding of web taxonomies, and (iii)
	new web interaction techniques and interfaces. These notions allow
	us to cast the design of interactive (and responsive) websites in
	terms of the underlying dialog structure and, further, suggest a
	simple implementation strategy with a clean separation of concerns.
	We also highlight new research directions opened up by the generative
	programming approach to interactive information retrieval such as
	the idea of web interaction axioms.},
  affiliation = {Department of Computer Science, University of Dayton, OH 45469-2160,
	USA},
  booktitle = {Generative Programming and Component Engineering},
  isbn = {978-3-540-29138-1},
  keyword = {Computer Science},
  owner = {daniel},
  timestamp = {2011.11.06},
  url = {http://dx.doi.org/10.1007/11561347_15}
}

@INBOOK{springerlink:10.1007/978-3-642-22389-1_7,
  pages = {72-84},
  title = {A JRuby Infrastructure for Converged Web and SIP Applications},
  publisher = {Springer Berlin Heidelberg},
  year = {2011},
  editor = {Snasel, Vaclav and Platos, Jan and El-Qawasmeh, Eyas},
  author = {Pjanić, Edin and Hasanović, Amer},
  volume = {188},
  series = {Communications in Computer and Information Science},
  note = {10.1007/978-3-642-22389-1_7},
  abstract = {In this paper we present a Ruby infrastructure that can be used for
	rapid development of Web applications with SIP signaling capabilities.
	We construct this infrastructure by combining the Java based Cipango
	SIP/HTTP Servlet Application Server with the Ruby on Rails Web development
	framework. We provide detailed explanations of the steps required
	to build this infrastructure and produce a SIP registrar example
	application with a simple Web interface. The described infrastructure
	allows Ruby applications to utilize the entire functionality provided
	by the SIP Servlet API and can be used as a good starting point for
	the development of Ruby-based domain specific languages for the SIP
	protocol. We also compare the proposed infrastructure with the existing
	Ruby frameworks for SIP application development.},
  affiliation = {Faculty of Electrical Engineering, University of Tuzla, Franjevačka
	2, 75000 Tuzla, Bosnia and Herzegovina},
  booktitle = {Digital Information Processing and Communications},
  isbn = {978-3-642-22389-1},
  keyword = {Computer Science},
  owner = {daniel},
  timestamp = {2011.11.06},
  url = {http://dx.doi.org/10.1007/978-3-642-22389-1_7}
}

@INBOOK{springerlink:10.1007/978-3-540-73551-9_17,
  pages = {242-257},
  title = {Experience with Safe Dynamic Reconfigurations in Component-Based
	Embedded Systems},
  publisher = {Springer Berlin / Heidelberg},
  year = {2007},
  editor = {Schmidt, Heinz and Crnkovic, Ivica and Heineman, George and Stafford,
	Judith},
  author = {Polakovic, Juraj and Mazare, Sebastien and Stefani, Jean-Bernard
	and David, Pierre-Charles},
  volume = {4608},
  series = {Lecture Notes in Computer Science},
  note = {10.1007/978-3-540-73551-9_17},
  abstract = {Supporting dynamic reconfiguration is required even in highly constrained
	embedded systems, to allow software patches and updates, and to allow
	adaptations to changes in environmental and operating conditions
	without service interruption. Dynamic reconfiguration, however, is
	a complex and error prone process. In this paper we report our experience
	in implementing safe dynamic reconfigurations in embedded devices
	with limited resources. Our approach relies on a component-based
	framework for building reconfigurable operating systems, and the
	use of a domain specific language (DSL) for reconfiguration.},
  affiliation = {FranceTelecom R&D, MAPS/AMS Lab, Grenoble France},
  booktitle = {Component-Based Software Engineering},
  isbn = {978-3-540-73550-2},
  keyword = {Computer Science},
  owner = {daniel},
  timestamp = {2011.11.06},
  url = {http://dx.doi.org/10.1007/978-3-540-73551-9_17}
}

@INBOOK{springerlink:10.1007/978-3-540-71836-9_6,
  pages = {111-133},
  title = {Let’s Modularize the Data Model Specifications of the ObjectLens
	in VisualWorks/Smalltalk},
  publisher = {Springer Berlin / Heidelberg},
  year = {2007},
  editor = {De Meuter, Wolfgang},
  author = {Prasse, Michael},
  volume = {4406},
  series = {Lecture Notes in Computer Science},
  note = {10.1007/978-3-540-71836-9_6},
  abstract = {The ObjectLens framework of VisualWorks maps objects to ta bles. This
	mapping is described in a data mapping model, which itself is spe
	cified in one dataModelSpec method. This method is monolithic and
	defines the whole data model of an application. This is a suitable
	approach to start with. However, when the business area extends to
	a set of similar applications, like a software product family, each
	of these applications needs its own data mo del specification. All
	specifications of the product family would be quite si milar but
	there is no appropriate reuse-mechanism, which could be used. Consequently,
	the monolithic design specifications lead to a high degree of redundancy,
	which complicates software development and maintenance. Therefore,
	this paper describes an approach, which leads to a separation of
	the monolithic data model specifications. The main idea is to define
	the map pings of each class in the class itself using inheritance
	and generate the whole specification from a list of single class
	data models. In this way, declarative and generative programming
	techniques are combined.},
  affiliation = {Collogia Unternehmungsberatung AG, Ubierring 11, D-50678 Köln Germany},
  booktitle = {Advances in Smalltalk},
  isbn = {978-3-540-71835-2},
  keyword = {Computer Science},
  owner = {daniel},
  timestamp = {2011.11.06},
  url = {http://dx.doi.org/10.1007/978-3-540-71836-9_6}
}

@INBOOK{springerlink:10.1007/978-3-540-31849-1_2,
  pages = {2-14},
  title = {DSL Weaving for Distributed Information Flow Systems},
  publisher = {Springer Berlin / Heidelberg},
  year = {2005},
  editor = {Zhang, Yanchun and Tanaka, Katsumi and Yu, Jeffrey and Wang, Shan
	and Li, Minglu},
  author = {Pu, Calton and Swint, Galen},
  volume = {3399},
  series = {Lecture Notes in Computer Science},
  note = {10.1007/978-3-540-31849-1_2},
  abstract = {Aspect-oriented programming (AOP) is a promising field for reducing
	application complexity. However, it has proven difficult to implement
	weavers for general purpose languages. Nevertheless, we felt some
	functionality for our information flow abstraction, Infopipes, might
	be best captures in aspects. In this paper, we describe a weaver
	built for domain specific languages (DSLs) related to Infopipes around
	an off-the-shelf XSLT processor. Aspects are written in XSLT, XML
	annotations are added to existing DSL generation templates, and XML
	directives are added to our Infopipes specification. Finally, we
	successfully demonstrate a generated+woven application that adds
	the quality of service (QoS) dimension CPU usage awareness to an
	image streaming application.},
  affiliation = {Georgia Institute of Technology, CERCS, College of Computing, 801
	Atlantic Drive, Atlanta, Georgia 30332-0280, USA},
  booktitle = {Web Technologies Research and Development - APWeb 2005},
  isbn = {978-3-540-25207-8},
  keyword = {Computer Science},
  owner = {daniel},
  timestamp = {2011.11.06},
  url = {http://dx.doi.org/10.1007/978-3-540-31849-1_2}
}

@INBOOK{springerlink:10.1007/3-540-47853-1_7,
  pages = {1-16},
  title = {Feature Interaction in Composed Systems},
  publisher = {Springer Berlin / Heidelberg},
  year = {2002},
  editor = {Frohner, Ákos},
  author = {Pulvermueller, Elke and Speck, Andreas and Coplien, James and D’Hondt,
	Maja and De Meuter, Wolfgang},
  volume = {2323},
  series = {Lecture Notes in Computer Science},
  note = {10.1007/3-540-47853-1_7},
  abstract = {The history of computer science has shown that decomposing software
	applications helps managing their complexity and facilitates reuse,
	but also bears challenging problems still unsolved, such as the assembly
	of the decomposed features when non-trivial feature interactions
	are involved. Examples of features include concerns or aspects, black
	box or white box components, and functional and non-functional requirements.
	Approaches such as object-oriented and component-based software development,
	as well as relatively new directions such as aspect-oriented programming,
	multi-dimensional separation of concerns and generative programming,
	all provide technical support for the definition and syntactical
	assembly of features, but fall short on the semantic level, for example
	in spotting meaningless or even faulty combinations. At previous
	ECOOPs, OOPSLAs and GCSEs dedicated events have been organised around
	the aforementioned technologies, where we experienced a growing awareness
	of this feature interaction problem. However, feature interaction
	is often merely dismissed as a secondary problem, percolating as
	an afterthought while other issues are being addressed. The intention
	of this workshop was to be the first co-ordinated effort to address
	the general problem of feature interaction in composed systems separately
	from other issues.},
  affiliation = {Universitaet Karlsruhe Postfach 6980 Karlsruhe Germany},
  booktitle = {Object-Oriented Technology},
  isbn = {978-3-540-43675-1},
  keyword = {Computer Science},
  owner = {daniel},
  timestamp = {2011.11.06},
  url = {http://dx.doi.org/10.1007/3-540-47853-1_7}
}

@INBOOK{springerlink:10.1007/978-3-540-89020-1_7,
  pages = {82-97},
  title = {Domain Specific Languages with Graphical and Textual Views},
  publisher = {Springer Berlin / Heidelberg},
  year = {2008},
  editor = {Schürr, Andy and Nagl, Manfred and Zündorf, Albert},
  author = {Pérez Andrés, Francisco and de Lara, Juan and Guerra, Esther},
  volume = {5088},
  series = {Lecture Notes in Computer Science},
  note = {10.1007/978-3-540-89020-1_7},
  abstract = {We show our approach for the definition of Domain Specific Languages
	integrating both graphical and textual views. The approach is based
	on the meta-modelling concepts provided by the AToM 3 tool. In this
	way, the language designer starts building the meta-model of the
	complete language. Then, he can select (possibly overlapping) submodels
	of the meta-model to define the different diagram types (i.e. language
	viewpoints). By default, the viewpoint is assigned a graphical concrete
	syntax, although a textual one can also be given. This is performed
	by selecting (or creating) triple graph grammar rules to translate
	from the viewpoint meta-model to a DSL called Textual that contains
	the most common elements of textual languages (such as expressions
	or operators). From a Textual model, a parser is automatically generated,
	where the semantic actions of the EBNF grammar are graph grammar
	rules, derived from the viewpoint meta-model. In this way, the parsing
	results in a model conformant to the viewpoint meta-model, which
	can be seamlessly integrated with other graphical and textual views.},
  affiliation = {Univ. Autónoma de Madrid Polytechnic School Spain},
  booktitle = {Applications of Graph Transformations with Industrial Relevance},
  isbn = {978-3-540-89019-5},
  keyword = {Computer Science},
  owner = {daniel},
  timestamp = {2011.11.06},
  url = {http://dx.doi.org/10.1007/978-3-540-89020-1_7}
}

@INBOOK{springerlink:10.1007/11783565_9,
  pages = {123-138},
  title = {Designing Software Architectures with an Aspect-Oriented Architecture
	Description Language},
  publisher = {Springer Berlin / Heidelberg},
  year = {2006},
  editor = {Gorton, Ian and Heineman, George and Crnkovic, Ivica and Schmidt,
	Heinz and Stafford, Judith and Szyperski, Clemens and Wallnau, Kurt},
  author = {Pérez, Jennifer and Ali, Nour and Carsí, Jose and Ramos, Isidro},
  volume = {4063},
  series = {Lecture Notes in Computer Science},
  note = {10.1007/11783565_9},
  abstract = {A great deal of languages have emerged and have demonstrated the advantages
	that Aspect-Oriented Programming offers. For this reason, the aspect-oriented
	approach is being introduced into the early phases (analysis and
	design) of the software life cycle. In this work, we present an Aspect-Oriented
	Architecture Description Language (AOADL) to specify software architectures
	of complex, dynamic and distributed software systems. This AOADL
	follows the PRISMA approach, which integrates the advantages of Component-Based
	Software Development (CBSD) and Aspect-Oriented Software Development
	(AOSD). The PRISMA AOADL combines components and aspects in an elegant
	and novel way achieving a better management of crosscutting-concerns.
	In addition, it is independent of the technology, and it has great
	expressive power in order to facilitate the automatic code generation
	from its specifications. In this work, we demonstrate how PRISMA
	AOADL improves the management, maintainability and reusability of
	software architectures introducing the notion of aspect in its ADL.},
  affiliation = {Department of Information Systems and Computation, Polytechnic University
	of Valencia, Camino de Vera s/n, E-46022 Valencia, Spain},
  booktitle = {Component-Based Software Engineering},
  isbn = {978-3-540-35628-8},
  keyword = {Computer Science},
  owner = {daniel},
  timestamp = {2011.11.06},
  url = {http://dx.doi.org/10.1007/11783565_9}
}

@INBOOK{springerlink:10.1007/978-3-540-77222-4_8,
  pages = {84-97},
  title = {A Survey of Model Driven Engineering Tools for User Interface Design},
  publisher = {Springer Berlin / Heidelberg},
  year = {2007},
  editor = {Winckler, Marco and Johnson, Hilary and Palanque, Philippe},
  author = {Pérez-Medina, Jorge-Luis and Dupuy-Chessa, Sophie and Front, Agnès},
  volume = {4849},
  series = {Lecture Notes in Computer Science},
  note = {10.1007/978-3-540-77222-4_8},
  abstract = {The introduction of new technologies leads to a more and more complex
	interactive systems design. In order to describe the future interactive
	system, the human computer interaction (HCI) domain uses specific
	models and tools. In another way, the Model Driven Engineering (MDE)
	approach has been proposed in software engineering domain in order
	to provide techniques and tools for dealing with models in an automated
	way. MDE approach is based on models, meta-models, models transformation
	and models weaving and aims to produce productive models, i.e. models
	concentrated on their generative power. Considering these two domains
	and the already existing HCI works in MDE, the goal of this paper
	is to understand actual HCI design needs and to study how MDE tools
	can support HCI needs. As a first response, it proposes a survey
	of existing MDE tools in regards to HCI model management.},
  affiliation = {Laboratory of Informatics of Grenoble, 385 rue de la bibliothèque,
	B.P. 53, 38041 Grenoble Cedex 9, France},
  booktitle = {Task Models and Diagrams for User Interface Design},
  isbn = {978-3-540-77221-7},
  keyword = {Computer Science},
  owner = {daniel},
  timestamp = {2011.11.06},
  url = {http://dx.doi.org/10.1007/978-3-540-77222-4_8}
}

@INBOOK{springerlink:10.1007/11568346_50,
  pages = {461-463},
  title = {Tutorial 3: Domain Engineering – Using Domain Concepts to Guide
	Software Design},
  publisher = {Springer Berlin / Heidelberg},
  year = {2005},
  editor = {Akoka, Jacky and Liddle, Stephen and Song, Il-Yeol and Bertolotto,
	Michela and Comyn-Wattiau, Isabelle and van den Heuvel, Willem-Jan
	and Kolp, Manuel and Trujillo, Juan and Kop, Christian and Mayr,
	Heinrich},
  author = {Reinhartz-Berger, Iris and Sturm, Arnon and Wand, Yair},
  volume = {3770},
  series = {Lecture Notes in Computer Science},
  note = {10.1007/11568346_50},
  abstract = {As the variability of information and software systems has increased,
	the need for an engineering discipline concerned with building reusable
	assets (such as specification sets, patterns and components) on one
	hand and representing and managing knowledge in specific domains
	on the other hand has become crucial. This discipline, called domain
	engineering, supports the notion of a domain, defined as a set of
	applications that use a set of common concepts for describing requirements,
	problems and capabilities. The purpose of domain engineering is to
	identify, model, construct, catalog, and disseminate a set of software
	artifacts that can be applied to existing and future software in
	a particular application domain. As such, it can support the effective
	and efficient management and development of software assets. Hence,
	it is important to introduce this discipline among software engineering
	practitioners and researchers.},
  affiliation = {Department of Management Information Systems, University of Haifa,
	Haifa, 31905 Israel},
  booktitle = {Perspectives in Conceptual Modeling},
  isbn = {978-3-540-29395-8},
  keyword = {Computer Science},
  owner = {daniel},
  timestamp = {2011.11.06},
  url = {http://dx.doi.org/10.1007/11568346_50}
}

@INBOOK{springerlink:10.1007/11787044_7,
  pages = {78-89},
  title = {MDD Maturity Model: A Roadmap for Introducing Model-Driven Development},
  publisher = {Springer Berlin / Heidelberg},
  year = {2006},
  editor = {Rensink, Arend and Warmer, Jos},
  author = {Rios, Erkuden and Bozheva, Teodora and Bediaga, Aitor and Guilloreau,
	Nathalie},
  volume = {4066},
  series = {Lecture Notes in Computer Science},
  note = {10.1007/11787044_7},
  abstract = {Experience reports show that MDD reduces time-to-market and increases
	productivity by means of platform independent business logic modelling
	and automation. Achieving these two concepts in the organisation
	is not a one step process. This paper explains the MDD Maturity Model
	developed to drive this task in a structured way. The MDD Maturity
	Model establishes five capability levels towards the progressive
	adoption of MDD within an organisation. Each level describes a coherent
	set of engineering, management and support practices involved in
	the MDD approach, and characterizes the MDD artefacts, called MDD
	elements, used in or resulted from those practices. The paper presents
	also the validation process that the model will undergo in two large
	organisations and two SMEs.},
  affiliation = {European Software Institute, Parque Tecnológico de Zamudio, #204,
	E-48170 Zamudio, Spain},
  booktitle = {Model Driven Architecture – Foundations and Applications},
  isbn = {978-3-540-35909-8},
  keyword = {Computer Science},
  owner = {daniel},
  timestamp = {2011.11.06},
  url = {http://dx.doi.org/10.1007/11787044_7}
}

@ARTICLE{springerlink:10.1007/s00766-011-0124-1,
  author = {Robles Luna, Esteban and Rossi, Gustavo and Garrigós, Irene},
  title = {WebSpec: a visual language for specifying interaction and navigation
	requirements in web applications},
  journal = {Requirements Engineering},
  year = {2011},
  volume = {16},
  pages = {297-321},
  note = {10.1007/s00766-011-0124-1},
  abstract = {Web application development is a complex and time-consuming process
	that involves different stakeholders (ranging from customers to developers);
	these applications have some unique characteristics like navigational
	access to information, sophisticated interaction features, etc. However,
	there have been few proposals to represent those requirements that
	are specific to Web applications. Consequently, validation of requirements
	(e.g., in acceptance tests) is usually informal and as a result troublesome.
	To overcome these problems, we present WebSpec, a domain-specific
	language for specifying the most relevant and characteristic requirements
	of Web applications: those involving interaction and navigation.
	We describe WebSpec diagrams, discussing their abstraction and expressive
	power. With a simple though realistic example, we show how we have
	used WebSpec in the context of an agile Web development approach
	discussing several issues such as automatic test generation, management
	of changes in requirements, and improving the understanding of the
	diagrams through application simulation.},
  affiliation = {LIFIA, Facultad de Informática, UNLP, La Plata, Argentina},
  issn = {0947-3602},
  issue = {4},
  keyword = {Computer Science},
  owner = {daniel},
  publisher = {Springer London},
  timestamp = {2011.11.06},
  url = {http://dx.doi.org/10.1007/s00766-011-0124-1}
}

@INBOOK{springerlink:10.1007/978-1-84628-923-1_6,
  pages = {109-155},
  title = {Modeling and Implementing Web Applications with Oohdm},
  publisher = {Springer London},
  year = {2008},
  editor = {Rossi, Gustavo and Pastor, Oscar and Schwabe, Daniel and Olsina,
	Luis},
  author = {Rossi, Gustavo and Schwabe, Daniel},
  series = {Human-Computer Interaction Series},
  note = {10.1007/978-1-84628-923-1_6},
  affiliation = {Universidad Nacional de La Plata (also at CONICET) LIFIA Facultad
	de Informatica Argentina},
  booktitle = {Web Engineering: Modelling and Implementing Web Applications},
  isbn = {978-1-84628-923-1},
  keyword = {Computer Science},
  owner = {daniel},
  timestamp = {2011.11.06},
  url = {http://dx.doi.org/10.1007/978-1-84628-923-1_6}
}

@INBOOK{springerlink:10.1007/978-1-84628-923-1_4,
  pages = {49-63},
  title = {Overview of Design Issues for Web Applications Development},
  publisher = {Springer London},
  year = {2008},
  editor = {Rossi, Gustavo and Pastor, Oscar and Schwabe, Daniel and Olsina,
	Luis},
  author = {Rossi, Gustavo and Schwabe, Daniel and Olsina, Luis and Pastor, Oscar},
  series = {Human-Computer Interaction Series},
  note = {10.1007/978-1-84628-923-1_4},
  affiliation = {Universidad Nacional de La Plata (also at CONICET) LIFIA Facultad
	de Informatica Argentina},
  booktitle = {Web Engineering: Modelling and Implementing Web Applications},
  isbn = {978-1-84628-923-1},
  keyword = {Computer Science},
  owner = {daniel},
  timestamp = {2011.11.06},
  url = {http://dx.doi.org/10.1007/978-1-84628-923-1_4}
}

@INBOOK{springerlink:10.1007/978-3-540-87654-0_18,
  pages = {318-332},
  title = {Model Driven Engineering for Designing Adaptive Multi-Agents Systems},
  publisher = {Springer Berlin / Heidelberg},
  year = {2008},
  editor = {Artikis, Alexander and O’Hare, Gregory and Stathis, Kostas and
	Vouros, George},
  author = {Rougemaille, Sylvain and Migeon, Frédéric and Maurel, Christine
	and Gleizes, Marie-Pierre},
  volume = {4995},
  series = {Lecture Notes in Computer Science},
  note = {10.1007/978-3-540-87654-0_18},
  abstract = {A challenge for our days is to provide new efficient CASE (Computer
	Aided Software Engineering) tools enabling MAS designers towards
	Model Driven Engineering (MDE) approaches. The goal of MDE is to
	improve the development process and the quality of the software produced.
	Our work focuses on two different aspects of MAS. The functional
	one, which is application dependent and close to the decision process
	of agents, and the operational one related to elementary capabilities
	of agents. For each point of view, we have defined specific meta-models.
	Our goal in this paper is to provide a mapping from the functional
	meta-model to the operational that constitutes a specific platform
	model. As we are interested in adaptive systems, we have to deal
	with adaptation both at the agent and the system level. We address
	this problem by respectively using the JavAct flexible architecture
	and the Adaptive MAS principles.},
  affiliation = {IRIT – Paul Sabatier University 118, Route de Narbonne 31062 Toulouse,
	Cedex 9 France},
  booktitle = {Engineering Societies in the Agents World VIII},
  isbn = {978-3-540-87653-3},
  keyword = {Computer Science},
  owner = {daniel},
  timestamp = {2011.11.06},
  url = {http://dx.doi.org/10.1007/978-3-540-87654-0_18}
}

@INBOOK{springerlink:10.1007/978-3-540-39815-8_23,
  pages = {377-396},
  title = {A Case for Test-Code Generation in Model-Driven Systems},
  publisher = {Springer Berlin / Heidelberg},
  year = {2003},
  editor = {Pfenning, Frank and Smaragdakis, Yannis},
  author = {Rutherford, Matthew and Wolf, Alexander},
  volume = {2830},
  series = {Lecture Notes in Computer Science},
  note = {10.1007/978-3-540-39815-8_23},
  abstract = {A primary goal of generative programming and model-driven development
	is to raise the level of abstraction at which designers and developers
	interact with the software systems they are building. During initial
	development, the benefits of abstraction are clear. However, during
	testing and maintenance, increased distance from the implementation
	can be a disadvantage. We view test cases and test harnesses as an
	essential bridge between the high-level specifications and the implementation.
	As such, the generation of test cases for fully generated components
	and test harnesses for partially generated components is of fundamental
	importance to model-driven systems. In this paper we present our
	experience with test-case and test-harness generation for a family
	of model-driven, component-based distributed systems. We describe
	our development tool, MODEST, and motivate our decision to invest
	the extra effort needed to generate test code. We present our approach
	to test-case and test-harness generation and describe the benefits
	to developers and maintainers of generated systems. Furthermore,
	we quantify the relative cost of generating test code versus application
	code and find that the artifact templates for producing test code
	are simpler than those used for application code. Given the described
	benefits to developers and maintainers and the relatively low cost
	of test-code development, we argue that test-code generation should
	be a fundamental feature of model-driven development efforts.},
  affiliation = {Department of Computer Science, University of Colorado, Boulder, Colorado
	80309-430, USA},
  booktitle = {Generative Programming and Component Engineering},
  isbn = {978-3-540-20102-1},
  keyword = {Computer Science},
  owner = {daniel},
  timestamp = {2011.11.06},
  url = {http://dx.doi.org/10.1007/978-3-540-39815-8_23}
}

@ARTICLE{springerlink:10.1007/s10270-009-0122-7,
  author = {Ráth, István and Ökrös, András and Varró, Dániel},
  title = {Synchronization of abstract and concrete syntax in domain-specific
	modeling languages},
  journal = {Software and Systems Modeling},
  year = {2010},
  volume = {9},
  pages = {453-471},
  note = {10.1007/s10270-009-0122-7},
  abstract = {Modern domain-specific modeling (DSM) frameworks provide refined techniques
	for developing new languages based on the clear separation of conceptual
	elements of the language (called abstract syntax ) and their graphical
	visual representation (called concrete syntax ). This separation
	is usually achieved by recording traceability information between
	the abstract and concrete syntax using mapping models . However,
	state-of-the-art DSM frameworks impose severe restrictions on traceability
	links between elements of the abstract syntax and the concrete syntax.
	In the current paper, we propose a mapping model which allows to
	define arbitrarily complex mappings between elements of the abstract
	and concrete syntax. Moreover, we demonstrate how live model transformations
	can complement mapping models in providing bidirectional synchronization
	and implicit traceability between models of the abstract and the
	concrete syntax. In addition, we introduce a novel architecture for
	DSM environments which enables these concepts, and provide an overview
	of the tool support.},
  affiliation = {Department of Measurement and Information Systems, Budapest University
	of Technology and Economics, Magyar tudósok krt. 2, 1117 Budapest,
	Hungary},
  issn = {1619-1366},
  issue = {4},
  keyword = {Computer Science},
  owner = {daniel},
  publisher = {Springer Berlin / Heidelberg},
  timestamp = {2011.11.06},
  url = {http://dx.doi.org/10.1007/s10270-009-0122-7}
}

@INBOOK{springerlink:10.1007/978-3-540-87875-9_52,
  pages = {751-765},
  title = {Visual ScatterUnit: A Visual Model-Driven Testing Framework of Wireless
	Sensor Networks Applications},
  publisher = {Springer Berlin / Heidelberg},
  year = {2008},
  editor = {Czarnecki, Krzysztof and Ober, Ileana and Bruel, Jean-Michel and
	Uhl, Axel and Völter, Markus},
  author = {Saad, Mohammad and Kamenzky, Nicolai and Schiller, Jochen},
  volume = {5301},
  series = {Lecture Notes in Computer Science},
  note = {10.1007/978-3-540-87875-9_52},
  abstract = {We present a model-driven test environment called Visual ScatterUnit,
	which optimizes the application testing process of wireless sensor
	networks. Instead of having to implement the test case completely
	manually, the model-driven test environment allows the abstract modeling
	of the test process. At the same time the test case’s technical
	implementation requirements are kept hidden from the user. In the
	following a code generator is able to create the necessary test case
	code, which complies with technical requirements from the test case
	model. The test case is executed with the help of Visual ScatterUnit
	and the test results are subsequently visualized in the test case
	model’s diagrams. In this way the user can easily comprehend the
	test run and consequently understand the cause of failure. Furthermore
	the test case’s abstract modeling allows it to be validated, which
	brings with it a quality assurance for the executable test case.},
  affiliation = {Computer Systems & Telematics, Freie Universität Berlin, Takustr.
	9, 14195 Berlin, Germany},
  booktitle = {Model Driven Engineering Languages and Systems},
  isbn = {978-3-540-87874-2},
  keyword = {Computer Science},
  owner = {daniel},
  timestamp = {2011.11.06},
  url = {http://dx.doi.org/10.1007/978-3-540-87875-9_52}
}

@INBOOK{springerlink:10.1007/978-3-540-44995-9_11,
  pages = {38-82},
  title = {Implementation Issues in Product Line Scoping},
  publisher = {Springer Berlin / Heidelberg},
  year = {2000},
  editor = {Frakes, William},
  author = {Schmid, Klaus and Gacek, Cristina},
  volume = {1844},
  series = {Lecture Notes in Computer Science},
  note = {10.1007/978-3-540-44995-9_11},
  abstract = {Often product line engineering is treated similar to the waterfall
	model in traditional software engineering, i.e., the different phases
	(scoping, analysis, architecting, implementation) are treated as
	if they could be clearly separated and would follow each other in
	an ordered fashion. However, in practice strong interactions between
	the individual phases become apparent. In particular, how implementation
	is done has a strong impact on economic aspects of the project and
	thus how to adequately plan it. Hence, assessing these relationships
	adequately in the beginning has a strong impact on performing a product
	line project right.},
  affiliation = {Fraunhofer Institute for Experimental Software Engineering (IESE)
	Sauerwiesen 6, D-67661 Kaiserslautern, Germany},
  booktitle = {Software Reuse: Advances in Software Reusability},
  isbn = {978-3-540-67696-6},
  keyword = {Computer Science},
  owner = {daniel},
  timestamp = {2011.11.06},
  url = {http://dx.doi.org/10.1007/978-3-540-44995-9_11}
}

@INBOOK{springerlink:10.1007/11663430_25,
  pages = {237-246},
  title = {Workshop 9 Summary},
  publisher = {Springer Berlin / Heidelberg},
  year = {2006},
  editor = {Bruel, Jean-Michel},
  author = {Schmidt, Douglas and Nechypurenko, Andrey and Wuchner, Egon},
  volume = {3844},
  series = {Lecture Notes in Computer Science},
  note = {10.1007/11663430_25},
  abstract = {Software product-lines are an important technology for meeting the
	growing demand for highly customized – yet reusable – solutions.
	Commonality-variability analysis (CVA) is a well-known approach to
	address the challenges of software product-line development. The
	goal of CVA is to identify (1) what aspects of a software system
	are stable across multiple variants or over time, (2) what aspects
	of a software system vary across multiple variants or over time,
	and (3) the development techniques that best address specific commonalities
	and their variabilities, e.g., to allow substitution of custom variable
	implementations via a common interface. Model-driven development
	(MDD) provides effective techniques for documenting and conveying
	the results of a CVA by combining • Metamodeling , which defines
	type systems that precisely express key abstract syntax characteristics
	and static semantic constraints associated with product-lines for
	particular application domains, such as software defined radios,
	avionics mission computing, and inventory tracking. • Domain-specific
	modeling languages (DSMLs) , which provide programming notations
	that are guided by and extend metamodels to formalize the process
	of specifying product-line structure, behavior, and requirements
	in a domain. • Model transformations and code generators , which
	ensure the consistency of product-line implementations with analysis
	information associated with functional and quality of service (QoS)
	requirements captured by structural and behavioral models. Key advantages
	of using MDD in conjunction with CVA are (1) rigorously capturing
	the key roles and responsibilities in a CVA and (2) helping automate
	repetitive tasks that must be accomplished for each product instance.
	Often, however, new customer requirements invalidate the results
	of earlier CVAs, such that a CVA and its derived meta-models, DSMLs,
	and generators must be modified invasively and intrusively to reflect
	these new requirements.},
  affiliation = {Vanderbilt University, Nashville, TN USA},
  booktitle = {Satellite Events at the MoDELS 2005 Conference},
  isbn = {978-3-540-31780-7},
  keyword = {Computer Science},
  owner = {daniel},
  timestamp = {2011.11.06},
  url = {http://dx.doi.org/10.1007/11663430_25}
}

@INBOOK{springerlink:10.1007/978-3-540-30175-2_13,
  pages = {239-255},
  title = {A Unification of Inheritance and Automatic Program Specialization},
  publisher = {Springer Berlin / Heidelberg},
  year = {2004},
  editor = {Karsai, Gabor and Visser, Eelco},
  author = {Schultz, Ulrik},
  volume = {3286},
  series = {Lecture Notes in Computer Science},
  note = {10.1007/978-3-540-30175-2_13},
  abstract = {The object-oriented style of programming facilitates program adaptation
	and enhances program genericness, but at the expense of efficiency.
	Automatic program specialization can be used to generate specialized,
	efficient implementations for specific scenarios, but requires the
	program to be structured appropriately for specialization and is
	yet another new concept for the programmer to understand and apply.
	We have unified automatic program specialization and inheritance
	into a single concept, and implemented this approach in a modified
	version of Java named JUST. When programming in JUST, inheritance
	is used to control the automatic application of program specialization
	to class members during compilation to obtain an efficient implementation.
	This paper presents the language JUST, which integrates object-oriented
	concepts, block structure, and techniques from automatic program
	specialization to provide both a generative programming language
	where object-oriented designs can be efficiently implemented and
	a simple yet powerful automatic program specializer for an object-oriented
	language.},
  affiliation = {DAIMI/ISIS, University of Aarhus, Denmark},
  booktitle = {Generative Programming and Component Engineering},
  isbn = {978-3-540-23580-4},
  keyword = {Computer Science},
  owner = {daniel},
  timestamp = {2011.11.06},
  url = {http://dx.doi.org/10.1007/978-3-540-30175-2_13}
}

@ARTICLE{springerlink:10.1007/s10990-011-9068-x,
  author = {Sculthorpe, Neil and Nilsson, Henrik},
  title = {Keeping calm in the face of change},
  journal = {Higher-Order and Symbolic Computation},
  year = {2010},
  volume = {23},
  pages = {227-271},
  note = {10.1007/s10990-011-9068-x},
  abstract = {Functional Reactive Programming (FRP) is an approach to reactive programming
	where systems are structured as networks of functions operating on
	signals (time-varying values). FRP is based on the synchronous data-flow
	paradigm and supports both (an approximation to) continuous-time
	and discrete-time signals (hybrid systems). What sets FRP apart from
	most other languages for similar applications is its support for
	systems with dynamic structure and for higher-order reactive constructs.
	This paper contributes towards advancing the state of the art of
	FRP implementation by studying the notion of signal change and change
	propagation in a setting of structurally dynamic networks of n -ary
	signal functions operating on mixed continuous-time and discrete-time
	signals. We first define an ideal denotational semantics (time is
	truly continuous) for this kind of FRP, along with temporal properties,
	expressed in temporal logic, of signals and signal functions pertaining
	to change and change propagation. Using this framework, we then show
	how to reason about change; specifically, we identify and justify
	a number of possible optimisations, such as avoiding recomputation
	of unchanging values. Note that due to structural dynamism, and the
	fact that the output of a signal function may change because time
	is passing even if the input is unchanging, the problem is significantly
	more complex than standard change propagation in networks with static
	structure.},
  affiliation = {School of Computer Science, University of Nottingham, Nottingham,
	UK},
  issn = {1388-3690},
  issue = {2},
  keyword = {Computer Science},
  owner = {daniel},
  publisher = {Springer Netherlands},
  timestamp = {2011.11.06},
  url = {http://dx.doi.org/10.1007/s10990-011-9068-x}
}

@ARTICLE{springerlink:10.1007/s10270-010-0181-9,
  author = {Sen, Sagar and Moha, Naouel and Mahé, Vincent and Barais, Olivier
	and Baudry, Benoit and Jézéquel, Jean-Marc},
  title = {Reusable model transformations},
  journal = {Software and Systems Modeling},
  pages = {1-15},
  note = {10.1007/s10270-010-0181-9},
  abstract = {Model transformations written for an input metamodel may often apply
	to other metamodels that share similar concepts. For example, a transformation
	written to refactor Java models can be applicable to refactoring
	UML class diagrams as both languages share concepts such as classes,
	methods, attributes, and inheritance. Deriving motivation from this
	example, we present an approach to make model transformations reusable
	such that they function correctly across several similar metamodels.
	Our approach relies on these principal steps: (1) We analyze a transformation
	to obtain an effective subset of used concepts. We prune the input
	metamodel of the transformation to obtain an effective input metamodel
	containing the effective subset. The effective input metamodel represents
	the true input domain of transformation. (2) We adapt a target input
	metamodel by weaving it with aspects such as properties derived from
	the effective input metamodel. This adaptation makes the target metamodel
	a subtype of the effective input metamodel. The subtype property
	ensures that the transformation can process models conforming to
	the target input metamodel without any change in the transformation
	itself. We validate our approach by adapting well known refactoring
	transformations ( Encapsulate Field , Move Method , and Pull Up Method
	) written for an in-house domain-specific modeling language (DSML)
	to three different industry standard metamodels (Java, MOF, and UML).},
  affiliation = {INRIA Rennes, Bretagne Atlantique/IRISA, Université Rennes 1, Triskell
	Team, Campus de Beaulieu, 35042 Rennes Cedex, France},
  issn = {1619-1366},
  keyword = {Computer Science},
  owner = {daniel},
  publisher = {Springer Berlin / Heidelberg},
  timestamp = {2011.11.06},
  url = {http://dx.doi.org/10.1007/s10270-010-0181-9}
}

@INBOOK{springerlink:10.1007/978-3-540-69384-0_21,
  pages = {154-163},
  title = {Functional Meta-programming for Parallel Skeletons},
  publisher = {Springer Berlin / Heidelberg},
  year = {2008},
  editor = {Bubak, Marian and van Albada, Geert and Dongarra, Jack and Sloot,
	Peter},
  author = {Serot, Jocelyn and Falcou, Joel},
  volume = {5101},
  series = {Lecture Notes in Computer Science},
  note = {10.1007/978-3-540-69384-0_21},
  abstract = {We describe the implementation in M eta O caml of a small domain specific
	language for skeleton-based parallel programming. We show how the
	meta-programming facilities offered by this language make it possible
	to virtually eliminate the run-time overhead for the resulting programs,
	compared to a hand-crafted, low-level implementation.},
  affiliation = {UMR 66O2 CNRS/U. Blaise Pascal LASMEA Campus des Cézeaux F-63177
	Aubière France},
  booktitle = {Computational Science – ICCS 2008},
  isbn = {978-3-540-69383-3},
  keyword = {Computer Science},
  owner = {daniel},
  timestamp = {2011.11.06},
  url = {http://dx.doi.org/10.1007/978-3-540-69384-0_21}
}

@INBOOK{springerlink:10.1007/978-3-540-72901-3_13,
  pages = {172-183},
  title = {Adopting Model Driven Development in a Large Financial Organization},
  publisher = {Springer Berlin / Heidelberg},
  year = {2007},
  editor = {Akehurst, David and Vogel, Régis and Paige, Richard},
  author = {Shirtz, Dov and Kazakov, Michael and Shaham-Gafni, Yael},
  volume = {4530},
  series = {Lecture Notes in Computer Science},
  note = {10.1007/978-3-540-72901-3_13},
  abstract = {Two years ago the IT Division of a large financial organization in
	Israel made a strategic decision to adopt Model Driven Development
	as its major development methodology. This decision was based on
	assessing the results of several pilot projects that had run during
	the previous year using this methodology. The QA Department that
	was the main advocate of this move took upon itself to lead the adoption
	effort. In this paper we report on the process of adopting Model
	Driven Development in the IT Division of the financial organization,
	from inception to successful maturation. We provide details on the
	methodology, models and tools, and describe the challenges, benefits,
	and lessons learnt.},
  affiliation = {Hanegev 11, Tel Aviv Israel Israel},
  booktitle = {Model Driven Architecture- Foundations and Applications},
  isbn = {978-3-540-72900-6},
  keyword = {Computer Science},
  owner = {daniel},
  timestamp = {2011.11.06},
  url = {http://dx.doi.org/10.1007/978-3-540-72901-3_13}
}

@INBOOK{springerlink:10.1007/978-3-540-78139-4_46,
  pages = {520-531},
  title = {Language-Driven Development of Web-Based Learning Applications},
  publisher = {Springer Berlin / Heidelberg},
  year = {2008},
  editor = {Leung, Howard and Li, Frederick and Lau, Rynson and Li, Qing},
  author = {Sierra, José-Luis and Fernández-Manjón, Baltasar and Fernández-Valmayor,
	Alfredo},
  volume = {4823},
  series = {Lecture Notes in Computer Science},
  note = {10.1007/978-3-540-78139-4_46},
  abstract = {In this paper we propose a language-driven approach for the high-level
	design of web-based learning applications. In our approach we define
	a domain-specific language that characterizes the key application
	aspects. Then we assign a suitable operational semantics to this
	language, and we keep it independent of low-level implementation
	details such as interaction / presentation or database updating.
	The resulting design can be easily implemented using the model-view-controller
	pattern that is very well supported by standard implementation technologies.
	In addition, these language-driven designs also allow for rapid prototyping,
	exploration and early discovery of application features, as well
	as for rational collaboration processes between instructors and developers.
	We exemplify our approach with a Socratic Tutoring System.},
  affiliation = {Universidad, Complutense de Madrid Dpto. Ingeniería del Software
	e Inteligencia Artificial. Fac. Informática C/ Profesor José García
	Santesmases s/n 28040 Madrid Spain},
  booktitle = {Advances in Web Based Learning – ICWL 2007},
  isbn = {978-3-540-78138-7},
  keyword = {Computer Science},
  owner = {daniel},
  timestamp = {2011.11.06},
  url = {http://dx.doi.org/10.1007/978-3-540-78139-4_46}
}

@ARTICLE{springerlink:10.1007/s10664-006-6401-9,
  author = {Sinha, Avik and Smidts, Carol},
  title = {An experimental evaluation of a higher-ordered-typed-functional specification-based
	test-generation technique},
  journal = {Empirical Software Engineering},
  year = {2006},
  volume = {11},
  pages = {173-202},
  note = {10.1007/s10664-006-6401-9},
  abstract = {HOTTest is a model based test automation technique of software systems
	based on models of the system described using HaskellDB. HaskellDB
	is an embedded domain specific language derived from Haskell. HOTTest
	enforces a systematic abstraction process and exploits system invariants
	for automatically producing test cases for domain specific requirements.
	Use of functional languages for system modeling is a new concept
	and hence HOTTest is subject to concerns of usability, like any other
	new technique. Also, the syntax and the declarative style of Haskell
	based languages make them difficult to learn. Similar concerns can
	be raised for HOTTest as it shares the same syntax with Haskell.
	In this paper we describe an experiment designed to study the usability
	of HOTTest and to compare it with existing model based test design
	techniques. The results show that HOTTest is more usable than the
	traditional technique and demonstrate that the test suites produced
	by HOTTest are more effective and efficient than those generated
	using the traditional model based test design technique.},
  affiliation = {IBM TJ Watson Research Center Hawthrone New York USA Hawthrone New
	York USA},
  issn = {1382-3256},
  issue = {2},
  keyword = {Computer Science},
  owner = {daniel},
  publisher = {Springer Netherlands},
  timestamp = {2011.11.06},
  url = {http://dx.doi.org/10.1007/s10664-006-6401-9}
}

@INBOOK{springerlink:10.1007/978-3-540-75912-6_22,
  pages = {298-310},
  title = {Olympic Agents},
  publisher = {Springer Berlin / Heidelberg},
  year = {2007},
  editor = {Draheim, Dirk and Weber, Gerald},
  author = {Skarmeas, Nikolaos and Loverdos, Christos and Tsiara, Katerina and
	Bassakidis, Alexandros and Tzoumas, Aris and Livas, Dimitris},
  volume = {4473},
  series = {Lecture Notes in Computer Science},
  note = {10.1007/978-3-540-75912-6_22},
  abstract = {We present an agent-oriented middle-tier architecture deployed during
	the realisation of the Athens 2004 Olympics results internet broadcasting.
	The system involved the online processing of messages (XML in nature)
	and their publishing to the www.athens2004.com internet site. Those
	messages were containing the Games intermediate and final results
	and were originated from the Olympic venues. For the accomplishment
	of this task a number of systems and applications needed to be integrated.
	Also the domain posed some unique problems regarding the fact that
	for the first time in the history of the Games a real time approach
	for broadcasting results was deployed and furthermore due to the
	reliability and performance requirements of the system. Various enterprise
	application integration patterns were used in conjunction with an
	agent oriented design approach. Asynchronous intercommunicating agents
	were deployed for realizing the architectural components of the system.},
  affiliation = {Avaca Technologies S.A., L. Katsoni 40, Athens, GR-114 71 Greece},
  booktitle = {Trends in Enterprise Application Architecture},
  isbn = {978-3-540-75911-9},
  keyword = {Computer Science},
  owner = {daniel},
  timestamp = {2011.11.06},
  url = {http://dx.doi.org/10.1007/978-3-540-75912-6_22}
}

@INBOOK{springerlink:10.1007/BFb0054107,
  pages = {550-570},
  title = {Implementing layered designs with mixin layers},
  publisher = {Springer Berlin / Heidelberg},
  year = {1998},
  editor = {Jul, Eric},
  author = {Smaragdakis, Yannis and Batory, Don},
  volume = {1445},
  series = {Lecture Notes in Computer Science},
  note = {10.1007/BFb0054107},
  abstract = {Mixin layers are a technique for implementing layered object-oriented
	designs (e.g., collaboration-based designs). Mixin layers are similar
	to abstract subclasses (mixin classes) but scaled to a multiple-class
	granularity. We describe mixin layers from a programming language
	viewpoint, discuss checking the consistency of a mixin layer composition,
	and analyze the language support issues involved.},
  affiliation = {The University of Texas at Austin Department of Computer Sciences
	78712 Austin Texas 78712 Austin Texas},
  booktitle = {ECOOP’98 — Object-Oriented Programming},
  isbn = {978-3-540-64737-9},
  keyword = {Computer Science},
  owner = {daniel},
  timestamp = {2011.11.06},
  url = {http://dx.doi.org/10.1007/BFb0054107}
}

@ARTICLE{springerlink:10.1007/s11042-010-0478-2,
  author = {Soares, Luiz and Rodrigues, Rogério and Cerqueira, Renato and Barbosa,
	Simone},
  title = {Variable and state handling in NCL},
  journal = {Multimedia Tools and Applications},
  year = {2010},
  volume = {50},
  pages = {465-489},
  note = {10.1007/s11042-010-0478-2},
  abstract = {Most time-based declarative languages have limited support for variable
	definition and manipulation, which causes developers to resort to
	imperative languages. However, a declarative language should provide
	a variable handling model sufficiently rich to describe a wide range
	of interactive applications, avoiding, as much as possible, the help
	of an imperative scripting language. On the other hand, the declarative
	simplicity should not be lost, leaving for the imperative objects
	more complex manipulations, with the necessary care to avoid any
	impact in the application’s temporal graph. Based on this principle,
	variables and the presentation state are handled by NCL and Ginga-NCL,
	as discussed in this paper. NCL is the declarative language of the
	Brazilian Terrestrial Digital TV System (SBTVD) supported by its
	middleware called Ginga. NCL and Ginga-NCL are part of ISDB standards
	and also of ITU-T Recommendations for IPTV services.},
  affiliation = {Pontifícia Universidade Católica do Rio de Janeiro Rua Marquês
	de São Vicente 225 22451-900 Rio de Janeiro RJ Brazil},
  issn = {1380-7501},
  issue = {3},
  keyword = {Computer Science},
  owner = {daniel},
  publisher = {Springer Netherlands},
  timestamp = {2011.11.06},
  url = {http://dx.doi.org/10.1007/s11042-010-0478-2}
}

@INBOOK{springerlink:10.1007/978-3-540-25932-9_5,
  pages = {1270-1270},
  title = {An Agent-Based Domain Specific Framework for Rapid Prototyping of
	Applications in Evolutionary Biology},
  publisher = {Springer Berlin / Heidelberg},
  year = {2004},
  editor = {Leite, João and Omicini, Andrea and Sterling, Leon and Torroni,
	Paolo},
  author = {Son, Tran and Pontelli, Enrico and Ranjan, Desh and Milligan, Brook
	and Gupta, Gopal},
  volume = {2990},
  series = {Lecture Notes in Computer Science},
  note = {10.1007/978-3-540-25932-9_5},
  abstract = {In this paper we present a brief overview of the ΦLOG project, aimed
	at the development of a domain specific framework for the rapid prototyping
	of applications in evolutionary biology. This includes the development
	of a domain specific language, called ΦLOG, and an agent-based implementation
	for the monitoring and execution of ΦLOG’s programs. A ΦLOG program
	– representing an intended application from an evolutionary biologist
	– is a specification of what to do to achieve her/his goal. The
	execution and monitoring component of our system will automatically
	figure out how to do it. We achieve that by viewing the available
	bioinformatic tools and data repositories as web services and casting
	the problem of execution of a sequence of bioinformatic services
	(possibly with loops, branches, and conditionals, specified by biologists)
	as the web services composition problem.},
  affiliation = {Department of Computer Science, New Mexico State University},
  booktitle = {Declarative Agent Languages and Technologies},
  isbn = {978-3-540-22124-1},
  keyword = {Computer Science},
  owner = {daniel},
  timestamp = {2011.11.06},
  url = {http://dx.doi.org/10.1007/978-3-540-25932-9_5}
}

@ARTICLE{springerlink:10.1007/s11334-010-0139-7,
  author = {Sprinkle, Jonathan and Eames, Brandon},
  title = {Time-triggered buffers for event-based middleware systems},
  journal = {Innovations in Systems and Software Engineering},
  year = {2011},
  volume = {7},
  pages = {9-22},
  note = {10.1007/s11334-010-0139-7},
  abstract = {Application developers utilizing event-based middleware have sought
	to leverage domain-specific modeling for the advantages of intuitive
	specification, code synthesis, and support for design evolution.
	For legacy and cyber-physical systems, the use of event-based middleware
	may mean that changes in computational platform can result anomalous
	system behavior, due to the presence of implicit temporal dependencies.
	These anomalies are a function not of the component implementation,
	but of the model of computation employed for supporting system composition.
	In order to address these behavioral anomalies, the paper presents
	an approach where time-based blocks are inserted into the system
	to account for the temporal dependencies. An advantage of capturing
	the system composition in a domain-specific modeling language is
	the ability to efficiently refactor an application to include time-triggered,
	event-based schedulers. This paper describes how an existing event-based
	component topology can be modified to permit a time-triggered model
	of computation, with no changes to the existing component software.
	Further, the time-triggered components can be deployed alongside
	standard publish/subscribe methodologies. This strategy is beneficial
	to the maintenance of existing legacy systems upon upgrade, since
	the current operational mode could be maintained with minimal changes
	to the legacy software even under changes to the target platform
	which alter execution speed. These time-triggered layers are discussed
	in three permutations: fully triggered, start triggered, and release
	triggered. A discussion is provided regarding the limitations of
	each approach, and a brief example is given. The example shows how
	to apply these triggering approaches without the modification of
	existing components, but instead through the insertion of triggered
	buffers between legacy components.},
  affiliation = {Department of Electrical and Computer Engineering, University of Arizona,
	1230 E. Speedway Blvd., Bldg. #104, Tucson, AZ 85721-0104, USA},
  issn = {1614-5046},
  issue = {1},
  keyword = {Computer Science},
  owner = {daniel},
  publisher = {Springer London},
  timestamp = {2011.11.06},
  url = {http://dx.doi.org/10.1007/s11334-010-0139-7}
}

@INBOOK{springerlink:10.1007/11880240_5,
  pages = {57-72},
  title = {Adopting Model Driven Software Development in Industry – A Case
	Study at Two Companies},
  publisher = {Springer Berlin / Heidelberg},
  year = {2006},
  editor = {Nierstrasz, Oscar and Whittle, Jon and Harel, David and Reggio, Gianna},
  author = {Staron, Miroslaw},
  volume = {4199},
  series = {Lecture Notes in Computer Science},
  note = {10.1007/11880240_5},
  abstract = {Model Driven Software Development (MDD) is a vision of software development
	where models play a core role as primary development artifacts. Its
	industrial adoption depends on several factors, including possibilities
	of increasing productivity and quality by using models. In this paper
	we present a case study of two companies willing to adopt the principles
	of MDD. One of the companies is in the process of adopting MDD while
	the other withdrew from its initial intentions. The results provide
	insights into the differences in requirements for MDD in these organizations,
	factors determining the decision upon adoption and the potentially
	suitable modeling notation for the purpose of each of the companies.
	The analysis of the results from this case study, supported by the
	conclusions from a previous case study of a successful MDD adoption,
	show also which conditions should be fulfilled in order to increase
	the chances of succeeding in adopting MDD.},
  affiliation = {Department of Applied IT, Software Engineering and Management, IT
	University in Göteborg, Box 8718, SE-402 75 Göteborg, Sweden},
  booktitle = {Model Driven Engineering Languages and Systems},
  isbn = {978-3-540-45772-5},
  keyword = {Computer Science},
  owner = {daniel},
  timestamp = {2011.11.06},
  url = {http://dx.doi.org/10.1007/11880240_5}
}

@ARTICLE{springerlink:10.1007/s10257-011-0172-6,
  author = {Strecker, Stefan and Frank, Ulrich and Heise, David and Kattenstroth,
	Heiko},
  title = {\&lt;span style="font-variant:small-caps"\&gt;\&lt;small\&gt;MetricM\&lt;/small\&gt;\&lt;/span\&gt;:
	a modeling method in support of the reflective design and use of
	performance measurement systems},
  journal = {Information Systems and E-Business Management},
  pages = {1-36},
  note = {10.1007/s10257-011-0172-6},
  abstract = {Performance indicators play a key role in management practice. The
	existence of a coherent and consistent set of performance indicators
	is widely regarded as a prerequisite to making informed decisions
	in line with set objectives of the firm. Designing such a system
	of performance indicators requires a profound understanding of the
	relations between financial and non-financial metrics, organizational
	goals, aspired decision scenarios, and the relevant organizational
	context—including subtleties resulting from implicit assumptions
	and hidden agendas potentially leading to dysfunctional consequences
	connected with the ill-informed use of performance indicators. In
	this paper, we investigate whether a domain-specific modeling method
	can address requirements essential to the reflective design of performance
	measurement systems, and which structural and procedural features
	such a method entails. The research follows a design research process
	in which we describe a research artifact, and evaluate it to assess
	whether it meets intended goals and domain requirements. In the paper,
	we specify design goals, requirements and assumptions underlying
	the method construction, discuss the structural specification of
	the method and its design rationale, and provide an initial method
	evaluation. The results indicate that the modeling method satisfies
	the requirements of the performance measurement domain, and that
	such a method contributes to the reflective definition and interpretation
	of performance measurement systems.},
  affiliation = {Information Systems and Enterprise Modelling Research Group, Institute
	for Computer Science and Business Information Systems, University
	of Duisburg-Essen, Universitaetsstr. 9, 45141 Essen, Germany},
  issn = {1617-9846},
  keyword = {Computer Science},
  owner = {daniel},
  publisher = {Springer Berlin / Heidelberg},
  timestamp = {2011.11.06},
  url = {http://dx.doi.org/10.1007/s10257-011-0172-6}
}

@INBOOK{springerlink:10.1007/11901914_38,
  pages = {523-537},
  title = {Model-Based Tool-Chain Infrastructure for Automated Analysis of Embedded
	Systems},
  publisher = {Springer Berlin / Heidelberg},
  year = {2006},
  editor = {Graf, Susanne and Zhang, Wenhui},
  author = {Su, Hang and Hemingway, Graham and Chen, Kai and Koo, T.},
  volume = {4218},
  series = {Lecture Notes in Computer Science},
  note = {10.1007/11901914_38},
  abstract = {In many safety-critical applications of embedded systems, the system
	dynamics exhibits hybrid behaviors. To enable automatic analysis
	of these embedded systems, many analysis tools have been developed
	based on hybrid automata model. These tools are constructed by their
	own domain-specific modeling languages (DSMLs) but they are different
	in various aspects. To enable meaningful semantic interpretation
	of DSMLs, we propose an infrastructure for semantic anchoring that
	facilitates the transformational specification of DSML semantics.
	In the semantic anchoring infrastructure, the semantics of a DSML
	can be anchored to a well-defined semantic unit, which captures the
	operational semantics of hybrid automaton, via model transformation.
	The Abstract State Machine (ASM) is used as the underlying formal
	framework for the semantic unit. The semantics of a DSML is defined
	by specifying the transformation between the abstract syntax metamodel
	of the DSML and that of the semantic unit. The infrastructure can
	also enable model exchange among DSMLs while referring to the common
	semantic unit. Hence, hybrid automata based DSMLs can be integrated
	to form a meaningful tool chain by deploying this proposed infrastructure.
	In this paper, we demonstrate how effective the tool-chain infrastructure
	is by considering a practical case study involving the hybrid automata
	DSMLs, HyVisual and ReachLab.},
  affiliation = {Department of Electrical Engineering and Computer Science, Vanderbilt
	University, Nashville, TN USA},
  booktitle = {Automated Technology for Verification and Analysis},
  isbn = {978-3-540-47237-7},
  keyword = {Computer Science},
  owner = {daniel},
  timestamp = {2011.11.06},
  url = {http://dx.doi.org/10.1007/11901914_38}
}

@INBOOK{springerlink:10.1007/978-3-540-87875-9_9,
  pages = {128-142},
  title = {The Future of Train Signaling},
  publisher = {Springer Berlin / Heidelberg},
  year = {2008},
  editor = {Czarnecki, Krzysztof and Ober, Ileana and Bruel, Jean-Michel and
	Uhl, Axel and Völter, Markus},
  author = {Svendsen, Andreas and Olsen, Gøran and Endresen, Jan and Moen, Thomas
	and Carlson, Erik and Alme, Kjell-Joar and Haugen, Øystein},
  volume = {5301},
  series = {Lecture Notes in Computer Science},
  note = {10.1007/978-3-540-87875-9_9},
  abstract = {Producing the source code for a railway interlocking system based
	on the description of a station has traditionally been a multistage
	manual process. We show how this process can be automated and made
	less error-prone by introducing model-driven development (MDD). This
	paper addresses the experience of developing a Domain Specific Language
	(DSL) to describe railway stations, Train Control Language (TCL),
	and tools to support this language. In the railroad domain where
	there are extreme safety requirements, it is essential to show that
	consistency and completeness can be assured. We address how the model
	is used to generate several different representations for different
	purposes. We look at advantages and challenges with our approach,
	and we discuss improvements to existing technologies to support our
	case better.},
  affiliation = {SINTEF, Forskningsveien 1, Oslo, Norway},
  booktitle = {Model Driven Engineering Languages and Systems},
  isbn = {978-3-540-87874-2},
  keyword = {Computer Science},
  owner = {daniel},
  timestamp = {2011.11.06},
  url = {http://dx.doi.org/10.1007/978-3-540-87875-9_9}
}

@INBOOK{springerlink:10.1007/3-540-45351-2_3,
  pages = {4-4},
  title = {Embedded Software and Systems: Challenges and Approaches},
  publisher = {Springer Berlin / Heidelberg},
  year = {2001},
  editor = {Di Benedetto, Maria and Sangiovanni-Vincentelli, Alberto},
  author = {Sztipanovits, Janos},
  volume = {2034},
  series = {Lecture Notes in Computer Science},
  note = {10.1007/3-540-45351-2_3},
  abstract = {One of the most pervasive applications of computing is information
	processing tightly integrated with physical processes. Embedded computing
	rapidly takes over the role of being a universal integrator for physical
	systems. This trend is based on a fundamental technical reason: digital
	information processing is uniquely suitable for controlling and implementing
	complex interactions among physical system components. The expanding
	integration role of computing challenges the state-of-the-art in
	both system and software design. First, the traditional separation
	of related design disciplines is not maintainable. Predictability
	of the design requires integrated modeling and analysis of physical
	processes and information processing. Second, the narrow focus of
	current software technology on functional composition is not sufficient.
	Essential physical properties of embedded computing systems, such
	as timing, noise or fault behavior, cut across functional boundaries,
	which makes software design and implementation extremely hard and
	expensive. Third, design technologies, which are based on the modeling
	and analysis of systems with static structure, are becoming inadequate.
	Although networked embedded computing combined with inexpensive MEMS-based
	sensors and actuators make the construction of large physical systems
	with continuously changing structure and physical interactions feasible,
	their design is an open challenge. The first part of the talk provides
	an overview of the unique challenges and new research directions
	in embedded system and software design. The second part of the talk
	describes the Model-Integrated Computing (MIC) approach to address
	some of these challenges. Using the design of structurally adaptive
	embedded processing systems as example, the following three topics
	will be covered: 1. Methods and tools for the specification and construction
	of multiple-view, domain-specific modeling languages and integrated
	design environments. The MIC approach is based on the application
	of meta-modeling, meta-programmable modeling tools and model translators
	that form the foundation for composable design environments. 2. Automated
	synthesis of processing architectures satisfying multiple functional
	and physical constraints. The method described is based on symbolic
	constraint satisfaction. 3. Application of generative programming
	techniques with special emphasis on model-based software generators.},
  affiliation = {Vanderbilt University Department of Electrical Engineering and Computer
	Science Nashville TN USA},
  booktitle = {Hybrid Systems: Computation and Control},
  isbn = {978-3-540-41866-5},
  keyword = {Computer Science},
  owner = {daniel},
  timestamp = {2011.11.06},
  url = {http://dx.doi.org/10.1007/3-540-45351-2_3}
}

@INBOOK{springerlink:10.1007/978-3-540-87875-9_35,
  pages = {490-504},
  title = {Integrating Performance Analysis in the Model Driven Development
	of Software Product Lines},
  publisher = {Springer Berlin / Heidelberg},
  year = {2008},
  editor = {Czarnecki, Krzysztof and Ober, Ileana and Bruel, Jean-Michel and
	Uhl, Axel and Völter, Markus},
  author = {Tawhid, Rasha and Petriu, Dorina},
  volume = {5301},
  series = {Lecture Notes in Computer Science},
  note = {10.1007/978-3-540-87875-9_35},
  abstract = {The paper proposes to integrate performance analysis in the early
	phases of the model-driven development process for Software Product
	Lines (SPL). We start by adding generic performance annotations to
	the UML model representing the set of core reusable SPL assets. The
	annotations are generic and use the MARTE Profile recently adopted
	by OMG. A first model transformation realized in the Atlas Transformation
	Language (ATL), which is the focus of this paper, derives the UML
	model of a specific product with concrete MARTE performance annotations
	from the SPL model. A second transformation generates a Layered Queueing
	Network performance model for the given product by applying an existing
	transformation approach named PUMA, developed in previous work. The
	proposed technique is illustrated with an e-commerce case study that
	models the commonality and variability in both structural and behavioural
	SPL views. A product is derived and the performance of two design
	alternatives is compared.},
  affiliation = {School of Computer Science, Carleton University, Ottawa, Canada},
  booktitle = {Model Driven Engineering Languages and Systems},
  isbn = {978-3-540-87874-2},
  keyword = {Computer Science},
  owner = {daniel},
  timestamp = {2011.11.06},
  url = {http://dx.doi.org/10.1007/978-3-540-87875-9_35}
}

@ARTICLE{springerlink:10.1023/A:1010078412711,
  author = {Thibault, Scott and Consel, Charles and Lawall, Julia L. and Marlet,
	Renaud and Muller, Gilles},
  title = {Static and Dynamic Program Compilation by Interpreter Specialization},
  journal = {Higher-Order and Symbolic Computation},
  year = {2000},
  volume = {13},
  pages = {161-178},
  note = {10.1023/A:1010078412711},
  abstract = {Interpretation and run-time compilation techniques are increasingly
	important because they can support heterogeneous architectures, evolving
	programming languages, and dynamically-loaded code. Interpretation
	is simple to implement, but yields poor performance. Run-time compilation
	yields better performance, but is costly to implement. One way to
	preserve simplicity but obtain good performance is to apply program
	specialization to an interpreter in order to generate an efficient
	implementation of the program automatically. Such specialization
	can be carried out at both compile time and run time.},
  issn = {1388-3690},
  issue = {3},
  keyword = {Computer Science},
  owner = {daniel},
  publisher = {Springer Netherlands},
  timestamp = {2011.11.06},
  url = {http://dx.doi.org/10.1023/A:1010078412711}
}

@INBOOK{springerlink:10.1007/11896548_46,
  pages = {613-624},
  title = {NeuroQL: A Domain-Specific Query Language for Neuroscience Data},
  publisher = {Springer Berlin / Heidelberg},
  year = {2006},
  editor = {Grust, Torsten and Höpfner, Hagen and Illarramendi, Arantza and
	Jablonski, Stefan and Mesiti, Marco and Müller, Sascha and Patranjan,
	Paula-Lavinia and Sattler, Kai-Uwe and Spiliopoulou, Myra and Wijsen,
	Jef},
  author = {Tian, Hao and Sunderraman, Rajshekhar and Calin-Jageman, Robert and
	Yang, Hong and Zhu, Ying and Katz, Paul},
  volume = {4254},
  series = {Lecture Notes in Computer Science},
  note = {10.1007/11896548_46},
  abstract = {In this paper, we propose a domain-specific query language called
	NeuroQL for the neuroscience domain. NeuroQL is designed primarily
	for neuroinformatics database users and aims to enable users to directly
	interact with neuroscience databases in their professional concepts
	and terms with the help of a conceptual data model. NeuroQL is DBMS
	independent and can be translated into traditional query language
	such as SQL, OQL and XQuery. It integrates some object-oriented features,
	and supports neuron domain-specific data types and query operators,
	which can dynamically evolve when the underlying database schema
	evolves.},
  affiliation = {Department of Computer Science, Georgia State University, Atlanta,
	GA 30303, USA},
  booktitle = {Current Trends in Database Technology – EDBT 2006},
  isbn = {978-3-540-46788-5},
  keyword = {Computer Science},
  owner = {daniel},
  timestamp = {2011.11.06},
  url = {http://dx.doi.org/10.1007/11896548_46}
}

@INBOOK{springerlink:10.1007/978-3-540-88643-3_11,
  pages = {425-441},
  title = {Evolving a DSL Implementation},
  publisher = {Springer Berlin / Heidelberg},
  year = {2008},
  editor = {Lämmel, Ralf and Visser, Joost and Saraiva, João},
  author = {Tratt, Laurence},
  volume = {5235},
  series = {Lecture Notes in Computer Science},
  note = {10.1007/978-3-540-88643-3_11},
  abstract = {Domain Specific Languages (DSLs) are small languages designed for
	use in a specific domain. DSLs typically evolve quite radically throughout
	their lifetime, but current DSL implementation approaches are often
	clumsy in the face of such evolution. In this paper I present a case
	study of an DSL evolving in its syntax, semantics, and robustness,
	implemented in the Converge language. This shows how real-world DSL
	implementations can evolve along with changing requirements.},
  affiliation = {Bournemouth University Poole Dorset BH12 5BB United Kingdom},
  booktitle = {Generative and Transformational Techniques in Software Engineering
	II},
  isbn = {978-3-540-88642-6},
  keyword = {Computer Science},
  owner = {daniel},
  timestamp = {2011.11.06},
  url = {http://dx.doi.org/10.1007/978-3-540-88643-3_11}
}

@ARTICLE{springerlink:10.1007/s11334-009-0077-4,
  author = {Truşcan, Dragoş and Lundkvist, Torbjörn and Alanen, Marcus and
	Sandström, Kim and Porres, Ivan and Lilius, Johan},
  title = {MDE for SoC design},
  journal = {Innovations in Systems and Software Engineering},
  year = {2009},
  volume = {5},
  pages = {49-64},
  note = {10.1007/s11334-009-0077-4},
  abstract = {We employ the principles of model-driven engineering to assist the
	design of system-on-chip (SoC) architectures. As a concrete example,
	we look at the MICAS architecture, for which we propose a graphical
	specification language, defined via metamodeling techniques, that
	models the architecture at different abstraction levels. Model transformations
	are defined to support the refinement of MICAS specification towards
	implementation. In addition, several libraries are put in place,
	to enable reuse and automation throughout the design process. Tool
	support for editing the specifications, enforcing their consistency,
	and for running the transformations is provided via the Coral modeling
	framework. The approach shows that model-driven engineering can be
	seen as an enabler in providing computer-aided software engineering
	(CASE) tool support and automation for the development of SoC architectures.},
  affiliation = {Åbo Akademi University Department of Information Technologies Joukahaisenkatu
	3-5B 20520 Turku Finland},
  issn = {1614-5046},
  issue = {1},
  keyword = {Computer Science},
  owner = {daniel},
  publisher = {Springer London},
  timestamp = {2011.11.06},
  url = {http://dx.doi.org/10.1007/s11334-009-0077-4}
}

@INBOOK{springerlink:10.1007/3-540-44815-2_14,
  pages = {189-201},
  title = {Just When You Thought Your Little Language Was Safe: “Expression
	Templates” in Java},
  publisher = {Springer Berlin / Heidelberg},
  year = {2001},
  editor = {Butler, Greg and Jarzabek, Stan},
  author = {Veldhuizen, Todd},
  volume = {2177},
  series = {Lecture Notes in Computer Science},
  note = {10.1007/3-540-44815-2_14},
  abstract = {Template techniques in C++ allow a modest degree of generative programming
	: creating specialized code for specialized problems. This use of
	templates has been controversial; indeed,one of the oft-cited reasons
	for migrating to Java is that it provides a simpler language,free
	of complexities such as templates. The essence of generative programming
	in C++ is not templates — the language feature — but rather the
	underlying algorithms in the compiler (template instantiation) which
	unintentionally resemble an optimization called partial evaluation
	[ 12 , 18 ]. By devising a partial evaluator for Java,we reproduce
	some of the generative programming aspects of C++ templates,wit hout
	extending the Java language. The prototype compiler,called Lunar
	,is capable of doing “expression templates” in Java to optimize
	numerical array objects.},
  affiliation = {Indiana University Computer Science Department Extreme Computing Laboratory
	Bloomington Indiana 47405 USA},
  booktitle = {Generative and Component-Based Software Engineering},
  isbn = {978-3-540-42578-6},
  keyword = {Computer Science},
  owner = {daniel},
  timestamp = {2011.11.06},
  url = {http://dx.doi.org/10.1007/3-540-44815-2_14}
}

@INBOOK{springerlink:10.1007/978-3-540-88643-3_7,
  pages = {291-373},
  title = {WebDSL: A Case Study in Domain-Specific Language Engineering},
  publisher = {Springer Berlin / Heidelberg},
  year = {2008},
  editor = {Lämmel, Ralf and Visser, Joost and Saraiva, João},
  author = {Visser, Eelco},
  volume = {5235},
  series = {Lecture Notes in Computer Science},
  note = {10.1007/978-3-540-88643-3_7},
  abstract = {The goal of domain-specific languages (DSLs) is to increase the productivity
	of software engineers by abstracting from low-level boilerplate code.
	Introduction of DSLs in the software development process requires
	a smooth workflow for the production of DSLs themselves. This requires
	technology for designing and implementing DSLs, but also a methodology
	for using that technology. That is, a collection of guidelines, design
	patterns, and reusable DSL components that show developers how to
	tackle common language design and implementation issues. This paper
	presents a case study in domain-specific language engineering. It
	reports on a project in which the author designed and built WebDSL,
	a DSL for web applications with a rich data model, using several
	DSLs for DSL engineering: SDF for syntax definition and Stratego/XT
	for code generation. The paper follows the stages in the development
	of the DSL. The contributions of the paper are three-fold. (1) A
	tutorial in the application of the specific SDF and Stratego/XT technology
	for building DSLs. (2) A description of an incremental DSL development
	process. (3) A domain-specific language for web-applications with
	rich data models. The paper concludes with a survey of related approaches.},
  affiliation = {Delft University of Technology Software Engineering Research Group},
  booktitle = {Generative and Transformational Techniques in Software Engineering
	II},
  isbn = {978-3-540-88642-6},
  keyword = {Computer Science},
  owner = {daniel},
  timestamp = {2011.11.06},
  url = {http://dx.doi.org/10.1007/978-3-540-88643-3_7}
}

@INBOOK{springerlink:10.1007/11557432_37,
  pages = {492-506},
  title = {Using a Domain-Specific Language and Custom Tools to Model a Multi-tier
	Service-Oriented Application — Experiences and Challenges},
  publisher = {Springer Berlin / Heidelberg},
  year = {2005},
  editor = {Briand, Lionel and Williams, Clay},
  author = {Vokáč, Marek and Glattetre, Jens},
  volume = {3713},
  series = {Lecture Notes in Computer Science},
  note = {10.1007/11557432_37},
  abstract = {A commercial Customer Relationship Management application of approx.
	1.5 MLOC of C++ code is being reimplemented, in stages, as a service-oriented,
	multi-tier application in C# on Microsoft .NET. We have chosen to
	use a domain-specific language both to model the external service-oriented
	interfaces, and to manage the transition to the internal, object-oriented
	implementation. Generic UML constructs such as class diagrams do
	not capture enough semantics to model these concepts. By defining
	a UML Profile that incorporates the concepts we wish to model, we
	have in effect created a Domain-Specific Language for our application.
	The models are edited using Rational XDE, but we have substituted
	our own code generator. This generator is a relatively generic text-substitution
	engine, which takes a template text and performs substitutions based
	on the model. The generator uses reflection to convert the UML and
	Profile concepts into substitution tags, which are in turn used in
	the template text. In this way, we can translate the semantics of
	the model into executable code, WSDL or other formats in a flexible
	way. We have successfully used this approach on a prototype scale,
	and are now transitioning to full-scale development.},
  affiliation = {Simula Research Laboratory, P.O.Box 134, 1325 Lysaker, Norway},
  booktitle = {Model Driven Engineering Languages and Systems},
  isbn = {978-3-540-29010-0},
  keyword = {Computer Science},
  owner = {daniel},
  timestamp = {2011.11.06},
  url = {http://dx.doi.org/10.1007/11557432_37}
}

@INBOOK{springerlink:10.1007/978-3-540-70621-2_24,
  pages = {293-306},
  title = {Introducing a Change-Resistant Framework for the Development and
	Deployment of Evolving Applications},
  publisher = {Springer Berlin Heidelberg},
  year = {2008},
  editor = {Filipe, Joaquim and Shishkov, Boris and Helfert, Markus},
  author = {Voulalas, Georgios and Evangelidis, Georgios},
  volume = {10},
  series = {Communications in Computer and Information Science},
  note = {10.1007/978-3-540-70621-2_24},
  abstract = {Software development is an R&D intensive activity, dominated by human
	creativity and diseconomies of scale. Current efforts focus on design
	patterns, reusable components and forward-engineering mechanisms
	as the right next stage in cutting the Gordian knot of software.
	Model-driven development improves productivity by introducing formal
	models that can be understood by computers. Through these models
	the problems of portability, interoperability, maintenance, and documentation
	are also successfully addressed. However, the problem of evolving
	requirements, which is more prevalent within the context of business
	applications, additionally calls for efficient mechanisms that ensure
	consistency between models and code, and enable seamless and rapid
	accommodation of changes, without interrupting severely the operation
	of the deployed application. This paper introduces a framework that
	supports rapid development and deployment of evolving web-based applications,
	based on an integrated database schema. The proposed framework can
	be seen as an extension of the Model Driven Architecture targeting
	a specific family of applications.},
  affiliation = {University of Macedonia Department of Applied Informatics 156 Egnatia
	St. Thessaloniki Greece},
  booktitle = {Software and Data Technologies},
  isbn = {978-3-540-70621-2},
  keyword = {Computer Science},
  owner = {daniel},
  timestamp = {2011.11.06},
  url = {http://dx.doi.org/10.1007/978-3-540-70621-2_24}
}

@INBOOK{springerlink:10.1007/11557432_44,
  pages = {584-600},
  title = {Modeling Turnpike Frontend System: A Model-Driven Development Framework
	Leveraging UML Metamodeling and Attribute-Oriented Programming},
  publisher = {Springer Berlin / Heidelberg},
  year = {2005},
  editor = {Briand, Lionel and Williams, Clay},
  author = {Wada, Hiroshi and Suzuki, Junichi},
  volume = {3713},
  series = {Lecture Notes in Computer Science},
  note = {10.1007/11557432_44},
  abstract = {This paper describes and empirically evaluates a new model-driven
	development framework, called Modeling Turnpike (or mTurnpike). It
	allows developers to model and program domain-specific concepts (ideas
	and mechanisms specific to a particular business or technology domain)
	and to transform them to the final (compilable) source code. By leveraging
	UML metamodeling and attribute-oriented programming, mTurnpike provides
	an abstraction to represent domain-specific concepts at the modeling
	and programming layers simultaneously. The mTurnpike frontend system
	transforms domain-specific concepts from the modeling layer to programming
	layer, and vise versa, in a seamless manner. Its backend system combines
	domain-specific models and programs, and transforms them to the final
	(compilable) source code. This paper focuses on the frontend system
	of mTurnpike, and describes its design, implementation and performance
	implications. In order to demonstrate how to exploit mTurnpike in
	application development, this paper also shows a development process
	using an example DSL (domain specific language) to specify service-oriented
	distributed systems.},
  affiliation = {Department of Computer Science, University of Massachusetts, Boston},
  booktitle = {Model Driven Engineering Languages and Systems},
  isbn = {978-3-540-29010-0},
  keyword = {Computer Science},
  owner = {daniel},
  timestamp = {2011.11.06},
  url = {http://dx.doi.org/10.1007/11557432_44}
}

@INBOOK{springerlink:10.1007/11663430_43,
  pages = {357-358},
  title = {Modeling Turnpike: A Model-Driven Framework for Domain-Specific Software
	Development},
  publisher = {Springer Berlin / Heidelberg},
  year = {2006},
  editor = {Bruel, Jean-Michel},
  author = {Wada, Hiroshi and Suzuki, Jun},
  volume = {3844},
  series = {Lecture Notes in Computer Science},
  note = {10.1007/11663430_43},
  abstract = {This Ph.D. research investigates a generic model-driven development
	(MDD) framework that supports various domain-specific solutions (i.e.
	modeling, programming and development processes to directly deal
	with domain concepts), and empirically evaluates a series of techniques
	to develop such a framework. Steps towards creating the proposed
	framework include investigating a generic foundation to handle arbitrary
	Domain Specific Languages (DSLs); strategies, principles and tradeoffs
	in different DSL designs (e.g. DSL syntax and semantics); building
	blocks for modeling and programming domain concepts; transformation
	strategies from domain concepts to the final (compilable) source
	code; development processes to leverage the proposed framework well;
	model-driven approaches for maintenance and tests; and performance
	implications of major functional components in the framework.},
  affiliation = {Department of Computer Science, University of Massachusetts, Boston},
  booktitle = {Satellite Events at the MoDELS 2005 Conference},
  isbn = {978-3-540-31780-7},
  keyword = {Computer Science},
  owner = {daniel},
  timestamp = {2011.11.06},
  url = {http://dx.doi.org/10.1007/11663430_43}
}

@INBOOK{springerlink:10.1007/978-3-540-72901-3_15,
  pages = {194-203},
  title = {A Model Driven Software Factory Using Domain Specific Languages},
  publisher = {Springer Berlin / Heidelberg},
  year = {2007},
  editor = {Akehurst, David and Vogel, Régis and Paige, Richard},
  author = {Warmer, Jos},
  volume = {4530},
  series = {Lecture Notes in Computer Science},
  note = {10.1007/978-3-540-72901-3_15},
  abstract = {This paper describes the development of the SMART-Microsoft Software
	Factory. This factory is a fully model driven factory that makes
	extensive use of the Microsoft DSL Tools and is bases on the Microsoft
	Service Oriented Architecture. We describe the process used for developing
	the factory and share the experience gained in the first projects
	in which this factory has been used. The first project has 73% of
	the delivered code being generated.},
  affiliation = {Ordina The Netherlands The Netherlands},
  booktitle = {Model Driven Architecture- Foundations and Applications},
  isbn = {978-3-540-72900-6},
  keyword = {Computer Science},
  owner = {daniel},
  timestamp = {2011.11.06},
  url = {http://dx.doi.org/10.1007/978-3-540-72901-3_15}
}

@INBOOK{springerlink:10.1007/978-3-540-69073-3_6,
  pages = {47-58},
  title = {A Comparison of Standard Compliant Ways to Define Domain Specific
	Languages},
  publisher = {Springer Berlin / Heidelberg},
  year = {2008},
  editor = {Giese, Holger},
  author = {Weisemöller, Ingo and Schürr, Andy},
  volume = {5002},
  series = {Lecture Notes in Computer Science},
  note = {10.1007/978-3-540-69073-3_6},
  abstract = {Domain specific languages are of increasing importance for today’s
	software development processes. Their area of application ranges
	from process modeling over architecture description and system design
	to behavioral specification and simulation. There are numerous approaches
	for the definition and implementation of DSLs. Among others, the
	OMG offers UML profiles as a lightweight extension of a predefined
	multi-purpose language and MOF as a metamodeling language, which
	can be used to define DSLs from scratch. This contribution investigates
	various approaches to define DSLs, focusing on architectural description
	languages as an example. Besides the usage of UML profiles and the
	definition of an entirely new language with MOF, the adaption of
	the UML based on a metamodel extension is also considered. As a consequence
	of the shortcomings depicted for the different approaches, we suggest
	to combine UML profiles and metamodeling in order to compensate their
	weaknesses and take advantage of their benefits.},
  affiliation = {Technische Universität Darmstadt Real-Time Systems Lab D-64283 Darmstadt
	Germany},
  booktitle = {Models in Software Engineering},
  isbn = {978-3-540-69069-6},
  keyword = {Computer Science},
  owner = {daniel},
  timestamp = {2011.11.06},
  url = {http://dx.doi.org/10.1007/978-3-540-69073-3_6}
}

@INBOOK{springerlink:10.1007/11499053_63,
  pages = {1327-1328},
  title = {Agile Development with Domain Specific Languages},
  publisher = {Springer Berlin / Heidelberg},
  year = {2005},
  editor = {Baumeister, Hubert and Marchesi, Michele and Holcombe, Mike},
  author = {Wills, Alan and Kelly, Steven},
  volume = {3556},
  series = {Lecture Notes in Computer Science},
  note = {10.1007/11499053_63},
  abstract = {This workshop will investigate the application of Domain Specific
	Languages within Agile development. A Domain Specific Language (DSL)
	is designed to express the requirements and solutions of a particular
	business or architectural domain. SQL, GUI designers, workflow languages
	and regular expressions are familiar examples. In recent years, Domain-Specific
	Modeling has yielded spectacular productivity improvements in domains
	such as telephony and embedded systems. By creating graphical or
	textual languages specific to the needs of an individual project
	or product line within one company, DSM offers maximum agility. With
	current tools, creating a language and related tool support is fast
	enough to make DSM a realistic possibility for projects of all sizes.},
  affiliation = {Microsoft},
  booktitle = {Extreme Programming and Agile Processes in Software Engineering},
  isbn = {978-3-540-26277-0},
  keyword = {Computer Science},
  owner = {daniel},
  timestamp = {2011.11.06},
  url = {http://dx.doi.org/10.1007/11499053_63}
}

@INBOOK{springerlink:10.1007/978-3-540-69100-6_10,
  pages = {137-152},
  title = {Array OL Descriptions of Repetitive Structures in VHDL},
  publisher = {Springer Berlin / Heidelberg},
  year = {2008},
  editor = {Schieferdecker, Ina and Hartman, Alan},
  author = {Wood, Stephen and Akehurst, David and Howells, Gareth and McDonald-Maier,
	Klaus},
  volume = {5095},
  series = {Lecture Notes in Computer Science},
  note = {10.1007/978-3-540-69100-6_10},
  abstract = {With the continuing advances in semiconductor technology driving the
	rise in complexity of electronic embedded systems, there is a demand
	for the development of high level modelling environments for computer-aided
	design. The modelling of highly repetitive structures in graphical
	form poses a particular challenge if a hierarchical approach is not
	adopted. This paper proposes a mechanism for describing such component
	structures in a compact form based upon extensions of the Array Oriented
	Language (Array-OL). An example is given as to how the structure
	described is subsequently mapped into VHDL code.},
  affiliation = {University of Kent, Canterbury, UK},
  booktitle = {Model Driven Architecture – Foundations and Applications},
  isbn = {978-3-540-69095-5},
  keyword = {Computer Science},
  owner = {daniel},
  timestamp = {2011.11.06},
  url = {http://dx.doi.org/10.1007/978-3-540-69100-6_10}
}

@INBOOK{springerlink:10.1007/978-3-540-68073-4_41,
  pages = {390-399},
  title = {Appendix: Workshop and Tutorial Abstracts},
  publisher = {Springer Berlin / Heidelberg},
  year = {2008},
  editor = {Mei, Hong},
  author = {Zhao, Jianjun and Poulin, Jeff},
  volume = {5030},
  series = {Lecture Notes in Computer Science},
  note = {10.1007/978-3-540-68073-4_41},
  abstract = {Software reuse is a promising and attractive concept for improving
	software productivity, quality and time to market. However, a series
	of problems will often be encountered when considering reuse in a
	completely general context, including incompatible variability assumption,
	architecture mismatch, inability for more specific problem, etc.
	So a more promising way is to practice reuse based product development
	within specific domain in a prescribed way, as in the area of domain
	engineering and software product line.},
  affiliation = {No Affiliations},
  booktitle = {High Confidence Software Reuse in Large Systems},
  isbn = {978-3-540-68062-8},
  keyword = {Computer Science},
  owner = {daniel},
  timestamp = {2011.11.06},
  url = {http://dx.doi.org/10.1007/978-3-540-68073-4_41}
}

@INBOOK{springerlink:10.1007/978-3-540-75209-7_18,
  pages = {256-270},
  title = {A Business-Process-Driven Approach for Generating E-Commerce User
	Interfaces},
  publisher = {Springer Berlin / Heidelberg},
  year = {2007},
  editor = {Engels, Gregor and Opdyke, Bill and Schmidt, Douglas and Weil, Frank},
  author = {Zhao, Xulin and Zou, Ying and Hawkins, Jen and Madapusi, Bhadri},
  volume = {4735},
  series = {Lecture Notes in Computer Science},
  note = {10.1007/978-3-540-75209-7_18},
  abstract = {A business process contains a set of interdependent activities that
	describe operations provided by an organization. E-commerce applications
	are designed to automate business processes. A business process specification
	(i.e., a workflow) is defined by a business analyst from the viewpoint
	of the end-users. The process encapsulates the knowledge related
	to the natural work rhythms that a business user would follow when
	using an e-commerce application. In this paper, we analyze the information
	embedded in business process specifications, and infer the functional
	and usability requirements. We use the inferred information in a
	model-driven approach to automatically generate user interfaces (UIs)
	from a business process specification through a set of transformations.
	To improve the usability of UIs for the e-commerce applications,
	each transformation is guided by usability principles.},
  affiliation = {Electrical and Computer Engineering Depart, Queen’s University,
	Kingston, Ontario Canada},
  booktitle = {Model Driven Engineering Languages and Systems},
  isbn = {978-3-540-75208-0},
  keyword = {Computer Science},
  owner = {daniel},
  timestamp = {2011.11.06},
  url = {http://dx.doi.org/10.1007/978-3-540-75209-7_18}
}

@INBOOK{springerlink:10.1007/978-3-540-30175-2_1,
  pages = {583-605},
  title = {Generating AspectJ Programs with Meta-AspectJ},
  publisher = {Springer Berlin / Heidelberg},
  year = {2004},
  editor = {Karsai, Gabor and Visser, Eelco},
  author = {Zook, David and Huang, Shan and Smaragdakis, Yannis},
  volume = {3286},
  series = {Lecture Notes in Computer Science},
  note = {10.1007/978-3-540-30175-2_1},
  abstract = {Meta-AspectJ (MAJ) is a language tool for generating AspectJ programs
	using code templates. MAJ itself is an extension of Java, so users
	can interleave arbitrary Java code with AspectJ code templates. MAJ
	is a structured meta-programming tool: a well-typed generator implies
	a syntactically correct generated program. MAJ promotes a methodology
	that combines aspect-oriented and generative programming. Potential
	applications range from implementing domain-specific languages with
	AspectJ as a back-end to enhancing AspectJ with more powerful general-purpose
	constructs. In addition to its practical value, MAJ offers valuable
	insights to meta-programming tool designers. It is a mature meta-programming
	tool for AspectJ (and, by extension, Java): a lot of emphasis has
	been placed on context-sensitive parsing and error-reporting. As
	a result, MAJ minimizes the number of meta-programming (quote/unquote)
	operators and uses type inference to reduce the need to remember
	type names for syntactic entities.},
  affiliation = {College of Computing, Georgia Institute of Technology, Atlanta, GA
	30332, USA},
  booktitle = {Generative Programming and Component Engineering},
  isbn = {978-3-540-23580-4},
  keyword = {Computer Science},
  owner = {daniel},
  timestamp = {2011.11.06},
  url = {http://dx.doi.org/10.1007/978-3-540-30175-2_1}
}