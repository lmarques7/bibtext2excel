% This file was created with JabRef 2.7.2.
% Encoding: UTF8

@CONFERENCE{Acher20111333,
  author = {Acher, M.a , Collet, P.a , Lahire, P.a , France, R.B.b },
  title = {A domain-specific language for managing feature models},
  year = {2011},
  pages = {1333-1340},
  note = {cited By (since 1996) 1},
  abstract = {Feature models are a popular formalism for managing variability in
	software product lines (SPLs). In practice, developing an SPL can
	involve modeling a large number of features representing different
	viewpoints, sub-systems or concerns of the software system. To manage
	complexity, there is a need to separate, relate and compose several
	feature models while automating the reasoning on their compositions
	in order to enable rigorous SPL validation and configuration. In
	this paper, we propose a Domain-Specific Language (DSL) that is dedicated
	to the management of feature models and that complements existing
	tool support. Rationale for this language is discussed and its main
	constructs are presented through examples. We show how the DSL can
	be used to realize a non trivial scenario in which multiple SPLs
	are managed. © 2011 ACM.},
  affiliation = {University of Nice Sophia Antipolis, I3S Laboratory (CNRS UMR 6070),
	France; Colorado State University, Computer Science Department, United
	States},
  author_keywords = {domain-specific language; Feature models; product lines},
  document_type = {Conference Paper},
  journal = {Proceedings of the ACM Symposium on Applied Computing},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-79959314603&partnerID=40&md5=4e5fe7dd6019ee0d712c65196b1e11d6}
}

@CONFERENCE{Acher201191,
  author = {Acher, M.a , Collet, P.a , Lahire, P.a , France, R.B.b },
  title = {Managing feature models with familiar: A demonstration of the language
	and its tool support},
  year = {2011},
  pages = {91-96},
  note = {cited By (since 1996) 0},
  abstract = {Developing software product lines involves modeling a large number
	of features, usually using feature models, that represent different
	viewpoints, sub-systems or concerns of the software system. To manage
	complexity on a large scale, there is a need to separate, relate
	and compose several feature models while automating the reasoning
	on their compositions. This demonstration gives an overview of a
	Domain-Specific Language, familiar, that is dedicated to the management
	of feature models. Its comprehensive programming environment, based
	on Eclipse, is also described. It complements existing tool support
	(i.e., FeatureIDE). Copyright 2011 ACM.},
  affiliation = {University of Nice Sophia Antipolis, I3S Laboratory, CNRS UMR 6070,
	France; Computer Science Department, Colorado State University, United
	States},
  author_keywords = {Domain-specific language; Feature models; Product lines},
  document_type = {Conference Paper},
  journal = {ACM International Conference Proceeding Series},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-79952823634&partnerID=40&md5=de13c792d82cecfc359b58d2b7661e1c}
}

@ARTICLE{Achilleos20071,
  author = {Achilleos, A.a , Georgalas, N.b , Yang, K.a },
  title = {An open source domain-specific tools framework to support model driven
	development of OSS},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2007},
  volume = {4530 LNCS},
  pages = {1-16},
  note = {cited By (since 1996) 2},
  abstract = {Telecommunications companies undergo massive transformations which
	reflect onto exacting requirements for controlling the costs of new
	Operation Support Systems (OSS) development and integration. This
	calls for the adoption of new approaches, which improve agility and
	reusability. Model Drive Development (MDD), as specified by OMG,
	can drastically tackle these issues and has, therefore, attracted
	the interest of the telecommunications industry. Equally important
	is the Open Source paradigm. For MDD to gain wide industrial adoption,
	tools should be available to facilitate the OSS development process.
	In this paper, we specify requirements MDD tools should meet for
	effective application of the approach. An extensive survey is then
	carried out to evaluate existing meta-modelling frameworks over the
	identified tools requirements. Eventually, we present the Integrated
	Eclipse Model driven Environment (IEME), which comprises a unified
	environment of bundled Eclipse-based MDD facilities that also supports
	the automatic generation of domain-specific tools. © Springer-Verlag
	Berlin Heidelberg 2007.},
  affiliation = {University of Essex, Dept. of Electronic Systems Engineering, United
	Kingdom; British Telecom Group, United Kingdom},
  author_keywords = {Domain specific languages; MDA; Meta-modelling; Model-driven development;
	Modelling editor tools},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-37149043897&partnerID=40&md5=af2948d4fb8fea15057d628137f27855}
}

@CONFERENCE{Adar2007762,
  author = {Adar, E., Kim, M.},
  title = {SoftGUESS: Visualization and exploration of code clones in context},
  year = {2007},
  pages = {762-765},
  note = {cited By (since 1996) 3},
  abstract = {We introduce SoftGUESS, a code clone exploration system. SoftGUESS
	is built on the more general GUESS system which provides users with
	a mechanism to interactively explore graph structures both through
	direct manipulation as well as a domain-specific language. We demonstrate
	SoftGUESS through a number of mini-applications to analyze evolutionary
	code-clone behavior in software systems. The miniapplications of
	SoftGUESS represent a novel way of looking at code-clones in the
	context of many system features. It is our hope that SoftGUESS will
	form the basis for other analysis tools in the softwareengineering
	domain. © 2007 IEEE.},
  affiliation = {University of Washington, Computer Science and Engineering},
  art_number = {4222642},
  document_type = {Conference Paper},
  journal = {Proceedings - International Conference on Software Engineering},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-34548765475&partnerID=40&md5=f1d4b2d4c36b47bd947e2fb72d91df98}
}

@ARTICLE{Adda2011258,
  author = {Adda, M.},
  title = {A constrained crawling approach and its application to a specialised
	search engine},
  journal = {International Journal of Information and Communication Technology},
  year = {2011},
  volume = {3},
  pages = {258-273},
  number = {3},
  note = {cited By (since 1996) 0},
  abstract = {In this paper, we present an approach to crawl and parse websites
	based on their logical structure rather than on an aleatory exploration
	method. In this approach, we use a set of constraints to identify
	web pages and their components. To enforce these constraints, we
	present a set of primitives that rely on predicate verification.
	Our model has the attractiveness of being flexible to reflect tree-like
	logical structures of websites, thus it avoids the need to use complex
	information analysis and content classification techniques. Furthermore,
	because the model is implemented as a domain specific language (DSL),
	describing crawling tasks is straightforward. Using this DSL, we
	developed and deployed a prototype of dynamic web application with
	full-text search capabilities that periodically crawls, parses, and
	analyses the content of selected online newspapers. A set of experiments,
	and comparisons highlight the effectiveness of the proposed crawling
	approach. Copyright © 2011 Inderscience Enterprises Ltd.},
  affiliation = {Department of Computer Science, Engineering and Mathematics, University
	of Quebec at Rimouski, 300, allée des Ursulines, Rimouski, QC, G5L
	3A1, Canada},
  author_keywords = {Information retrieval; Search engines; Web crawling},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-80051710775&partnerID=40&md5=43270756c63bc25b2dd0522683e53014}
}

@ARTICLE{Adda201025,
  author = {Adda, M.a , Mcheick, H.b , Mili, H.c },
  title = {Formal model and DSL for separation of concerns based on views},
  journal = {Journal of Object Technology},
  year = {2010},
  volume = {9},
  pages = {25-50},
  number = {6},
  note = {cited By (since 1996) 0},
  abstract = {The separation of concerns (SOC), as a conceptual tool, enables us
	to manage the complexity of software systems that we develop. The
	benefits of this paradigm, such as reuse, enhanced quality and adaptability,
	have been key drivers of its adoption. Modern software systems and
	applications take advantage of the technologies built around this
	paradigm, in which a client program can access different functional
	aspects (views) of the same domain. One of these SOC approaches is
	View-oriented Computing (VOC), which suffers from a formal model
	to canonically and consistently represent the different concepts
	of VOC as well to have the necessary background to formally verify
	the systems build on top of it. This paper describes a formal algebra-based
	model to describe different entities related to VOC. Especially,
	it introduces algebra and formalism associated with a Domain Specific
	Language (DSL) notation to illustrate the VOC paradigm. © JOT 2010.},
  affiliation = {Département de mathématiques, informatique et génie, Université du
	Québec à Rimouski, Rimouski QC, Canada; Département d'informatique,
	Université du Québec à Chicoutimi, Chicoutimi QC, Canada; Département
	d'informatique, Université du Québec à Montréal, QC, Canada},
  author_keywords = {Formal model; Separation of concerns; View-oriented computing},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-78449263214&partnerID=40&md5=3c2e24597014d5528ed6281a21283ca1}
}

@CONFERENCE{Agaram201175,
  author = {Agaram, M.K., Liu, C.},
  title = {An engine-independent framework for business rules development},
  year = {2011},
  pages = {75-84},
  note = {cited By (since 1996) 0},
  abstract = {There is a compelling need for highly customized Domain Specific Languages
	and Business Vocabulary in certain industries such as insurance,
	mortgage, and finance to enable Knowledge Workers to articulate and
	to automate complex rules pertinent to their areas of function within
	their companies. Rule Engine vendors attempt to provide a solution
	to the problem by selling an integrated Rules Engine and Business
	Rules Management System. Usually, the BRMS's provided by vendors
	need to be customized and integrated into the overall Enterprise
	Architecture. This results in the Enterprise Architecture to be tightly
	coupled with the vendor's rule offering. Moreover, it poses a significant
	risk to the Enterprise as vendor solutions change between releases.
	The Enterprise Architecture needs a way to insulate itself from such
	impacts. This paper describes a framework that delivers the core
	BRMS functions of authoring and representation in a vendor neutral
	fashion. In addition, the paper sheds light on specific areas of
	the framework that can be standardized. © 2011 IEEE.},
  affiliation = {Information Systems and Support, Delta Dental of Michigan, Okemos,
	United States},
  art_number = {6037562},
  author_keywords = {Business rule components; Business rules; Business rules languages;
	Business vocabulary; Domain specific languages},
  document_type = {Conference Paper},
  journal = {Proceedings - IEEE International Enterprise Distributed Object Computing
	Workshop, EDOC},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-80054962166&partnerID=40&md5=9f60279b73df7158fdd885aff6c49710}
}

@ARTICLE{Agrawal2006261,
  author = {Agrawal, A., Karsai, G., Neema, S., Shi, F., Vizhanyo, A.},
  title = {The design of a language for model transformations},
  journal = {Software and Systems Modeling},
  year = {2006},
  volume = {5},
  pages = {261-288},
  number = {3},
  note = {cited By (since 1996) 19},
  abstract = {Model-driven development of software systems envisions transformations
	applied in various stages of the development process. Similarly,
	the use of domain-specific languages also necessitates transformations
	that map domain-specific constructs into the constructs of an underlying
	programming language. Thus, in these cases, the writing of transformation
	tools becomes a first-class activity of the software engineer. This
	paper introduces a language that was designed to support implementing
	highly efficient transformation programs that perform model-to-model
	or model-to-code translations. The language uses the concepts of
	graph transformations and metamodeling, and is supported by a suite
	of tools that allow the rapid prototyping and realization of transformation
	tools. © Springer-Verlag 2006.},
  affiliation = {Institute for Software Integrated Systems, Vanderbilt University,
	Nashville, TN 37235, United States},
  author_keywords = {Graph rewriting; Graph transformation; Model driven architecture;
	Model transformation; UML},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-33748302114&partnerID=40&md5=7bcadb014a81d4fdc769b0fbf27e37a0}
}

@ARTICLE{Agron2009262,
  author = {Agron, J.},
  title = {Domain-specific language for HW/SW Co-design for FPGAs},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2009},
  volume = {5658 LNCS},
  pages = {262-284},
  note = {cited By (since 1996) 0},
  abstract = {This article describes FSMLanguage, a domain-specific language for
	HW/SW co-design targeting platform FPGAs. Modern platform FPGAs provide
	a wealth of configurable logic in addition to embedded processors,
	distributed RAM blocks, and DSP slices in order to help facilitate
	building HW/SW co-designed systems. A technical challenge in building
	such systems is that the practice of designing software and hardware
	requires different areas of expertise and different description domains,
	i.e. languages and vocabulary. FSMLanguage attempts to unify these
	domains by defining a way to describe HW/SW co-designed systems in
	terms of sets of finite-state machines - a concept that is reasonably
	familiar to both software programmers and hardware designers. FSMLanguage
	is a domain-specific language for describing the functionality of
	a finite-state machine in such a way that its implementation can
	be re-targeted to software or hardware in an efficient manner. The
	efficiency is achieved by exploiting the resources found within modern
	platform FPGAs - namely the distributed RAM blocks, soft-core processors,
	and the ability to construct dedicated communication channels between
	FSMs in the reconfigurable fabric. The language and its compiler
	promote uniformity in the description of a HW/SW co-designed system,
	which allows a system designer to make partitioning and implementation
	strategy decisions later in the design cycle. © IFIP International
	Federation for Information Processing 2009.},
  affiliation = {Dept. of Computer Science and Computer Engineering, University of
	Arkansas, 504 J.B. Hunt Building, Fayetteville, AR},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-69049092004&partnerID=40&md5=3419e5bfbb0357c30e4753a32e265cda}
}

@CONFERENCE{Ahmad2010285,
  author = {Ahmad, M.},
  title = {First step towards a domain specific language for self-adaptive systems},
  year = {2010},
  pages = {285-290},
  note = {cited By (since 1996) 0},
  abstract = {Self-adaptive systems are capable of autonomously modifying their
	behavior at run-time in response to changing environmental conditions.
	In order to modify the behavior, requirements play an important role,
	as they tend to change for these systems. For this we need to identify
	those requirements that are concerned with the adaptability features
	of the self-adaptive systems. In order to cope with the uncertainty
	inherent in self-adaptive systems, requirements engineering languages
	for these systems should include explicit constructs. RELAX is a
	requirement engineering language for self-adaptive systems that incorporates
	uncertainty into the specification of these systems. To go one step
	further, we aim at developing a domain specific language that would
	bridge the gap between requirements and the overall system model.
	The first step that is illustrated in this paper is to build a textual
	editor for RELAX. ©2010 IEEE.},
  affiliation = {University of Toulouse, CNRS/IRIT Laboratory, 118 Rte de Norbonne,
	F-31062 Toulouse Cedex, France},
  art_number = {5536629},
  author_keywords = {Domain Specific Language (DSL); Dynamically Adaptive Systems (DASs);
	Eclipse Modeling Framework (EMF)},
  document_type = {Conference Paper},
  journal = {NOTERE'10 - 10th Annual International Conference on New Technologies
	of Distributed Systems},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-77955979319&partnerID=40&md5=435550a9c8e449d70e0c51ac947de623}
}

@CONFERENCE{Ahmadi2010215,
  author = {Ahmadi, N., Lelli, F., Jazayeri, M.},
  title = {Supporting domain-specific programming in Web 2.0: A case study of
	smart devices},
  year = {2010},
  pages = {215-223},
  note = {cited By (since 1996) 0},
  abstract = {Web 2.0 communities emerge regularly with the growing need for domain-specific
	programming over Web APIs. Even though Web mashups provide access
	to Web APIs, they ignore domain-specific programming needs. On the
	other hand, developing domain-specific languages (DSLs) is costly
	and not feasible for such ad hoc communities. We propose User Language
	Domain (ULD): an intermediate Web-based architecture using a domain-specific
	embedded languages approach that reduces the cost of DSL development
	to plugging the Web APIs into a host end user programming language.
	We have implemented the proposed architecture in the context of smart
	devices, where we plug the functionality of different Lego Mindstorms
	devices into a Web-based visual programming language. We expect that
	several domains, such as smart homes or wearable computers can use
	the ULD architecture to reduce development effort. © 2010 IEEE.},
  affiliation = {Faculty of Informatics, University of Lugano, Lugano, Switzerland},
  art_number = {5475034},
  author_keywords = {Domain specific languages; End user programming; Plugin architecture;
	Smart devices; Ubiquitous computing; Web 2.0 communities},
  document_type = {Conference Paper},
  journal = {Proceedings of the Australian Software Engineering Conference, ASWEC},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-77954339937&partnerID=40&md5=0ece091f0a201c68596a921cca6ed330}
}

@CONFERENCE{Aitken1998114,
  author = {Aitken, William, Dickens, Brian, Kwiatkowski, Paul, de Moor, Oege,
	Richter, David, Simonyi, Charles},
  title = {Transformation in intentional programming},
  year = {1998},
  pages = {114-123},
  note = {cited By (since 1996) 3},
  abstract = {Intentional programming is a new paradigm in software engineering
	that allows programming languages to be implemented in a highly extensible
	manner. In particular, the programmer can specify new abstractions
	that are specific to his problem domain, while simultaneously recording
	any domain specific optimizations that may apply to such new abstractions.
	This paper describes a system that implements intentional programming,
	focusing on the facilities for program transformation. The key difference
	with other approaches lies in the way the order of transformation
	is controlled: emphasis is placed on specifying that order in a compositional
	fashion, so that transformations are easily re-used.},
  affiliation = {Microsoft Corp, Redmond, United States},
  document_type = {Conference Paper},
  journal = {International Conference on Software Reuse},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-0031677036&partnerID=40&md5=a90532080c908d15f8d7461374016faa}
}

@CONFERENCE{Akoumianakis2008267,
  author = {Akoumianakis, D., Vidakis, N., Vellis, G., Milolidakis, G., Kotsalis,
	D.},
  title = {Interaction scenarios in the 'social' experience factory: assembling
	collaborative artefacts through component reuse and social interaction},
  year = {2008},
  pages = {267-272},
  note = {cited By (since 1996) 1},
  abstract = {This paper describes interaction scenarios in the context of community-based
	collaborative activities. We first present the notion of a 'social'
	experience factory (SEF) which underlies the conduct of collaborative
	work in the context of an electronic village of local interest on
	regional tourism. The SEF is biased towards building up experiences
	for reuse and facilitating the production of artefacts (information-based
	services) by assembling deposited 'shared' components. In its current
	formulation, the SEF implements techniques and tools for building
	visual domain-specific languages and constructing artefacts as instances
	of a corresponding family. The paper reports on the details of these
	techniques and illustrates their application in the construction,
	negotiation and tailoring of vacation packages in the domain of tourism.},
  affiliation = {iSTLab, Department of Applied Information Technology and Multimedia
	Technological, Education Institution of Crete Stavromenos, 71 004
	Heraklion, Crete, Greece},
  author_keywords = {Collaboration; Domain-specific visual languages; Experience factory},
  document_type = {Conference Paper},
  journal = {Proceedings of the 3rd IASTED International Conference on Human-Computer
	Interaction, HCI 2008},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-62949087074&partnerID=40&md5=8f8568ab743a40083e142c062b42a48d}
}

@ARTICLE{Alam2008223,
  author = {Alam, M., Hafner, M., Breu, R.},
  title = {Constraint based role based access control in the SECTET-framework:
	A model-driven approach},
  journal = {Journal of Computer Security},
  year = {2008},
  volume = {16},
  pages = {223-260},
  number = {2},
  note = {cited By (since 1996) 6},
  abstract = {With respect to Service Oriented Architectures (SOA's) paradigm, the
	core Role Based Access Control (RBAC) has several limitations. In
	SOA, permissions to execute web services are not assigned statically
	to roles but are associated with a set of Permission Assignment Constraints
	(PAC) upon the fulfilment of which a role is assigned a permission
	to execute a web service. Further, the RBAC does not support partial
	inheritance which is an integral requirement in SOA. A major challenge
	in SOA is the inheritance of permissions associated with PAC in the
	presence of role hierarchies. This contribution has three objectives.
	First we propose an extension to Role Based Access Control (available
	at csrc.nist.gov/rbac/), which we call Constraint based RBAC (CRBAC),
	in order to make RBAC applicable to the dynamic environment of SOA.
	Within CRBAC, a high-level language - called SECTET-PL (available
	at http:// qe-informatik.uibk.ac.at/~muhammad/TechnicalReportSECTETPL.pdf)
	is used for the specification of PAC. Being part of the SECTET-framework
	for model-driven security for B2B-workflows, SECTET-PL is a policy
	language influenced by OCL (available at http://www.omg.org/docs/ptc/03-10-14.pdf)
	and interpreted in the context of UML models. Using the Model Driven
	Architecture (MDA) (available at http://www.omg.org/mda) paradigm,
	we then describe the transformation of high-level security models
	to low-level web services standard artefacts with the help of the
	Eclipse Modelling Framework and OpenArchitectureWare. Finally, we
	present the target architecture of the SECTET-framework used to realize
	the security artefacts generated from the transformations and thus
	completes the cycle of MDA. © 2008 - IOS Press and the authors. All
	rights reserved.},
  affiliation = {Research Group Quality Engineering, Universität Innsbruck, Austria},
  author_keywords = {Domain specific language; Model driven architecture; Model driven
	engineering; Service oriented architecture},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-38349100724&partnerID=40&md5=db9ec9b84cafa9b18e05c6a905164ead}
}

@ARTICLE{Alam2007289,
  author = {Alam, M., Hafner, M., Breu, R., Unterthiner, S.},
  title = {A framework for modelling restricted delegation of rights in the
	SECTET},
  journal = {Computer Systems Science and Engineering},
  year = {2007},
  volume = {22},
  pages = {289-305},
  number = {5},
  note = {cited By (since 1996) 0},
  abstract = {We present a novel approach for modelling restricted delegation of
	rights in a distributed environment based on web services. In existing
	delegation models, delegated permissions are statically assigned
	to a role which is not the case in Service Oriented Architecture's
	(SOA). In SOA, permissions to execute web services are delegated
	to roles with a set of dynamic constraints. These constraints play
	a key role in the assignment of permissions to roles. This paper
	presents an extension to our model Constraint based Role Based Access
	Control (CRBAC), CRBAC1, in order to support permission-level delegation
	based on dynamic constraints. Our approach integrates SECTET-PL [1],
	a predicative language for modelling access rights based on the concept
	of Role Based Access Control (RBAC). SECTET-PL is part of the SECTET
	framework for model-driven security for B2B workflows. Our Rights
	Delegation Model combines the concept of roles from RBAC with the
	predicative specification of SECTET-PL. The Rights Delegation Model
	is translated into XACML Delegation Policies, which are interpreted
	by a security gateway. © 2007 CRL Publishing Ltd.},
  affiliation = {Research Group, Quality Engineering University of Innsbruck, Austria},
  author_keywords = {Delegation of rights; Domain specific language; Model driven architecture;
	Model driven engineering; Service oriented architecture},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-38949134784&partnerID=40&md5=e1735d13007d4257a55b2a44b615b4bd}
}

@ARTICLE{Alias200563,
  author = {Alias, C., Barthou, D.},
  title = {On domain-specific languages reengineering},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2005},
  volume = {3676 LNCS},
  pages = {63-77},
  note = {cited By (since 1996) 1},
  abstract = {Domain-specific languages (DSL) provides high-level functions making
	applications easier to write, and to maintain. Unfortunately, many
	applications are written from scratch and poorly documented, which
	make them hard to maintain. An ideal solution should be to rewrite
	them in a appropriate DSL. In this paper, we present TeMa (Template
	Matcher), an automatic tool to recognize high-level functions in
	source code. Preliminary results show how TeMa can be used to reformulate
	Fortran code into Signal Processing Language (SPL) used in SPIRAL.
	This opens new possibilities for domain-specific languages. © Springer-Verlag
	Berlin Heidelberg 2005.},
  affiliation = {Laboratoire PRiSM, Université de Versailles, France},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-33646130402&partnerID=40&md5=80a70002c460b7a25f9192bc61d72449}
}

@CONFERENCE{Alvaro2011249,
  author = {Alvaro, P., Conway, N., Hellerstein, J.M., Marczak, W.R.},
  title = {Consistency analysis in Bloom: A CALM and collected approach},
  year = {2011},
  pages = {249-260},
  note = {cited By (since 1996) 0},
  abstract = {Distributed programming has become a topic of widespread interest,
	and many programmers now wrestle with tradeoffs between data consistency,
	availability and latency. Distributed transactions are often rejected
	as an undesirable tradeoff today, but in the absence of transactions
	there are few concrete principles or tools to help programmers design
	and verify the correctness of their applications. We address this
	situation with the CALM principle, which connects the idea of distributed
	consistency to program tests for logical monotonicity. We then introduce
	Bloom, a distributed programming language that is amenable to high-level
	consistency analysis and encourages order-insensitive programming.
	We present a prototype implementation of Bloom as a domain-specific
	language in Ruby. We also propose a program analysis technique that
	identifies points of order in Bloom programs: code locations where
	programmers may need to inject coordination logic to ensure consistency.
	We illustrate these ideas with two case studies: a simple key-value
	store and a distributed shopping cart service.},
  affiliation = {University of California, Berkeley, United States},
  document_type = {Conference Paper},
  journal = {CIDR 2011 - 5th Biennial Conference on Innovative Data Systems Research,
	Conference Proceedings},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-80053479013&partnerID=40&md5=c621fc68709e61ec263c65f20e327ab5}
}

@ARTICLE{Alves2003795,
  author = {Alves, N.M.M., De Mello Schneider, S.},
  title = {Implementation of an embedded hardware description language using
	Haskell},
  journal = {Journal of Universal Computer Science},
  year = {2003},
  volume = {9},
  pages = {795-812},
  number = {8},
  note = {cited By (since 1996) 1},
  abstract = {This paper describes an ongoing implementation of an embedded hardware
	description language (HDL) using Haskell as a host language. Traditionally,
	"functional" HDL's are made using lazy lists to model signals, so
	circuits are functions from lists of input values to lists of output
	values. We use another known approach for embedded languages, in
	which circuits are data, structures rather than functions. This style
	of implementation permits one to inspect the structure of the circuit,
	allowing one to perform different interpretations for the same description.
	The approach we present can also be applied to other domain-specific
	embedded languages. We provide an elegant implementation of memories
	and a set of new signal types. © J.UCS.},
  affiliation = {Universidade Federal de Uberlândia, Brazil},
  author_keywords = {Domain-specific languages; Embedded languages; Hardware description},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-23844546530&partnerID=40&md5=a73c1b268a111d5e9ecb9f115a83657b}
}

@ARTICLE{Amatriain2011544,
  author = {Amatriain, X.a , Arumi, P.b },
  title = {Frameworks generate domain-specific languages: A case study in the
	multimedia domain},
  journal = {IEEE Transactions on Software Engineering},
  year = {2011},
  volume = {37},
  pages = {544-558},
  number = {4},
  note = {cited By (since 1996) 0},
  abstract = {We present an approach to software framework development that includes
	the generation of domain-specific languages (DSLs) and pattern languages
	as goals for the process. Our model is made of three workflows -
	framework, metamodel, and patterns - and three phases - inception,
	construction, and formalization. The main conclusion is that when
	developing a framework, we can produce with minimal overhead - almost
	as a side effect - a metamodel with an associated DSL and a pattern
	language. Both outputs will not only help the framework evolve in
	the right direction, but will also be valuable in themselves. In
	order to illustrate these ideas, we present a case study in the multimedia
	domain. For several years, we have been developing a multimedia framework.
	The process has produced a full-fledged domain-specific metamodel
	for the multimedia domain, with an associated DSL and a pattern language.
	© 2006 IEEE.},
  affiliation = {Telefonica Research, Via Augusta, 177, Barcelona 08021, Spain; Barcelona
	Media, Av. Diagonal, 177, planta 9, 08018 Barcelona, Spain},
  art_number = {5441292},
  author_keywords = {CASE; Domain-specific architectures; life cycle; visual programming},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-79961087121&partnerID=40&md5=c8e51c7370161463431b9ec9cf7e4cb6}
}

@CONFERENCE{Amor2007,
  author = {Amor, M.a , Garcia, A.b , Fuentes, L.a },
  title = {AGOL: An aspect-oriented domain-specific language for MAS},
  year = {2007},
  note = {cited By (since 1996) 0},
  abstract = {Specific features of Multi-Agent Systems (MAS), such as autonomy,
	learning, mobility, coordination, are driving development concerns,
	which make evident the need for new design abstractions. Up to now,
	agent-oriented modeling languages have delivered basic MAS design
	abstractions - such as goals and actions - that explicitly tackle
	some of these concerns. However, the modularization of a plethora
	of fundamental MAS features has been hindered throughout the software
	lifecycle. This paper presents a methodological framework to address
	enhanced modularity and traceability of such crosscutting concerns
	in MAS development. Our design framework is mainly rooted at the
	proposition of a new domain-specific language, called AGOL. In addition,
	the proposed framework is supported by a bench of transformation
	rules of AGOL artifacts, which can be effectively used to derive
	agent implementations in two concrete aspect-oriented implementation
	platforms, namely AspectT and Malaca. © 2007 IEEE.},
  affiliation = {Dpto. Lenguajes Y Ciencias C, University of Malaga, Spain; Computing
	Department, Lancaster University, United Kingdom},
  art_number = {4279200},
  document_type = {Conference Paper},
  journal = {Proceedings - International Conference on Software Engineering},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-48749091205&partnerID=40&md5=8ca2ad860c3b0764142ab92ad49b6030}
}

@ARTICLE{Amyot2006183,
  author = {Amyot, D., Farah, H., Roy, J.-F.},
  title = {Evaluation of development tools for domain-specific modeling languages},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2006},
  volume = {4320 LNCS},
  pages = {183-197},
  note = {cited By (since 1996) 11},
  abstract = {Creating and maintaining tools for domain-specific modeling languages
	(DSML) demands time and efforts that often discourage potential developers.
	However, several tools are now available that promise to accelerate
	the development of DSML environments. In this paper, we evaluate
	five such tools (GME, Tau G2, RSA, XMF-Mosaic, and Eclipse with GEF
	and EMF) by observing how well they can be used to create graphical
	editors for the Goal-oriented Requirement Language (GRL), for which
	a simplified metamodel is provided. We discuss the evaluation criteria,
	results, and lessons learned during the creation of GRL editors with
	these technologies. © Springer-Verlag 2006.},
  affiliation = {SITE, University of Ottawa, Ottawa, ON, Canada},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-79952267930&partnerID=40&md5=ad3ddaf70d6bae6be800c41c432cb04b}
}

@CONFERENCE{An2011141,
  author = {An, K.a , Trewyn, A.a , Gokhale, A.a , Sastry, S.b },
  title = {Model-driven performance analysis of reconfigurable conveyor systems
	used in material handling applications},
  year = {2011},
  pages = {141-150},
  note = {cited By (since 1996) 0},
  abstract = {Reconfigurable conveyors are increasingly being adopted in multiple
	industrial sectors for their immense flexibility in adapting to new
	products and product lines. Before modifying the layout of the conveyor
	system for the new product line, however, engineers and layout planners
	must be able to answer many questions about the system, such as maximum
	sustainable rate of flow of goods, prioritization among goods, and
	tolerances of failures. Any analysis capability that provides answers
	to these questions must account for both the physical and cyber artifacts
	of the reconfigurable system all at once. Moreover, the same system
	should enable the stakeholders to seamlessly change the layouts and
	be able to analyze the pros and cons of the layouts. This paper addresses
	these challenges by presenting a model-driven analysis tool that
	provides three important capabilities. First, a domain-specific modeling
	language provides the stakeholders with intuitive artifacts to model
	conveyor layouts. Second, an analysis engine embedded within the
	model-driven tool provides an accurate simulation of the modeled
	conveyor system accounting for both the physical and cyber issues.
	Third, generative capabilities within the tool help to automate the
	analysis process. The merits of our model-driven analysis tool are
	evaluated in the context of an example conveyor topology. © 2011
	IEEE.},
  affiliation = {Department of Electrical Engineering and Computer Science, Vanderbilt
	University, Nashville, TN 37235, United States; Department of Electrical
	and Computer Engineering, University of Akron, Akron, OH 44325, United
	States},
  art_number = {5945429},
  author_keywords = {design-time analysis; model-based simulations; Reconfigurable conveyors},
  document_type = {Conference Paper},
  journal = {Proceedings - 2011 IEEE/ACM 2nd International Conference on Cyber-Physical
	Systems, ICCPS 2011},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-79961143053&partnerID=40&md5=c3b0be34766734236b79cea96ce8a033}
}

@ARTICLE{Anand20091126,
  author = {Anand, C.K., Kahl, W.},
  title = {An optimized cell BE special function library generated by coconut},
  journal = {IEEE Transactions on Computers},
  year = {2009},
  volume = {58},
  pages = {1126-1138},
  number = {8},
  note = {cited By (since 1996) 2},
  abstract = {Abstract-Coconut, a tool for developing high-assurance, high-performance
	kernels for scientific computing, contains an extensible domain-specific
	language (DSL) embedded in Haskell. The DSL supports interactive
	prototyping and unit testing, simplifying the process of designing
	efficient implementations of common patterns. Unscheduled C and scheduled
	assembly language output are supported. Using the patterns, even
	nonexpert users can write efficient function implementations, leveraging
	special hardware features. A production-quality library of elementary
	functions for the Cell BE SPU compute engines has been developed.
	Coconutgenerated and -scheduled vector functions were more than four
	times faster than commercially distributed functions written in C
	with intrinsics (a nicer syntax for in-line assembly), wrapped in
	loops and scheduled by spuxlc. All Coconut functions were faster,
	but the difference was larger for hard-to-approximate functions for
	which register-level SIMD lookups made a bigger difference. Other
	helpful features in the language include facilities for translating
	interval and polynomial descriptions between GHCi, a Haskell interpreter
	used to prototype in the DSL, and Maple, used for exploration and
	minimax polynomial generation. This makes it easier to match mathematical
	properties of the functions with efficient calculational patterns
	in the SPU ISA. By using single, literate source files, the resulting
	functions are remarkably readable. © 2009 IEEE.},
  affiliation = {Department of Computing and Software, ITB-202, McMaster University,
	1280 Main St. West, Hamilton, ON L8S 4K1, Canada},
  art_number = {A3},
  author_keywords = {Applicative (functional) programming; Code generation; Parallel and
	vector implementations; SIMD processors; Special function approximations;
	Specialized application languages},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-77955079685&partnerID=40&md5=6cb782232adc904dc70378a51c88dd16}
}

@ARTICLE{Anand2001,
  author = {Anand, S., Chin, W.-N., Khoo, S.-C.},
  title = {Charting patterns on price history},
  journal = {SIGPLAN Notices (ACM Special Interest Group on Programming Languages)},
  year = {2001},
  volume = {36},
  pages = {134-145},
  number = {10},
  note = {cited By (since 1996) 1},
  abstract = {It is an established notion among financial analysts that price moves
	in patterns and these patterns can be used to forecast future price.
	As the definitions of these patterns are often subjective, every
	analyst has a need to define and search meaningful patterns from
	historical time series quickly and efficiently. However, such discovery
	process can be extremely laborious and technically challenging in
	the absence of a high level pattern definition language. In this
	paper, we propose a chart-pattern language (CPL for short) to facilitate
	pattern discovery process. Our language enables financial analysts
	to (1) define patterns with subjective criteria, through introduction
	of fuzzy constraints, and (2) incrementally compose complex patterns
	from simpler patterns. We demonstrate through an array of examples
	how real life patterns can be expressed in CPL. In short, CPL provides
	a high-level platform upon which analysts can define and search patterns
	easily and without any programming expertise. CPL is a domain-specific
	language embedded in Haskell. We show how various features of a functional
	language, such as pattern matching, higher-order functions, lazy
	evaluation, facilitate pattern definitions and implementation. Furthermore,
	Haskell's type system frees the programmers from annotating the programs
	with types. Copyright 2001 ACM.},
  affiliation = {School of Computing, National University of Singapore},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-17144395971&partnerID=40&md5=14f706ebaaaf2f0158806e6a6970ea78}
}

@CONFERENCE{Anand2001134,
  author = {Anand, S., Chin, W.-N., Khoo, S.-C.},
  title = {Charting patterns on price history},
  year = {2001},
  pages = {134-145},
  note = {cited By (since 1996) 4},
  abstract = {It is an established notion among financial analysts that price moves
	in patterns and these patterns can be used to forecast future price.
	As the definitions of these patterns are often subjective, every
	analyst has a need to define and search meaningful patterns from
	historical time series quickly and efficiently. However, such discovery
	process can be extremely laborious and technically challenging in
	the absence of a high level pattern definition language. In this
	paper, we propose a chart-pattern language (CPL for short) to facilitate
	pattern discovery process. Our language enables financial analysts
	to (1) define patterns with subjective criteria, through introduction
	of fuzzy constraints, and (2) incrementally compose complex patterns
	from simpler patterns. We demonstrate through an array of examples
	how real life patterns can be expressed in CPL. In short, CPL provides
	a high-level platform upon which analysts can define and search patterns
	easily and without any programming expertise. CPL is a domain-specific
	language embedded in Haskell. We show how various features of a functional
	language, such as pattern matching, higher-order functions, lazy
	evaluation, facilitate pattern definitions and implementation. Furthermore,
	Haskell's type system frees the programmers from annotating the programs
	with types.},
  affiliation = {School of Computing, National University of Singapore, Singapore,
	Singapore},
  document_type = {Conference Paper},
  journal = {Proceedings of the ACM SIGPLAN International Conference on Functional
	Programming, ICFP},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-0034783035&partnerID=40&md5=6f85ece7ec070c6c1a0b425f54d3cbe5}
}

@CONFERENCE{Ancona200753,
  author = {Ancona, D.a , Ancona, M.a , Cuni, A.a , Matsakis, N.D.b },
  title = {RPython: A step towards reconciling dynamically and statically typed
	OO languages},
  year = {2007},
  pages = {53-64},
  note = {cited By (since 1996) 8},
  abstract = {Although the C-based interpreter of Python is reasonably fast, implementations
	on the CLI or the JVM platforms offers some advantages in terms of
	robustness and interoperability. Unfortunately, because the CLI and
	JVM are primarily designed to execute statically typed, object-oriented
	languages, most dynamic language implementations cannot use the native
	bytecodes for common operations like method calls and exception handling;
	as a result, they are not able to take full advantage of the power
	offered by the CLI and JVM. We describe a different approach that
	attempts to preserve the flexibility of Python, while still allowing
	for efficient execution. This is achieved by limiting the use of
	the more dynamic features of Python to an initial, bootstrapping
	phase. This phase is used to construct a final RPython (Restricted
	Python) program that is actually executed. RPython is a proper subset
	of Python, is statically typed, and does not allow dynamic modification
	of class or method definitions; however, it can still take advantage
	of Python features such as mixins and first-class methods and classes.
	This paper presents an overview of RPython, including its design
	and its translation to both CLI and JVM bytecode. We show how the
	bootstrapping phase can be used to implement advanced features, like
	extensible classes and generative programming. We also discuss what
	work remains before RPython is truly ready for general use, and compare
	the performance of RPython with that of other approaches. © 2007
	ACM.},
  affiliation = {DISI, University of Genova, Italy; ETH Zurich, Switzerland},
  author_keywords = {.NET; JVM; Python},
  document_type = {Conference Paper},
  journal = {Proceedings of the Conference on Object-Oriented Programming Systems,
	Languages, and Applications, OOPSLA},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-41149148138&partnerID=40&md5=5e50d2a6354b65559e835105a3d12d68}
}

@CONFERENCE{Anderson19981020,
  author = {Anderson, Gail, Mont, Andrew Casson-du, Macintosh, Ann, Rae, Robert,
	Gleeson, Barry},
  title = {Producing BT's yellow pages with Formation},
  year = {1998},
  pages = {1020-1026},
  note = {cited By (since 1996) 0},
  abstract = {This case study illustrates how the adoption of AI technology can
	benefit smaller companies as well as major corporations. Pindar Set
	is a small UK company which has originated the Yellow Pages directories
	for British Telecommunications plc since 1979. AIAI is a technology
	transfer organization which has delivered innovative solutions to
	industrial clients since 1984. Together, AIAI and Pindar have developed
	a next-generation layout system, Formation. Formation is fast, easy
	to use and flexible, and had already delivered benefits through marketing
	trials before being successfully deployed in production of the Yellow
	Pages in December 1997. The heart of Formation is a 2D layout engine
	which formats input data according to styles written in LSSL, a domain-specific
	language developed at AIAI. Through representing the layout knowledge
	in Formation explicitly in LSSL styles, and ensuring that it can
	easily be modified, Pindar has enabled itself to respond far better
	to its customer's present and future needs.},
  affiliation = {Univ of Edinburgh, Scotland, United Kingdom},
  document_type = {Conference Paper},
  journal = {Innovative Applications of Artificial Intelligence - Conference Proceedings},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-0031619008&partnerID=40&md5=d02ff2919f12974df86b5354843471fc}
}

@ARTICLE{Anderson1998452,
  author = {Anderson, S.a b , Tourlas, K.a },
  title = {Design for Proof: An Approach to the Design of Domain-Specific Languages},
  journal = {Formal Aspects of Computing},
  year = {1998},
  volume = {10},
  pages = {452-468},
  number = {5-6},
  note = {cited By (since 1996) 2},
  abstract = {We propose that the domain of a Domain-Specific Language (DSL) can
	be characterised by: 1. the class of environments in which systems
	developed in the language are expected to operate; and 2. the class
	of properties which such systems are expected to possess. The design
	of DSLs should therefore include the development of a proof system
	that eases the task of proving the properties in the class identified
	for the anticipated operating environments. We develop these ideas
	in the context of industrial computing systems by presenting a semantics
	and proof system for a language based on IEC 1131-3, the international
	standard programming language for programmable controllers. Of particular
	significance in this example is the use of a diagrammatic representation
	and the development of a proof system for a class of invariance properties
	that requires only local knowledge of the structure of diagrams.},
  affiliation = {Lab. for the Found. of Comp. Science, Division of Informatics, University
	of Edinburgh, Edinburgh, United Kingdom; LFCS, Division of Informatics,
	University of Edinburgh, Edinburgh EH9 3JZ, United Kingdom},
  author_keywords = {Domain-specific languages; Industrial critical systems; Programmable
	controllers; Programming language design},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-2542596175&partnerID=40&md5=a21d7badd00212559453702afe374f42}
}

@CONFERENCE{Angyal2008463,
  author = {Angyal, L., Lengyel, L., Charaf, H.},
  title = {A synchronizing technique for syntactic model-code round-trip engineering},
  year = {2008},
  pages = {463-472},
  note = {cited By (since 1996) 3},
  abstract = {The introduction of UML class diagrams has not raised the abstraction
	level of development to the extent that was intended: class diagrams
	are only the visual representations of source class skeletons implemented
	in a programming language. To improve the productivity, domain-specific
	languages are applied, which cover a narrow domain, and their high
	abstraction makes use of the domain experts easier. The simultaneous
	evolution of the source code and the software models causes the loss
	of synchronization. Round-tripping the domain-specific models is
	not supported by model-driven development tools, because the abstraction
	gap between the models and the generated code prevents the use of
	general approaches. However, developers should have the opportunity
	of choosing between the artifacts that are more efficient for applying
	the modifications. This paper introduces how different tools achieve
	the preservation of manually written code while the model is evolving.
	In contrast, we present our approach that allows the customization
	of the generated code. The abstraction gap is closed by performing
	model transformations and an incremental merge. © 2008 IEEE.},
  affiliation = {Budapest University of Technology and Economics, Goldmann György tér
	3, H-1111 Budapest, Hungary},
  art_number = {4492428},
  author_keywords = {AST merging; Domain-specific models; Model-code synchronization; Model-driven
	development; Three-way AST differencing},
  document_type = {Conference Paper},
  journal = {Proceedings - Fifteenth IEEE International Conference and Workshops
	on the Engineering of Computer-Based Systems, ECBS 2008},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-44149126009&partnerID=40&md5=4626aef34194e1b83dafdafa6ae3a4d1}
}

@CONFERENCE{Angyal2010308,
  author = {Angyal, L., Lengyel, L., Mészáros, T., Charaf, H.},
  title = {Textual syntax mapping can enable syntactic merging},
  year = {2010},
  volume = {2},
  pages = {308-311},
  note = {cited By (since 1996) 0},
  abstract = {As the support is increasing for textual domain-specific languages
	(DSL), the reconstruction of visual models from the generated textual
	artifacts has also come into focus. The state-of-the-art bidirectional
	approaches support reversible text generation from models using single
	syntax mapping. However, even these tools have not gone such far
	to facilitate the synchronization between models and generated artifacts.
	This paper presents the importance of synchronization and how these
	mappings can enable syntactic reconciliation for custom DSLs. Our
	approach provides algorithms for supporting incremental DSL-driven
	software development, which enables the freedom of choosing between
	the textual or visual editing of artifacts. It depends on the developer
	which representation is more effective for her/him at a specific
	moment.},
  affiliation = {Department of Automation and Applied Informatics, Budapest University
	of Technology and Economics, Goldmann György tér 3, H-1111 Budapest,
	Hungary},
  author_keywords = {DSL; Incremental synchronization; Round-trip engineering; Textual
	syntax mapping},
  document_type = {Conference Paper},
  journal = {ICSOFT 2010 - Proceedings of the 5th International Conference on
	Software and Data Technologies},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-78751531681&partnerID=40&md5=edfaf0e957b0fd52404b6584e77ca3e6}
}

@CONFERENCE{Anonsen2005187,
  author = {Anonsen, S.},
  title = {Experiences in modeling for a domain specific language},
  year = {2005},
  volume = {3297},
  pages = {187-197},
  note = {cited By (since 1996) 3},
  abstract = {Building models with a domain specific language enables targeting
	specific platform and framework functionality. We built a domain
	specific language for use in modeling applications targeting our
	business application framework. Such models are used for tasks including
	generating C# code and producing object-relational mappings for business
	objects. The paper briefly describes the framework and its accompanying
	domain specific language and then describes issues we encountered
	in using an unconstrained UML tool to express our models, solutions
	we developed to deal with those issues and observations about the
	suitability of UML for application to such problems. We found that
	making a general-purpose, extensible modeling language serve the
	needs of a targeted domain specific language is a lot of work and
	is only partially successful. We conclude that what is needed is
	a more general purpose framework for creating domain specific languages
	and tools for them. © Springer-Verlag Berlin Heidelberg 2005.},
  affiliation = {Microsoft Corporation},
  document_type = {Conference Paper},
  journal = {Lecture Notes in Computer Science},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-23944450600&partnerID=40&md5=807e2fe95abb1996f24b64070de49ed9}
}

@CONFERENCE{Antao2008747,
  author = {Antao, T.a , Hastings, I.a , McBurney, P.b },
  title = {Ronald: A domain-specific language to study the interactions between
	malaria infections and drug treatments},
  year = {2008},
  pages = {747-752},
  note = {cited By (since 1996) 0},
  abstract = {Malaria kills more than 1 million people a year, mostly children in
	sub-Saharan Africa. Antimalarial drug resistance is one of the greatest
	challenges facing malaria control today. We present Ronald, a Domain-Specific
	Language to model the fundamental forces driving antimalarial drug
	resistance including drug pharmacokinetics and pharmacodynamics,
	drug regimens and parasite genotypes. Example of applications of
	this language include the study of the consequences of counterfeit
	or lower quality drugs, the implications of different dosage regimens,
	the impact of drug half life on the emerging and spread of resistance
	and the benefits and drawbacks of combination therapies, among many
	others.},
  affiliation = {Liverpool School of Tropical Medicine, University of Liverpool, Liverpool,
	United Kingdom; Department of Computer Science, University of Liverpool,
	Liverpool, United Kingdom},
  author_keywords = {Bioin-formatics; Domain specific languages; Infectious diseases; Malaria;
	Pharmacology},
  document_type = {Conference Paper},
  journal = {Proceedings of the 2008 International Conference on Bioinformatics
	and Computational Biology, BIOCOMP 2008},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-62649104797&partnerID=40&md5=d3250f427fcadf0e262812fde5caaf1b}
}

@CONFERENCE{Antkiewicz2007927,
  author = {Antkiewicz, M.},
  title = {Round-trip engineering using framework-specific modeling languages},
  year = {2007},
  pages = {927-928},
  note = {cited By (since 1996) 1},
  abstract = {This research explores the synergies between object-oriented application
	frameworks and model-driven engineering. We propose Framework-Specific
	Modeling Languages (FSMLs) which are domain-specific modeling languages
	designed for areas of concern to object-oriented frameworks. A framework-specific
	model expressed using an FSML describes how an application built
	on top of a framework is using the framework. The semantics of FSMLs
	can be precisely defined based on framework-completion knowledge:
	the prescribed steps and rules of writing the framework-completion
	code for the given framework. The mapping between the abstract syntax
	of an FSML and its base framework's API enables automatic forward-,
	reverse-, and round-trip engineering of the completion code.},
  affiliation = {University of Waterloo},
  author_keywords = {Framework-specific modeling; Framework-specific modeling languages;
	FSMLs; Object-oriented frameworks; Roundtrip engineering},
  document_type = {Conference Paper},
  journal = {Proceedings of the Conference on Object-Oriented Programming Systems,
	Languages, and Applications, OOPSLA},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-42149170082&partnerID=40&md5=b590eda523ea99f7a37c8437c546d340}
}

@ARTICLE{Antkiewicz2006692,
  author = {Antkiewicz, M., Czarnecki, K.},
  title = {Framework-specific modeling languages with round-trip engineering},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2006},
  volume = {4199 LNCS},
  pages = {692-706},
  note = {cited By (since 1996) 11},
  abstract = {We propose Framework-Specific Modeling Languages (FSMLs) as a special
	category of Domain-Specific Modeling Languages that are defined on
	top of an object-oriented application framework. They are used to
	express models showing how framework-provided abstractions are used
	in framework-based application code. Such models may be connected
	with the application code through a forward and a reverse mapping
	enabling round-trip engineering. We also propose a lightweight and
	iterative approach to round-trip engineering. Furthermore, we present
	a proof-of-concept FSML for modeling the interaction of workbench
	parts within Eclipse. Finally, we identify a number of challenges,
	opportunities, and directions for future research on FSMLs. © Springer-Verlag
	Berlin Heidelberg 2006.},
  affiliation = {University of Waterloo},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-33750283757&partnerID=40&md5=d50e75c6634f2af87c1e460681602e9c}
}

@CONFERENCE{Antkiewicz2006738,
  author = {Antkiewicz, M., Czarnecki, K.},
  title = {Round-trip engineering of eclipse plug-ins using eclipse workbench
	part interaction FSML},
  year = {2006},
  volume = {2006},
  pages = {738-739},
  note = {cited By (since 1996) 0},
  abstract = {A Framework-Specific Modeling Language (FSML) is a kind of Domain-Specific
	Modeling Language that is used for modeling framework-based software.
	FSMLs enable automated round-trip engineering over non-trivial model-to-code
	mappings and thereby simplify the task of creating and evolving framework-based
	applications. In this demonstration, we present a prototype implementation
	of Eclipse Workbench Part Interaction, a FSML capturing an aspect
	of Eclipse plug-in development. We walk through an example Eclipse
	plug-in development scenario and demonstrate the round-trip engineering
	capabilities of the prototype.},
  affiliation = {University of Waterloo, Canada},
  art_number = {1176701},
  author_keywords = {Domain-specific modeling; Eclipse; Framework-Specific Modeling Language;
	FSML; Object-oriented application framework; Roundtrip engineering;
	Workbench Part Interaction; WPI},
  document_type = {Conference Paper},
  journal = {Proceedings of the Conference on Object-Oriented Programming Systems,
	Languages, and Applications, OOPSLA},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-34248398474&partnerID=40&md5=785ac158cb47c71e69a940c70001a7fa}
}

@ARTICLE{Antkiewicz2009795,
  author = {Antkiewicz, M., Czarnecki, K., Stephan, M.},
  title = {Engineering of framework-specific modeling languages},
  journal = {IEEE Transactions on Software Engineering},
  year = {2009},
  volume = {35},
  pages = {795-824},
  number = {6},
  note = {cited By (since 1996) 8},
  abstract = {Framework-specific modeling languages (FSMLs) help developers build
	applications based on object-oriented frameworks. FSMLs model abstractions
	and rules of application programming interfaces (APIs) exposed by
	frameworks and can express models of how applications use APIs. Such
	models aid developers in understanding, creating, and evolving application
	code. We present four exemplar FSMLs and a method for engineering
	new FSMLs. The method was created postmortem by generalizing the
	experience of building the exemplars and by specializing existing
	approaches to domain analysis, software development, and quality
	evaluation of models and languages. The method is driven by the use
	cases that the FSML under development should support and the evaluation
	of the constructed FSML is guided by two existing quality frameworks.
	The method description provides concrete examples for the engineering
	steps, outcomes, and challenges. It also provides strategies for
	making engineering decisions. Our work offers a concrete example
	of software language engineering and its benefits. FSMLs capture
	existing domain knowledge in language form and support application
	code understanding through reverse engineering, application code
	creation through forward engineering, and application code evolution
	through round-trip engineering. © 2009 IEEE.},
  affiliation = {Department of Electrical and Computer Engineering, University of Waterloo,
	Waterloo, ON, N2L 3G1, Canada},
  art_number = {4907004},
  author_keywords = {Application programming interface (API); Domain-specific language;
	Evolution; Feature model; Forward engineering; Framework-specific
	model; Framework-specific modeling language; Mapping; Object-oriented
	framework; Reverse engineering; Round-trip engineering},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-73549111312&partnerID=40&md5=798e1c467434fba71e3710a3ddffd23d}
}

@CONFERENCE{Apter20115,
  author = {Apter, Y., Lorenz, D.H., Mishali, O.},
  title = {Toward debugging programs written in multiple domain specific aspect
	languages},
  year = {2011},
  pages = {5-8},
  note = {cited By (since 1996) 0},
  abstract = {Debugging an application written in multiple domain-specific aspect
	languages (DSALs), one for each domain, is a complex task. Each DSAL
	introduces its own source level abstractions, which should be visible
	and traceable during the debugging process. A debugging infrastructure
	for multiple DSAL applications should also enhance the viewing and
	tracing of the interactions between aspects implemented in the different
	DSALs. We report on initial steps to define and implement a debugger
	for Awesome, a co-weaving framework for composing multiple DSALs.
	The problem is illustrated through several scenarios, and design
	principles for a multiple DSAL debugging infrastructure are highlighted.},
  affiliation = {Open University of Israel, 1 Univeristy Rd., Raanana 43107, Israel},
  author_keywords = {Aspect-oriented programming; Debugging; Domain-specific languages},
  document_type = {Conference Paper},
  journal = {Proceedings of the 6th Annual Workshop on Domain-Specific Aspect
	Languages, DSAL 2011},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-79955366492&partnerID=40&md5=bd4c24799ebf9a94153be12c4e9e98b7}
}

@CONFERENCE{Aquino20101195,
  author = {Aquino, N.a , Vanderdonckt, J.a b , Pastor, O.a },
  title = {Transformation templates: Adding flexibility to model-driven engineering
	of user interfaces},
  year = {2010},
  pages = {1195-1202},
  note = {cited By (since 1996) 2},
  abstract = {Model-based user interface (UI) development environments are aimed
	at generating one or many UIs from one or many models. Model-driven
	engineering (MDE) of UIs is assumed to be superior to those environments
	since they make the UI design knowledge visible, explicit, and external,
	for instance as model-to-model transformations and model-to-code
	compilation rules. These transformations and rules are often considered
	inflexible, complex to express, and hard to develop by UI designers
	and developers who are not necessarily experts in MDE. In order to
	overcome these shortcomings, this paper introduces "Transformation
	Templates", an approach that is adding flexibility to the MDE of
	UIs by externalizing the transformation logic of UI models, and making
	it editable, customizable, and reusable. It is also intended to make
	it easier for UI designers to specify the transformations. A Transformation
	Template specifies a series of parameters that enable designers to
	parameterize the model transformation process at the concept level
	that is of a higher level of abstraction than at the level of physical
	properties of UI widgets. This paper presents an editor for Transformation
	Templates and an example of Parameter Type. Transformation Templates
	can be effectively and efficiently used in any circumstances where
	the transformation knowledge needs to be modified by non-experts,
	such as in domain specific languages where flexibility is required.
	© 2010 ACM.},
  affiliation = {Centro de Investigación en Métodos de Producción de Software, Universidad
	Politécnica de Valencia, Camino de Vera s/n, 46022 Valencia, Spain;
	Université Catholique de Louvain, Louvain School of Management (LSM),
	Place des Doyens, 1, B-1348, Louvain-la-Neuve, Belgium},
  author_keywords = {model-driven engineering of user interfaces; parameter; template;
	user interface model; user interface model transformation},
  document_type = {Conference Paper},
  journal = {Proceedings of the ACM Symposium on Applied Computing},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-77954734070&partnerID=40&md5=4a0dfc051084321c1372d7118a16e8ca}
}

@ARTICLE{Armstrong2008135,
  author = {Armstrong, C.W., Ford, R.W., Freeman, T.L., Riley, G.D.},
  title = {NOAH: A CSP-based language for describing the behaviour of coupled
	models},
  journal = {Software - Practice and Experience},
  year = {2008},
  volume = {38},
  pages = {135-159},
  number = {2},
  note = {cited By (since 1996) 1},
  abstract = {Scientists in many fields rely on computational simulations that are
	built from a collection of separate, inter-communicating single models
	(e.g. Earth System Models often consist of single models of the ocean,
	atmosphere and land processes); these simulations are called coupled
	models. Coupled models allow scientists to simulate richer scientific
	phenomena than is possible by running single models alone. Scientific
	interest is typically focused on the investigation served by a coupled
	model, rather than the complex and inadequately supported software
	engineering activity of constructing it. In response to this lack
	of support, a coupling methodology called the Flexible Coupling Approach
	(FCA) has been developed at the University of Manchester together
	with a tool that implements this approach, the Bespoke Framework
	Generator (BFG). Whilst being adequate for a large class of coupled
	models (e.g., many Earth System Models), the BFG is unable to handle
	coupled models with complex behavioural requirements (in terms of
	the scheduling and inter-communication of single models). To capture
	these more complex expressions of behaviour, this paper introduces
	NOAH, a domain-specific language that is implemented in the formalism
	Communicating Sequential Processes (CSP), and which is used by a
	new implementation of the FCA, called the CSP-based Framework Generator
	(CFG). NOAH is introduced through two example coupled models which
	have complex behavioural requirements. NOAH represents the first
	attempt to bring the advantages of using formal descriptions of coupled
	models to application scientists, providing a language in which to
	specify coupled model behaviour precisely and the ability to check
	that a coupled model is deadlock free using tools such as the Failures-Divergence
	Refinement (FDR) model checker. Copyright © 2007 John Wiley & Sons,
	Ltd.},
  affiliation = {School of Computer Science, University of Manchester, Oxford Road,
	Manchester M13 9PL, United Kingdom},
  author_keywords = {Automatic code generation; Coupled modelling; CSP; Deadlock; FCA},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-39449090462&partnerID=40&md5=f47103ef5562ba4515fcd6c24b454c67}
}

@CONFERENCE{Arora2008919,
  author = {Arora, R.},
  title = {Raising the level of abstraction of application-level Checkpointing},
  year = {2008},
  pages = {919-920},
  note = {cited By (since 1996) 0},
  abstract = {Checkpointing is one of the key ingredients required for writing fault-tolerant
	applications for dynamic and distributed computing environments.
	Manual reengineering of large legacy applications to insert checkpointing
	mechanisms is a daunting task, mainly due to the time and cost overheads.
	This poster describes an approach for nonintrusive reengineering
	of existing applications to insert a Checkpointing and Restart (CaR)
	mechanism. The user describes the CaR specifications at a high-level
	and the required code is semi-automatically generated and inserted
	in the application.},
  affiliation = {Department of Computer and Information Sciences, University of Alabama
	at Birmingham, 1300 University Blvd, Birmingham, AL 35294-1170, United
	States},
  author_keywords = {Checkpointing; Domain-specific language},
  document_type = {Conference Paper},
  journal = {Proceedings of the Conference on Object-Oriented Programming Systems,
	Languages, and Applications, OOPSLA},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-63349085463&partnerID=40&md5=d07a155acbf3263b614101dad3f527ea}
}

@CONFERENCE{Arora2009339,
  author = {Arora, R., Bangalore, P.},
  title = {A framework for raising the level of abstraction of explicit parallelization},
  year = {2009},
  pages = {339-342},
  note = {cited By (since 1996) 0},
  abstract = {In this research, a Framework for Synthesizing Parallel Applications
	(FraSPA) in a user-guided manner is being developed. The FraSPA would
	facilitate the synthesis of parallel applications from existing sequential
	applications and middleware components for multiple-platforms and
	diverse domains. The framework design is based upon design patterns
	and generative programming techniques. The main goal of this research
	is to raise the level of abstraction of the widely used low-level
	parallel programming approaches. A technique to separate parallel
	and sequential concerns will be demonstrated through this work. Other
	contributions will be in the area of design patterns and Domain-Specific
	Languages (DSLs) for parallel computing. The design patterns, along
	with the DSLs, will promote code reuse and code correctness. There
	would be a reduction in code complexity and code maintenance would
	become easy. The productivity of the end-users will increase. This
	research can be broadly classified as Software Engineering for High
	Performance Computing. © 2009 IEEE.},
  affiliation = {Department of Computer and Information Sciences, University of Alabama
	at Birmingham, CH 131, 1300 University Blvd, Birmingham, AL 35294-1170,
	United States},
  art_number = {5071016},
  document_type = {Conference Paper},
  journal = {2009 31st International Conference on Software Engineering - Companion
	Volume, ICSE 2009},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-70349665281&partnerID=40&md5=26fd105d0cfbbdcd25f71f53c3bb630e}
}

@CONFERENCE{Arora200951,
  author = {Arora, R., Bangalore, P., Mernik, M.},
  title = {Developing scientific applications using generative programming},
  year = {2009},
  pages = {51-58},
  note = {cited By (since 1996) 1},
  abstract = {Scientific applications usually involve large number of distributed
	and dynamic resources and huge datasets. A mechanism like checkpointing
	is essential to make these applications resilient to failures. Using
	checkpointing as an example, this paper presents an approach for
	integrating the latest software engineering techniques with the development
	of scientific software. Generative programming is used in this research
	to achieve the goals of non-intrusive reengineering of existing applications
	to insert the checkpointing mechanism and to decouple the checkpointing-specifications
	from its actual implementation. The end-user specifies the checkpointing
	details at a higher level of abstraction, using which the necessary
	code is generated and woven into the application. The lessons learned
	and the implementation approach presented in this paper can be applied
	to the development of scientific applications in general. The paper
	also demonstrates that the generated code does not introduce any
	inaccuracies and its performance is comparable to the manually inserted
	code. © 2009 IEEE.},
  affiliation = {Department of Computer and Information Sciences, University of Alabama,
	Birmingham, AL, United States},
  art_number = {5069162},
  document_type = {Conference Paper},
  journal = {Proceedings of the 2009 ICSE Workshop on Software Engineering for
	Computational Science and Engineering, SECSE 2009},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-70349925606&partnerID=40&md5=4d0b558d80f4c4e35b6e4194ca50124f}
}

@ARTICLE{Arora200826,
  author = {Arora, R., Mernik, M., Bangalore, P., Roychoudhury, S., Mukkai, S.},
  title = {A domain-specific language for application-level checkpointing},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2008},
  volume = {5375 LNCS},
  pages = {26-38},
  note = {cited By (since 1996) 0},
  affiliation = {Dept. of Computer and Information Sciences, University of Alabama
	at Birmingham, 1300 University Boulevard, Birmingham, AL 35294-1170,
	United States},
  author_keywords = {Abstraction; Checkpointing; Domain-Specific Languages; Program Transformation;
	Reliability},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-58449084080&partnerID=40&md5=144b2c565036998e0d1f295c407cacd8}
}

@ARTICLE{Arora2011227,
  author = {Arora, R.a , Bangalore, P.a , Mernik, M.a b },
  title = {A technique for non-invasive application-level checkpointing},
  journal = {Journal of Supercomputing},
  year = {2011},
  volume = {57},
  pages = {227-255},
  number = {3},
  note = {cited By (since 1996) 0},
  abstract = {One of the key elements required for writing self-healing applications
	for distributed and dynamic computing environments is checkpointing.
	Checkpointing is a mechanism by which an application is made resilient
	to failures by storing its state periodically to the disk. The main
	goal of this research is to enable non-invasive reengineering of
	existing applications to insert Application-Level Checkpointing (ALC)
	mechanism. The Domain-Specific Language (DSL) developed in this research
	serves as a perfect means towards this end and is used for obtaining
	the ALC-specifications from the end-users. These specifications are
	used for generating and inserting the actual checkpointing code into
	the existing application. The performance of the application having
	the generated checkpointing code is comparable to the performance
	of the application in which the checkpointing code was inserted manually.
	With slight modifications, the DSL developed in this research can
	be used for specifying the ALC mechanism in several base languages
	(e.g., C/C++, Java, and FORTRAN). © 2010 Springer Science+Business
	Media, LLC.},
  affiliation = {Dept. of Computer and Information Sciences, University of Alabama
	at Birmingham, 1300 University Blvd., Birmingham, AL 35294-1170,
	United States; Faculty of Electrical Engineering and Computer Science,
	University of Maribor, Smetanova 17, Maribor 2000, Slovenia},
  author_keywords = {Application-level checkpointing; Domain-specific language; Fault-tolerance},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-80051547950&partnerID=40&md5=01bc2fcfaaf94b654dad6707dabb7580}
}

@CONFERENCE{Arpaia20091716,
  author = {Arpaia, P.a b , Buzio, M.b , Fiscarelli, L.a b , Inglese, V.a c ,
	La Commara, G.a , Walckiers, L.b },
  title = {Measurement-Domain Specific Language for magnetic test specifications
	at CERN},
  year = {2009},
  pages = {1716-1720},
  note = {cited By (since 1996) 2},
  abstract = {A Measurement-Domain Specific Language (MDSL) for test procedure definition,
	measurement tasks synchronization, and instrument configuration is
	proposed. MDSL is a formal language specially designed for a specific
	domain of measurement and test, aimed at specifying complete, easy-to-understand,
	-reuse, and -maintain applications efficiently and quickly. Owing
	to MDSL constructs capability of abstracting key concepts of the
	domain, the test engineer can write more concise and higher level
	programs in shorter time without being a skilled programmer. The
	MDSL has been applied to the specifications of superconducting magnet
	tests of the Large Hadron Collider at CERN. © 2009 IEEE.},
  affiliation = {Dipartimento di Ingegneria, Università del Sannio, Benevento, Italy;
	Technology Department, Magnets, Superconductors and Cryostats, CERN,
	Genève, Switzerland; Dipartimento di Ingegneria Elettrica, Università
	degli Studi di Napoli - Federico II, Napoli, Italy},
  art_number = {5168733},
  author_keywords = {Component; Measurement, magnetic variables measurement, automatic
	test equipment},
  document_type = {Conference Paper},
  journal = {2009 IEEE Intrumentation and Measurement Technology Conference, I2MTC
	2009},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-70449794615&partnerID=40&md5=e4e9888ceafab8eb66d421908efbb3c1}
}

@CONFERENCE{Arsanjani2002287,
  author = {Arsanjani, A.},
  title = {Business compilers: Towards supporting a highly re-configurable architectural
	style for service-oriented architecture},
  year = {2002},
  pages = {287-288},
  note = {cited By (since 1996) 2},
  abstract = {Grammar-oriented Object design (GOOD) uses a business domain-specific
	language to model the flow and constraints on a set of collaborating
	enterprise components (EC). Maintenance of these components and their
	flow composition is a major issue. We present a software tool called
	the Business Compiler (BC) that facilitates the definition, debugging
	and execution of business flow languages in order to help animate
	and execute the collaboration of components reflecting the business
	process steps defined by a business modeler. Architects enhance the
	grammar with component services that serve as actions in the grammar.
	The combination of flow definition by modelers and component services
	by software architects provides a powerful collaborative environment
	for enabling the incremental creation of a highly re-configurable
	architectural style. BC consists of an application framework that
	supports component-based development and includes a GUI debugger
	front end. This helps modelers by providing dynamic documentation
	and can be used by architects to create and execute a formal specification
	of business flow to facilitate maintainability through a highly adaptive
	and re-configurable architectural style.},
  document_type = {Conference Paper},
  journal = {Conference on Software Maintenance},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-0036437984&partnerID=40&md5=d6cf58009face7b8e1334d448fb004df}
}

@CONFERENCE{Arsanjani2001130,
  author = {Arsanjani, A.},
  title = {A domain-language approach to designing dynamic enterprise component-based
	architectures to support business services},
  year = {2001},
  number = {TOOL},
  pages = {130-142},
  note = {cited By (since 1996) 3},
  abstract = {In this paper we present the solutions to a major subset of problems
	facing component-based development and integration (CBDI). These
	solutions include patterns, techniques, design artifacts and activities
	across what we have identified as the five domains of CBDI: namely,
	organizational, methodological, architectural, technology implementation
	and infrastructure. We present a taxonomy of CBDI domains that transcends
	technology and tools, to cover a wider spectrum of business and methodology
	concerns across an enterprise. Representative examples from the methodology
	and the architecture domains are given. Domain-specific languages
	are combined with the object paradigm to yield grammar-oriented object
	design (GOOD). GOOD helps identify and map reusable subsystems in
	a business model to a well-mannered component-first software architecture.
	We then demonstrate how these manners should be added as first-class
	constructs to the component-based paradigm of software engineering.},
  affiliation = {IBM Corporation, Maharishi University of Management, Endicott, NY,
	United States},
  author_keywords = {Adaptive object models; Component-based development; Domain-specific
	languages; Grammar-oriented object design; Methodology; Software
	architecture},
  document_type = {Conference Paper},
  journal = {Proceedings of the Conference on Technology of Object-Oriented Languages
	and Systems, TOOLS},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-0034860285&partnerID=40&md5=9919651aa96ae18e43b29d4c75994871}
}

@CONFERENCE{Arsanjani2001370,
  author = {Arsanjani, A.},
  title = {Rule pattern language 2001: A pattern language for adaptive manners
	and scalable business rule design and construction},
  year = {2001},
  number = {TOOL},
  pages = {370-376},
  note = {cited By (since 1996) 1},
  abstract = {Business Rules, Constraints, Policies and Workflow and in general,
	the "manners" or rules governing the behavior of objects and components
	within object-oriented software architectures need to be managed,
	designed and implemented across the software development life-cycle.
	With such far-reaching influence and impact on software development,
	it is expected that the process of Rule Management would be honed
	into a more disciplined set of practices and methods that could be
	applied uniformly across multiple projects. The expectation to achieve
	an engineering discipline through the distillation of the industry's
	body of knowledge pertaining to the way rules are handled has been
	the motivation of workshops and harvesting of best-practices across
	multiple projects in various industries over the past six years.
	This has led to a continuous refinement and update of the Rule Pattern
	Language (RPL). In this paper, we provide and overview of the patterns
	and focus on Rule Object, Type Rule and Configurabl e Workflow as
	three representative patterns in greater detail.},
  author_keywords = {Adaptive object models; Business rules; Component-based development;
	Domain-specific languages; Grammar-oriented object design; Methodology;
	Rule engine; Software architecture},
  document_type = {Conference Paper},
  journal = {Proceedings of the Conference on Technology of Object-Oriented Languages
	and Systems, TOOLS},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-0034866733&partnerID=40&md5=156679cefbc4e014e92c712381862609}
}

@CONFERENCE{Aschauer201049,
  author = {Aschauer, T., Dauenhauer, G., Pree, W.},
  title = {A modeling language's evolution driven by tight interaction between
	academia and industry},
  year = {2010},
  volume = {2},
  pages = {49-58},
  note = {cited By (since 1996) 1},
  abstract = {Domain specific languages play an important role in model-driven engineering
	of software-intensive industrial systems. A rich body of knowledge
	exists on the development of languages, modeling environments, and
	transformation systems. The understanding of architectural choices
	for combining these parts into a feasible solution, however, is not
	particularly deep. We report on an endeavor in the realm of a technology
	transfer process from academia to industry, where we encountered
	unexpected influences of the architecture on the modeling language.
	By examining the evolution of our language and its programming interface,
	we show that these influences mainly stemmed from practical considerations;
	for identifying these early on, tight interaction between our research
	lab and the industrial partner was key. In addition, we share insights
	into the practice of cooperating with industry by presenting essential
	lessons we learned. © 2010 ACM.},
  affiliation = {University of Salzburg, C. Doppler Laboratory Embedded Software Systems,
	Jakob-Haringer-Str. 2, 5020 Salzburg, Austria},
  author_keywords = {academic-industry cooperation; Clabjects; domains specific language;
	model driven engineering architecture},
  document_type = {Conference Paper},
  journal = {Proceedings - International Conference on Software Engineering},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-77954708867&partnerID=40&md5=c62dd561dc40a9a6dbb4a8ad6244b671}
}

@ARTICLE{Aschauer2008217,
  author = {Aschauer, T., Dauenhauer, G., Pree, W.},
  title = {Towards reusable automation system components},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2008},
  volume = {5030 LNCS},
  pages = {217-220},
  note = {cited By (since 1996) 0},
  abstract = {In this paper we present a domain specific language for describing
	an automation system, that is, its hardware and software components.
	These domain components form the basis of large-scale reuse so that
	specific automation systems can be configured efficiently. © 2008
	Springer-Verlag Berlin Heidelberg.},
  affiliation = {C. Doppler Laboratory, Embedded Software Systems, University of Salzburg,
	Jakob-Haringer-Str. 2, Salzburg 5020, Austria},
  author_keywords = {Component reuse; Domain specific modeling language},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-50949096097&partnerID=40&md5=9cb076f619fd5e9841a9e18168682363}
}

@CONFERENCE{Atkey200937,
  author = {Atkey, R., Lindley, S., Yallop, J.},
  title = {Unembedding domain-specific languages},
  year = {2009},
  pages = {37-48},
  note = {cited By (since 1996) 6},
  abstract = {Higher-order abstract syntax provides a convenient way of embedding
	domain-specific languages, but is awkward to analyse and manipulate
	directly. We explore the boundaries of higher-order abstract syntax.
	Our key tool is the unembedding of embedded terms as de Bruijn terms,
	enabling intensional analysis. As part of our solution we present
	techniques for separating the definition of an embedded program from
	its interpretation, giving modular extensions of the embedded language,
	and different ways to encode the types of the embedded language.
	Copyright © 2009 ACM.},
  affiliation = {School of Informatics, University of Edinburgh, LFCS},
  author_keywords = {Domain-specific languages; Higher-order abstract syntax; Type classes;
	Unembedding},
  document_type = {Conference Paper},
  journal = {Haskell'09 - Proceedings of the 2009 ACM SIGPLAN Haskell Symposium},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-72949120676&partnerID=40&md5=ed8e6a02e976e68dce5d151add33701a}
}

@ARTICLE{Atkins1999334,
  author = {Atkins, D.L., Ball, T.},
  title = {Mawl: A domain-specific language for form-based services},
  journal = {IEEE Transactions on Software Engineering},
  year = {1999},
  volume = {25},
  pages = {334-346},
  number = {3},
  note = {cited By (since 1996) 27},
  abstract = {A form-based service is one in which the flow of data between service
	and user is described by a sequence of query/response interactions,
	or forms. Mawl is a domain-specific language for programming form-based
	services in a device-independent manner. We focus on Mawl's form
	abstraction, which is the means for separating service logic from
	user interface description, and show how this simple abstraction
	addresses seven issues in service creation, analysis, and maintenance:
	compile-time guarantees, implementation flexibility, rapid prototyping,
	testing and validation, support for multiple devices, composition
	of services, and usage analysis.},
  affiliation = {Software Production Research Department, Bell Laboratories, Lucent
	Technologies, 263 W. Shuman Blvd, Naperville, IL 60566., United States},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-0032594220&partnerID=40&md5=574c61877e31a5f7cd36b8fbf2f9f4da}
}

@ARTICLE{Atkinson2010206,
  author = {Atkinson, C., Stoll, D., Bostan, P.},
  title = {Orthographic software modeling: A practical approach to view-based
	development},
  journal = {Communications in Computer and Information Science},
  year = {2010},
  volume = {69 CCIS},
  pages = {206-219},
  note = {cited By (since 1996) 0},
  abstract = {Although they are significantly different in how they decompose and
	conceptualize software systems, one thing that all advanced software
	engineering paradigms have in common is that they increase the number
	of different views involved in visualizing a system. Managing these
	different views can be challenging even when a paradigm is used independently,
	but when they are used together the number of views and inter-dependencies
	quickly becomes overwhelming. In this paper we present a novel approach
	for organizing and generating the different views used in advanced
	software engineering methods that we call Orthographic Software Modeling
	(OSM). This provides a simple metaphor for integrating different
	development paradigms and for leveraging domain specific languages
	in software engineering. Development environments that support OSM
	essentially raise the level of abstraction at which developers interact
	with their tools by hiding the idiosyncrasies of specific editors,
	storage choices and artifact organization policies. The overall benefit
	is to significantly simplify the use of advanced software engineering
	methods. © 2010 Springer-Verlag.},
  affiliation = {Institute of Computer Science, University of Mannheim, Mannheim 68131,
	Germany},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-78650723778&partnerID=40&md5=7ceb58408e889ead9cd4bb13f6005959}
}

@CONFERENCE{Atkinson200971,
  author = {Atkinson, C., Stoll, D., Bostan, P.},
  title = {Supporting view-based development through orthographic software modeling},
  year = {2009},
  pages = {71-86},
  note = {cited By (since 1996) 1},
  abstract = {Although they are significantly different in how they decompose and
	conceptualize software systems, one thing that all advanced software
	engineering paradigms have in common is that they increase the number
	of different views involved in visualizing a system. Managing these
	different views can be challenging even when a paradigm is used independently,
	but when they are used together the number of views and inter-dependencies
	quickly becomes overwhelming. In this paper we present a novel approach
	for organizing and generating the different views used in advanced
	software engineering methods that we call Orthographic Software Modeling
	(OSM). This provides a simple metaphor for integrating different
	development paradigms and for leveraging domain specific languages
	in software engineering. Development environments that support OSM
	essentially raise the level of abstraction at which developers interact
	with their tools by hiding the idiosyncrasies of specific editors,
	storage choices and artifact organization policies. The overall benefit
	is to significantly simplify the use of advanced software engineering
	methods.},
  affiliation = {Institute of Computer Science, University of Mannheim, 68131 Mannheim,
	Germany},
  document_type = {Conference Paper},
  journal = {ENASE 2009 - 4th International Conference on Evaluation of Novel
	Approaches to Software Engineering, Proceedings},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-74549123856&partnerID=40&md5=9e2c6a8db2bc03b7037a4459b5d41592}
}

@ARTICLE{Atkinson2009742,
  author = {Atkinson, C.a , Gutheil, M.b , Kennel, B.a },
  title = {A flexible infrastructure for multilevel language engineering},
  journal = {IEEE Transactions on Software Engineering},
  year = {2009},
  volume = {35},
  pages = {742-755},
  number = {6},
  note = {cited By (since 1996) 8},
  abstract = {Although domain-specific modeling tools have come a long way since
	the modern era of model-driven development started in the early 1990s
	and now offer an impressive range of features, there is still significant
	room for enhancing the flexibility they offer to end users and for
	combining the advantages of domain-specific and general-purpose languages.
	To do this, however, it is necessary to enhance the way in which
	the current generation of tools view metamodeling and support the
	representation of the multiple, ontological classification levels
	that often exist in subject domains. State-of-the-art tools essentially
	allow users to describe the abstract and concrete syntaxes of a language
	in the form of metamodels and to make statements in that language
	in the form of models. These statements typically convey information
	in terms of types and instances in the domain (e.g., the classes
	and objects of UML), but not in terms of types of types (i.e., domain
	metaclasses), and types of types of types, and so on, across multiple
	classification levels. In essence, therefore, while they provide
	rich support for linguistic metamodeling, the current generation
	of tools provides little if any built-in support for modeling ontological
	classification across more than one type/instance level in the subject
	domain. In this paper, we describe a prototype implementation of
	a new kind of modeling infrastructure that, by providing built-in
	support for multiple ontological as well as linguistic classification
	levels, offers various advantages over existing language engineering
	approaches and tools. These include the ability to view a single
	model from the perspective of both a general-purpose and a domain-specific
	modeling language, the ability to define constraints across multiple
	ontological classification levels, and the ability to tie the rendering
	of model elements to ontological as well as linguistic types over
	multiple classification levels. After first outlining the key conceptual
	ingredients of this new infrastructure and presenting the main elements
	of our current realization, we show these benefits through two small
	examples. © 2009 IEEE.},
  affiliation = {Institute for Computer Science, University of Mannheim, 6 Bebäudeteil
	B, Seminargebäde, D-68131 Mannheim, Germany; Itemis AG, Augustusring
	32, 53111 Bonn, Germany},
  art_number = {4907005},
  author_keywords = {Language engineering; Metamodeling; Multilevel modeling},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-73549105908&partnerID=40&md5=c097cabe7503d92f1f5f90dfe3dd8284}
}

@ARTICLE{Attardi2003275,
  author = {Attardi, G., Cisternino, A.},
  title = {Multistage programming support in CLI},
  journal = {IEE Proceedings: Software},
  year = {2003},
  volume = {150},
  pages = {275-281},
  number = {5},
  note = {cited By (since 1996) 2},
  abstract = {Execution environments such as CLR and JVM provide many features needed
	by multistage programming languages, though there is no explicit
	support for them. Besides, staged computations are widely used in
	areas such as Web programming and generative programming. In the
	paper the authors present a possible CLR extension (which can also
	be ported to JVM) to provide support for multi-stage languages. The
	extension is based on CodeBricks - a framework for run-time code
	generation which allows expressing homogenous transformations of
	intermediate language as a composition of methods. They discuss the
	code generation strategy adopted by the framework and how an extension
	to CLR may improve the performance of multi-stage applications, although
	CodeBricks can also be implemented using the standard CLR. An informal
	discussion of how to translate MetaML staging annotations into CodeBricks
	is provided with a simple example.},
  affiliation = {Dipartimento di Informatica, via Buonarroti, 2, I-56127, Pisa, Italy},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-0344494795&partnerID=40&md5=dca0d34675fabc9ba7c9f192a782e6b9}
}

@ARTICLE{Attardi2003306,
  author = {Attardi, G.a , Cisternino, A.a , Kennedy, A.b },
  title = {CodeBricks: Code fragments as building blocks},
  journal = {ACM SIGPLAN Notices},
  year = {2003},
  volume = {38},
  pages = {306-314},
  number = {10},
  note = {cited By (since 1996) 1},
  abstract = {We present a framework for code generation that allows programs to
	manipulate and generate code at the source level while the joining
	and splicing of executable code is carried out automatically at the
	intermediate code/VM level. The framework introduces a data type
	Code to represent code fragments: methods/operators from this class
	are used to reify a method from a class, producing its representation
	as an object of type Code. Code objects can be combined by partial
	application to other Code objects. Code combinators, corresponding
	to higher-order methods, allow splicing the code of a functional
	actual parameter into the resulting Code object. CodeBricks is a
	library implementing the framework for the .NET Common Language Runtime.
	The framework can be exploited by language designers to implement
	metaprogramming, multistage programming and other language features.
	We illustrate the use of the technique in the implementation of a
	fully featured regular expression compiler that generates code emulating
	a finite state automaton. We present benchmarks comparing the performance
	of the RE matcher built with CodeBricks with the hand written one
	present in .NET.},
  affiliation = {Dipartimento di Informatica, Via Buonarroti 2, I-56127 Pisa, Italy;
	Microsoft Research Ltd, 7, JJ. Thompson Av., CB Cambridge, United
	Kingdom},
  author_keywords = {Domain specific language; Generative programming; Metaprogramming;
	Multistage programming; Program generation; Program transformation;
	Reflection},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-1442264086&partnerID=40&md5=5e8ea4aae4de2ea97081ae7157aad590}
}

@CONFERENCE{Attardi200366,
  author = {Attardi, G.a , Cisternino, A.a , Kennedy, A.b },
  title = {CodeBricks: Code fragments as building blocks},
  year = {2003},
  pages = {66-74},
  note = {cited By (since 1996) 4},
  abstract = {We present a framework for code generation that allows programs to
	manipulate and generate code at the source level while the joining
	and splicing of executable code is carried out automatically at the
	intermediate code/VM level. The framework introduces a data type
	Code to represent code fragments: methods/operators from this class
	are used to reify a method from a class, producing its representation
	as an object of type Code. Code objects can be combined by partial
	application to other Code objects. Code combinators, corresponding
	to higher-order methods, allow splicing the code of a functional
	actual parameter into the resulting code object. CodeBricks is a
	library implementing the framework for the .NET Common Language Runtime.
	The framework can be exploited by language designers to implement
	metaprogramming, multistage programming and other language features.
	We illustrate the use of the technique in the implementation of a
	fully featured regular expression compiler that generates code emulating
	a finite state automaton. We present benchmarks comparing the performance
	of the RE matcher built with CodeBricks with the hand written one
	present in .NET.},
  affiliation = {Dipartimento di Informatica, via Buonarroti 2, I-56127 Pisa, Italy;
	Microsoft Research Ltd, 7, JJ. Thompson Av., CB Cambridge, United
	Kingdom},
  author_keywords = {Domain Specific Language; Generative programming; Metaprogramming;
	Multistage programming; Program generation; Program transformation;
	Reflection},
  document_type = {Conference Paper},
  journal = {Proceedings of the ACM SIGPLAN Symposium on Partial Evaluation and
	Semantics-Based Program Manipulation},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-0038378016&partnerID=40&md5=8d53ac89d0f19d834193dc13e554b9d0}
}

@CONFERENCE{Attig201112,
  author = {Attig, M., Brebner, G.},
  title = {400 Gb/s programmable packet parsing on a single FPGA},
  year = {2011},
  pages = {12-23},
  note = {cited By (since 1996) 0},
  abstract = {Packet parsing is necessary at all points in the modern networking
	infrastructure, to support packet classification and security functions,
	as well as for protocol implementation. Increasingly high line rates
	call for advanced hardware packet processing solutions, while increasing
	rates of change call for high-level programmability of these solutions.
	This paper presents an approach for harnessing modern Field Programmable
	Gate Array (FPGA) devices, which are a natural technology for implementing
	the necessary high-speed programmable packet processing. The paper
	introduces PP: a simple high-level language for describing packet
	parsing algorithms in an implementation-independent manner. It demonstrates
	that this language can be compiled to give high-speed FPGA-based
	packet parsers that can be integrated alongside other packet processing
	components to build network nodes. Compilation involves generating
	virtual processing architectures tailored to specific packet parsing
	requirements. Scalability of these architectures allows parsing at
	line rates from 1 to 400 Gb/s as required in different network contexts.
	Run-time programmability of these architectures allows dynamic updating
	of parsing algorithms during operation in the field. Implementation
	results show that programmable packet parsing of 600 million small
	packets per second can be supported on a single Xilinx Virtex-7 FPGA
	device handling a 400 Gb/s line rate. © 2011 IEEE.},
  affiliation = {Xilinx Labs., 2100 Logic Drive, San Jose, CA 95124, United States},
  art_number = {6062708},
  author_keywords = {Domain-specific languages and compilers; FPGA-based parallel processing;
	High-speed packet processing},
  document_type = {Conference Paper},
  journal = {Proceedings - 2011 7th ACM/IEEE Symposium on Architectures for Networking
	and Communications Systems, ANCS 2011},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-81255129079&partnerID=40&md5=a533d98b2a8913e9ef98e3006fbd9ef0}
}

@CONFERENCE{Avila-García20071006,
  author = {Avila-García, O., García, A.E., Rebull, E.V.S.},
  title = {Using software product lines to manage model families in model-driven
	engineering},
  year = {2007},
  pages = {1006-1011},
  note = {cited By (since 1996) 2},
  abstract = {The relationship between Software Product Lines (SPL) and Model-Driven
	Engineering (MDE) is not new in the literature. It mainly focuses
	on the use of Domain-Specific Languages to specify application families,
	rather than using the more classic feature models. However, more
	recent works propose another important synergy: the use of feature
	models to specify model families. In this paper we propose a Domain-Specific
	Transformation Language (DSTL) that helps in the creation of SPLs
	to manage model families. Moreover, we show the benefits coming from
	taking a new approach to DSTL development. In this approach, DSTL
	instances are not compiled into source code but transformed onto
	general-purpose transformation languages in order to be executed
	using already existent transformation engines. Copyright 2007 ACM.},
  affiliation = {Open Canarias, S.L., Santa Cruz de Tenerife, Spain},
  author_keywords = {Domain-specific languages; Model transformations; Model-driven engineering;
	Software product lines; SPEM},
  document_type = {Article},
  journal = {Proceedings of the ACM Symposium on Applied Computing},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-35248899174&partnerID=40&md5=8c01ec493ddfeb6f894e441471dd8d1d}
}

@CONFERENCE{Axelsson2010169,
  author = {Axelsson, E.a , Claessen, K.a , Dévaiy, G.b , Horváthy, Z.b , Keijzer,
	K.a , Lyckegårdz, B.c , Perssonz, A.a c , Sheeran, M.a , Svenningsson,
	J.a , Vajdax, A.d },
  title = {Feldspar: A domain specific language for digital signal processing
	algorithms},
  year = {2010},
  pages = {169-178},
  note = {cited By (since 1996) 1},
  abstract = {A new language, Feldspar, is presented, enabling high-level and platform-independent
	description of digital signal processing (DSP) algorithms. Feldspar
	is a pure functional language embedded in Haskell. It offers a high-level
	dataflow style of programming, as well as a more mathematical style
	based on vector indices. The key to generating efficient code from
	such descriptions is a high-level optimization technique called vector
	fusion. Feldspar is based on a low-level, functional core language
	which has a relatively small semantic gap to machine-oriented languages
	like C. The core language serves as the interface to the back-end
	code generator, which produces C. For very small examples, the generated
	code performs comparably to hand-written C code when run on a DSP
	target. While initial results are promising, to achieve good performance
	on larger examples, issues related to memory access patterns and
	array copying will have to be addressed. © 2010 IEEE.},
  affiliation = {Chalmers University of Technology, Sweden; Eötvös Loránd University,
	Hungary; Ericsson, Australia; Ericsson Software Research, Australia},
  art_number = {5558637},
  document_type = {Conference Paper},
  journal = {8th ACM/IEEE International Conference on Formal Methods and Models
	for Codesign, MEMOCODE 2010},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-77957770057&partnerID=40&md5=0a8324a2edf93b398e8b85f8b38faa3b}
}

@ARTICLE{Axelsson2011121,
  author = {Axelsson, E.a , Claessen, K.a , Sheeran, M.a , Svenningsson, J.a
	, Engdal, D.b , Persson, A.a b },
  title = {The design and implementation of Feldspar: An embedded language for
	digital signal processing},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2011},
  volume = {6647 LNCS},
  pages = {121-136},
  note = {cited By (since 1996) 0},
  abstract = {Feldspar is a domain specific language, embedded in Haskell, for programming
	digital signal processing algorithms. The final aim of a Feldspar
	program is to generate low level code with good performance. Still,
	we chose to provide the user with a purely functional DSL. The language
	is implemented as a minimal, deeply embedded core language, with
	shallow extensions built upon it. This paper presents full details
	of the essential parts of the implementation. Our initial conclusion
	is that this approach works well in our domain, although much work
	remains. © 2011 Springer-Verlag.},
  affiliation = {Chalmers University of Technology, Sweden; Ericsson, Sweden},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-80054098941&partnerID=40&md5=64789841de229d347f196446e9d34217}
}

@ARTICLE{Aycock2001803,
  author = {Aycock, J., Nigel Horspool, R.},
  title = {Schrödinger's token},
  journal = {Software - Practice and Experience},
  year = {2001},
  volume = {31},
  pages = {803-814},
  number = {8},
  note = {cited By (since 1996) 5},
  abstract = {A common problem when writing compilers for programming languages
	or little, domain-specific languages is that an input token may have
	several interpretations, depending on context. Solutions to this
	problem demand programmer intervention, obfuscate the language's
	grammar, and may introduce subtle bugs. We present a technique which
	is simple and without the above drawbacks - allowing a token to simultaneously
	have different types - and show how it can be applied to areas such
	as little language processing and fuzzy parsing. We also describe
	ways that compiler tools can support this technique.},
  affiliation = {Department of Computer Science, University of Victoria, P.O. Box 3055,
	Victoria, BC V8W 3P6, Canada},
  author_keywords = {Lexical analysis; Parsing; Superposition; Syntactic analysis},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-0035838417&partnerID=40&md5=f16f2324dd0093d2fcd5b8bb08878368}
}

@ARTICLE{Baars201051,
  author = {Baars, A.a , Doaitse Swierstra, S.b , Viera, M.c },
  title = {Typed transformations of typed grammars: The left corner transform},
  journal = {Electronic Notes in Theoretical Computer Science},
  year = {2010},
  volume = {253},
  pages = {51-64},
  number = {7},
  note = {cited By (since 1996) 0},
  abstract = {One of the questions which comes up when using embedded domain specific
	languages is to what extent we can analyze and transform embedded
	programs, as normally done in more conventional compilers. Special
	problems arise when the host language is strongly typed, and this
	host type system is used to type the embedded language. In this paper
	we describe how we can use a library, which was designed for constructing
	transformations of typed abstract syntax, in the removal of left
	recursion from a typed grammar description. The algorithm we describe
	is the Left-Corner Transform, which is small enough to be fully explained,
	involved enough to be interesting, and complete enough to serve as
	a tutorial on how to proceed in similar cases. The described transformation
	has been successfully used in constructing a compositional and efficient
	alternative to the standard Haskell read function. © 2010 Elsevier
	B.V. All rights reserved.},
  affiliation = {Instituto Tecnológico de Informática, Universidad Politécnica de Valencia,
	Valencia, Spain; Department of Computer Science, Utrecht University,
	Utrecht, Netherlands; Instituto de Computación, Universidad de la
	República, Montevideo, Uruguay},
  author_keywords = {GADT; Left-Corner Transform; Meta Programming; Type Systems; Typed
	Abstract Syntax; Typed Transformations},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-77956395985&partnerID=40&md5=ffc717341a66a6adee532c9c7e3fdb90}
}

@CONFERENCE{Baars200915,
  author = {Baars, A.I.a , Swierstra, S.D.b , Viera, M.c },
  title = {Typed transformations of typed abstract syntax},
  year = {2009},
  pages = {15-26},
  note = {cited By (since 1996) 2},
  abstract = {Advantages of embedded domain-specific languages (EDSLs) are one does
	not have to implement a separate type system nor abstraction mechanism,
	since these are directly borrowed from host language. Straightforward
	implementations of embedded specific languages map the semantics
	of the embedded language a function in the host language. The semantic
	mappings usually compositional, i.e. they directly follow the syntax
	of the language.of the questions which arises is whether conventional
	compilation, such as global analysis and resulting transformations,
	be applied in the context of EDSLs. The approach weis that, instead
	of mapping the embedded language directly a function, we first build
	a representation of the abstract syntax of the embedded program fragment.
	This syntax tree isanalyzed and transformed, and finally mapped onto
	function representing its denotational semantics. In this way we
	run-time "compilation" of the embedded language.time transformations
	on the embedded language can have huge effect on performance. In
	previous work (Viera et al. 2008) present a case study comparing
	the Read instances generated Haskells deriving construct with instances
	on which run-time transformations (precedence resolution, left-factorisation
	left-corner transformation) have been applied.this paper we present
	the library, which has an arrow like, which supports in the construction
	of analyses and transformations,we demonstrate its use in implementing
	a common expression elemination transformation. The library uses
	typed syntax to represent fragments of embedded programs containing
	and binding structures, while preserving the idea the type system
	of the host language is used to emulate the type of the embedded
	language. The tricky issue is how to keep collection of mutually
	recursive structures well-typed while it is transformed. finally
	discuss the typing rules of Haskell, its extensions those as implemented
	by the GHC and show that pure System-based systems are sufficiently
	rich to express what we want to express, albeit at the cost of an
	increased complexity of the code. © 2009 ACM.},
  affiliation = {Instituto Tecnológico de Informática, Universidad Politécnica de Valencia,
	Valencia, Spain; Department of Computer Science, Utrecht University,
	Utrecht, Netherlands; Instituto de Computación, Universidad de la
	República, Montevideo, Uruguay},
  author_keywords = {GADT, Meta Programming, Type Systems, Typed Transformations, Common
	Subexpression Elimination},
  document_type = {Conference Paper},
  journal = {Proceedings of the 2009 ACM SIGPLAN Workshop on Types in Language
	Design and Implementation, TLDI'09},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-67650085321&partnerID=40&md5=52ef2e486c5c6a302626e89d98d46656}
}

@CONFERENCE{Bachmann2006,
  author = {Bachmann, P.},
  title = {Static and metaprogramming patterns and static frameworks: A catalog.
	an application},
  year = {2006},
  note = {cited By (since 1996) 0},
  abstract = {The classic UNIX principle to write code that generates code instead
	of writing this code yourself [48, Chapters 1,9] is experiencing
	a revival. Much research was done, the techniques are better understood
	now, and the generation tools were refined. This pattern catalog
	consists of adaptations of the Gang of Four design patterns [27]
	Abstract Factory, Adapter, Strategy, and Visitor to the metaprogramming
	level. It shows that replacing runtime polymorphism by static polymorphism
	helps to lift variation from the code level up to the meta level,
	where it might more naturally belong to. Some of the patterns proposed
	are especially useful for facilitating portable code. The patterns
	shown can be used to build static Frameworks [50]. A simple example
	is also presented. For all patterns proposed we identified usage
	examples in popular existing applications or libraries. Each pattern
	presentation is accompanied with an example. These examples show
	sample code in C++. The template metaprogramming capabilities of
	C++ [2, 17, 65] allow us to express both the program and the meta
	program in the same programming language. Copyright 2006 ACM.},
  affiliation = {Institute for Medical Informatics and Biostatistics, Clarastrasse
	12, CH-4058 Basel, BS, Switzerland},
  art_number = {17},
  author_keywords = {Design pattern; Generative programming; Generic programming; Metaprogramming;
	Portability; Software product lines; Static polymorphism; Template;
	Template specialization},
  document_type = {Conference Paper},
  journal = {PLoP 2006 - PLoP Pattern Languages of Programs 2006 Conference Proceedings},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-67449108399&partnerID=40&md5=79728a4630872b836b980890d37630dc}
}

@ARTICLE{Bachmeyer2007179,
  author = {Bachmeyer, R.C., Delugach, H.S.},
  title = {A conceptual graph approach to feature modeling},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2007},
  volume = {4604 LNAI},
  pages = {179-191},
  note = {cited By (since 1996) 0},
  abstract = {A software product-line is a set of products built from a core set
	of software components. Although software engineers develop software
	productlines for various application types, they are most commonly
	used for embedded systems development, where the variability of hardware
	features requires variability in the supporting firmware. Feature
	models are used to represent the variability in these software product-lines.
	Various feature modeling approaches have been proposed, including
	feature diagrams, domain specific languages, constraint languages,
	and the semantic web language OWL. This paper explores a conceptual
	graph approach to feature modeling in an effort to produce feature
	models that have a more natural, and more easily expressed mapping
	to the problem domain. It demonstrates the approach using a standard
	Graph Product-line problem that has been discussed in various software
	product-line papers. A conceptual graph feature model is developed
	for the graph product-line and it is compared to other feature models
	for this product-line. © Springer-Verlag Berlin Heidelberg 2007.},
  affiliation = {Department of Computer Science, N300 Technology Hall, University of
	Alabama in Huntsville, Huntsville, AL 35899, United States},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-37249052943&partnerID=40&md5=e9c56fc52797b254734eca39b1095541}
}

@CONFERENCE{Baer200743,
  author = {Baer, P.A., Reichle, R., Zapf, M., Weise, T., Geihs, K.},
  title = {A generative approach to the development of autonomous robot software},
  year = {2007},
  pages = {43-52},
  note = {cited By (since 1996) 1},
  abstract = {The integration of new or existing software components into established
	architectures and the ability to deal with heterogeneity are key
	requirements for middleware and development frameworks for robotic
	systems. This paper presents SPICA, a software development framework
	for communication infrastructures of autonomous mobile robots. Utilizing
	the model-driven software development paradigm, communication and
	data flow can be defined on an abstract level. For this purpose,
	domain-specific languages and tools are provided that allow specification
	and generation of module communication infrastructures for communication
	between modules along with primitives for data management. The high-level
	platform-independent specifications are automatically transformed
	into low-level platform and programming language-specific source
	code. We illustrate the applicability of our approach with an elaborate
	example describing the design of a soccer robot architecture that
	has proven its strength during RoboCup 2006. Our experiences have
	revealed that SPICA is advantageous for prototyping as well as for
	building high performance systems. © 2007 IEEE.},
  affiliation = {Distributed Systems Group, University of Kassel, Wilhelmshöher Allee
	73, 34131 Kassel, Germany},
  art_number = {4148882},
  document_type = {Conference Paper},
  journal = {Proceedings - Fourth IEEE International Workshop on Engineering of
	Autonomic and Autonomous Systems, EASe 2007},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-34548118702&partnerID=40&md5=13b3b3e3895e565b8defc001890f6886}
}

@ARTICLE{Bafna2008730,
  author = {Bafna, S.a , Humphries, J.b , Miranker, D.P.c },
  title = {Schema driven assignment and implementation of life science identifiers
	(LSIDs)},
  journal = {Journal of Biomedical Informatics},
  year = {2008},
  volume = {41},
  pages = {730-738},
  number = {5},
  note = {cited By (since 1996) 3},
  abstract = {Life science identifier (LSID) is a global unique identifier standard
	intended to help rationalize the unique archival requirements of
	biological data. We describe LSID implementation architecture such
	that data managed by a relational database management system may
	be integrated with the LSID protocol as an add-on layer. The approach
	requires a database administrator (DBA) to specify an export schema
	detailing the content and structure of the archived data, and a mapping
	of the existing database to that schema. This specification can be
	expressed using SQL view syntax. In effect, we define a SQL-like
	language for implementing LSIDs. We describe the mapping of the view
	definition to an implementation as a set of databases triggers and
	a fixed runtime library. Thus a compiler for a domain-specific language
	could be written that would reduce the implementation of LSIDs to
	the task of writing SQL view-like definitions. © 2008 Elsevier Inc.},
  affiliation = {Department of Computer Sciences, The University of Texas, Austin,
	TX 78712, United States; Department of Geological Sciences, The University
	of Texas, Austin, TX 78712, United States; Department of Computer
	Sciences, Center for Computational Biology and Bioinformatics, The
	University of Texas, Austin, TX 78712, United States},
  author_keywords = {Biology; Export schema; LSID; Metadata; RDF; Resolution; Systematics;
	Trigger; View},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-52949117136&partnerID=40&md5=f481b174e1c251eda61edcdc98ac66b9}
}

@CONFERENCE{Bagge2010,
  author = {Bagge, A.H.},
  title = {Language description for front end implementation},
  year = {2010},
  note = {cited By (since 1996) 0},
  abstract = {For a language to be useful, it requires a robust and reliable implementation.
	Writing and maintaining such an implementation is a hard task, particularly
	for experimental or domain-specific language projects where resources
	are limited. This paper describes an implementation approach based
	on modular specifications of syntax and static semantics. Specification
	is done in a language description DSL, which serves both as a specification,
	and as code from which compiler front ends can be automatically generated.
	© ACM 2010.},
  affiliation = {Dept. of Informatics, Bergen Language Design Laboratory, University
	of Bergen, Norway},
  art_number = {9},
  author_keywords = {Languages},
  document_type = {Conference Paper},
  journal = {Proceedings of the 10th Workshop on Language Descriptions, Tools
	and Applications, LDTA 2010},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-78649782947&partnerID=40&md5=93ac18020881027d5a4bab4ab1312708}
}

@ARTICLE{Bagge2010123,
  author = {Bagge, A.H.},
  title = {Yet another language extension scheme},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2010},
  volume = {5969 LNCS},
  pages = {123-132},
  note = {cited By (since 1996) 1},
  abstract = {Magnolia is an experimental programming language designed to try out
	novel language features. For a language to be a flexible basis for
	new constructs and language extensions, it will need a flexible compiler,
	one where new features can be prototyped with a minimum of effort.
	This paper proposes a scheme for compilation by transformation, in
	which the compilation process can be extended by the program being
	compiled. We achieve this by making a domain-specific transformation
	language for processing Magnolia programs, and embedding it into
	Magnolia itself. © 2010 Springer-Verlag.},
  affiliation = {Bergen Language Design Laboratory, Dept. of Informatics, University
	of Bergen, Norway},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-77951526125&partnerID=40&md5=6d822f53e5f346d1450269d7dd234a99}
}

@ARTICLE{Bagge201015,
  author = {Bagge, A.H., David, V., Haveraaen, M.},
  title = {The axioms strike back: Testing with concepts and axioms in C++},
  journal = {ACM SIGPLAN Notices},
  year = {2010},
  volume = {45},
  pages = {15-24},
  number = {2},
  note = {cited By (since 1996) 0},
  abstract = {Modern development practises encourage extensive testing of code while
	it is still under development, using unit tests to check individual
	code units in isolation. Such tests are typically case-based, checking
	a likely error scenario or an error that has previously been identified
	and fixed. Coming up with good test cases is challenging, and focusing
	on individual tests can distract from creating tests that cover the
	full functionality. Axioms, known from program specification, allow
	for an alternative way of generating test cases, where the intended
	functionality is described as rules or equations that can be checked
	automatically. Axioms are proposed as part of the concept feature
	of the upcoming C++0x standard. In this paper, we describe how tests
	may be generated automatically from axioms in C++ concepts, and supplied
	with appropriate test data to form exctive automated unit tests.
	Copyright © 2009 ACM.},
  affiliation = {University of Bergen, Norway},
  author_keywords = {Algebraic Specification; Axiom-Based Testing Axioms; C++; C++0x Concepts;
	Generative Programming; Mouldable Programming; Program Transformation;
	Test Generation; Unit Testing},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-77957599251&partnerID=40&md5=c374f54b9feb057fe2b943db3082330f}
}

@CONFERENCE{Bagge2008721,
  author = {Bagge, A.H., David, V., Haveraaen, M.},
  title = {Axiom-based testing for C++},
  year = {2008},
  pages = {721-722},
  note = {cited By (since 1996) 4},
  abstract = {Axioms, known from program specification, allow program functionality
	to be described as rules or equations. The draft C++0x standard introduces
	axioms as part of the new concept feature. We will demonstrate a
	tool that uses these features for automated unit testing.},
  affiliation = {University of Bergen, Norway},
  author_keywords = {Axioms; C++; C++0x; Concepts; Generative programming; Mouldable programming;
	Program transformation; Specifications; Test generation; Unit testing},
  document_type = {Conference Paper},
  journal = {Proceedings of the Conference on Object-Oriented Programming Systems,
	Languages, and Applications, OOPSLA},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-63349090441&partnerID=40&md5=0b9dfe580f34ed9d49597fc0e2980fb3}
}

@CONFERENCE{Bagge2008773,
  author = {Bagge, A.H., David, V., Haveraaen, M.},
  title = {Testing with concepts and axioms in C++},
  year = {2008},
  pages = {773-774},
  note = {cited By (since 1996) 2},
  abstract = {Unit testing is a popular way of increasing software reliability.
	Axioms, known from program specification, allow functionality to
	be described as rules or equations. We show a method and prototype
	tool for using the proposed concept and axiom features of the upcoming
	C++0x standard for automated unit testing.},
  affiliation = {University of Bergen, Norway},
  author_keywords = {Axioms; C++; C++0x; Concepts; Generative programming; Mouldable programming;
	Program transformation; Specifications; Test generation; Unit testing},
  document_type = {Conference Paper},
  journal = {Proceedings of the Conference on Object-Oriented Programming Systems,
	Languages, and Applications, OOPSLA},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-63349110718&partnerID=40&md5=8e0880de88067cd1c9dcbf27e6779cac}
}

@ARTICLE{Baggi201166,
  author = {Baggi, M.a , Ballis, D.b , Falaschi, M.a },
  title = {An access control language based on term rewriting and description
	logic},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2011},
  volume = {6559 LNCS},
  pages = {66-83},
  note = {cited By (since 1996) 0},
  abstract = {This paper presents a rule-based, domain specific language for modeling
	access control policies which is particularly suitable for managing
	security in the semantic web, since (i) it allows one to evaluate
	authorization requests according to semantic information retrieved
	from remote knowledge bases; (ii) it supports semantic-based policy
	composition, delegation and closure via flexible operators which
	can be defined by security administrators in a pure declarative way
	with little effort. The operational engine of the language smoothly
	integrates description logic into standard term rewriting giving
	support to reasoning capabilities which are particularly useful in
	this context, since they allow one to naturally combine and reuse
	data extracted from multiple knowledge bases. Such a rewrite engine
	can be used to evaluate authorization requests w.r.t. a policy specification
	as well as to formally check properties regarding the security domain
	to be protected. The language we propose has been implemented in
	a prototypical system, which is written in Haskell. Some case studies
	have been analyzed to highlight the potentiality of our approach.
	© 2011 Springer-Verlag.},
  affiliation = {Dip. di Scienze Matematiche e Informatiche, Pian dei Mantellini 44,
	53100 Siena, Italy; Dip. Matematica e Informatica, Via delle Scienze
	206, 33100 Udine, Italy},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-79957591399&partnerID=40&md5=e8d03b99c5f7d8a45b36a4013dfc7438}
}

@CONFERENCE{Bai20092480,
  author = {Bai, S., Huang, C.-L., Tan, Y.-K., Ma, B.},
  title = {Language models learning for domain-specific natural language user
	interaction},
  year = {2009},
  pages = {2480-2485},
  note = {cited By (since 1996) 0},
  abstract = {Natural language interface is an important research topic in the area
	of natural language processing (NLP). Natural language interaction
	with robot could be the most natural and efficient way. In order
	to build speech enabled human language interface of robots, our research
	goal is to study the problems in this area and develop technologies
	that can potentially improve human-robot interaction. In particular,
	we present a learning method for building domain-specific language
	models (LM) for natural language user interfaces. This method is
	aimed to use small amount of domain-specific data as seeds to tap
	domain-specific resources residing in larger amount of general-domain
	data with the help of topic modeling technologies. The proposed algorithm
	first performs topic decomposition (TD) on the combined dataset of
	domain-specific and general-domain data using probabilistic latent
	semantic analysis (PLSA). Then it derives weighted domain-specific
	word n-gram counts with mixture modeling scheme of PLSA. Finally,
	it uses traditional n-gram modeling approach to construct domain-specific
	LMs from the domain-specific word n-gram counts. Experimental results
	show that this approach can outperform both stat-of-the-art methods
	and traditional supervised learning method. In addition, the semi-supervised
	learning method can achieve better performance even with very small
	amount of domain-specific data. © 2009 IEEE.},
  affiliation = {Social Robot Group, Institute for Infocomm Research, 1 Fusionopolis
	Way, #21-01 Connexis, Singapore 138632, Singapore},
  art_number = {5420442},
  document_type = {Conference Paper},
  journal = {2009 IEEE International Conference on Robotics and Biomimetics, ROBIO
	2009},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-77951464535&partnerID=40&md5=10c6f898675538bff3711eaf7385856a}
}

@CONFERENCE{Bai20105386,
  author = {Bai, S.a , Huang, C.-L.a , Ma, B.a , Li, H.a b },
  title = {Semi-supervised learning of language model using unsupervised topic
	model},
  year = {2010},
  pages = {5386-5389},
  note = {cited By (since 1996) 0},
  abstract = {We present a semi-supervised learning (SSL) method for building domain-specific
	language models (LMs) from general-domain data using probabilistic
	latent semantic analysis (PLSA). The proposed technique first performs
	topic decomposition (TD) on the combined dataset of domain-specific
	and general-domain data. Then it derives latent topic distribution
	of the interested domain, and derives domain-specific word n-gram
	counts with a PLSA style mixture model. Finally, it uses traditional
	n-gram modeling to construct domain-specific LMs from the domain-specific
	word n-gram counts. Experimental results show that this technique
	outperforms both states-of-the-art relative entropy text selection
	and traditional supervised training methods. ©2010 IEEE.},
  affiliation = {Institute for Infocomm Research, Singapore, Singapore; Department
	of Computer Science and Statistics, University of Eastern Finland,
	FI-80101 Joensuu, Finland},
  art_number = {5494940},
  author_keywords = {Language model; Semi-supervised learning; Topic model},
  document_type = {Conference Paper},
  journal = {ICASSP, IEEE International Conference on Acoustics, Speech and Signal
	Processing - Proceedings},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-78049354311&partnerID=40&md5=d1d79498f052572090e66d267754b9d7}
}

@CONFERENCE{Baker2002270,
  author = {Baker, J., Hsieh, W.C.},
  title = {Maya: Multiple-dispatch syntax extension in Java},
  year = {2002},
  pages = {270-281},
  note = {cited By (since 1996) 27},
  abstract = {We have designed and implemented Maya, a vers ion of Java that allows
	programmers to extend and reinterpret its syntax. Maya generalizes
	macro systems by treating grammar productions as generic functions,
	and semantic actions on productions as multimethods on the corresponding
	generic functions. Programmers can write new generic functions (i.e.,
	grammar productions) and new multimethods (i.e., semantic actions),
	through which they can extend the grammar of the language and change
	the semantics of its syntactic constructs, respectively. Maya's multimethods
	are compile-time metaprograms that transform abstract syntax: they
	execute at program compile-time, because they are semantic actions
	executed by the parser. Maya's multimethods can be dispatched on
	the syntactic structure of the input, as well as the static, source-level
	types of expressions in the input. In this paper we describe what
	Maya can do and how it works. We describe how its novel parsing techniques
	work and how Maya can statically detect certain kinds of errors,
	such as code that generates references to free variables. Finally,
	to demonstrate Maya's expressiveness, we describe how Maya can be
	used to implement the Multi Java language, which was described by
	Clifton et al. at OOPSLA 2000.},
  affiliation = {University of Utah, Salt Lake City, UT, United States},
  author_keywords = {Generative programming; Java; Macros; Metaprogramming},
  document_type = {Conference Paper},
  journal = {Proceedings of the ACM SIGPLAN Conference on Programming Language
	Design and Implementation (PLDI)},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-0036039843&partnerID=40&md5=c4da9a958282dc1a3f24184dcf691e3e}
}

@ARTICLE{Balaban2011517,
  author = {Balaban, M.a , Kifer, M.b },
  title = {Logic-based model-level software development with F-OML},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2011},
  volume = {6981 LNCS},
  pages = {517-532},
  note = {cited By (since 1996) 0},
  abstract = {Models are at the heart of the emerging Model-driven Engineering (MDE)
	approach in which software is developed by repeated transformations
	of models. Intensive efforts in the modeling community in the past
	two decades have produced an impressive variety of tool support for
	models. Nonetheless, models are still not widely used throughout
	the software evolution life cycle and, in many cases, they are neglected
	in later stages of software development. To make models more useful,
	one needs a powerful model-level IDE that supports a wide range of
	object modeling tasks. Such IDEs must have a consistent formal foundation.
	This paper introduces F-OML, a language intended as an expressive,
	executable formal basis for model-level IDEs. F-OML supports a wide
	variety of model-level activities, such as extending UML diagrams,
	defining design patterns, reasoning about UML diagrams, testing UML
	diagrams, specification of Domain Specific Modeling Languages, and
	meta-modeling. F-OML is a semantic layer on top of an elegant logic
	programming language of guarded path expressions, called PathLP.
	We believe that a combination of current object technology with F-OML
	as an underlying language can lay the basis for a powerful model-level
	IDE. © 2011 Springer-Verlag.},
  affiliation = {Ben-Gurion University, Israel; Stony Brook University, United States},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-80054086925&partnerID=40&md5=8aec05431cb7d7308847513b5a4d9b05}
}

@CONFERENCE{Balasubramanian2009645,
  author = {Balasubramanian, D.a , Jackson, E.K.b },
  title = {Lost in translation: Forgetful semantic anchoring},
  year = {2009},
  pages = {645-649},
  note = {cited By (since 1996) 0},
  abstract = {Assigning behavioral semantics to domain-specific languages (DSLs)
	opens the door for the application of formal methods, yet is largely
	an unresolved problem. Previously proposed solutions include semantic
	anchoring, in which a transformation from the DSL to an external
	framework that can supply both behavioral semantics and apply formal
	methods is constructed. The drawback of this approach is that it
	loses the structural constraints of the original DSL along with the
	details of the transformation, which can lead to erroneous results
	when formal methods are applied. We demonstrate this problem of "forgetful"
	semantic anchoring using existing approaches through a translation
	from dataflow systems to interface automata. We then describe our
	modeling tool FORMULA and apply it to the same example, showing how
	forgetful semantic anchoring can be avoided. © 2009 IEEE.},
  affiliation = {Vanderbilt University, Institute for Software Integrated Systems,
	Nashville, TN, United States; Microsoft Research, Redmond, WA, United
	States},
  art_number = {5431716},
  author_keywords = {Behavioral semantics; Composition},
  document_type = {Conference Paper},
  journal = {ASE2009 - 24th IEEE/ACM International Conference on Automated Software
	Engineering},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-77952148151&partnerID=40&md5=8cee2f003f3d2ff90ae18a9f5a37d0f2}
}

@ARTICLE{Balasubramanian2007171,
  author = {Balasubramanian, K., Balasubramanian, J., Parsons, J., Gokhale, A.,
	Schmidt, D.C.},
  title = {A Platform-Independent Component Modeling Language for Distributed
	Real-time and Embedded Systems},
  journal = {Journal of Computer and System Sciences},
  year = {2007},
  volume = {73},
  pages = {171-185},
  number = {2},
  note = {cited By (since 1996) 12},
  abstract = {This paper provides two contributions to the study of developing and
	applying domain-specific modeling languages (DSMLS) to distributed
	real-time and embedded (DRE) systems-particularly those systems using
	standards-based QoS-enabled component middleware. First, it describes
	the Platform-Independent Component Modeling Language (PICML), which
	is a DSML that enables developers to define component interfaces,
	QoS parameters and software building rules, and also generates descriptor
	files that facilitate system deployment. Second, it applies PICML
	to an unmanned air vehicle (UAV) application portion of an emergency
	response system to show how PICML resolves key component-based DRE
	system development challenges. Our results show that the capabilities
	provided by PICML-combined with its design- and deployment-time validation
	capabilities-eliminates many common errors associated with conventional
	techniques, thereby increasing the effectiveness of applying QoS-enabled
	component middleware technologies to the DRE system domain. © 2006
	Elsevier Inc. All rights reserved.},
  affiliation = {Department of EECS, Vanderbilt University, Nashville, TN, United States},
  author_keywords = {CoSMIC; Model-driven development; Real-time CORBA component model},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-33751400315&partnerID=40&md5=f329007753b18fae48ffa7e75978a138}
}

@CONFERENCE{Balasubramanian200793,
  author = {Balasubramanian, K., Schmidt, D.C., Molnár, Z., Lédeczi, Á.},
  title = {Component-based system integration via (meta)model composition},
  year = {2007},
  pages = {93-102},
  note = {cited By (since 1996) 3},
  abstract = {This paper provides three contributions to the study of functional
	integration of distributed enterprise systems. First, we describe
	the challenges associated with functionally integrating the software
	of these systems. Second, we describe how the composition of domain-specific
	modeling languages (DSMLs) can simplify the functional integration
	of enterprise distributed systems by enabling the combination of
	diverse middleware technologies. Third, we demonstrate how composing
	DSMLs can solve functional integration problems by reverse engineering
	an existing CORBA Component Model (CCM) system and exposing it as
	Web Service(s) to web clients who use these services. This paper
	shows that functional integration done using (meta)model composition
	provides significant benefits with respect to automation, reusability,
	and scalability compared to conventional integration processes and
	methods. © 2007 IEEE.},
  affiliation = {Institute for Software Integrated Systems, Vanderbilt University,
	Nashville, United States},
  art_number = {4148923},
  document_type = {Conference Paper},
  journal = {Proceedings of the International Symposium and Workshop on Engineering
	of Computer Based Systems},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-34250164667&partnerID=40&md5=34be84923725d0ad16811a961650d073}
}

@ARTICLE{Balasubramanian2006403,
  author = {Balasubramanian, K.a , Gokhale, A.a , Lin, Y.b , Zhang, J.b , Gray,
	J.b },
  title = {Weaving deployment aspects into domain-specific models},
  journal = {International Journal of Software Engineering and Knowledge Engineering},
  year = {2006},
  volume = {16},
  pages = {403-424},
  number = {3},
  note = {cited By (since 1996) 4},
  abstract = {Domain-specific models increase the level of abstraction used to develop
	large-scale component-based systems. Model-driven development (MDD)
	approaches (e.g., Model-Integrated Computing and Model-Driven Architecture)
	emphasize the use of models at all stages of system development.
	Decomposing problems using MDD approaches may result in a separation
	of the artifacts in a way that impedes comprehension. For example,
	a single concern (such as deployment of a distributed system) may
	crosscut different orthogonal activities (such as component specification,
	interaction, packaging and planning). To keep track of all entities
	associated with a component, and to ensure that the constraints for
	the system as a whole are not violated, a purely model-driven approach
	imposes extra effort, thereby negating some of the benefits of MDD.
	This paper provides three contributions to the study of applying
	aspect-oriented techniques to address the crosscutting challenges
	of model-driven component-based distributed systems development.
	First, we identify the sources of crosscutting concerns that typically
	arise in model-driven development of component-based systems. Second,
	we describe how aspect-oriented model weaving helps modularize these
	crosscutting concerns using model transformations. Third, we describe
	how we have applied model weaving using a tool called the Constraint-Specification
	Aspect Weaver (C-SAW) in the context of the Platform-Independent
	Component Modeling Language (PICML), which is a domain-specific modeling
	language for developing component-based systems. A case study of
	a joint-emergency response system is presented to express the challenges
	in modeling a typical distributed system. Our experience shows that
	model weaving is an effective and scalable technique for dealing
	with crosscutting aspects of component-based systems development.
	© World Scientific Publishing Company.},
  affiliation = {Department of Electrical Engineering and Computer Science, Vanderbilt
	University, P.O. Box 1829, Nashville, TN 57255, United States; Department
	of Computer and Information Sciences, University of Alabama at Birmingham,
	1300 University Boulevard, Birmingham, AL 35294, United States},
  author_keywords = {Aspect modeling; Component-based middleware; Deployment and configuration;
	Domain-specific modeling},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-33745783102&partnerID=40&md5=20292b9b53decd0eab0d40374af3d192}
}

@ARTICLE{Baligand2008483,
  author = {Baligand, F.a b , Rivierre, N.a , Ledoux, T.b },
  title = {QoS policies for business processes in Service Oriented Architectures},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2008},
  volume = {5364 LNCS},
  pages = {483-497},
  note = {cited By (since 1996) 0},
  abstract = {The advent of Service Oriented Architectures tends to promote a new
	kind of software architecture where services, exposing features accessible
	through highly standardized protocols, are composed in a loose coupling
	way. In such a context, where services are likely to be replaced
	or used by a large number of clients, the notion of Quality of Service
	(QoS), which focuses on the quality of the relationship between a
	service and its customers, becomes a key challenge. This paper aims
	to ease QoS management in service compositions through a better separation
	of concerns. For this purpose, we designed QoSL4BP, a domain-specific
	language which allows QoS policies specification for business processes.
	More specifically, the QoSL4BP language is designed to allow an architect
	to specify QoS constraints and mechanisms over parts of BPEL compositions.
	This language is executed by our ORQOS platform which cooperates
	in a non-intrusive way with orchestration engines. At pre-deployment
	time, ORQOS platform performs service planning depending on services
	QoS offers and on the QoS requirements in QoSL4BP policies. At runtime,
	QoSL4BP policies allow to react to QoS variations and to enact QoS
	management related mechanisms. © 2008 Springer Berlin Heidelberg.},
  affiliation = {France Telecom - R and D / MAPS / AMS, 38-40 rue du general Leclerc,
	92794 Issy les Moulineaux, France; OBASCO Group, EMN / INRIA, Ecole
	des Mines de Nantes, 4, rue Alfred Kastler, F - 44307 Nantes Cedex
	3, France},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-58049132539&partnerID=40&md5=89b32e66fc617f49a36053c2cd84fe77}
}

@ARTICLE{Baligand200738,
  author = {Baligand, F.a , Botlan, D.L.b , Ledoux, T.b , Combes, P.a },
  title = {A language for quality of service requirements specification in web
	services orchestrations},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2007},
  volume = {4652 LNCS},
  pages = {38-49},
  note = {cited By (since 1996) 2},
  abstract = {Service Oriented Architectures industry aims to deliver agile service
	infrastructures. In this context, solutions to specify service compositions
	(mostly BPEL language) and Quality of Service (QoS) of individual
	services have emerged. However, architects still lack adapted means
	to specify and implement QoS in service compositions. Typically,
	they use ad-hoc technical solutions that significantly reduce flexibility
	and require cost-effective development. Our approach aims to overcome
	this shortcoming by introducing both a new language and tool for
	QoS specification and implementation in service compositions. More
	specifically, our language is a declarative domain-specific language
	that allows the architect to specify QoS constraints and mechanisms
	in Web Service orchestrations. Our tool is responsible for the QoS
	constraints processing and for QoS mechanisms injection into the
	orchestration. A key property of our approach is to preserve compatibility
	with existing languages and standards. In this paper, we present
	our language and tool, as well as an illustrative scenario dealing
	with multiple QoS concerns. © Springer-Verlag Berlin Heidelberg 2007.},
  affiliation = {France Telecom, RandD / MAPS / AMS, 38-40 rue du general Leclerc,
	92794 Issy les Moulineaux, France; OBASCO Group, EMN / INRIA, Lina
	Ecole des Mines de Nantes, 4, rue Alfred Kastler, F - 44307 Nantes
	Cedex 3, France},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-38049169475&partnerID=40&md5=242259fa544b45259da02f94cac43ea7}
}

@ARTICLE{Balland200651,
  author = {Balland, E., Kirchner, C., Moreau, P.-E.},
  title = {Formal Islands},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2006},
  volume = {4019 LNCS},
  pages = {51-65},
  note = {cited By (since 1996) 3},
  abstract = {Motivated by the proliferation and usefulness of Domain Specific Languages
	as well as the demand for enriching well established languages by
	high level capabilities like pattern matching or invariant checking,
	we introduce the Formal Islands framework. The main idea consists
	to integrate, in existing programs, formally defined parts called
	islands, on which proofs and tests can be meaningfully developed.
	Then, Formal Islands could be safely dissolved into their hosting
	language to be transparently integrated in the existing development
	environment. The paper presents this generic framework and shows
	that the properties valid on the Formal Islands are also valid on
	the corresponding dissolved host codes. Formal Islands can be used
	as a general methodology to develop new DSLs and we show that language
	extensions like SQLJ - embedding SQL capabilities in Java -, or Tom
	- a Java language extension allowing for pattern matching and rewriting
	- are indeed islands. © Springer-Verlag Berlin Heidelberg 2006.},
  affiliation = {UHP and LORIA, INRIA and LORIA, INRIA and LORIA, BP 101, 54602 Villers-lès-Nancy
	Cedex, France},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-33746070058&partnerID=40&md5=074ec923ddbc5f209eedee4ac860fd16}
}

@ARTICLE{Ballis200851,
  author = {Ballis, D., Baruzzo, A., Comini, M.},
  title = {A Rule-based Method to Match Software Patterns Against UML Models},
  journal = {Electronic Notes in Theoretical Computer Science},
  year = {2008},
  volume = {219},
  pages = {51-66},
  number = {C},
  note = {cited By (since 1996) 1},
  abstract = {In a UML model, different aspects of a system are covered by different
	types of diagrams and this bears the risk that an overall system
	specification becomes barely tractable by the designer. When the
	model grows, it is likely that the architectural integrity will be
	compromised by extensions and bug-fixing operations. Hence, it is
	important to provide means to help designers to search in big models
	for particular instances of some variable schema of UML models (design
	patterns) they construct. This can help them both to find potential
	problems in the architecture design and to ensure that intended architectural
	choices had not been broken by mistake. In this paper we propose
	a rule-based method to find matches of design patterns into a UML
	model. The method is general enough to tackle most patterns and antipatterns.
	© 2008 Elsevier B.V. All rights reserved.},
  affiliation = {Dipartimento di Matematica e Informatica (DIMI), University of Udine,
	Via delle Scienze 206, 33100 Udine, Italy},
  author_keywords = {Pattern Matching; Rule-based domain specific language; UML Design
	Patterns; UML formal specification},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-55749091107&partnerID=40&md5=673f426c97b8839ee60722a9039bed9a}
}

@ARTICLE{Balogh2010224,
  author = {Balogh, A.c , Bergmann, G.a , Csertán, G.c , Gönczy, L.a , Horváth,
	Á.a , Majzik, I.a , Pataricza, A.a , Polgár, B.a , Ráth, I.a , Varró,
	D.a , Varró, G.b },
  title = {Workflow-driven tool integration using model transformations},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2010},
  volume = {5765 LNCS},
  pages = {224-248},
  note = {cited By (since 1996) 0},
  abstract = {The design of safety-critical systems and business-critical services
	necessitates to coordinate between a large variety of tools used
	in different phases of the development process. As certification
	frequently prescribes to achieve justified compliance with regulations
	of authorities, integrated tool chain should strictly adhere to the
	development process itself. In order to manage complexity, we follow
	a model-driven approach where the development process is captured
	using a precise domain-specific modeling language. Each individual
	step within this process is represented transparently as a service.
	Moreover, to carry out individual tasks, systems engineers are guided
	by semi-automated transformation steps and well-formedness constraint
	checking. Both of them are formalized by graph patterns and graph
	transformation rules as provided by the Viatra2 framework. In our
	prototype implementation, we use the popular JBPM workflow engine
	as orchestration means between different design and verification
	tools. We also give some insights how this tool integration approach
	was applied in recent projects. © 2010 Springer-Verlag Berlin Heidelberg.},
  affiliation = {Department of Measurement and Information Systems, Budapest University
	of Technology and Economics, Magyar tudósok krt. 2, H-1117 Budapest,
	Hungary; Department of Computer Science and Information Theory, Budapest
	University of Technology and Economics, Magyar tudósok krt. 2, H-1117
	Budapest, Hungary; OptxWare Research and Development LLC, Katona
	J. u. 39., H-1137, Hungary},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-78649516023&partnerID=40&md5=ab192c1d1b126c7649accf5f612583f3}
}

@ARTICLE{Barbosa2009259,
  author = {Barbosa, M.a , Moss, A.b , Page, D.a },
  title = {Constructive and destructive use of compilers in elliptic curve cryptography},
  journal = {Journal of Cryptology},
  year = {2009},
  volume = {22},
  pages = {259-281},
  number = {2},
  note = {cited By (since 1996) 1},
  abstract = {Although cryptographic software implementation is often performed
	by expert programmers, the range of performance and security driven
	options, as well as more mundane software engineering issues, still
	make it a challenge. The use of domain specific language and compiler
	techniques to assist in description and optimisation of cryptographic
	software is an interesting research challenge. In this paper we investigate
	two aspects of such techniques, focusing on Elliptic Curve Cryptography
	(ECC) in particular. Our constructive results show that a suitable
	language allows description of ECC based software in a manner close
	to the original mathematics; the corresponding compiler allows automatic
	production of an executable whose performance is competitive with
	that of a hand-optimised implementation. In contrast, we study the
	worrying potential for naïve compiler driven optimisation to render
	cryptographic software insecure. Both aspects of our work are set
	within the context of CACE, an ongoing EU funded project on this
	general topic. © 2008 International Association for Cryptologic Research.},
  affiliation = {Departamento de Informática, Universidade Do Minho, Campus de Gualtar,
	Braga 4710-057, Portugal; Department of Computer Science, University
	of Bristol, Merchant Venturers Building, Woodland Road, Bristol BS8
	1UB, United Kingdom},
  author_keywords = {Compilers; Elliptic curve cryptography (ECC); Implementation; Optimisation;
	Specialisation},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-64249159739&partnerID=40&md5=318f60fe2265f78e10402b2c1e52ddca}
}

@ARTICLE{Barbosa20071785,
  author = {Barbosa, M.a , Moss, A.b , Page, D.b },
  title = {Compiler assisted elliptic curve cryptography},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2007},
  volume = {4804 LNCS},
  pages = {1785-1802},
  number = {PART 2},
  note = {cited By (since 1996) 1},
  abstract = {Although cryptographic software implementation is often performed
	by expert programmers, the range of performance and security driven
	options, as well as more mundane software engineering issues, still
	make it a challenge. The use of domain specific language and compiler
	techniques to assist in description and optimisation of cryptographic
	software is an interesting research challenge. Our results, which
	focus on Elliptic Curve Cryptography (ECC), show that a suitable
	language allows description of ECC based software in a manner close
	to the original mathematics; the corresponding compiler allows automatic
	production of an executable whose performance is competitive with
	that of a hand-optimised implementation. Our work are set within
	the context of CACE, an ongoing EU funded project on this general
	topic. © Springer-Verlag Berlin Heidelberg 2007.},
  affiliation = {Departamento de Informática, Universidade do Minho, Campus de Gualtar,
	4710-057 Braga, Portugal; Department of Computer Science, University
	of Bristol, Merchant Venturers Building, Woodland Road, Bristol,
	BS8 1UB, United Kingdom},
  author_keywords = {Compilers; Elliptic Curve Cryptography (ECC); Implementation; Optimisation;
	Specialisation},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-38349004533&partnerID=40&md5=36f86afd4b055cb6cc9ed52aab8767b9}
}

@CONFERENCE{Barbosa2008330,
  author = {Barbosa, P.E.S., Ramalho, F., De Figueiredo, J.C.A., Junior, A.D.D.S.},
  title = {Incorporating semantic algebra in the MDA framework},
  year = {2008},
  volume = {SE},
  number = {GSDCA/M/-},
  pages = {330-336},
  note = {cited By (since 1996) 2},
  abstract = {Denotational semantics is commonly used to precisely define the meaning
	of a programming language. This meaning is given by functions that
	map syntactic elements to mathematically well defined sets called
	semantic algebra. Models in semantic algebra need to be processed
	through reductions towards a normal-form in order to allow the verification
	of semantics properties. MDA is a current trend that shifts the focus
	and effort from implementation to models, metamodels and transformations
	during the development process. In order to put forward denotational
	semantics in the MDA vision, we turn semantic algebra into an useful
	domain-specific language. In this context, this paper describes our
	proposed MOF metamodel and ATL reductions between the generated models.
	The metamodel serves as abstract syntax for semantic algebra. It
	is useful for static semantics verifications. The reductions enable
	processing towards a normal-form to compare semantics. This process
	can be guided by using some rewrite system.},
  affiliation = {Universidade Federal de Campina Grande, Departamento de Sistemas e
	Computação, Campina Grande, Brazil},
  author_keywords = {Denotational semantics; Formal methods and MDA; Metamodels},
  document_type = {Conference Paper},
  journal = {ICSOFT 2008 - Proceedings of the 3rd International Conference on
	Software and Data Technologies},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-57649217888&partnerID=40&md5=25a6a5256380d0058ec7ec5b50ba9dfc}
}

@ARTICLE{Bardohl2004214,
  author = {Bardohl, R.a , Ehrig, H.a , De Lara, J.b , Taentzer, G.a },
  title = {Integrating meta-modelling aspects with graph transformation for
	efficient visual language definition and model manipulation},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2004},
  volume = {2984},
  pages = {214-228},
  note = {cited By (since 1996) 18},
  abstract = {Visual languages (VLs) play a central role in modelling various system
	aspects. Besides standard languages like UML, a variety of domain-specific
	languages exist which are the more used the more tool support is
	available for them. Different kinds of generators have been developed
	which produce visual modelling environments based on VL specifications.
	To define a VL, declarative as well as constructive approaches are
	used. The meta modelling approach is a declarative one where classes
	of symbols and relations are defined and associated to each other.
	Constraints describe additional language properties. Defining a VL
	by a graph grammar, the constructive way is followed where graphs
	describe the abstract syntax of models and graph rules formulate
	the language grammar. In this paper, we extend algebraic graph grammars
	by a node type inheritance concept which opens up the possibility
	to integrate both approaches by identifying symbol classes with node
	types and associations with edge types of some graph class. In this
	way, declarative as well as constructive elements may be used for
	language definition and model manipulation. Two concrete approaches,
	the GENGED and the AToM3 approach, illustrate how VLs can be defined
	and models can be manipulated by the techniques described above.
	© Springer-Verlag 2004.},
  affiliation = {Computer Science Department Technische, Universitat Berlin, Berlin,
	Germany; Escuela Politécnica Superior Ingeniería Informática, Universidad
	Autónoma de Madrid},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-35048842808&partnerID=40&md5=8283a151fba85ae0da64029afb1dc22b}
}

@ARTICLE{Barn201046,
  author = {Barn, B.S., Clark, T.},
  title = {A domain specific language for contextual design},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2010},
  volume = {6409 LNCS},
  pages = {46-61},
  note = {cited By (since 1996) 0},
  abstract = {This paper examines the role of user-centered design (UCD) approaches
	to design and implementation of a mobile social software application
	to support student social workers in their work place. The experience
	of using a variant of UCD is outlined. The principles and expected
	norms of UCD raised a number of key lessons. It is proposed that
	these problems and lessons are a result of the inadequacy of precision
	of modeling the outcomes of UCD, which prevents model driven approaches
	to method integration between UCD approaches. Given this, it is proposed
	that the Contextual Design method is a good candidate for enhancing
	with model driven principles. A subset of the Work model focussing
	on Cultural and Flow models are described using a domain specific
	language and supporting tool built using the MetaEdit+ platform.
	© 2010 IFIP International Federation for Information Processing.},
  affiliation = {Middlesex University, Hendon, London, NW4 4BT, United Kingdom},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-78650240317&partnerID=40&md5=44c23b2f386138a0a7776690a4e77b97}
}

@CONFERENCE{Barreto2001161,
  author = {Barreto, L.P., Muller, G.},
  title = {Bossa: A DSL framework for application-specific scheduling policies},
  year = {2001},
  pages = {161},
  note = {cited By (since 1996) 0},
  abstract = {A framework for easing the development of adaptable process scheduling
	infrastructures is presented. This framework permits the development
	and installation of basic scheduling policies. The framework architecture
	relies on two basic components: Virtual Schedulers (VSs) and Application-Specific
	Policies (ASPs).},
  affiliation = {COMPOSE group, IRISA/INRIA, Campus de Beaulieu, 35042 Rennes Cedex,
	France},
  document_type = {Conference Paper},
  journal = {Proceedings of the Workshop on Hot Topics in Operating Systems -
	HOTOS},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-0035703689&partnerID=40&md5=cff36eb8a5f88995e28c50761aacd9c7}
}

@CONFERENCE{Barrett200799,
  author = {Barrett, K.a , Davy, S.a , Strassner, J.b , Jennings, B.a , Van Der
	Meer, S.a , Donnelly, W.a },
  title = {A model based approach for policy tool generation and policy analysis},
  year = {2007},
  pages = {99-105},
  note = {cited By (since 1996) 16},
  abstract = {We outline an approach to policy specification and analysis in which
	an information model is used as the starling point for semi-automated
	generation of an integrated suite of languages, tools and an ontology.
	The suite includes separate domain-specific languages for the specification
	of systems structure and policies respectively, editors and checkers
	for these languages, and a baseline ontology that can be augmented
	with semantic information to support policy analyses processes. We
	describe a prototypical realisation of the approach, showing how
	the languages, tools and ontology are used to support policy transformation
	and conflict detection processes. © 2007 IEEE.},
  affiliation = {Telecommunications Software and Systems Group, Waterford Institute
	of Technology, Cork Road, Waterford, Ireland; Motorola Labs, Schaumburg,
	IL, United States},
  art_number = {4404174},
  author_keywords = {Model driven development; Network management; Ontologies; Policy based
	management},
  document_type = {Conference Paper},
  journal = {2007 1st International Global Information Infrastructure Symposium,
	GIIS 2007 - "Closing the Digital Divide"},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-35348894843&partnerID=40&md5=df92560974d88c16b9c808399bfc1471}
}

@CONFERENCE{Barrientos2009635,
  author = {Barrientos, P.A.a b , López, P.E.M.b },
  title = {Developing DSLs using combinators. A design pattern},
  year = {2009},
  volume = {4},
  pages = {635-642},
  note = {cited By (since 1996) 0},
  abstract = {The development of domain-specific languages (DSLs) is considered
	by many authors as a hard task. To simplify the design of DSLs we
	describe a design pattern based on the combinators technique, which
	can also provide guidelines for previous domain analysis phase because
	it is based on equational reasoning over the domain knowledge. Combinators
	is a common technique from functional programming to write programs.
	It was used many times to implement domain-specific embedded languages
	(DSELs) but that implementation approach is not the only one. In
	this paper we present the pattern together with the underlying and
	basic ideas behind it. We also show benefits of using it and illustrate
	the use of this pattern with some examples. © 2009 IEEE.},
  affiliation = {Facultad de Informática, Universidad Nacional de La Plata, Argentina;
	Universidad Nacional de Quilmes, Argentina},
  art_number = {5352773},
  author_keywords = {Combinators; Design patterns; DSLs},
  document_type = {Conference Paper},
  journal = {Proceedings of the International Multiconference on Computer Science
	and Information Technology, IMCSIT '09},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-78649744926&partnerID=40&md5=2da1ddd96031b52f0457d09c56d1dadf}
}

@ARTICLE{Barringer201157,
  author = {Barringer, H.a , Havelund, K.b },
  title = {TraceContract: A scala DSL for trace analysis},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2011},
  volume = {6664 LNCS},
  pages = {57-72},
  note = {cited By (since 1996) 0},
  abstract = {In this paper we describe TraceContract, an API for trace analysis,
	implemented in the Scala programming language. We argue that for
	certain forms of trace analysis the best weapon is a high level programming
	language augmented with constructs for temporal reasoning. A trace
	is a sequence of events, which may for example be generated by a
	running program, instrumented appropriately to generate events. The
	API supports writing properties in a notation that combines an advanced
	form of data parameterized state machines with temporal logic. The
	implementation utilizes Scala's support for defining internal Domain
	Specific Languages (DSLs). Furthermore Scala's combination of object
	oriented and functional programming features, including partial functions
	and pattern matching, makes it an ideal host language for such an
	API. © 2011 Springer-Verlag.},
  affiliation = {School of Computer Science, University of Manchester, United Kingdom;
	Jet Propulsion Laboratory, California Institute of Technology, United
	States},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-79959971647&partnerID=40&md5=ff635d8d57cd5096f987d237c4e8b754}
}

@CONFERENCE{Barron2006285,
  author = {Barron, P., Cahill, V.},
  title = {YABS: A domain-specific language for pervasive computing based on
	stigmergy},
  year = {2006},
  pages = {285-294},
  note = {cited By (since 1996) 3},
  abstract = {This paper presents YABS, a novel domain-specific language for defining
	entity behavior in pervasive computing environments. The programming
	model of YABS is inspired by nature and, in particular, the observations
	made by the French biologist Grassé on how social insects coordinate
	their actions using indirect communication via the environment, a
	phenomenon that has become known as stigmergy. Following this approach
	yields a simple yet expressive language that abstracts the complexities
	of dealing with the variety of underlying technologies typical of
	pervasive computing environments and that facilitates the incremental
	construction and improvement of solutions while providing high-level
	constructs for defining the behavior of entities and their coordination.
	We show how YABS has been used to program a number of pervasive computing
	applications both deployed and simulated. Copyright © 2006 ACM.},
  affiliation = {Distributed Systems Group, School of Computer Science and Statistics,
	Trinity College, Dublin 2, Ireland},
  author_keywords = {Pervasive computing; Stigmergy},
  document_type = {Conference Paper},
  journal = {Proceedings of the 5th International Conference on Generative Programming
	and Component Engineering, GPCE'06},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-34547481889&partnerID=40&md5=16e9ba26c3c45c939e4621e430b31ca9}
}

@ARTICLE{Bassett200790,
  author = {Bassett, P.G.},
  title = {The case for frame-based software engineering},
  journal = {IEEE Software},
  year = {2007},
  volume = {24},
  pages = {90-99},
  number = {4},
  note = {cited By (since 1996) 0},
  abstract = {A frame is an archetype - a model from which all similar things are
	made. Frame technology can synthesize any information structure (such
	as a program) from machine-adaptable frames. The author contrasts
	FT with object-oriented classes. By canonically defining each information
	structure in terms of its unique properties, frames avoid the complexities
	induced by code-level redundancies. Frames also solve the problem
	of how to regenerate domain-specific-language programs without destroying
	prior customizations. The article includes evidence of FT's efficacy,
	its impact on software's life cycle, elements of frame design, and
	an easy way to get started. © 2007 IEEE.},
  affiliation = {Cutter Consortium},
  author_keywords = {Automatic programming; Evolutionary programming; Reuse models; Software
	engineering process},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-34547138153&partnerID=40&md5=9a5286df76b88c531f94a40239bb1a5a}
}

@CONFERENCE{Batory2006230,
  author = {Batory, D.},
  title = {Feature modularity in software product lines},
  year = {2006},
  pages = {230},
  note = {cited By (since 1996) 0},
  abstract = {Feature Oriented Programming (FOP) is a design methodology and tools
	for program synthesis in software product lines. Programs are specified
	declarad vely in terms of features. FOP has been used to develop
	product-lines in widely varying domains, including compilers for
	extensible Java dialects [6], fire support simulators for the U.S.
	Army [4], network protocols [1], web portlets [8], and program verification
	tools [9]. The fundamental units of modularization in FOP are program
	extensions (aspects, mixins, or traits) that encapsulate the implementation
	of an individual feature. An FOP model of a product-line is an algebra:
	base programs are constants and program extensions are functions
	(that add a specified feature to an input program). Program designs
	are expressions -compositions of functions and constants -that are
	amenable to optimization and analysis. FOP is at the confluence of
	many different areas of research: product lines, aspect oriented
	programming, metaprogramming (program design as a computation), layered
	designs [1], declarative domain specific languages [2], automatic
	programming (i.e., mapping a declarative specification of a program
	to an efficient implementation) [3], and multidimensional separation
	of concerns [5]. This tutorial reviews core results on FOP: compositional
	models of software development and program synthesis [6], models
	and tools for synthesizing code and non-code artifacts [6], formal
	representations of feature models and automatic algorithms for verifying
	feature compositions [2], relationships between metaprogramming,
	product lines, and model driven engineering (MDE) [7], and tool demonstrations
	of the above. © 2006 IEEE.},
  affiliation = {Department of Computer Sciences, University of Texas at Austin, Austin,
	TX, United States},
  art_number = {1691612},
  document_type = {Conference Paper},
  journal = {Proceedings - 10th International Software Product Line Conference,
	SPLC 2006},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-34547329631&partnerID=40&md5=6e0b2366101642cb6808b81832584324}
}

@ARTICLE{Batory20063,
  author = {Batory, D.},
  title = {A tutorial on feature oriented programming and the AHEAD tool suite},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2006},
  volume = {4143 LNCS},
  pages = {3-35},
  note = {cited By (since 1996) 8},
  abstract = {Feature oriented programming (FOP) is the study of feature modularity
	and its use in program synthesis. AHEAD is a theory of FOP that is
	based on a fundamental concept of generative programming that functions
	map programs. This enables the design of programs to be expressed
	compositionally as algebraic expressions, which are suited for automated
	analysis, manipulation, and program synthesis. This paper is a tutorial
	on FOP and AHEAD. We review AHEAD's theory and the tool set that
	implements it. © Springer-Verlag Berlin Heidelberg 2006.},
  affiliation = {Department of Computer Sciences, University of Texas at Austin, Austin,
	TX 78712, United States},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-33750069131&partnerID=40&md5=724055bf016c77d18acf81c6ba77ea6f}
}

@CONFERENCE{Batory2004702,
  author = {Batory, D.},
  title = {Feature-oriented programming and the AHEAD tool suite},
  year = {2004},
  volume = {26},
  pages = {702-703},
  note = {cited By (since 1996) 29},
  abstract = {Feature Oriented Programming (FOP) is an emerging paradigm for application
	synthesis, analysis, and optimization. A target application is specified
	declaratively as a set of features, like many consumer products (e.g.,
	personal computers, automobiles). FOP technology translates such
	declarative specifications into efficient programs. AHEAD is a model
	of FOP that is based on step-wise refinement, which advocates that
	complex programs can be synthesized from simple programs by incrementally
	adding features. The AHEAD Tool Suite (ATS) supports program development
	in AHEAD. AHEAD and ATS are among the most advanced models/tools
	for large-scale program synthesis.},
  affiliation = {Department of Computer Sciences, University of Texas at Austin, Austin,
	TX 78712, United States},
  document_type = {Conference Paper},
  journal = {Proceedings - International Conference on Software Engineering},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-4544349705&partnerID=40&md5=6effc5fdb654ee2741573e73776d0fba}
}

@CONFERENCE{Batory2003753,
  author = {Batory, D.},
  title = {A tutorial on feature oriented programming and product-lines},
  year = {2003},
  pages = {753-754},
  note = {cited By (since 1996) 7},
  abstract = {Feature Oriented Programming (FOP) is a design methodology and tools
	for program synthesis. The goal is to specify a target program in
	terms of the features that it offers, and to synthesize an efficient
	program that meets these specifications. FOP has been used to develop
	product-lines in disparate domains, including compilers for extensible
	Java dialects [3], fire support simulators for the U.S. Army [5],
	high-performance network protocols [1], and program verification
	tools [14].},
  affiliation = {Department of Computer Sciences, University of Texas at Austin, Austin,
	TX 78712, United States},
  document_type = {Conference Paper},
  journal = {Proceedings - International Conference on Software Engineering},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-0037924547&partnerID=40&md5=13c4902eebc2ea4d599c7806f5a399d2}
}

@ARTICLE{Batory2002191,
  author = {Batory, D.a b , Johnson, C.a c , Macdonald, B.a c , Von Heeder, D.a
	c },
  title = {Achieving extensibility through product-lines and domain-specific
	languages: A case study},
  journal = {ACM Transactions on Software Engineering and Methodology},
  year = {2002},
  volume = {11},
  pages = {191-214},
  number = {2},
  note = {cited By (since 1996) 37},
  abstract = {This is a case study in the use of product-line architectures (PLAs)
	and domain-specific languages (DSLs) to design an extensible command-and-control
	simulator for Army fire support. The reusable components of our PLA
	are layers or "aspects" whose addition or removal simultaneously
	impacts the source code of multiple objects in multiple, distributed
	programs. The complexity of our component specifications is substantially
	reduced by using a DSL for defining and refining state machines,
	abstractions that are fundamental to simulators. We present preliminary
	results that show how our PLA and DSL synergistically produce a more
	flexible way of implementing state-machine-based simulators than
	is possible with a pure Java implementation.},
  affiliation = {University of Texas, Austin, TX, United States; Department of Computer
	Sciences, University of Texas at Austin, Austin, TX 78712, United
	States; Applied Research Labs., University of Texas at Austin, Austin,
	TX 78713, United States},
  author_keywords = {Aspects; Domain-specific languages; GenVoca; Refinements; Simulation},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-2942713451&partnerID=40&md5=fc5a8453c4dc7f82ae4a112cad132311}
}

@CONFERENCE{Batory1998255,
  author = {Batory, Don, Chen, Gang, Robertson, Eric, Wang, Tao},
  title = {Design wizards and visual programming environments for generators},
  year = {1998},
  pages = {255-266},
  note = {cited By (since 1996) 0},
  abstract = {Domain-specific generators will increasingly rely on graphical specification
	languages - applets - for declarative specifications of target applications.
	Applets will provide front-ends to generators and related tools to
	produce customized code on demand. Critical to the success of this
	approach will be domain-specific design wizards, tools that guide
	users in their selection of components for constructing particular
	applications. In this paper, we present the P3 ContainerStore applet,
	its generator, and design wizard.},
  affiliation = {Univ of Texas at Austin, Austin, United States},
  document_type = {Conference Paper},
  journal = {International Conference on Software Reuse},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-0031699123&partnerID=40&md5=7c3f6c43c45ead507666211e4e992902}
}

@CONFERENCE{Batory1998143,
  author = {Batory, Don, Lofaso, Bernie, Smaragdakis, Yannis},
  title = {JTS: Tools for implementing domain-specific languages},
  year = {1998},
  pages = {143-153},
  note = {cited By (since 1996) 59},
  abstract = {The Jakarta Tool Suite (JTS) aims to reduce substantially the cost
	of generator development by providing domain-independent tools for
	creating domain-specific languages and component-based generators
	called GenVoca generators. JTS is a set of precompiler-compiler tools
	for extending industrial programming languages (e.g., Java) with
	domain-specific constructs. JTS is itself a GenVoca generator, where
	precompilers for JTS-extended languages are constructed from components.},
  affiliation = {Univ of Texas at Austin, Austin, United States},
  document_type = {Conference Paper},
  journal = {International Conference on Software Reuse},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-0031675048&partnerID=40&md5=1045e6de1d95bc2a94a4fb05a458cec0}
}

@CONFERENCE{Baudry2010,
  author = {Baudry, B.a , Bazex, P.b , Dalbin, J.-C.c , Dhaussy, P.d , Dubois,
	H.e , Percebois, C.b , Poupart, E.f , Sabatier, L.g },
  title = {Trust in MDE components: The DOMINO experiment},
  year = {2010},
  note = {cited By (since 1996) 0},
  abstract = {A large number of modeling activities can be automatic or computer
	assisted. This automation ensures a more rapid and robust software
	development. However, engineers must ensure that the models have
	the properties required for the application. In order to tend towards
	this requirement, the DOMINO project (DOMaINs and methodological
	prOcess) proposes to use the so-called trustworthy Model-Driven Engineering
	(MDE) components and aims to provide a methodology for the validation
	and qualification of such components.},
  affiliation = {IRISA, Campus universitaire de Beaulieu, 35042 Rennes, France; IRIT,
	Université de Toulouse, 31062 Toulouse, France; Airbus France, 316,
	route de Bayonne, 31060 Toulouse, France; ENSIETA, 2, rue François
	Verny, 29806 Brest, France; CEA LIST, Point Courrier 94, 91191 Gif-sur-Yvette,
	France; CNES, 31401 Toulouse, France; Sodifrance, 15, chemin de la
	Crabe, 31300 Toulouse, France},
  art_number = {2},
  author_keywords = {Component; Domain-specific languages; Model-driven engineering trust;
	Mutation analysis; OCL contracts; Proofs; Requirement; Transformation
	tests; Transformation traceability},
  document_type = {Conference Paper},
  journal = {ACM International Conference Proceeding Series},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-78650492334&partnerID=40&md5=d652e376d1de20b8e85e2d5b54cc20b4}
}

@ARTICLE{Bauer2010294,
  author = {Bauer, T., Erwig, M.},
  title = {Declarative scripting in Haskell},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2010},
  volume = {5969 LNCS},
  pages = {294-313},
  note = {cited By (since 1996) 0},
  abstract = {We present a domain-specific language embedded within the Haskell
	programming language to build scripts in a declarative and type-safe
	manner. We can categorize script components into various orthogonal
	dimensions, or concerns, such as IO interaction, configuration, or
	error handling. In particular, we provide special support for two
	dimensions that are often neglected in scripting languages, namely
	creating deadlines for computations and tagging and tracing of computations.
	Arbitrary computations may be annotated with a textual tag explaining
	its purpose. Upon failure a detailed context for that error is automatically
	produced. The deadline combinator allows one to set a timeout on
	an operation. If it fails to complete within that amount of time,
	the computation is aborted. Moreover, this combinator works with
	the tag combinator so as to produce a contextual trace. © 2010 Springer-Verlag.},
  affiliation = {Oregon State University, Corvallis, OR, United States},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-77951585098&partnerID=40&md5=727c2886ac3567be9b661914797808c8}
}

@CONFERENCE{Beal201065,
  author = {Beal, J., Webb, J., Atighetchi, M.},
  title = {Adjustable autonomy for cross-domain entitlement decisions},
  year = {2010},
  pages = {65-71},
  note = {cited By (since 1996) 0},
  abstract = {Cross-domain information exchange is a growing problem, as business
	and governmental organizations increasingly need to integrate their
	information systems with those of partially trusted partners. Current
	identity management and access control technologies operate only
	within a specific domain and are unable to scale to the asymmetric,
	heteroge-neously administered, and highly restrictive security policies
	of cross-domain environments. We approach the problem as one of adjustable
	autonomy, in which the human administrator needs to encode policy
	intent in a way that allows routine decisions about policy interactions
	to be safely delegated to the machine. In this paper, we present
	work toward such a system, combining a lattice representation of
	access control decisions and client attributes with search through
	a space of cross-domain mapping relations. This combination enables
	a policy resolution algorithm that resolves routine policy interactions
	while flagging potential conflicts for attention from a human administrator.
	© 2010 ACM.},
  affiliation = {Raytheon BBN Technologies, 10 Moulton Street, Cambridge, MA 02138,
	United States},
  author_keywords = {Cross-domain; Domain-specific language; Policy description},
  document_type = {Conference Paper},
  journal = {Proceedings of the ACM Conference on Computer and Communications
	Security},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-78650082745&partnerID=40&md5=5b573282cbc577b1489db4933211f3d1}
}

@ARTICLE{Behjati2011236,
  author = {Behjati, R.a b , Yue, T.a , Nejati, S.a , Briand, L.a b , Selic,
	B.a c },
  title = {Extending SysML with AADL concepts for comprehensive system architecture
	modeling},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2011},
  volume = {6698 LNCS},
  pages = {236-252},
  note = {cited By (since 1996) 0},
  abstract = {Recent years have seen a proliferation of languages for describing
	embedded systems. Some of these languages have emerged from domain-specific
	frameworks, and some are adaptions or extensions of more general-purpose
	languages. In this paper, we focus on two widely-used standard languages:
	the Architecture Analysis and Design Language (AADL) and the Systems
	Modeling Language (SysML). AADL was born as an avionics-focused domain-specific
	language and later on has been revised to represent and support a
	more general category of embedded real-time systems. SysML is an
	extension of the Unified Modeling Language (UML) intended to support
	system engineering and modeling. We propose the ExSAM profile that
	extends SysML by adding AADL concepts to it with the goal of exploiting
	the key advantages of both languages in a seamless way. More precisely,
	by using ExSAM and any SysML modeling environment, we will be able
	to both model system engineering concepts and use AADL analysis tools
	where needed. We describe the ExSAM profile through several examples
	and compare it with existing alternatives. We have implemented ExSAM
	using IBM Rational Rhapsody and evaluated its completeness and usefulness
	through two case studies. © 2011 Springer-Verlag.},
  affiliation = {Simula Research Laboratory, Lysaker, Norway; University of Oslo, Oslo,
	Norway; Malina Software Corp., Ottawa, ON, Canada},
  author_keywords = {AADL; Architecture modeling languages; Embedded control systems; Integrated
	Control Systems (ICSs); SysML; Systems modeling languages},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-79959270570&partnerID=40&md5=89ea72fc468b3d135f01d2d900198f1e}
}

@CONFERENCE{Behrens2010123,
  author = {Behrens, H.},
  title = {MDSD for the iPhone: Developing a domain-specific language and IDE
	tooling to produce real world applications for mobile devices},
  year = {2010},
  pages = {123-127},
  note = {cited By (since 1996) 0},
  abstract = {During the last years, code generators and models have become increasingly
	popular tools to support software development processes in manyfold
	ways. At the same time, the emerging pervasiveness of domain-specific
	languages (DSLs) in this field has complemented the idea of raising
	the level of abstraction by introducing specialized view points of
	a certain problem space. In combination with a proper set of idioms
	at the target platform generation-based approaches allow for weaving
	generated parts of an application with handwritten enhancements and
	refinements over the whole application lifecycle. The mobile division
	of itemis AG has delivered an implementation of such a model-based
	solution for mobile devices that uses a DSL to completely describe
	the structure and behavior of data-centric mobile applications. Its
	tool support reaches from static analysis over code navigation to
	compiler and simulator integration of the iPhone development platform.
	© 2010 ACM.},
  affiliation = {Itemis AG, Germany},
  author_keywords = {Development environment; Domain-specific language; Eclipse; IPhone;
	Mobile devices; Model-driven software development},
  document_type = {Conference Paper},
  journal = {Proceedings of the ACM International Conference Companion on Object
	Oriented Programming Systems Languages and Applications Companion,
	SPLASH '10},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-78650136989&partnerID=40&md5=f3c6254073779a6cc0b3696cf7a37476}
}

@ARTICLE{Belix2005621,
  author = {Belix, J.E., Fernandes, S.M., Shimizu Melnikoff, S.S., Spina, E.},
  title = {Effort reducing in software modeling on MDA approach},
  journal = {WSEAS Transactions on Computers},
  year = {2005},
  volume = {4},
  pages = {621-626},
  number = {6},
  note = {cited By (since 1996) 0},
  abstract = {The MDA (Model Driven Architecture) is an approach for software development
	that has the ability to produce applications for virtually every
	middleware platform from the same base model. All the MDA development
	projects start with the creation of a Platform Independent Model
	(PIM), which expresses only business functionality and behavior,
	abstracting away platform-specific details. This paper focuses on
	defin ing recommendations to help reducing the necessary effort to
	represent the PIM model, by the adoption of predefined solutions
	for the software to be generated. The paper also presents a taxonomy
	for these predefined solutions and the consequences of their use,
	pertaining to modeling effort.},
  affiliation = {The Department of Computing and Digital Systems Engineering, University
	of São Paulo - Polytechnic School, Av. Professor Luciano Gualberto,
	São Paulo, SP 05508-900, Brazil},
  author_keywords = {Abstractions; CASE tools; Generative programming; MDA; MDD; Software
	architecture},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-21944433791&partnerID=40&md5=1f4c1bcc6582fadf15818f2af52d0558}
}

@CONFERENCE{Bell2007994,
  author = {Bell, P.},
  title = {A practical high volume software product line},
  year = {2007},
  pages = {994-1003},
  note = {cited By (since 1996) 2},
  abstract = {Many Software Product Line case studies focus on the fact that an
	ROI can be achieved in 3-5 projects. This paper asks the question
	"what has to be done differently to be able to generate 10,000 custom
	applications a year?" As wholesalers of custom web applications for
	Small to Medium Sized Businesses, we have to create highly customizable
	web applications in minutes - not months. After 18 months of research
	and experimentation we have developed a layered system that focuses
	on the reuse of declarative executable specifications rather than
	the reuse of imperative code, allowing us to blend speed of development
	with flexibility of the generated solutions. The system uses a feature
	modeler to select common functionality and a decision support system
	to de-skill the customization process. It has a collection of domain
	specific languages for describing the vast majority of custom functionality
	required by our clients and an extensible framework allowing any
	system functionality to be overloaded/extended using custom code
	if necessary. In this paper we provide an introduction to the key
	theoretical concepts required to understand the system. We then introduce
	our domain specific languages for describing web applications. We
	then look at the process of building applications using SystemsForge
	and then we highlight our conclusions to date and document some of
	the outstanding issues that we are still investigating relating to
	managing domain specific language evolution and interactions.},
  affiliation = {SystemsForge, 9/10 St Andrew Square, Edinburgh EH2 2AF, United Kingdom},
  author_keywords = {Architecture; Configuration management; Domain specific language;
	Experience; Feature modeling; Language oriented programming; Practitioner
	report; Software product line},
  document_type = {Conference Paper},
  journal = {Proceedings of the Conference on Object-Oriented Programming Systems,
	Languages, and Applications, OOPSLA},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-42149134917&partnerID=40&md5=85cab4fd7b0f03df73a900ffd8668c14}
}

@CONFERENCE{Bencomo2006,
  author = {Bencomo, N., Blair, G., Grace, P.},
  title = {Models, reflective mechanisms and family-based systems to support
	dynamic configuration},
  year = {2006},
  volume = {183},
  note = {cited By (since 1996) 0},
  abstract = {Middleware platforms must satisfy an increasingly broad and variable
	set of requirements arising from the needs of both applications and
	underlying systems deployed in dynamically changing environments
	such as environment monitoring and disaster management. To meet these
	requirements, middleware platforms must offer a high degree of configurability
	at deployment time and runtime. At Lancaster we use reflection, components
	and component frameworks, and middleware families as the basis of
	our approach to develop dynamically configurable middleware platforms.
	In our approach, components and component frameworks provide structure,
	and reflection provides support for dynamic configuration and extensibility
	for run-time evolution and adaptation. This approach however has
	contributed to make the development and operation of middleware platforms
	even more complex. Middleware developers deal with a large number
	of variability decisions when planning (re)configurations and adaptations.
	This paper examines how Model-Driven Engineering (MDE), Domain Specific
	Languages (DSLs) and System Family Engineering can be used to improve
	the development of middleware families, systematically generating
	middleware configurations from high level descriptions. We present
	Genie, a DSL-based prototype development-tool that supports the specification,
	validation and generation of artefacts for component-based reflective
	middleware. In particular, this paper describes how the Genie toolkit
	improves the development of the Gridkit middleware through the modelling
	and automated generation of middleware policies; that remove the
	complexity of handling large number of runtime adaptation policies.
	Copyright 2006 ACM.},
  affiliation = {Lancaster University, Comp. Dep., InfoLab21, Lancaster, LA1 4WA, United
	Kingdom},
  art_number = {1169088},
  author_keywords = {DSL; Grid computing; MDE; Reflective middleware; System families},
  document_type = {Article},
  journal = {ACM International Conference Proceeding Series},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-34547170534&partnerID=40&md5=0515f8136d6f84a1c8f4c6c129a6959e}
}

@ARTICLE{Bennett2010338,
  author = {Bennett, M., Borgen, R., Havelund, K., Ingham, M., Wagner, D.},
  title = {Prototyping a domain-specific language for monitor and control systems},
  journal = {Journal of Aerospace Computing, Information and Communication},
  year = {2010},
  volume = {7},
  pages = {338-364},
  number = {11},
  note = {cited By (since 1996) 0},
  abstract = {This paper describes a domain-specific language prototype developed
	for the NASA Constellation launch control system project. A key element
	of the launch control system architecture, the domain-specific language
	prototype is a specialized monitor and control language composed
	of constructs for specifying and programming test, checkout, and
	launch processing applications for flight and ground systems. The
	principal objectives of the prototyping activity were to perform
	a proof-of-concept of an approach to ultimately lower the lifecycle
	costs of application software for the launch control system, and
	to explore mitigations for a number of development risks perceived
	by the project. The language has been implemented as a library that
	extends the dynamically-typed Python scripting language, and validated
	in a demonstration of capability required for Constellation. A study
	of the statically typed Scala programming language as an alternative
	domain-specific language implementation language is also presented.
	© 2010 by the American Institute of Aeronautics and Astronautics,
	Inc.},
  affiliation = {Jet Propulsion Laboratory, California Institute of Technology, Pasadena,
	CA 91109, United States},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-78650251912&partnerID=40&md5=cf3c8fdaf64239953ca708e6b718ef23}
}

@CONFERENCE{Benton200713,
  author = {Benton, W.C., Fischer, C.N.},
  title = {Interactive, scalable, declarative program analysis: From prototype
	to implementation},
  year = {2007},
  pages = {13-24},
  note = {cited By (since 1996) 4},
  abstract = {Static analyses provide the semantic foundation for tools ranging
	from optimizing compilers to refactoring browsers and advanced debuggers.
	Unfortunately, developing new analysis specifications and implementations
	is often difficult and error-prone. Since analysis specifications
	are generally written in a declarative style, logic programming presents
	an attractive model for producing executable specifications of analyses.
	However, prior work on using logic programming for program analysis
	has focused exclusively on solving constraints derived from program
	texts by an external preprocessor. In this paper, we present DIMPLE,
	an analysis framework for Java bytecodes implemented in the Yap Prolog
	system [8]. DIMPLE provides both a representation of Java bytecodes
	in a database of relations and a declarative domain-specific language
	for specifying new analyses as queries over this database. DIMPLE
	thus enables researchers to use logic programming for every step
	of the analysis development process, from specification to prototype
	to implementation. We demonstrate that our approach facilitates rapid
	prototyping of new program analyses and produces executable analysis
	implementations that are speed-competitive with specialized analysis
	toolkits. Copyright © 2007 ACM.},
  affiliation = {Computer Sciences Department, University of Wisconsin, Madison, WI
	53706},
  author_keywords = {Bytecodes; Java; Logic programming; Program analysis; Prototyping;
	Tabled prolog},
  document_type = {Conference Paper},
  journal = {PPDP'07: Proceedings of the 9th International ACM SIGPLAN Conference
	on Principles and Practice of Declarative Programming},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-34548101177&partnerID=40&md5=1509ec01b5f0fe7f2aa7afc6df89d0a7}
}

@ARTICLE{Bergel201168,
  author = {Bergel, A.a , Nierstrasz, O.b , Renggli, L.a , Ressia, J.b },
  title = {Domain-specific profiling},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2011},
  volume = {6705 LNCS},
  pages = {68-82},
  note = {cited By (since 1996) 0},
  abstract = {Domain-specific languages and models are increasingly used within
	general-purpose host languages. While traditional profiling tools
	perform well on host language code itself, they often fail to provide
	meaningful results if the developers start to build and use abstractions
	on top of the host language. In this paper we motivate the need for
	dedicated profiling tools with three different case studies. Furthermore,
	we present an infrastructure that enables developers to quickly prototype
	new profilers for their domain-specific languages and models. © 2011
	Springer-Verlag Berlin Heidelberg.},
  affiliation = {PLEIAD Lab, Department of Computer Science (DCC), University of Chile,
	Chile; Software Composition Group, University of Bern, Switzerland},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-79960151496&partnerID=40&md5=b5e76b854e3141a9bfb178d21186402c}
}

@ARTICLE{Bergmann2011389,
  author = {Bergmann, G., Horváth, Á., Ráth, I., Varró, D.},
  title = {Incremental evaluation of model queries over EMF models: A tutorial
	on EMF-IncQuery},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2011},
  volume = {6698 LNCS},
  pages = {389-390},
  note = {cited By (since 1996) 0},
  abstract = {Model driven development platforms such as the industry leader Eclipse
	Modeling Framework (EMF) greatly benefit from pattern matching, as
	it supports various usecases including model validation, model transformation,
	code generation and domain specific behaviour simulation. Pattern
	matching is a search for model elements conforming to a given pattern
	that describes their arrangement and properties, e.g. finding a violation
	of a complex well-formedness constraint of a domain specific modeling
	language. © 2011 Springer-Verlag.},
  affiliation = {Budapest University of Technology and Economics, Department of Measurement
	and Information Systems, Magyar tudósok krt. 2, H-1117 Budapest,
	Hungary},
  author_keywords = {EMF; incremental pattern matching; model query},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-79959209275&partnerID=40&md5=8ee2d4a7fc01c6eb98d3ab64f60d74e4}
}

@CONFERENCE{Bergmann200825,
  author = {Bergmann, G., Ökrös, A., Ráth, I., Varró, D., Varró, G.},
  title = {Incremental pattern matching in the VIATRA model transformation system},
  year = {2008},
  pages = {25-32},
  note = {cited By (since 1996) 0},
  abstract = {Incremental pattern matching is a key challenge for many tool integration,
	model synchronization and (discrete-event) model simulation tasks.
	An incremental pattern matching engine explicitly stores existing
	matches, while these matches are maintained incrementally with respect
	to the changes of the underlying model. In the current paper, we
	present an adaptation of RETE networks [6] in order to provide incremental
	support for the transformation language of the VIATRA2 framework.
	We evaluate the performance of the incremental engine on a benchmark
	problem assessing the speedup of incremental processing in the case
	of as-long-as-possible type of rule applications. Copyright 2008
	ACM.},
  affiliation = {Budapest University of Technology and Economics, Department of Measurement
	and Information Systems, Magyar Tudósok krt. 2, 1117 Budapest, Hungary},
  author_keywords = {Domain-specific languages; Incremental graph pattern matching; Incremental
	model transformation},
  document_type = {Conference Paper},
  journal = {Proceedings - International Conference on Software Engineering},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-57449114393&partnerID=40&md5=279417a819030a069bbda5f1d0779344}
}

@CONFERENCE{Bergstrom2007475,
  author = {Bergstrom, E., Pandey, R.},
  title = {Composing μSIC: A lightweight service model for wireless sensor networks},
  year = {2007},
  pages = {475-483},
  note = {cited By (since 1996) 0},
  abstract = {Although Wireless Sensor Network applications share a common set of
	limitations (e.g. resource scarcity and lossy radio communication
	models) a basic set of runtime services (e.g. routing, time synchronization,
	and code dissemination), applications are often designed in an adhoc
	fashion, reducing the amount of code reuse, making a component-based
	software engineering approach desirable. We present a micro service
	component model, entitled μSIC, that abstracts a sensor node as an
	entity that provides and uses services. This model is realized through
	the use of the μSIC runtime, a small and efficient Message-Oriented
	Middleware (MOM) tailored for resource-constrained devices. The μSIC
	runtime can perform service-paging, a method of storing a service's
	state to flash memory and restoring it whenever the service is needed.
	Secondly, we provide a domain-specific language allowing applications
	to be expressed as a collection of services that run on top of the
	μSIC runtime and enables a multi-threaded programming model. © 2007
	IEEE.},
  affiliation = {Department of Computer Science, University of California, Davis, Davis,
	CA 95616, United States},
  art_number = {4394966},
  document_type = {Conference Paper},
  journal = {2007 International Conference on Sensor Technologies and Applications,
	SENSORCOMM 2007, Proceedings},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-46449096690&partnerID=40&md5=fe241108cb7d356835c05f5d4616da08}
}

@ARTICLE{Berkenkötter2007159,
  author = {Berkenkötter, K.},
  title = {OCL-based validation of a railway domain profile},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2007},
  volume = {4364 LNCS},
  pages = {159-168},
  note = {cited By (since 1996) 3},
  abstract = {Domain-specific languages become more and more important these days
	as they facilitate the close collaboration of domain experts and
	software developers. One effect of this general tendency is the increasing
	number of UML profiles. UML itself as a popular modeling language
	is capable of modeling all kinds of systems but it is often inefficient
	due to its wide-spectrum approach. Profiles tailor the UML to a specific
	domain and can hence be seen as domain-specific dialects of UML.
	At the moment, they mainly introduce new terminology, often in combination
	with OCL constraints which describe the new constructs more precisely.
	As most tools do not support validation of OCL expressions let alone
	supplementing profiles with OCL constraints, it is difficult to check
	if models based on a profile comply to this profile. A related problem
	is checking whether constraints in the profile contradict constraints
	in the UML specification. In this paper, it is shown how to complete
	these tasks with the tool USE. As an example, a profile from the
	railway control systems domain is taken which describes the use of
	its modeling elements strictly my means of OCL. Models based on this
	profile serve as a foundation for automated code generation and require
	unambiguous meaning. © Springer-Verlag Berlin Heidelberg 2007.},
  affiliation = {University of Bremen, P.O. Box 330 440, 28334 Bremen, Germany},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-38149053620&partnerID=40&md5=4fa74dfa85db648b03324eb611dc4c1a}
}

@ARTICLE{Berkenkötter2006398,
  author = {Berkenkötter, K., Hannemann, U.},
  title = {Modeling the Railway Control Domain rigorously with a UML 2.0 profile},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2006},
  volume = {4166 LNCS},
  pages = {398-411},
  note = {cited By (since 1996) 4},
  abstract = {We introduce the Railway Control Systems Domain (RCSD) profile of
	the Unified Modeling Language UML 2.0 as a domain specific modeling
	language for railway and tramway control systems. The RCSD profile
	covers the segments of the rail network, sensors, and control elements
	like signals and switches. Using these terms of the railway domain,
	it facilitates the communication between domain experts and specialists
	for embedded control system development. Defined as a profile for
	UML 2.0, the development of precise RCSD descriptions is supported
	by standard UML tools, visualizing railway networks in the same way
	as domain experts are used to. The static description of networks
	is complemented by the characterization of the dynamics within the
	network with trains running on predefined routes. This behaviour
	is provided by the semantics of a state transition system derived
	from the object diagram of a particular network model. This rigorous
	semantic approach constitutes a prerequisite for further tool-supported
	analysis of safety requirements, and generation of the actual control
	system. © Springer-Verlag Berlin Heidelberg 2006.},
  affiliation = {University of Bremen, P.O. Box 330 440, 28334 Bremen, Germany},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-33751016359&partnerID=40&md5=20ab3ccc8942042ab2663d6dcd3e4351}
}

@ARTICLE{Bertrand1999347,
  author = {Bertrand, F., Augeraud, M.},
  title = {BDL: A specialized language for per-object reactive control},
  journal = {IEEE Transactions on Software Engineering},
  year = {1999},
  volume = {25},
  pages = {347-362},
  number = {3},
  note = {cited By (since 1996) 4},
  abstract = {The problem of describing the concurrent behavior of objects in object-oriented
	languages is addressed. The approach taken is to let methods be the
	behavior units whose synchronization is controlled separate from
	their specification. Our proposal is a domain-specific language,
	called BDL, for expressing constraints on this control and actually
	implementing its enforcement. We propose a model where each object
	includes a so-called `execution controller,' programmed in BDL. This
	separates cleanly the concepts of what the methods do, the object
	processes, from the circumstances in which they are allowed to do
	it, the control. The object controller ensures that scheduling constraints
	between the object's methods are met. Aggregate objects can be controlled
	in terms of their components. This language has a convenient formal
	base. Thus, using BDL expressions, behavioral properties of objects
	or groups of interesting objects can be verified. Our approach allows,
	for example, deadlock detection or verification of safety properties,
	while maintaining a reasonable code size for the running controller.
	A compiler from BDL has been implemented, automatically generating
	controller code in an Esterel program, i.e., in a reactive programming
	language. From this code, the Esterel compiler, in turn, generates
	an automaton on which verifications are done. Then this automaton
	is translated into a C code to be executed. This multistage process
	typifies the method for successful use of a domain-specific language.
	This also allows high-level concurrent programming.},
  affiliation = {Laboratoire d'Informatique et d'Imagerie Industrielle, UFR Sciences,
	Université de la Rochelle, Avenue Marillac, 17042 La Rochelle, Cedex
	01, France},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-0032594243&partnerID=40&md5=a52e98080b301f1b8fd361212fa4488b}
}

@CONFERENCE{Bestavros2010231,
  author = {Bestavros, A.a , Kfoury, A.a , Lapets, A.a , Ocean, M.J.b },
  title = {Safe compositional network sketches: Formal framework},
  year = {2010},
  pages = {231-241},
  note = {cited By (since 1996) 1},
  abstract = {NetSketch is a tool for the specification of constrained-flow applications
	and the certification of desirable safety properties imposed thereon.
	NetSketch assists system integrators in two types of activities:
	modeling and design. As a modeling tool, it enables the abstraction
	of an existing system while retaining sufficient information about
	it to carry out future analysis of safety properties. As a design
	tool, NetSketch enables the exploration of alternative safe designs
	as well as the identification of minimal requirements for out-sourced
	subsystems. NetSketch embodies a lightweight formal verification
	philosophy, whereby the power (but not the heavy machinery) of a
	rigorous formalism is made accessible to users via a friendly interface.
	NetSketch does so by exposing tradeoffs between exactness of analysis
	and scalability, and by combining traditional whole-system analysis
	with a more flexible compositional analysis. The compositional analysis
	is based on a strongly-typed Domain-Specific Language (DSL) for describing
	and reasoning about constrained-flow networks at various levels of
	sketchiness along with invariants that need to be enforced thereupon.
	In this paper, we define the formal system underlying the operation
	of NetSketch, in particular the DSL behind NetSketch's userinterface
	when used in "sketch mode", and prove its soundness relative to appropriately-defined
	notions of validity. In a companion paper [7], we overview NetSketch,
	highlight its salient features, and illustrate how it could be used
	in applications that include: the management/shaping of traffic flows
	in a vehicular network (as a proxy for cyber-physical systems (CPS)
	applications) and a streaming media network (as a proxy for Internet
	applications). © 2010 ACM.},
  affiliation = {Computer Science Dept., Boston University, Boston, MA 02215, United
	States; Computer Science Dept., Endicott College, Beverly, MA 09195,
	United States},
  author_keywords = {Compositionality; Design; Modeling; Typing; Verification},
  document_type = {Conference Paper},
  journal = {HSCC'10 - Proceedings of the 13th ACM International Conference on
	Hybrid Systems: Computation and Control},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-77953052603&partnerID=40&md5=a9858b7cbf6f4be78c2074d84160efbd}
}

@CONFERENCE{Bettin2003114,
  author = {Bettin, J., Hoare, J.},
  title = {Time Conscious Objects™},
  year = {2003},
  pages = {114},
  note = {cited By (since 1996) 0},
  abstract = {In most business software systems the time dimension of business objects
	plays a significant role. Time is a crosscutting concern that is
	hard to separate from other business logic. We have developed a toolkit
	that allows existing business application systems to be extended
	with "time- conscious" behavior in a non-intrusive way by factoring
	out all aspects of time-related behavior into a framework and a set
	of classes that is distinct from the existing code base. The Time
	Conscious Objects™ (TCO™) toolkit is currently implemented in Java™,
	but through the use of generation technology the toolkit can easily
	be made available in any language that supports polymorphism.},
  affiliation = {SoftMetaWare, PO Box 617, Waiheke Island, Auckland, New Zealand},
  author_keywords = {Auditability; Domain-driven development; Domain-specific languages;
	Logging; Model driven architecture (MDA); Redo; Temporal; Time; Undo;
	Versioning},
  document_type = {Conference Paper},
  journal = {Proceedings of the Conference on Object-Oriented Programming Systems,
	Languages, and Applications, OOPSLA},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-79951660488&partnerID=40&md5=36aae6c4ef993e25f702ab5798a51099}
}

@CONFERENCE{Bettin2003290,
  author = {Bettin, J., Hoare, J.},
  title = {Time Conscious Objects™: A domain-specific framework and generator},
  year = {2003},
  pages = {290-291},
  note = {cited By (since 1996) 0},
  abstract = {In most business software systems the time dimension of business objects
	plays a significant role. Time is a crosscutting concern that is
	hard to separate from other business logic. We have developed a toolkit
	that allows existing business application systems to be extended
	with "time- conscious" behavior in a non-intrusive way by factoring
	out all aspects of time-related behavior into a framework and a set
	of classes that is distinct from the existing code base. The Time
	Conscious Objects™ (TCO™) toolkit is currently implemented in Java™,
	but through the use of generation technology the toolkit can easily
	be made available in any language that supports polymorphism.},
  affiliation = {SoftMetaWare, PO Box 617, Waiheke Island, Auckland, New Zealand},
  author_keywords = {Auditability; Domain-driven development; Domain-specific languages;
	Logging; Model driven architecture (MDA); Redo; Temporal; Time; Undo;
	Versioning},
  document_type = {Conference Paper},
  journal = {Proceedings of the Conference on Object-Oriented Programming Systems,
	Languages, and Applications, OOPSLA},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-79951604048&partnerID=40&md5=18bf07944f023a332a9b2d04502a91cf}
}

@CONFERENCE{Bettin2009709,
  author = {Bettin, J.a , Cook, W.b , Clark, T.c , Kelly, S.d },
  title = {Knowledge industry survival strategy (KISS): Fundamental principles
	and interoperability requirements for domain specific modeling languages},
  year = {2009},
  pages = {709-710},
  note = {cited By (since 1996) 1},
  abstract = {Domain Specific Languages are raising the level of abstraction of
	software specifications and of knowledge represen-tation in general.
	When DSLs are used to formalize the results of domain analysis, the
	result is a clean separation of concerns in the problem space. This
	is a major advance over aspect oriented programming, where separation
	of concerns is only achieved in the solution space. However, the
	level of interoperability between current DSL tools is comparable
	to the level of interoperability between CASE tools in the 90s. To
	increase the popularity of DSL based approaches, this needs to change.
	Software development has become highly decentralized, and an assumption
	that all parties in a global software supply chain will use identical
	tooling is simply not realistic. As a result today's software supply
	chains are much less automated than supply chains in other, more
	mature industries. The KISS series of workshops is used to incrementally
	establish a consensus on the fundamental principles that underpin
	the use of DSLs, and to improve DSL tool interoperability.},
  affiliation = {Sofismo, Switzerland; University of Texas, Austin, TX, United States;
	Thames Valley University, United Kingdom; MetaCase, Finland},
  author_keywords = {Domain specific language; Interoperability; Model driven software;
	Modeling language design; Modularity},
  document_type = {Conference Paper},
  journal = {Proceedings of the Conference on Object-Oriented Programming Systems,
	Languages, and Applications, OOPSLA},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-72249106452&partnerID=40&md5=e9edce938b3a12f7771e8465c627da5a}
}

@CONFERENCE{Bettin200388,
  author = {Bettin, J.a , Van Emde Boas, G.b },
  title = {Generative Model Transformer},
  year = {2003},
  pages = {88-89},
  note = {cited By (since 1996) 0},
  abstract = {The Generative Model Transformer (GMT) project is an Open Source initiative
	to build a Model Driven Architecure™ tool that allows fully customisable
	Platform Independent Models, Platform Description Models, Texture
	Mappings, and Refinement Transformations. The project should result
	in (a) a tool that fulfils the MDA promise for faster/more accurate/better
	maintainable application development, (b) a tool for industrial use,
	and (c) MDA related research - which is encouraged and needed. A
	distinctive feature of GMT is the emphasis of model transformations
	as "first-class model citizens". The implementation of model transformations
	is envisaged to be in conformance with the future OMG modeling standard
	for Queries, Views, and Transformations (QVT).},
  affiliation = {SoftMetaWare, PO Box 617, Waiheke Island, Auckland, New Zealand; Bronstee
	Software and Services, Franz Lisztlaan 5, 2102 CJ Heemstede, Netherlands},
  author_keywords = {Domain-specific languages; Generative Model Transformer (GMT); Model
	Driven Architecture (MDA); Model transformation; Open Source; QVT},
  document_type = {Conference Paper},
  journal = {Proceedings of the Conference on Object-Oriented Programming Systems,
	Languages, and Applications, OOPSLA},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-79951655544&partnerID=40&md5=78a5b6a15394dba67299be53aa53c096}
}

@CONFERENCE{Bettin2003294,
  author = {Bettin, J.a , Van Emde Boas, G.b , Willink, E.D.c },
  title = {Generative Model Transformer : An open source MDA tool initiative},
  year = {2003},
  pages = {294-295},
  note = {cited By (since 1996) 0},
  abstract = {The Generative Model Transformer (GMT) project is an Open Source initiative
	to build a Model Driven Architecure™ tool that allows fully customisable
	Platform Independent Models, Platform Description Models, Texture
	Mappings, and Refinement Transformations. The project should result
	in (a) a tool that fulfils the MDA promise for faster/more accurate/better
	maintainable application development, (b) a tool for industrial use,
	and (c) MDA related research - which is encouraged and needed. A
	distinctive feature of GMT is the emphasis of model transformations
	as "first-class model citizens". The implementation of model transformations
	is envisaged to be in conformance with the future OMG modeling standard
	for Queries, Views, and Transformations (QVT).},
  affiliation = {SoftMetaWare, PO Box 617, Waiheke Island, Auckland, New Zealand; Bronstee
	Software and Services, Franz Lisztlaan 5, 2102 CJ Heemstede, Netherlands;
	Thales Research and Technology Limited, Reading, United Kingdom},
  author_keywords = {Domainspecific languages; Generative Model Transformer (GMT); Model
	Driven Architecture (MDA); Model transformation; Open source; QVT},
  document_type = {Conference Paper},
  journal = {Proceedings of the Conference on Object-Oriented Programming Systems,
	Languages, and Applications, OOPSLA},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-79951659201&partnerID=40&md5=69cb32fa2657598d4c6c18117409e2b1}
}

@CONFERENCE{Bettini2010129,
  author = {Bettini, L.a , Damiani, F.a , Schaefer, I.b , Strocco, F.a },
  title = {A prototypical Java-like language with records and traits},
  year = {2010},
  pages = {129-138},
  note = {cited By (since 1996) 1},
  abstract = {Traits have been designed as units of fine-grained behavior reuse
	in the object-oriented paradigm. In this paper, we present the language
	Sugared Welterweight Record-Trait Java (SWRTJ), a Java dialect with
	records and traits. Records have been devised to complement traits
	for fine-grained state reuse. Records and traits can be composed
	by explicit linguistic operations, allowing code manipulations to
	achieve fine-grained code reuse. Classes are assembled from (composite)
	records and traits and instantiated to generate objects. We present
	the prototypical implementation of SWRTJ using Xtext, an Eclipse
	framework for the development of programming languages as well as
	other domain-specific languages. Our implementation comprises an
	Eclipse-based editor for SWRTJ with typical IDE functionalities,
	and a stand-alone compiler, which translates SWRTJ programs into
	standard Java programs. © 2010 ACM.},
  affiliation = {Dipartimento di Informatica, Università di Torino, C.so Svizzera,
	185, 10149 Torino, Italy; Chalmers University of Technology, 421
	96 Gothenburg, Sweden},
  author_keywords = {Eclipse; implementation; Java; trait; type system},
  document_type = {Conference Paper},
  journal = {Proceedings of the 8th International Conference on the Principles
	and Practice of Programming in Java, PPPJ 2010},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-78549252146&partnerID=40&md5=ece112509ccfc336d8ddf60e01c5793e}
}

@CONFERENCE{Bharadwaj2007173,
  author = {Bharadwaj, R.a , Mukhopadhyay, S.b },
  title = {SOLj: A domain-specific language (DSL) for secure service-based systems},
  year = {2007},
  pages = {173-180},
  note = {cited By (since 1996) 1},
  abstract = {We present SOLj (Secure Operations Language-Java), an event-driven
	domain-specific synchronous programming extension of Java for developing
	secure service-based systems. The language has capabilities for handling
	service invocations asynchronously, includes strong typing for the
	enforcement of information flow and security policies, and exception
	handling mechanisms to deal with failures of components or services
	(both benign and Byzantine). Applications written in SOLj are formally
	verifiable using static analysis techniques. SOLj programs may be
	deployed, configured, and run on SINS (Secure Infrastructure for
	Networked Systems) under development at the Naval Research Laboratory.
	© 2007 IEEE.},
  affiliation = {Naval Research Laboratory, 4555 Overlook Avenue, Washington, DC 20375;
	Utah State University, Logan, UT 84322-4205},
  art_number = {4144628},
  document_type = {Conference Paper},
  journal = {Proceedings of the IEEE Computer Society Workshop on Future Trends
	of Distributed Computing Systems},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-34547254652&partnerID=40&md5=0a5865a1a2b5fec8e8f4f83f9d5711ce}
}

@CONFERENCE{Bibbo20083,
  author = {Bibbo, L.M.a , García, D.a , Pons, C.a b },
  title = {A domain specific language for the development of collaborative systems},
  year = {2008},
  pages = {3-12},
  note = {cited By (since 1996) 0},
  abstract = {Domain-Specific Languages (DSLs) are high level languages defined
	for combining expressivity and simplicity by means of constructs
	which are close to the problem domain and distant from the intricacies
	of underlying software implementation constraints. This paper presents
	a language to graphically document the analysis and design decisions
	embodied in Collaborative System development. The language was designed
	as a conservative extension of the UML and it enables the application
	of the MDD approach to the development of such systems. © 2008 IEEE.},
  affiliation = {LIFIA, Faculty of Informatics, National University of La Plata, Buenos
	Aires, Argentina; Facultad de Tecnología Informática, Universidad
	Abierta Interamericana, Buenos Aires, Argentina},
  art_number = {4685758},
  document_type = {Conference Paper},
  journal = {Proceedings - International Conference of the Chilean Computer Science
	Society, SCCC},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-58049147622&partnerID=40&md5=ed2343a6f0792e1fa742edcbf8425eeb}
}

@CONFERENCE{Biermann2009625,
  author = {Biermann, E., Ehrig, K., Ermel, C., Hurrelmann, J.},
  title = {Generation of simulation views for domain specific modeling languages
	based on the eclipse modeling framework},
  year = {2009},
  pages = {625-629},
  note = {cited By (since 1996) 0},
  abstract = {The generation of tools for domain specific modeling languages (DSMLs)
	is a key issue in model-driven development. Various tools already
	support the generation of domain-specific visual editors from models,
	but tool generation for visual behavior modeling languages is not
	yet supported in a satisfactory way. In this paper we propose a generic
	approach to specify DSML environments visually by models and transformation
	rules based on the Eclipse Modeling Framework (EMF). Editing rules
	define the behavior of generated visual editors, whereas simulation
	rules describe a model's operational semantics. From a DSML definition
	(model and transformation rules), an Eclipse plug-in is generated,
	implementing a visual DSML environment including an editor and (possibly
	multiple) simulators for different simulation views on the model.
	We present the basic components of Tiger2, our EMF-based generation
	environment, along the environment generation process for a small
	DSML modeling the behavior of ants in an ant hill. © 2009 IEEE.},
  affiliation = {Institut für Softwaretechnik und Theoretische Informatik, Technische
	Universität Berlin, Germany},
  art_number = {5431720},
  author_keywords = {EMF; EMF transformation; Graph transformation; Simulation; Visual
	environment generation},
  document_type = {Conference Paper},
  journal = {ASE2009 - 24th IEEE/ACM International Conference on Automated Software
	Engineering},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-77952144567&partnerID=40&md5=780e7ac76d62b0476fe2fa80f91c2b83}
}

@CONFERENCE{Binder20119,
  author = {Binder, W.a , Moret, P.a , Ansaloni, D.a , Sarimbekov, A.a , Yokokawa,
	A.a , Tanter, E.b },
  title = {Towards a domain-specific aspect language for dynamic program analysis},
  year = {2011},
  pages = {9-11},
  note = {cited By (since 1996) 0},
  abstract = {Despite the increasing importance of dynamic analysis in modern software
	engineering, the basic abstractions used to develop dynamic analysis
	tools have not significantly improved for long time. Developing dynamic
	analyses with low-level instrumentation techniques is error-prone
	and time consuming, whereas high-level approaches using aspect-oriented
	programming limit expressiveness, because the join point model in
	current general-purpose aspect languages has not been especially
	designed for dynamic analysis tasks. In this position paper, we promote
	a new domain-specific aspect language for dynamic program analysis
	in order to provide new foundations for the productive development
	of flexible and efficient dynamic analysis tools.},
  affiliation = {Faculty of Informatics, University of Lugano, Switzerland; PLEIAD
	Laboratory, Computer Science Department (DCC), University of Chile,
	Chile},
  author_keywords = {Domain-specific languages; Dynamic program analysis},
  document_type = {Conference Paper},
  journal = {Proceedings of the 6th Annual Workshop on Domain-Specific Aspect
	Languages, DSAL 2011},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-79955407333&partnerID=40&md5=6e52cf411d1ef9dc67b8e6c4d877d05a}
}

@ARTICLE{Birukou2010122,
  author = {Birukou, A.a , D'Andrea, V.a , Leymann, F.c , Serafinski, J.b , Silveira,
	P.a , Strauch, S.c , Tluczek, M.b },
  title = {An integrated solution for runtime compliance governance in SOA},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2010},
  volume = {6470 LNCS},
  pages = {122-136},
  note = {cited By (since 1996) 2},
  abstract = {In response to recent financial scandals (e.g. those involving Enron,
	Fortis, Parmalat), new regulations for protecting the society from
	financial and operational risks of the companies have been introduced.
	Therefore, companies are required to assure compliance of their operations
	with those new regulations as well as those already in place. Regulations
	are only one example of compliance sources modern organizations deal
	with every day. Other sources of compliance include licenses of business
	partners and other contracts, internal policies, and international
	standards. The diversity of compliance sources introduces the problem
	of compliance governance in an organization. In this paper, we propose
	an integrated solution for runtime compliance governance in Service-Oriented
	Architectures (SOAs). We show how the proposed solution supports
	the whole cycle of compliance management: from modeling compliance
	requirements in domain-specific languages through monitoring them
	during process execution to displaying information about the current
	state of compliance in dashboards. We focus on the runtime part of
	the proposed solution and describe it in detail. We apply the developed
	framework in a real case study coming from EU FP7 project COMPAS,
	and this case study is used through the paper to illustrate our solution.
	© 2010 Springer-Verlag.},
  affiliation = {DISI, University of Trento, TN 38123, Italy; Telcordia Poland, Poznan,
	Poland; IAAS, University of Stuttgart, 70569, Germany},
  author_keywords = {business process; complex event processing; compliance governance;
	monitoring; SOA},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-78650789443&partnerID=40&md5=dfd9827d69dfa494335e1f16fadd4021}
}

@ARTICLE{Bissyandé2010273,
  author = {Bissyandé, T.F.a , Réveillère, L.a , Bromberg, Y.-D.a , Lawall, J.L.b
	c , Muller, G.c },
  title = {Bridging the gap between legacy services and web services},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2010},
  volume = {6452 LNCS},
  pages = {273-292},
  note = {cited By (since 1996) 0},
  abstract = {Web Services is an increasingly used instantiation of Service-Oriented
	Architectures (SOA) that relies on standard Internet protocols to
	produce services that are highly interoperable. Other types of services,
	relying on legacy application layer protocols, however, cannot be
	composed directly. A promising solution is to implement wrappers
	to translate between the application layer protocols and the WS protocol.
	Doing so manually, however, requires a high level of expertise, in
	the relevant application layer protocols, in low-level network and
	system programming, and in the Web Service paradigm itself. In this
	paper, we introduce a generative language based approach for constructing
	wrappers to facilitate the migration of legacy service functionalities
	to Web Services. To this end, we have designed the Janus domain-specific
	language, which provides developers with a high-level way to describe
	the operations that are required to encapsulate legacy service functionalities.
	We have successfully used Janus to develop a number of wrappers,
	including wrappers for IMAP and SMTP servers, for a RTSP-compliant
	media server and for UPnP service discovery. Preliminary experiments
	show that Janus-based WS wrappers have performance comparable to
	manually written wrappers. © IFIP International Federation for Information
	Processing 2010.},
  affiliation = {LaBRI, University of Bordeaux, France; DIKU, University of Copenhagen,
	Denmark; Lip6, INRIA, France},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-79956312840&partnerID=40&md5=86a291ab11cbab2476c66e9c9317692b}
}

@ARTICLE{Blouin201162,
  author = {Blouin, A.a , Combemale, B.a , Baudry, B.a , Beaudoux, O.b },
  title = {Modeling model slicers},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2011},
  volume = {6981 LNCS},
  pages = {62-76},
  note = {cited By (since 1996) 0},
  abstract = {Among model comprehension tools, model slicers are tools that extract
	a subset from a model, for a specific purpose. Model slicers are
	tools that let modelers rapidly gather relevant knowledge from large
	models. However, existing slicers are dedicated to one modeling language.
	This is an issue when we observe that new domain specific modeling
	languages (DSMLs), for which we want slicing abilities, are created
	almost on a daily basis. This paper proposes the Kompren language
	to model and generate model slicers for any DSL (e.g. software development
	and building architecture) and for different purposes (e.g. monitoring
	and model comprehension). Kompren's abilities for model slicers construction
	is based on case studies from various domains. © 2011 Springer-Verlag.},
  affiliation = {IRISA/INRIA, Triskell Team, Rennes, France; GRI-ESEO, Angers, France},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-80054087712&partnerID=40&md5=bdf8cb387ffa4c0b2c8e6c1dde8e3fa4}
}

@CONFERENCE{Bock2006312,
  author = {Bock, C.a , Zuehlke, D.b },
  title = {Model-driven HMI development - Can meta-case tools relieve the pain?},
  year = {2006},
  volume = {2},
  pages = {312-319},
  note = {cited By (since 1996) 0},
  abstract = {Today metamodeling and domain-specific languages represent many promising
	beginnings to create nongeneric tool support for individual modelling
	tasks. Due to the inherent complexity and numerous variants of human-machine
	interfaces (HMIs) model-driven development becomes increasingly interesting
	for manufacturers and suppliers in the automtive industry. Particularly,
	the development of powerful user interfaces requires appropriate
	development processes as well as easy-to-use software tools. Since
	suitable tool kits are missing in the field of HMI development this
	paper describes the utilization of visual domain-specific languages
	for model-driven useware engineering in general and model-based specification
	of automotive HMIs in special. Moreover, results from a survey among
	developers are presented revealing the requirements for HMI specific
	tool support. Additionally, experiences with using current meta-CASE
	tools as well as standard office applications for creating a visual
	domain-specific language are presented. Based on these experiences
	requirements for future meta-CASE tools are derived.},
  affiliation = {Dr. Ing. h.c. F. Porsche AG, Stuttgart, Germany; German Research Center
	for Artificial Intelligence DFKI GmbH, Center for Human Machine Interaction,
	PO Box 3049, Kaiserslautern 67653, Germany},
  author_keywords = {Electronic specification; Model-driven HMI development; Model-driven
	useware engineering},
  document_type = {Conference Paper},
  journal = {ICSOFT 2006 - 1st International Conference on Software and Data Technologies,
	Proceedings},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-77954000823&partnerID=40&md5=6728ea4a568717a65e23fcade00d1b6f}
}

@ARTICLE{Bodeveix2005187,
  author = {Bodeveix, J.-P.a , Filali, M.a , Lawall, J.b , Muller, G.c },
  title = {Formal methods meet domain specific languages},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2005},
  volume = {3771 LNCS},
  pages = {187-206},
  note = {cited By (since 1996) 1},
  abstract = {In this paper, we relate an experiment whose aim is to study how to
	combine two existing approaches for ensuring software correctness:
	Domain Specific Languages (DSLs) and formal methods. As examples,
	we consider the Bossa DSL and the B formal method. Bossa is dedicated
	to the development of process schedulers and has been used in the
	context of Linux and Chorus. B is a refinement based formal method
	which has especially been used in the domain of railway systems.
	In this paper, we use B to express the correctness of a Bossa specification.
	Furthermore, we show how B can be used as an alternative to the existing
	Bossa tools for the production of certified schedulers. © Springer-Verlag
	Berlin Heidelberg 2005.},
  affiliation = {IRIT, Université Paul Sabatier, 118 route de Narbonne, F-31062 Toulouse
	Cedex, France; DIKU, University of Copenhagen, 2100 Copenhagen, Denmark;
	Ecole des Mines de Nantes, INRIA, LINA, 44307 Nantes Cedex 3, France},
  author_keywords = {Decision procedure; DSL; Formal methods; Refinements; Scheduling},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-33646718787&partnerID=40&md5=20a0429f4e516aea1a389e48f6339036}
}

@CONFERENCE{Bond2010167,
  author = {Bond, B.a , Hammil, K.a , Litchev, L.a , Singh, S.b },
  title = {FPGA circuit synthesis of accelerator data-parallel programs},
  year = {2010},
  pages = {167-170},
  note = {cited By (since 1996) 1},
  abstract = {This paper describes the techniques used to describe and synthesize
	FPGA circuits expressed in a data-parallel domain specific language
	(DSL) called Accelerator. We identify the subset of data-parallel
	descriptions that are upported by our system and explain how we track
	memory access patterns which allow us to generate efficient FPGA
	circuits. © 2010 IEEE.},
  affiliation = {Microsoft, 1 Microsoft Way, Redmond, WA 98052, United States; Microsoft,
	7 JJ Thomson Avenue, Cambridge CB3 0FB, United Kingdom},
  art_number = {5474053},
  document_type = {Conference Paper},
  journal = {Proceedings - IEEE Symposium on Field-Programmable Custom Computing
	Machines, FCCM 2010},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-77954288223&partnerID=40&md5=808ed444b0a8aa4b971b046d330ef36d}
}

@ARTICLE{Bordignon2011157,
  author = {Bordignon, M., Schultz, U.P., Stoy, K.},
  title = {Model-based kinematics generation for modular mechatronic toolkits},
  journal = {ACM SIGPLAN Notices},
  year = {2011},
  volume = {46},
  pages = {157-166},
  number = {2},
  note = {cited By (since 1996) 0},
  abstract = {Modular robots are mechatronic devices that enable the construction
	of highly versatile and flexible robotic systems whose mechanical
	structure can be dynamically modified. The key feature that enables
	this dynamic modification is the capability of the individual modules
	to connect to each other in multiple ways and thus generate a number
	of different mechanical systems, in contrast with the monolithic,
	fixed structure of conventional robots. The mechatronic flexibility,
	however, complicates the development of models and programming abstractions
	for modular robots, since manually describing and enumerating the
	full set of possible interconnections is tedious and error-prone
	for real-world robots. In order to allow for a general formulation
	of spatial abstractions for modular robots and to ensure correct
	and streamlined generation of code dependent on mechanical properties,
	we have developed the Modular Mechatronics Modelling Language (M3L).
	M3L is a domain-specific language, which can model the kinematic
	structure of individual robot modules and declaratively describe
	their possible interconnections, rather than requiring the user to
	enumerate them in their entirety. From this description, the M3L
	compiler generates the code that is needed to simulate the resulting
	robots within Webots, a widely used commercial robot simulator, and
	the software component needed for spatial structure computations
	by a virtual machine-based runtime system, which we have developed
	and used for programming physical modular robots. Copyright © 2010
	ACM.},
  affiliation = {Modular Robotics Lab, Maersk Institute, University of Southern Denmark,
	Denmark},
  author_keywords = {Code generation; Domain-specific languages; Robotics},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-79951738984&partnerID=40&md5=377d604a475f9e673e546d9bb203100c}
}

@CONFERENCE{Bordignon2010157,
  author = {Bordignon, M., Schultz, U.P., Stoy, K.},
  title = {Model-based kinematics generation for modular mechatronic toolkits},
  year = {2010},
  pages = {157-166},
  note = {cited By (since 1996) 0},
  abstract = {Modular robots are mechatronic devices that enable the construction
	of highly versatile and flexible robotic systems whose mechanical
	structure can be dynamically modified. The key feature that enables
	this dynamic modification is the capability of the individual modules
	to connect to each other in multiple ways and thus generate a number
	of different mechanical systems, in contrast with the monolithic,
	fixed structure of conventional robots. The mechatronic flexibility,
	however, complicates the development of models and programming abstractions
	for modular robots, since manually describing and enumerating the
	full set of possible interconnections is tedious and error-prone
	for real-world robots. In order to allow for a general formulation
	of spatial abstractions for modular robots and to ensure correct
	and streamlined generation of code dependent on mechanical properties,
	we have developed the Modular Mechatronics Modelling Language (M3L).
	M3L is a domain-specific language, which can model the kinematic
	structure of individual robot modules and declaratively describe
	their possible interconnections, rather than requiring the user to
	enumerate them in their entirety. From this description, the M3L
	compiler generates the code that is needed to simulate the resulting
	robots within Webots, a widely used commercial robot simulator, and
	the software component needed for spatial structure computations
	by a virtual machine-based runtime system, which we have developed
	and used for programming physical modular robots. © 2010 ACM.},
  affiliation = {Modular Robotics Lab., Maersk Institute, University of Southern, Denmark},
  author_keywords = {Code generation; Domain-specific languages; Robotics},
  document_type = {Conference Paper},
  journal = {GPCE'10 - Proceedings of the 2010 Conference on Generative Programming
	and Component Engineering},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-78650104599&partnerID=40&md5=af0e1916a182559c8802a4a01ac3c45e}
}

@ARTICLE{Boronat200918,
  author = {Boronat, A.a , Heckel, R.a , Meseguer, J.b },
  title = {Rewriting logic semantics and verification of model transformations},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2009},
  volume = {5503},
  pages = {18-33},
  note = {cited By (since 1996) 5},
  abstract = {Model transformations are used in model-driven development for mechanizing
	the interoperability and integration among modeling languages. Due
	to the graph-theoretic nature of models, the theory of graph transformation
	systems and its technological support provide a convenient environment
	for formalizing and verifying model transformations, which can then
	be used for defining the semantics of modelbased domain-specific
	languages. In this paper, we present an approach for formalizing
	and verifying QVT-like transformations that reuses the main concepts
	of graph transformation systems. Specifically, we formalize model
	transformations as theories in rewriting logic, so that Maude's reachability
	analysis and model checking features can be used for verifying them.
	This approach also provides a new perspective on graph transformation
	systems, where their formal semantics is given in rewriting logic.
	All the ideas presented are implemented in MOMENT2. In this way,
	we can define formal model transformations in the Eclipse Modeling
	Framework (EMF) and we can verify them in Maude. We use a model of
	a distributed mutual exclusion algorithm to illustrate the approach.},
  affiliation = {Department of Computer Science, University of Leicester; Department
	of Computer Science, University of Illinois at Urbana-Champaign},
  author_keywords = {LTL model checking; Maude; Model and graph transformations; MOF; QVT;
	Reachability analysis; Rewriting logic},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-67650153258&partnerID=40&md5=d4bcf7acfb022a3c7c521e34f8338a5f}
}

@ARTICLE{Boskovic2009227,
  author = {Boskovic, M.a , Gasevic, D.b , Pahl, C.c , Schatz, B.d },
  title = {The first international workshop on Non-Functional system properties
	in domain specific modeling languages (NFPinDSML2008)},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2009},
  volume = {5421},
  pages = {227-228},
  note = {cited By (since 1996) 0},
  abstract = {This workshop brought together researchers and practitioners from
	communities dedicated to non-functional properties of software systems
	and researches from language engineering to study the principles
	of integration of various non-functional system properties and language
	engineering in order to further expand principles of reasoning about
	nonfunctional properties of software systems in Domain Specific Modeling
	Languages, and model-driven engineering in general.},
  affiliation = {TrustSoft Graduate School, University of Oldenburg, Germany; School
	of Computing and Information Systems, Athabasca University, Canada;
	School of Computing, Dublin City University, Ireland; Institute for
	Informatics, Technical University Munich, Germany},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-67650105897&partnerID=40&md5=7e5b62f8ff52555c59e550e2284330b6}
}

@ARTICLE{Boström2005167,
  author = {Boström, P., Waldén, M.},
  title = {Development of fault tolerant grid applications using distributed
	B},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2005},
  volume = {3771 LNCS},
  pages = {167-186},
  note = {cited By (since 1996) 1},
  abstract = {Computational grids have become popular for constructing large scale
	distributed systems. Grid applications typically run in a very heterogeneous
	environment and fault tolerance is therefore very important for their
	correctness. Since the construction of correct distributed systems
	is difficult with traditional development methods we propose the
	use of formal methods. We use Event B as our formal framework, which
	we extend with new constructs such as remote procedures and notifications
	for reasoning about grid systems. The extended language, called Distributed
	B, ensures that the application can handle both node and network
	failures. Furthermore, the new constructs in Distributed B enable
	straightforward implementation of the specifications, as well as
	automatic generation of the needed proof obligations. © Springer-Verlag
	Berlin Heidelberg 2005.},
  affiliation = {Åbo Akademi University, Department of Computer Science, Turku Centre
	for Computer Science (TUCS), Lemminkäisenkatu 14 A, 20520 Turku,
	Finland},
  author_keywords = {Domain specific languages; Event B; Fault tolerance; Grid computing;
	Language extensions; Stepwise development},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-33646744921&partnerID=40&md5=0e4b800e69cca7c621fee01637fe9491}
}

@ARTICLE{Botterweck201068,
  author = {Botterweck, G.a , Polzer, A.b , Kowalewski, S.b },
  title = {Using higher-order transformations to derive variability mechanism
	for embedded systems},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2010},
  volume = {6002 LNCS},
  pages = {68-82},
  note = {cited By (since 1996) 0},
  abstract = {The complexity of embedded systems can partly be handled by models
	and domain-specific languages (DSLs) like Matlab / Simulink. If we
	want to apply such techniques to families of similar systems, we
	have to describe their variability, i.e., commonalities and differences
	between the similar systems. Here, approaches from Software Product
	Lines (SPL) and variability modeling can be helpful. In this paper,
	we discuss three challenges which arise in this context: (1) We have
	to integrate mechanisms for describing variability into the DSL.
	(2) To efficiently derive products, we require techniques and tool-support
	that allow us to configure a particular product and resolve variability
	in the DSL. (3) When resolving variability, we have to take into
	account dependencies between elements, e.g., when removing Simulink
	blocks we have to remove the signals between these blocks as well.
	The approach presented here uses higher-order transformations (HOT),
	which derive the variability mechanisms (as a generated model transformation)
	from the meta-model of a DSL. © Springer-Verlag Berlin Heidelberg
	2010.},
  affiliation = {Lero, University of Limerick, Limerick, Ireland; Embedded Software
	Laboratory, RWTH Aachen University, Aachen, Germany},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-78650337004&partnerID=40&md5=6eb05b7d9909f0488fbec94a4b2fd967}
}

@CONFERENCE{Boubeta-Puig2011398,
  author = {Boubeta-Puig, J., Medina-Bulo, I., García-Domínguez, A.},
  title = {Analogies and differences between mutation operators for WS-BPEL
	2.0 and other languages},
  year = {2011},
  pages = {398-407},
  note = {cited By (since 1996) 0},
  abstract = {Applying mutation testing to a program written in a certain language
	requires that a set of mutation operators is defined for that language.
	The mutation operators need to adequately cover the features of that
	language in order to be effective. In this work, we evaluate qualitatively
	the operators defined for the Web Services Business Process Execution
	Language 2.0 (WS-BPEL) and study the differences and similarities
	between WS-BPEL and other languages. We review the existing operators
	for several structured and object oriented general-purpose programming
	languages, and for several domain-specific languages. Results confirm
	that WSBPEL is very different from other languages, as half of the
	mutation operators for this language are equivalent to those of other
	languages. Our study concludes that the set of WS-BPEL mutation operators
	can be improved. © 2011 IEEE.},
  affiliation = {Department of Computer Languages and Systems, University of Cádiz,
	Cádiz, Spain},
  art_number = {5954439},
  author_keywords = {Mutation analysis; Mutation operators; Test-suite effectiveness; Testing;
	Web services; WS-BPEL},
  document_type = {Conference Paper},
  journal = {Proceedings - 4th IEEE International Conference on Software Testing,
	Verification, and Validation Workshops, ICSTW 2011},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-80051652998&partnerID=40&md5=a401c198007585105a9d4a3c67910698}
}

@ARTICLE{Boulanger2010310,
  author = {Boulanger, F., Jacquet, C., Hardebolle, C., Rouis, E.},
  title = {Modeling heterogeneous points of view with ModHel'X},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2010},
  volume = {6002 LNCS},
  pages = {310-324},
  note = {cited By (since 1996) 1},
  abstract = {Non-functional properties (NFPs) concern various characteristics of
	a system (cost, power, QoS). These characteristics belong to different
	models of the system, built by different design teams, using different
	formalisms. Therefore, the design of a system includes a number of
	domain-specific modeling languages, used to express various NFPs.
	This paper focuses on the heterogeneity of the points of view on
	the system. We show that "multi-view" approaches which do not rely
	on a unique underlying model appear better-suited to express NFPs
	than model weaving or annotations. However, existing approaches in
	this category do not yet support model execution. We introduce a
	multi-view extension to Mod- Hel'X, a framework for executing heterogeneous
	models, and we show how it can be used for modeling non-functional
	characteristics of a system and expressing NFPs. A key point of this
	approach is that it relies only on the core concepts of ModHel'X,
	but uses them in new ways. © Springer-Verlag Berlin Heidelberg 2010.},
  affiliation = {SUPELEC, 3 rue Joliot-Curie, 91192 Gif-sur-Yvette Cedex, France},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-78650389773&partnerID=40&md5=a8b773ffa23180041bcca8e4b7a8eed1}
}

@ARTICLE{Bourdev2011243,
  author = {Bourdev, L.a b , Jrvi, J.c },
  title = {Efficient run-time dispatching in generic programming with minimal
	code bloat},
  journal = {Science of Computer Programming},
  year = {2011},
  volume = {76},
  pages = {243-257},
  number = {4},
  note = {cited By (since 1996) 0},
  abstract = {Generic programming with C++ templates results in efficient but inflexible
	code: efficient, because the exact types of inputs to generic functions
	are known at compile time; inflexible because they must be known
	at compile time. We show how to achieve run-time polymorphism without
	compromising performance by instantiating the generic algorithm with
	a comprehensive set of possible parameter types, and choosing the
	appropriate instantiation at run time. Applying this approach navely
	can result in excessive template bloat: a large number of template
	instantiations, many of which are identical at the assembly level.
	We show practical examples of this approach quickly approaching the
	limits of the compiler. Consequently, we combine this method of run-time
	polymorphism for generic programming, with a strategy for reducing
	the number of necessary template instantiations. We report on using
	our approach in GIL, Adobe's open source Generic Image Library. We
	observed a notable reduction, up to 70% at times, in executable sizes
	of our test programs. This was the case even with compilers that
	perform aggressive template hoisting at the compiler level, due to
	significantly smaller dispatching code. The framework draws from
	both the generic and generative programming paradigms, using static
	metaprogramming to fine tune the compilation of a generic library.
	Our test bed, GIL, is deployed in a real world industrial setting,
	where code size is often an important factor. © 2010 Elsevier B.V.
	All rights reserved.},
  affiliation = {Adobe Systems Inc., 345 Park Avenue, San Jose, CA 95110, United States;
	EECS U.C. Berkeley, Berkeley, CA 94720, United States; Texas A and
	M University, TAMU 3112, College Station, TX 77843, United States},
  author_keywords = {C++ templates; Generic programming; Template bloat; Template metaprogramming},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-79551504751&partnerID=40&md5=ab6163aaddd805622665c8fdb3c52747}
}

@CONFERENCE{Bourdon2008243,
  author = {Bourdon, J., Ishida, T.},
  title = {Speech act annotation for domain specific multilingual expression
	services},
  year = {2008},
  pages = {243-250},
  note = {cited By (since 1996) 0},
  abstract = {We propose an approach to overcome cultural barriers, specifically
	pragmatic misunderstandings about the intention of the speaker by
	annotating domain specific language resources according to an ontology
	based on speech acts. These annotations are capable to account for
	indirect speech acts as well as for phenomena of mitigation and reinforcement.
	The presented architecture preserves the original structure of the
	resource by providing metadata specified using RDF. We illustrate
	our purpose by a manually annotated corpus designed to facilitate
	interaction with foreign patients in Japanese hospitals. © 2008 IEEE.},
  affiliation = {Ishida and Matsubara Laboratory, Department of Social Informatics,
	Kyoto University, Kyoto 606-8501, Japan},
  art_number = {4724469},
  document_type = {Conference Paper},
  journal = {Proceedings of the 2nd International Symposium on Universal Communication,
	ISUC 2008},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-60749109308&partnerID=40&md5=782b160eb46e758202000a2a246a257b}
}

@ARTICLE{Bozzon2007210,
  author = {Bozzon, A.a , Iofciu, T.b , Nejdl, W.b , Tönnies, S.b },
  title = {Integrating databases, search engines and web applications: A model-driven
	approach},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2007},
  volume = {4607 LNCS},
  pages = {210-225},
  note = {cited By (since 1996) 0},
  abstract = {This paper addresses conceptual modeling and automatic code generation
	for search engine integration with data intensive Web applications.
	We have analyzed the similarities (and differences) between IR and
	database systems to extend an existing domain specific language for
	data-driven Web applications. The extended Web modeling language
	specifies the search engine's index schemas based on the data schema
	of the Web application and uniquely designs the interaction between
	the database, the Web application, the search engine and users. We
	also provide an implementation of a CASE tool extension for visual
	modeling and code generation. Experimentation of the proposed approach
	has been successfully applied in the context of the COOPER project.
	© Springer-Verlag Berlin Heidelberg 2007.},
  affiliation = {Politecnico di Milano, P.zza L. da Vinci 32, I-20133 Milano, Italy;
	Forschungszentrum L3S, Appelstr. 9a, 30167 Hannover, Germany},
  author_keywords = {Index modeling; Search engine design; Web engineering; Web site design},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-38149014114&partnerID=40&md5=26be0b3bcfe47b90cb9b29edf510a6e9}
}

@ARTICLE{Boškovic2010291,
  author = {Boškovic, M.a , Gaševic, D.a , Pahl, C.b , Schätz, B.c },
  title = {The 2nd international workshop on non-functional system properties
	in domain specific modeling languages (NFPinDSML2009)},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2010},
  volume = {6002 LNCS},
  pages = {291-295},
  note = {cited By (since 1996) 0},
  abstract = {Domain Specific Modeling Languages (DSMLs) are becoming a common-place
	for engineering software systems of a particular domain. Currently,
	the study of DSMLs is mostly dedicated to engineering languages for
	specification of functional properties of systems. Until now, the
	study of engineering DSMLs has mostly been dedicated to specifying
	functional properties of domain specific systems. Besides functional
	properties, so called nonfunctional properties (NFP) such as safety,
	reliability, timeliness and so on, have been recognized as important
	as functional ones. This workshop discusses integration of NFP estimation
	and evaluation to Model Driven Engineering with DSMLs. © Springer-Verlag
	Berlin Heidelberg 2010.},
  affiliation = {School of Computing and Information Systems, Athabasca University,
	Canada; School of Computing, Dublin City University, Ireland; Institut
	für Informatik, Technische Universität MuVnchen, Germany},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-78650411164&partnerID=40&md5=3c3edea5dfd5673c13a3c5be4a743cba}
}

@ARTICLE{Bošković2011308,
  author = {Bošković, M.a , Cancila, D.b , Pahl, C.c , Schätz, B.d },
  title = {The 3rd international workshop on non-functional system properties
	in domain specific modeling languages (NFPinDSML2010)},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2011},
  volume = {6627 LNCS},
  pages = {308-311},
  note = {cited By (since 1996) 0},
  abstract = {The NFPinDSML2010 is the 3rd issue in the series of workshops discussing
	a challenging issue: principles and methods of integrating estimation
	and evaluation of Non-functional System Properties (NFP), in Model-driven
	Engineering (MDE) with Domain Specific Modeling Languages (DSML).
	Particularly, NFPinDSML2010 topic was integration of certification
	and compliance in MDE. © 2011 Springer-Verlag Berlin Heidelberg.},
  affiliation = {SCIS, Athabasca University, Canada; Atego, Paris Office, France; School
	of Computing, Dublin City University, Ireland; Fortiss GmbH, Germany},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-79957631914&partnerID=40&md5=3ec67a25de77578b42a5b94569c3463f}
}

@ARTICLE{Bošković200962,
  author = {Bošković, M.a , Hasselbring, W.b },
  title = {Model driven performance measurement and assessment with MoDePeMART},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2009},
  volume = {5795 LNCS},
  pages = {62-76},
  note = {cited By (since 1996) 1},
  abstract = {Software performance is one of important software Quality of Service
	attributes. For this reason, several approaches integrate performance
	prediction in Model Driven Engineering(MDE). However, MDE still lacks
	a systematic approach for performance measurement and metrics assessment.
	This paper presents MoDePeMART, an approach for Model Driven Performance
	Measurement and Assessment with Relational Traces. The approach suggests
	declarative specification of performance metrics in a domain specific
	language and usage of relational databases for storage and metric
	computation. The approach is evaluated with the implementation of
	a UML Profile for UML Class and State diagrams and transformations
	from profile to a commercial relational database management system.
	© 2009 Springer Berlin Heidelberg.},
  affiliation = {Athabasca University, Canada; Software Engineering Group, University
	of Kiel, Germany},
  author_keywords = {Model Driven Engineering; Software Performance Measurement and Assessment;
	Transformational and Reactive Systems},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-77249090404&partnerID=40&md5=50af076387796875922fa20ed37e7870}
}

@ARTICLE{Brabrand20072,
  author = {Brabrand, C., Schwartzbach, M.I.},
  title = {The metafront system: Safe and extensible parsing and transformation},
  journal = {Science of Computer Programming},
  year = {2007},
  volume = {68},
  pages = {2-20},
  number = {1 SPEC. ISS.},
  note = {cited By (since 1996) 3},
  abstract = {We present the metafront tool for specifying flexible, safe, and efficient
	syntactic transformations between languages defined by context-free
	grammars. The transformations are guaranteed to terminate and to
	map grammatically legal input to grammatically legal output. We rely
	on a novel parser algorithm that is designed to support gradual extensions
	of a grammar by allowing productions to remain in a natural style
	and by statically reporting ambiguities and errors in terms of individual
	productions as they are being added. Our tool may be used as a parser
	generator in which the resulting parser automatically supports a
	flexible, safe, and efficient macro processor, or as an extensible
	lightweight compiler generator for domain-specific languages. We
	show substantial examples of both kinds. © 2007 Elsevier B.V. All
	rights reserved.},
  affiliation = {BRICS, DAIMI, Department of Computer Science, DK-8000 Aarhus C, Denmark},
  author_keywords = {Context-free grammars; Language extensibility; Parsing; Transformation},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-34547420720&partnerID=40&md5=3aeffca5588dd66eba40e100abdbfd35}
}

@ARTICLE{Brabrand2003592,
  author = {Brabrand, C.a , Schwartzbach, M.I.b , Vanggaard, M.b },
  title = {The metafront system: Extensible parsing and transformation},
  journal = {Electronic Notes in Theoretical Computer Science},
  year = {2003},
  volume = {82},
  pages = {592-611},
  number = {3},
  note = {cited By (since 1996) 8},
  abstract = {We present the metafront tool for specifying flexible, safe, and efficient
	syntactic transformations between languages defined by context-free
	grammars. The transformations are guaranteed to terminate and to
	map grammatically legal input to grammatically legal output. We rely
	on a novel parser algorithm that is designed to support gradual extensions
	of a grammar by allowing productions to remain in a natural style
	and by statically reporting ambiguities and errors in terms of individual
	productions as they are being added. Our tool may be used as a parser
	generator in which the resulting parser automatically supports a
	flexible, safe, and efficient macro processor, or as an extensible
	lightweight compiler generator for domain-specific languages. We
	show substantial examples of both kinds. © 2003 Published by Elsevier
	Science B.V.},
  affiliation = {INRIA/LaBRI, ENSEIRB, Domaine Universitaire, 1, Ave. du Docteur Albert
	Schweitzer, F-33402 Talence Cedex, France; BRICS, Department of Computer
	Science, University of Aarhus Ny Munkegade, Building 540, DK-8000
	Aarhus C, Denmark},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-12844280292&partnerID=40&md5=a9d27dbf0b877a0ea4f6851d534d4982}
}

@CONFERENCE{Bradford2008,
  author = {Bradford, P.G.a , Ray, D.A.b },
  title = {Semantics for a domain-specific language for the digital forensics
	domain},
  year = {2008},
  note = {cited By (since 1996) 0},
  abstract = {This paper reviews details around the motivation for creating a domain-specific
	language that allows the easy design of software tools that support
	digital investigation. These tools will enable the specification
	of security requirements, support the activities of various investigations,
	certify security properties, and formulate security claims. Additionally,
	the main purpose of this paper is to introduce a proposed syntax
	for a language that is appropriate to the specific needs of the digital
	investigation domain. Copyright 200X ACM.},
  affiliation = {University of Alabama, P.O. Box 870290, Tuscaloosa, AL 35487-0290;
	University of Virginia College at Wise, 1 College Ave, Wise, VA 24293},
  art_number = {a11},
  author_keywords = {Digital forensics; Domain-specific languages},
  document_type = {Conference Paper},
  journal = {CSIIRW'08 - 4th Annual Cyber Security and Information Intelligence
	Research Workshop: Developing Strategies to Meet the Cyber Security
	and Information Intelligence Challenges Ahead},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-62849087007&partnerID=40&md5=9f0222a5d9918c01a60793a68dd8e79a}
}

@CONFERENCE{Bradford2008428,
  author = {Bradford, P.G.a , Ray, D.A.b },
  title = {Requirements for digital forensics investigation domain-specific
	languages},
  year = {2008},
  pages = {428-434},
  note = {cited By (since 1996) 0},
  abstract = {This paper gives an analysis of the digital forensics problem domain
	to enable the design of effective and practical domain specific languages
	for digital forensics investigations. The focus is on design and
	implementation using standard components. The paper first addresses
	domain specific languages in general terms and then addresses the
	steps necessary to create them. The paper looks at domain analysis
	for our particular digital investigation domain. To address domain
	analysis the paper reviews several key domain models that have been
	created in the field of digital forensics. The paper also examines
	DSL design and answers questions about the nature of our particular
	DSL. These concern relations to previous DSLs, what goals and principles
	will be supported by our DSL, and the particular structure of our
	DSL. The paper also briefly touches on DSL implementation issues,
	although the details of these are left for a later paper.},
  affiliation = {Computer Science Department, University of Alabama, Tuscaloosa, AL,
	United States; Math and Computer Science Department, University of
	Virginia College at Wise, Wise, VA, United States},
  author_keywords = {Application generator; Computer security; Digital investigations;
	Domain-specific language; System security management},
  document_type = {Conference Paper},
  journal = {Proceedings of the 2008 International Conference on Security and
	Management, SAM 2008},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-62749191531&partnerID=40&md5=ec3710976d6a7f0741c3dc7db663a874}
}

@CONFERENCE{Brady2006111,
  author = {Brady, E., Hammond, K.},
  title = {A verified staged interpreter is a verified compiler},
  year = {2006},
  pages = {111-120},
  note = {cited By (since 1996) 5},
  abstract = {Dependent types and multi-stage programming have both been used, separately,
	in programming language design and implementation. Each technique
	has its own advantages - - with dependent types, we can verify aspects
	of interpreters and compilers such as type safety and stack invariants.
	Multi-stage programming, on the other hand, can give the implementor
	access to underlying compiler technology; a staged interpreter is
	a translator. In this paper, we investigate the combination of these
	techniques. We implement an interpreter for a simply typed lambda
	calculus, using dependent types to guarantee correctness properties
	by construction. We give explicit proofs of these correctness properties,
	then add staging annotations to generate a translator from the interpreter.
	In this way, we have constructed a verified compiler from a verified
	staged interpreter. We illustrate the application of the technique
	by considering a simple staged interpreter that provides guarantees
	for some simple resource bound properties, as might be found in a
	domain specific language for real-time embedded systems. Copyright
	© 2006 ACM.},
  affiliation = {School of Computer Science, University of St Andrews, St Andrews,
	United Kingdom},
  author_keywords = {Dependent types; Domain specific language implementation; Functional
	programming; Multi-stage programming; Partial evaluation; Resource
	aware programming},
  document_type = {Conference Paper},
  journal = {Proceedings of the 5th International Conference on Generative Programming
	and Component Engineering, GPCE'06},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-34547487371&partnerID=40&md5=7d611bdc2c25a6b2f3d027d052e335dd}
}

@ARTICLE{Brady2010,
  author = {Brady, E.C., Hammond, K.},
  title = {Scrapping your inefficient engine: Using partial evaluation to improve
	domain-specific language implementation},
  journal = {ACM SIGPLAN Notices},
  year = {2010},
  volume = {45},
  pages = {297-308},
  number = {9},
  note = {cited By (since 1996) 1},
  abstract = {Partial evaluation aims to improve the efficiency of a program by
	specialising it with respect to some known inputs. In this paper,
	we show that partial evaluation can be an effective and, unusually,
	easy to use technique for the efficient implementation of embedded
	domain-specific languages. We achieve this by exploiting dependent
	types and by following some simple rules in the definition of the
	interpreter for the domain-specific language. We present experimental
	evidence that partial evaluation of programs in domain-specific languages
	can yield efficient residual programs whose performance is competitive
	with their Java and C equivalents and which are also, through the
	use of dependent types, verifiably resource-safe. Using our technique,
	it follows that a verifiably correct and resource-safe program can
	also be an efficient program. Copyright © 2010 ACM.},
  affiliation = {School of Computer Science, University of St. Andrews, St. Andrews,
	United Kingdom},
  author_keywords = {Dependent types; Partial evaluation},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-79551661424&partnerID=40&md5=ec821105c3ad4f70be4d3d76d22cedd1}
}

@CONFERENCE{Brady2010297,
  author = {Brady, E.C., Hammond, K.},
  title = {Scrapping your inefficient engine: Using partial evaluation to improve
	domain-specific language implementation},
  year = {2010},
  pages = {297-308},
  note = {cited By (since 1996) 0},
  abstract = {Partial evaluation aims to improve the efficiency of a program by
	specialising it with respect to some known inputs. In this paper,
	we show that partial evaluation can be an effective and, unusually,
	easy to use technique for the efficient implementation of embedded
	domain-specific languages. We achieve this by exploiting dependent
	types and by following some simple rules in the definition of the
	interpreter for the domain-specific language. We present experimental
	evidence that partial evaluation of programs in domain-specific languages
	can yield efficient residual programs whose performance is competitive
	with their Java and C equivalents and which are also, through the
	use of dependent types, verifiably resource-safe. Using our technique,
	it follows that a verifiably correct and resource-safe program can
	also be an efficient program. © 2010 ACM.},
  affiliation = {School of Computer Science, University of St. Andrews, St Andrews,
	United Kingdom},
  author_keywords = {dependent types; partial evaluation},
  document_type = {Conference Paper},
  journal = {Proceedings of the ACM SIGPLAN International Conference on Functional
	Programming, ICFP},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-78249278452&partnerID=40&md5=f672769545044b716c9f797442c5d70e}
}

@ARTICLE{Braga2004149,
  author = {Braga, C.a , Sztajnberg, A.b },
  title = {Towards a rewriting semantics for a software architecture description
	language},
  journal = {Electronic Notes in Theoretical Computer Science},
  year = {2004},
  volume = {95},
  pages = {149-168},
  note = {cited By (since 1996) 0},
  abstract = {Software architecture description languages (ADL) allow a software
	designer to focus on high- level aspects of an application by abstracting
	from the details of the components that compose an architecture.
	It is precisely this abstraction that makes ADLs suitable for verification
	using model checking techniques. ADLs are, in a way, domain-specific
	languages for aspects such as coordination, distribution and quality-of-service.
	The CBabel ADL defines the concept of contracts that precisely captures
	these architecture-level aspects. In this paper we propose a rewriting
	semantics for CBabel, that is, a formal semantics for CBabel specified
	in rewriting logic, a unifying formalism for concurrency models that
	has interesting properties as a logic and semantic framework due
	to its unified view of computation and proof. Using the Maude system,
	a high-performance implementation of rewriting logic, we formally
	verify the producer-consumer-buffer problem using model checking
	and state search. © 2004 Published by Elsevier B.V.},
  affiliation = {Universidade Federal Fluminense, Niterói, Brazil; Universidade Do
	Estado Do Rio de Janeiro, Rio de Janeiro, Brazil},
  author_keywords = {Architecture description languages; Model checking; Rewriting semantics},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-18944402507&partnerID=40&md5=cb52981b01e42a701c3deebf5f7b4785}
}

@ARTICLE{Brahe2006241,
  author = {Brahe, S., Østerbye, K.},
  title = {Business process modeling: Defining domain specific modeling languages
	by use of UML profiles},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2006},
  volume = {4066 LNCS},
  pages = {241-255},
  note = {cited By (since 1996) 5},
  abstract = {General-purpose modeling languages are inadequate to model and visualize
	business processes precisely. An enterprise has its own vocabulary
	for modeling processes and its specific tasks may have attached data
	that define the tasks precisely. We propose using Domain Specific
	Modeling (DSM) languages to model business processes, such that an
	enterprise can define its own DSM language(s) capturing its vocabulary
	and data requirement. We suggest using UML profiles and UML activity
	diagrams as the semantic base for these DSM languages and present
	tools that are able to create a DSM language and tool support for
	a given domain. One tool, called ADSpecializer, can generate a UML
	profile and its tool support of a given application domain. The other
	tool, ADModeler, is used to create UML activity diagrams within such
	a domain-specific UML profile. The two tools enable an enterprise
	to efficiently define and utilize their own DSM language. © Springer-Verlag
	Berlin Heidelberg 2006.},
  affiliation = {IT University of Copenhagen, Copenhagen, Denmark},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-33746435793&partnerID=40&md5=f73ef1b68f10810755789881782598e0}
}

@ARTICLE{Brahe2007166,
  author = {Brahe, S.a , Bordbar, B.b },
  title = {A pattern-based approach to business process modeling and implementation
	in web services},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2007},
  volume = {4652 LNCS},
  pages = {166-177},
  note = {cited By (since 1996) 3},
  abstract = {There are often three groups of experts involved in the design and
	implementation of business processes in a service oriented enterprise;
	business analysts, solution architects and system developers. They
	collaborate with each other to transform a high-level design created
	by a business analyst to a final executable workflow, based on a
	service composition language such as the Business Process Execution
	Language (BPEL). In this paper, we present a new approach to support
	and semi-automate this transformation process, thus producing applications
	of higher quality in shorter time. The idea is to capture existing
	knowledge in the enterprise, which is required for transforming models
	from one abstraction level to another, as reusable, parameterized
	patterns. These patterns are used for tool based model transformations
	of the business processes. To support our approach, we shall make
	use of Domain Specific Modeling Languages (DSMLs) designed for each
	enterprise to capture models of a business process at different levels
	of abstraction, each suitable for the use of one of the groups of
	experts. The presented approach bridges the gap between business
	and IT by providing customizable language-, tool- and transformation
	support for the different groups of experts within the enterprise
	and is illustrated by an example. © Springer-Verlag Berlin Heidelberg
	2007.},
  affiliation = {Danske Bank, IT University of Copenhagen, Denmark; School of Computer
	Science, University of Birmingham, United Kingdom},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-38049166148&partnerID=40&md5=a9c754359c7e286ece5ab6fe94f9c622}
}

@ARTICLE{Brambilla2009167,
  author = {Brambilla, M., Fraternali, P., Tisi, M.},
  title = {A transformation framework to bridge domain specific languages to
	MDA},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2009},
  volume = {5421},
  pages = {167-180},
  note = {cited By (since 1996) 2},
  abstract = {The Model Driven Architecture aims at the integration of di.erent
	modeling languages, artifacts and tools in a uni.ed technical space.
	Pre-existing development methodologies based on Domain Speci.c Languages
	(DSL) require a complex process to bene.t from this integration.
	After aMOF metamodel for the DSL is de.ned, there is no standard
	methodology to move legacy models and tools to the new architecture.
	This paper proposes a general model-driven integration procedure
	for pre-MDA DSLs. The procedure, given the de.nition of suitable
	model transformations, is completely automatic. The proposed framework
	is fully implemented, in a way independent of the speci.c DSL that
	must be transformed. As a case study, a toolsuite based on WebML,
	a DSL for designing Web applications, is bridged to MDA.},
  affiliation = {Politecnico di Milano, Dipartimento di Elettronica e Informazione,
	P.za L. Da Vinci, 32. I-20133 Milano, Italy},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-67650187964&partnerID=40&md5=9c2f34954ebc845ed8855dbb6a482eba}
}

@ARTICLE{Brambilla20101,
  author = {Brambilla, M.a , Ceri, S.a , Tisi, M.b },
  title = {Search computing: A model-driven perspective},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2010},
  volume = {6142 LNCS},
  pages = {1-15},
  note = {cited By (since 1996) 2},
  abstract = {Search Computing is a novel discipline that focuses on exploratory
	search of multi-domain Web queries like "Where can I attend an interesting
	conference in my field close to a sunny beach?". The approach is
	based on the interaction between cooperating search services, using
	ranking and joining of results as the dominant factors for service
	composition. This paper sketches the main characteristics of search
	computing and discusses how software engineering and model-driven
	engineering are challenged by the search computing problems. We present
	Search Computing applications from a model-driven perspective, in
	terms of (1) the models describing the objects of interest, (2) the
	specification of applications through model transformations, and
	(3) the definition of a domain specific language (DSL) defined for
	the specification of search query plans. This work provides a first
	exploration of MDE approaches applied to search computing and poses
	a set of challenges to the model transformation community. © 2010
	Springer-Verlag.},
  affiliation = {Politecnico di Milano, Dipartimento di Elettronica Ed Informazione,
	V. Ponzio 34/5, Milano 20133, Italy; AtlanMod, INRIA, Ecole des Mines
	de Nantes, rue Alfred Kastler, Nantes Cedex 3 F-44307, France},
  author_keywords = {ATL; conceptual models; MDD; MDE; model transformations; Search Computing;
	search engine; software engineering},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-77954728539&partnerID=40&md5=7e76736588df7aa63c659659b0bf7829}
}

@CONFERENCE{Brandic2010244,
  author = {Brandic, I.a , Dustdar, S.a , Anstett, T.b , Schumm, D.b , Leymann,
	F.b , Konrad, R.c },
  title = {Compliant Cloud Computing (C3): Architecture and language support
	for user-driven compliance management in Clouds},
  year = {2010},
  pages = {244-251},
  note = {cited By (since 1996) 2},
  abstract = {Cloud computing represents a promising computing paradigm, where computational
	power is provided similar to utilities like water, electricity or
	gas. While most of the Cloud providers can guarantee some measurable
	non-functional performance metrics e.g., service availability or
	throughput, there is lack of adequate mechanisms for guaranteeing
	certifiable and auditable security, trust, and privacy of the applications
	and the data they process. This lack represents an obstacle for moving
	most business relevant applications into the Cloud. In this paper
	we devise a novel approach for compliance management in Clouds, which
	we termed Compliant Cloud Computing (C3). On one hand, we propose
	novel languages for specifying compliance requirements concerning
	security, privacy, and trust by leveraging domain specific languages
	and compliance level agreements. On the other hand, we propose the
	C3 middleware responsible for the deployment of certifiable and auditable
	applications, for provider selection in compliance with the user
	requirements, and for enactment and enforcement of compliance level
	agreements. We underpin our approach with a use case discussing various
	techniques necessary for achieving security, privacy, and trust in
	Clouds as for example data fragmentation among different protection
	domains or among different geographical regions. © 2010 IEEE.},
  affiliation = {Distributed Systems Group, Vienna University of Technology, Vienna,
	Austria; Institute of Architecture of Application Systems, University
	of Stuttgart, Stuttgart, Germany; T-Systems International GmbH, Frankfurt,
	Germany},
  art_number = {5557988},
  author_keywords = {Compliance managmenet; DSLs; SLAs},
  document_type = {Conference Paper},
  journal = {Proceedings - 2010 IEEE 3rd International Conference on Cloud Computing,
	CLOUD 2010},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-77957964959&partnerID=40&md5=997bf3df56b82fbff42bdce5deefdb43}
}

@ARTICLE{Bravenboer2006297,
  author = {Bravenboer, M., De Groot, R., Visser, E.},
  title = {MetaBorg in action: Examples of domain-specific language embedding
	and assimilation using stratego/XT},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2006},
  volume = {4143 LNCS},
  pages = {297-311},
  note = {cited By (since 1996) 8},
  abstract = {General-purpose programming languages provide limited facilities for
	expressing domain-specific concepts in a natural manner. All domain
	concepts need to be captured using the same generic syntactic and
	semantic constructs. Generative programming methods and program transformation
	techniques can be used to overcome this lack of abstraction in general-purpose
	languages. In this tutorial we describe the METABORG method for embedding
	domainspecific languages, tailored syntactically and semantically
	to the application domain at hand, in a general-purpose language.
	METABORG is based on Stratego/XT, a language and toolset for the
	implementation of program transformation systems, which is used for
	the definition of syntactic embeddings and assimilation of the embedded
	constructs into the surrounding code. We illustrate METABORG with
	three examples. JavaSwul is a custom designed language for implementing
	graphical user-interfaces, which provides high-level abstractions
	for component composition and event-handling. JavaRegex is a new
	embedding of regular expression matching and string rewriting. JavaJava
	is an embedding of Java in Java for generating Java code. For these
	cases we show how Java programs in these domains become dramatically
	more readable, and we give an impression of the implementation of
	the language embeddings. © Springer-Verlag Berlin Heidelberg 2006.},
  affiliation = {Department of Information and Computing Sciences, Universiteit Utrecht,
	P.O. Box 80089, 3508 TB, Utrecht, Netherlands},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-33750051621&partnerID=40&md5=1272a273c096b943854709c4be98a963}
}

@ARTICLE{Bravenboer200834,
  author = {Bravenboer, M., Visser, E.},
  title = {Designing syntax embeddings and assimilations for language libraries},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2008},
  volume = {5002 LNCS},
  pages = {34-46},
  note = {cited By (since 1996) 0},
  abstract = {Language libraries extend regular libraries with domain-specific notation.
	More precisely, a language library is a combination of a domain-specific
	language embedded in the general-purpose host language, a regular
	library implementing the underlying functionality, and an assimilation
	transformation that maps embedded DSL fragments to host language
	code. While the basic architecture for realizing language libraries
	is the same for all applications, there are many design choices to
	be made in the design of a particular combination of library, guest
	language syntax, host language, and assimilation. In this paper,
	we give an overview of the design space for syntax embeddings and
	assimilations for the realization of language libraries. © 2008 Springer-Verlag
	Berlin Heidelberg.},
  affiliation = {Software Engineering Research Group, Delft University of Technology,
	Netherlands},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-47749132651&partnerID=40&md5=d2213696cc75905c913b0500e88f6179}
}

@ARTICLE{Bravenboer2004365,
  author = {Bravenboer, M., Visser, E.},
  title = {Concrete syntax for objects: Domain-specific language embedding and
	assimilation without restrictions},
  journal = {ACM SIGPLAN Notices},
  year = {2004},
  volume = {39},
  pages = {365-383},
  number = {10},
  note = {cited By (since 1996) 24},
  abstract = {Application programmer's interfaces give access to domain knowledge
	encapsulated in class libraries without providing the appropriate
	notation for expressing domain composition. Since object-oriented
	languages are designed for extensibility and reuse, the language
	constructs are often sufficient for expressing domain abstractions
	at the semantic level. However, they do not provide the right abstractions
	at the syntactic level. In this paper we describe METABORG, a method
	for providing concrete syntax for domain abstractions to application
	programmers. The method consists of embedding domain-specific languages
	in a general purpose host language and assimilating the embedded
	domain code into the surrounding host code. Instead of extending
	the implementation of the host language, the assimilation phase implements
	domain abstractions in terms of existing APIs leaving the host language
	undisturbed. Indeed, METABORG can be considered a method for promoting
	APIs to the language level. The method is supported by proven and
	available technology, i.e. the syntax definition formalism SDF and
	the program transformation language and toolset Stratego/XT. We illustrate
	the method with applications in three domains: code generation, XML
	generation, and user-interface construction.},
  affiliation = {Inst. of Info. and Comp. Sciences, Universiteit Utrecht, P.O. Box
	80089, 3508 TB Utrecht, Netherlands},
  author_keywords = {Concrete Object Syntax; Domain-Specific Languages; Embedded Languages;
	Extensible Syntax; Meta Programming; METABORG; Rewriting; SDP; Stratego;
	Syntax Extension},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-17044384157&partnerID=40&md5=ef119f227ff68535f44139751364e391}
}

@ARTICLE{Bromberg200921,
  author = {Bromberg, Y.-D.a , Réveillère, L.a , Lawall, J.L.b , Muller, G.c
	},
  title = {Automatic Generation of Network Protocol Gateways},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2009},
  volume = {5896 LNCS},
  pages = {21-41},
  note = {cited By (since 1996) 2},
  abstract = {The emergence of networked devices in the home has made it possible
	to develop applications that control a variety of household functions.
	However, current devices communicate via a multitude of incompatible
	protocols, and thus gateways are needed to translate between them.
	Gateway construction, however, requires an intimate knowledge of
	the relevant protocols and a substantial understanding of low-level
	network programming, which can be a challenge for many application
	programmers. This paper presents a generative approach to gateway
	construction, z2z, based on a domain-specific language for describing
	protocol behaviors, message structures, and the gateway logic. Z2z
	includes a compiler that checks essential correctness properties
	and produces efficient code. We have used z2z to develop a number
	of gateways, including SIP to RTSP, SLP to UPnP, and SMTP to SMTP
	via HTTP, involving a range of issues common to protocols used in
	the home. Our evaluation of these gateways shows that z2z enables
	communication between incompatible devices without increasing the
	overall resource usage or response time. © 2009 Springer-Verlag Berlin
	Heidelberg.},
  affiliation = {University of Bordeaux, France; University of Copenhagen, Denmark;
	Ecole des Mines de Nantes / INRIA-Regal, France},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-70549105999&partnerID=40&md5=9260e25b15ee9972dc6d6b3ff3ce0ea0}
}

@ARTICLE{Broom2002449,
  author = {Broom, B., Fowler, R., Kennedy, K.},
  title = {KelpIO: A telescope-ready domain-specific I/O library for irregular
	block-structured applications},
  journal = {Future Generation Computer Systems},
  year = {2002},
  volume = {18},
  pages = {449-460},
  number = {4},
  note = {cited By (since 1996) 0},
  abstract = {To ameliorate the need to spend significant programmer time modifying
	parallel programs to achieve high-performance, while maintaining
	compact, comprehensible source codes, this paper advocates the use
	of telescoping languages technology to automatically apply, during
	the normal compilation process, high-level performance enhancing
	transformations to applications using a high-level domain-specific
	I/O library. We believe that this approach will be more acceptable
	to application developers than new language extensions, but will
	be just as amenable to optimization by advanced compilers, effectively
	making it a domain-specific language extension for I/O. The paper
	describes a domain-specific I/O library for irregular block-structured
	applications based on the KeLP library, describes high-level transformations
	of the library primitives for improving performance, and describes
	how a high-level domain-specific optimizer for applying these transformations
	could be constructed using the telescoping languages framework. ©
	2002 Published by Elsevier Science B.V.},
  affiliation = {Department of Computer Science, Rice University, Houston, TX 77251-1892,
	United States},
  author_keywords = {Compilation; Domain-specific languages; Input/output library},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-0036499083&partnerID=40&md5=f33aa39a06bee1ce16afc02fd28648d0}
}

@ARTICLE{Bruns200032,
  author = {Bruns, G.R., Frey, A.E., Mataga, P.A., Tripp, S.J.},
  title = {Automated software development with XML and the Java* language},
  journal = {Bell Labs Technical Journal},
  year = {2000},
  volume = {5},
  pages = {32-43},
  number = {2},
  note = {cited By (since 1996) 1},
  abstract = {In software development with domain-specific languages (DSLs), one
	defines a requirements language for an application domain and then
	develops a compiler to generate an implementation from a requirements
	document. Because DSLs and DSL compilers are expensive to develop,
	DSLs are seen as cost effective only when many products of the same
	domain will be developed. In this paper, we show how the cost of
	DSL design and DSL compiler development can be reduced by defining
	DSLs as Extensible-Markup-Language (XML) dialects and by developing
	DSL compilers using commercial XML tools and the Java* language.
	This approach is illustrated through the Call View Data Language
	(CDL), a new DSL that generates provisioning support code and database
	table definitions for Lucent Technologies' 7R/ETM Network Feature
	Server.},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-0034172062&partnerID=40&md5=4b47b8e9ef15c54b6129862b7686e1b7}
}

@CONFERENCE{Bryant2002209,
  author = {Bryant, B.R.a , Burt, C.C.a , Auguston, M.b , Raje, R.R.c , Olson,
	A.M.c },
  title = {Formal specification of generative component assembly using two-level
	grammar},
  year = {2002},
  volume = {27},
  pages = {209-212},
  note = {cited By (since 1996) 0},
  abstract = {Two-Level Grammar (TLG) is proposed as a formal specification language
	for generative assembly of components. Both generative domain models
	and generative rules may be expressed in TLG and these specifications
	may be automatically translated into an implementation which realizes
	an integration of components according to the principles of the Unified
	Meta-component Model (UMM) and Unified Approach (UA) to component
	integration. Furthermore, this implementation realizes Quality of
	Service (QoS) guarantees by means of static QoS verification at the
	time of system assembly, and dynamic QoS validation on a set of test
	cases. Copyright 2002 ACM.},
  affiliation = {Computer/Information Sci., Univ. Alabama-Birmingham, Birmingham, AL
	35294, United States; Computer Science, New Mexico State University,
	Las Cruces, NM 88003, United States; Computer/Information Sci., Indiana
	Univ. Purdue Univ., Indianapolis, IN 46202, United States},
  author_keywords = {component-based software; formal specification; generative programming;
	two-level grammar},
  document_type = {Conference Paper},
  journal = {ACM International Conference Proceeding Series},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-77953737756&partnerID=40&md5=2d47524fad86dc8a16cfeb380687cb30}
}

@CONFERENCE{Bryant201065,
  author = {Bryant, B.R.a , Gray, J.b , Mernik, M.c },
  title = {Domain-specific software engineering},
  year = {2010},
  pages = {65-68},
  note = {cited By (since 1996) 0},
  abstract = {This paper projects that an important future direction in software
	engineering is domain-specific software engineering (DSE). From requirements
	specification to design, and then implementation, a tighter coupling
	between the description of a software system with its application
	domain has the potential to improve both the correctness and reliability
	of the software system, and also lead to greater opportunities for
	software automation. In this position paper, we explore the impact
	of this emerging paradigm on requirements specification, design modeling,
	and implementation, as well as challenge areas benefiting from the
	new paradigm. Copyright 2010 ACM.},
  affiliation = {University of Alabama at Birmingham, Computer and Information Sciences,
	Birmingham, AL 35294-1170, United States; University of Alabama,
	Department of Computer Science, Tuscaloosa, AL 35487-0290, United
	States; University of Maribor, Smetanova 17, SI-2000 Maribor, Slovenia},
  author_keywords = {Domain-specific languages; Domain-specific modeling; Requirements
	specification},
  document_type = {Conference Paper},
  journal = {Proceedings of the FSE/SDP Workshop on the Future of Software Engineering
	Research, FoSER 2010},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-79951615892&partnerID=40&md5=3dffae751cc6645e48b8db1fe343d354}
}

@ARTICLE{Bryant2010276,
  author = {Bryant, B.R.a , Mernik, M.a b , Hrnčič, D.b , Javed, F.c , Liu, Q.a
	, Sprague, A.a },
  title = {Grammar inference technology applications in software engineering},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2010},
  volume = {6339 LNAI},
  pages = {276-279},
  note = {cited By (since 1996) 0},
  abstract = {While Grammar Inference (GI) has been successfully applied to many
	diverse domains such as speech recognition and robotics, its application
	to software engineering has been limited, despite wide use of context-free
	grammars in software systems. This paper reports current developments
	and future directions in the applicability of GI to software engineering,
	where GI is seen to offer innovative solutions to the problems of
	inference of domain-specific language (DSL) specifications from example
	DSL programs and recovery of metamodels from instance models. © 2010
	Springer-Verlag.},
  affiliation = {University of Alabama at Birmingham, Department of Computer and Information
	Sciences, Birmingham, AL 35294-1170, United States; University of
	Maribor, Faculty of Electrical Engineering and Computer Science,
	Smetanova 17, SI-2000 Maribor, Slovenia; Regions Financial Corp.,
	Mortgage Shared Systems, Birmingham, AL 35244, United States},
  author_keywords = {domain-specific languages; grammar inference; metamodel},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-78149261900&partnerID=40&md5=b96bc23c5a04cdc4455eeebdaf90ab5d}
}

@ARTICLE{Bräuer2008182,
  author = {Bräuer, M., Demuth, B.},
  title = {Model-level integration of the OCL standard library using a pivot
	model with generics support},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2008},
  volume = {5002 LNCS},
  pages = {182-193},
  note = {cited By (since 1996) 0},
  abstract = {OCL 2.0 specifies a standard library of predefined types and associated
	operations. A model-level representation of the library is required
	to reference its elements within the abstract syntax model created
	by an OCL parser. Existing OCL engines build this model in the implementation
	code which severely limits reusability, flexibility and maintainability.
	To address these problems, we show how a common pivot model with
	explicit support for template types can help to externalize the definition
	of the standard library and integrate it with instances of arbitrary
	domain-specific modeling languages. We exemplify the feasibility
	of our approach with a prototypical implementation for the Dresden
	OCL2 Toolkit and present a tailored EMF editor for modeling the OCL
	types and operations. We limit our discussion to the model level,
	i.e., we do not consider an implementation of the standard library
	for an execution engine. © 2008 Springer-Verlag Berlin Heidelberg.},
  affiliation = {Software Technology Group, Dresden University of Technology, Dresden
	01062, Germany},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-47849088620&partnerID=40&md5=1df72921b5e3f74007ad719457af80dc}
}

@ARTICLE{Bräuer200834,
  author = {Bräuer, M., Lochmann, H.},
  title = {An ontology for software models and its practical implications for
	semantic web reasoning},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2008},
  volume = {5021 LNCS},
  pages = {34-48},
  note = {cited By (since 1996) 2},
  abstract = {Ontology-Driven Software Development (ODSD) advocates using ontologies
	for capturing knowledge about a software system at development time.
	So far, ODSD approaches have mainly focused on the unambiguous representation
	of domain models during the system analysis phase. However, the design
	and implementation phases can equally benefit from the logical foundations
	and reasoning facilities provided by the Ontology technological space.
	This applies in particular to Model-Driven Software Development (MDSD)
	which employs models as first class entities throughout the entire
	software development process. We are currently developing a tool
	suite called HybridMDSD that leverages Semantic Web technologies
	to integrate different domain-specific modeling languages based on
	their ontological foundations. To this end, we have defined a new
	upper ontology for software models that complements existing work
	in conceptual and business modeling. This paper describes the structure
	and axiomatization of our ontology and its underlying conceptualization.
	Further, we report on the experiences gained with validating the
	integrity and consistency of software models using a Semantic Web
	reasoning architecture. We illustrate practical solutions to the
	implementation challenges arising from the open-world assumption
	in OWL and lack of nonmonotonic queries in SWRL. © 2008 Springer-Verlag
	Berlin Heidelberg.},
  affiliation = {SAP Research CEC Dresden, Chemnitzer Str. 48, Dresden 01187, Germany},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-45449105964&partnerID=40&md5=3e11cef4b9245466d63316d5f9b5826e}
}

@CONFERENCE{Budiselic2010507,
  author = {Budiselic, I.a , Zuzak, I.a , Benc, I.b },
  title = {Application middleware for convergence of IP Multimedia system and
	Web Services},
  year = {2010},
  pages = {507-512},
  note = {cited By (since 1996) 0},
  abstract = {Current network applications are typically created for one of two
	worlds. Communication applications targeting mobile devices usually
	communicate using the SIP protocol and are integrated into IP Multimedia
	systems of mobile network operators. On the other hand, applications
	targeting the enterprise market typically adhere to the SOAP protocol
	and integrate with Web Services exposed on the Internet. However,
	existing and future applications would benefit from access to services
	exposed by both of these protocols in both the mobile network and
	the Internet. In this paper we present the architecture of an application
	middleware that acts as a bidirectional gateway among IP Multimedia
	and Web Services systems. The middleware provides infrastructure
	for SIP and SOAP message handling, and session and network resource
	management. The middleware exposes interfaces for defining application
	specific rules for communication between protocol domains. Lastly,
	we outline a domain specific language that simplifies definition
	of such rules.},
  affiliation = {School of Electrical Engineering and Computing, University of Zagreb,
	Zagreb, Croatia; Ericsson Nikola Tesla d.d., Zagreb, Croatia},
  art_number = {5533443},
  document_type = {Conference Paper},
  journal = {MIPRO 2010 - 33rd International Convention on Information and Communication
	Technology, Electronics and Microelectronics, Proceedings},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-77956354436&partnerID=40&md5=8fe6d5772a313e97dcb15942f169b22f}
}

@CONFERENCE{Buffenbarger2001292,
  author = {Buffenbarger, J., Gruell, K.},
  title = {A language for software subsystem composition},
  year = {2001},
  pages = {292},
  note = {cited By (since 1996) 0},
  abstract = {A software system often consists of thousands of source files, which
	must be translated into thousands of intermediate files, which eventually
	must be translated into some small number of library and executable
	files. Collectively, these steps compose its build process. A large
	software system can be difficult to build. The steps can be numerous
	and complex. Of course, there are a variety of tools to assist us
	(e.g., Make), but their languages emphasize the specification of
	low-level details (e.g., compiler names and options), rather than
	high-level attributes (e.g., host/target platforms and required subsystems).
	This paper describes a new domain-specific language for specifying
	the composition and construction of a software system, where the
	emphasis is on high-level attributes. A specification is processed
	by a pipeline of fairly simple tools to produce a set of makefiles,
	which are then processed by Make in the usual way.},
  author_keywords = {Domain-Specific Languages; Software Configuration Management; Software
	Engineering; Software-Build Tools Software-Specification Languages},
  document_type = {Conference Paper},
  journal = {Proceedings of the Hawaii International Conference on System Sciences},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-0034974348&partnerID=40&md5=8234cc792a52e27681f56c8789488735}
}

@CONFERENCE{Bui2006,
  author = {Bui, N.B.a b , Jeffery, R.a },
  title = {DSLBench: Applying DSL in benchmark generation},
  year = {2006},
  volume = {183},
  note = {cited By (since 1996) 0},
  abstract = {Meeting performance requirements is a challenging software engineering
	problem in designing and constructing middleware based applications.
	Considerable efforts have been spent to build performance analysis
	models from the application architectural models that can be applied
	before the implementation phase. Accurate analysis models require
	realistic performance data to be populated into the performance models,
	which represents the performance characteristics of the middleware
	and the application hosted by the middleware runtime environment.
	Benchmark applications are usually developed to collect these performance
	data. However, benchmark generation for middleware-based systems
	is a costly and time consuming process because of the complexity
	of programming models and technology specific features of different
	types of middleware. The paper proposes an approach to automate benchmark
	generation processes following Model Driven Development methodology,
	which aims to construct deployable benchmark applications from the
	high-level design models. A modelling language is designed specifically
	for performance testing domain by using the recently released Microsoft
	Domain Specific Language toolkit. This approach can be integrated
	into Visual Studio 2005 Team System as a "plug in " to model and
	generate load testing suites. Copyright 2006 ACM.},
  affiliation = {Empirical Software Engineering Program, National ICT Australia Ltd.;
	School of Computer Science and Engineering, University of New South
	Wales, Australia},
  art_number = {1169087},
  author_keywords = {Domain specific language; Domain specific modelling; Model driven
	development; Performance; Testing},
  document_type = {Article},
  journal = {ACM International Conference Proceeding Series},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-34547183485&partnerID=40&md5=c247a4b33fb9e80d5b68e4ca4d4db934}
}

@CONFERENCE{Bui2007169,
  author = {Bui, N.B.a , Zhu, L.b , Gorton, I.c , Liu, Y.b },
  title = {Benchmark generation using domain specific modeling},
  year = {2007},
  pages = {169-178},
  note = {cited By (since 1996) 0},
  abstract = {Performance benchmarks are domain specific applications that are specialized
	to a certain set of technologies and platforms. The development of
	a benchmark application requires mapping the performance specific
	domain concepts to an implementation and producing complex technology
	and platform specific code. Domain Specific Modeling (DSM) promises
	to bridge the gap between application domains and implementations
	by allowing designers to specify solutions in domain-specific abstractions
	and semantics through Domain Specific Languages (DSL). This allows
	generation of a final implementation automatically from high level
	models. The modeling and task automation benefits obtained from this
	approach usually justify the upfront cost involved. This paper employs
	a DSM based approach to invent a new DSL, DSLBench, for benchmark
	generation. DSLBench and its associated code generation facilities
	allow the design and generation of a completely deployable benchmark
	application for performance testing from a high level model. DSLBench
	is implemented using Microsoft Domain Specific Language toolkit.
	It is integrated with the Visual Studio 2005 Team Suite as a plug-in
	to provide extra modeling capabilities for performance testing. We
	illustrate the approach using a case study based on .Net and C#.
	© 2007 IEEE.},
  affiliation = {School of Computer Science and Engineering, University of New South
	Wales, Australia; Empirical Software Engineering, National ICT Australia
	Ltd., Australia; Pacific Northwest National Laboratory, United States},
  art_number = {4159670},
  document_type = {Conference Paper},
  journal = {Proceedings of the Australian Software Engineering Conference, ASWEC},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-34548129529&partnerID=40&md5=aaeff7efd6bb63e5c5d98feb7f55b2a2}
}

@CONFERENCE{Bunch201159,
  author = {Bunch, C.a , Chohan, N.a , Krintz, C.a , Shams, K.b },
  title = {Neptune: A domain specific language for deploying HPC software on
	cloud platforms},
  year = {2011},
  pages = {59-68},
  note = {cited By (since 1996) 0},
  abstract = {In this paper, we present the design and implementation of Neptune,
	a domain specific language (DSL) that automates configuration and
	deployment of existing HPC software via cloud computing platforms.
	We integrate Neptune into a popular, open-source cloud platform,
	and extend the platform with support for user-level and automated
	placement of cloud services and HPC components. Such platform integration
	of Neptune facilitates hybrid-cloud application execution as well
	as portability across disparate cloud fabrics. Supporting additional
	cloud fabrics through a single interface enables high throughput
	computing (HTC) to be achieved by users who do not necessarily own
	grid-level resources but do have access to otherwise independent
	cloud technologies. We evaluate Neptune using different applications
	that employ a wide range of popular HPC packages for their implementation
	including MPI, X10, MapReduce, DFSP, and dwSSA. In addition, we show
	how Neptune can be extended to support other HPC software and application
	domains, and thus be used as a mechanism for many task computing
	(MTC). © 2011 ACM.},
  affiliation = {Computer Science Department, University of California, Santa Barbara,
	CA, United States; Jet Propulsion Laboratory, California Institute
	of Technology, United States},
  author_keywords = {cloud platform; domain specific language; service placement},
  document_type = {Conference Paper},
  journal = {ScienceCloud'11 - Proceedings of the 2nd International Workshop on
	Scientific Cloud Computing},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-79961055793&partnerID=40&md5=0aeb77131a5a713aaae127fd13012e7b}
}

@CONFERENCE{Bureš2009501,
  author = {Bureš, T.a b , Hnětynka, P.b , Malohlava, M.b },
  title = {Using a product line for creating component systems},
  year = {2009},
  pages = {501-508},
  note = {cited By (since 1996) 2},
  abstract = {Component systems have become a wide-spread technology and found their
	place in several application domains. Each component system has its
	specifics and particularities that reflect its focus and the application
	domain it is intended for. Although important, the diversity of component
	systems leads to a number of problems including having different
	tools for each systems, unnecessary duplication of functionality
	and problems with integration when several domains are to be targeted.
	Based on categorization of component application domains, we propose
	a "meta-component system", which provides a software product line
	for creating custom component systems. We focus especially on the
	deployment and execution environment, which is where most diversities
	are found. We demonstrate the usage of the "meta-component system"
	and propose how it is to be realized by two core concepts of SOFA
	2, namely connector generator and microcomponents. Copyright 2009
	ACM.},
  affiliation = {Institute of Computer Science, Academy of Sciences of the Czech Republic,
	Pod Vodárenskou věží, Prague 8, 18000, Czech Republic; Department
	of Software Engineering, Faculty of Mathematics and Physics, Charles
	University, Malostranské náměstí 25, Prague 1, 11800, Czech Republic},
  author_keywords = {Component systems; Generative programming; Product line engineering;
	Runtime environment},
  document_type = {Conference Paper},
  journal = {Proceedings of the ACM Symposium on Applied Computing},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-72949123443&partnerID=40&md5=da4f397a3989520e07633d21473e3cc4}
}

@CONFERENCE{Bureš2008138,
  author = {Bureš, T.a b , Malohlava, M.b , Hnětynka, P.b },
  title = {Using DSL for automatic generation of software connectors},
  year = {2008},
  pages = {138-147},
  note = {cited By (since 1996) 1},
  abstract = {Component-based engineering is a recognized paradigm, which models
	an application as a collection of reusable components. The key idea
	behind components is that they contain only the business logic and
	communicate with one another only via well-defined interfaces. The
	communication paths among components (so called bindings) are in
	modern component systems realized by software connectors, which allow
	explicit modeling of communication and also its implementation at
	runtime. An important aspect of using connectors is the possibility
	of their automatic generation, which saves a significant amount of
	development work. However, the generation itself is not a trivial
	task, since there is a big semantic gap between the abstract specification
	of a connector at design time and its implementation at runtime.
	In this paper, we present an approach to generating implementations
	of software connectors. The approach is based on a new domain specific
	language for describing templates of connector implementations and
	a transformation framework using the Strate-go/XT term rewriting
	system for generating source code of connectors. © 2008 IEEE.},
  affiliation = {Institute of Computer Science, Academy of Sciences of the Czech Republic,
	Pod Vodarenskou vezi 2, Prague 8, 18207, Czech Republic; Department
	of Software Engineering, Faculty of Mathematics and Physics, Charles
	University, Malostranske namesti 25, Prague 1, 11800, Czech Republic},
  art_number = {4464018},
  document_type = {Conference Paper},
  journal = {Proceedings - 7th International Conference on Composition-Based Software
	Systems, ICCBSS 2008},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-49649094268&partnerID=40&md5=e7498d1ff598998fd9c0f69b7398a9b5}
}

@ARTICLE{Burgy2011575,
  author = {Burgy, L.a , Réveillère, L.b , Lawall, J.c , Muller, G.d },
  title = {Zebu: A language-based approach for network protocol message processing},
  journal = {IEEE Transactions on Software Engineering},
  year = {2011},
  volume = {37},
  pages = {575-591},
  number = {4},
  note = {cited By (since 1996) 0},
  abstract = {A network application communicates with other applications according
	to a set of rules known as a protocol. This communication is managed
	by the part of the application known as the protocol-handling layer,
	which enables the manipulation of protocol messages. The protocol-handling
	layer is a critical component of a network application since it represents
	the interface between the application and the outside world. It must
	thus satisfy two constraints: It must be efficient to be able to
	treat a large number of messages and it must be robust to face various
	attacks targeting the application itself or the underlying platform.
	Despite these constraints, the development process of this layer
	still remains rudimentary and requires a high level of expertise.
	It includes translating the protocol specification written in a high-level
	formalism such as ABNF toward low-level code such as C. The gap between
	these abstraction levels can entail many errors. This paper proposes
	a new language-based approach to developing protocol-handling layers,
	to improve their robustness without compromising their performance.
	Our approach is based on the use of a domain-specific language, Zebu,
	to specify the protocol-handling layer of network applications that
	use textual HTTP-like application protocols. The Zebu syntax is very
	close to that of ABNF, facilitating the adoption of Zebu by domain
	experts. By annotating the original ABNF specification of a protocol,
	the Zebu user can dedicate the protocol-handling layer to the needs
	of a given application. The Zebu compiler first checks the annotated
	specification for inconsistencies, and then generates a protocol-handling
	layer according to the annotations. This protocol-handling layer
	is made up of a set of data structures that represent a message,
	a parser that fills in these data structures, and various stub functions
	to access these data structures or drive the parsing of a message.
	© 2006 IEEE.},
  affiliation = {Princeton University, 35 Olden Street, Princeton, NJ 08540, United
	States; University of Bordeaux, LaBRI - Laboratoire Bordelais de
	Recherche en Informatique, 351 cours de la Libération, F-33405 Talence
	Cedex, France; DIKU, University of Copenhagen, LiP6, 4 place Jussieu,
	75005 Paris, France; INRIA-Regal, LIP6, 4 place Jussieu, 750005 Paris,
	France},
  art_number = {5487528},
  author_keywords = {domain-specific languages; message composing; message parsing; Network
	protocols},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-79961031075&partnerID=40&md5=1d63cac50878202e093cabab5331cbd3}
}

@CONFERENCE{Burgy2007149,
  author = {Burgy, L.a , Réveillère, L.a , Lawall, J.L.b , Muller, G.c },
  title = {A language-based approach for improving the robustness of network
	application protocol implementations},
  year = {2007},
  pages = {149-158},
  note = {cited By (since 1996) 6},
  abstract = {The secure and robust functioning of a network relies on the defect-free
	implementation of network applications. As network protocols have
	become increasingly complex, however, hand- writing network message
	processing code has become increasingly error-prone. In this paper,
	we present a domain-specific language, Zebu, for generating robust
	and efficient message processing layers. A Zebu specification, based
	on the notation used in RFCs, describes protocol message formats
	and related processing constraints. Zebu-based applications are efficient,
	since message fragments can be specified to be processed on demand.
	Zebu-based applications are also robust, as the Zebu compiler automatically
	checks specification consistency and generates parsing stubs that
	include validation of the message structure. Using a message torture
	suite in the context of SIP and RTSP, we show that Zebu-generated
	code is both complete and defect-free. © 2007 IEEE.},
  affiliation = {Phoenix Group, INRIA / LaBRI, University of Bordeaux, France; University
	of Copenhagen, Copenhagen, Denmark; École des Mines de Nantes, INRIA
	/ LINA, France},
  art_number = {4365692},
  author_keywords = {Domain-specific languages; Message processing; Network protocols},
  document_type = {Conference Paper},
  journal = {Proceedings of the IEEE Symposium on Reliable Distributed Systems},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-47249119202&partnerID=40&md5=f8f4cf5c1d0129b7f78c1a111b9a2a2f}
}

@CONFERENCE{Butler2001760,
  author = {Butler, G., Batory, D., Eisenecker, U.},
  title = {Generative techniques for product lines},
  year = {2001},
  pages = {760-761},
  note = {cited By (since 1996) 2},
  abstract = {A software product line leverages the knowledge of one or more domains
	in order to achieve short time-to-market, cost savings, and high
	quality software. The highest level of reuse comes by using domain-specific
	languages or visual builders to describe a member of the product
	line, and to generate the member from the description. Generative
	techniques can help us to capture the configuration knowledge for
	a product line and use it to generate concrete family members. This
	workshop focuses on technical issues of product lines, rather than
	economic issues.},
  affiliation = {Concordia University, Montreal, Canada},
  document_type = {Conference Paper},
  journal = {Proceedings - International Conference on Software Engineering},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-0035000896&partnerID=40&md5=84c00df6ab6901189ca2db9610398e08}
}

@ARTICLE{Bánhalmi2007241,
  author = {Bánhalmi, A.a , Paczolay, D.a , Tóth, L.a , Kocsor, A.b },
  title = {Development of a Hungarian medical dictation system},
  journal = {Informatica (Ljubljana)},
  year = {2007},
  volume = {31},
  pages = {241-246},
  number = {2},
  note = {cited By (since 1996) 0},
  abstract = {This paper reviews the current state of a Hungarian project which
	seeks to create a speech recognition system for the dictation of
	thyroid gland medical reports. First, we present the MRBA speech
	corpus that was assembled to support the training of general-purpose
	Hungarian speech recognition systems. Then we describe the processing
	of medical reports that were collected to help the creation of domain-specific
	language models. At the acoustic modelling level we experimented
	with two techniques - a conventional HMM one and an ANN-based solution
	- which are both briefly described in the paper. Finally, we present
	the language modelling methodology currently applied in the system,
	and round off with recognition results on test data taken from four
	speakers. The scores show that on a somewhat restricted sub-domain
	of the task we are able to produce word accuracies well over 95%.},
  affiliation = {Research Group on Artificial Intelligence, Hungarian Academy of Sciences,
	University of Szeged, Aradi vértanúk tere 1, H-6720 Szeged; Applied
	Intelligence Laboratory Ltd., Research Group on Artificial Intelligence
	NPC, Petofi Sgt. 43, H-6723 Szeged, Hungary},
  author_keywords = {2D-cepstrum; Dictation systems; Speech recognition},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-34547534010&partnerID=40&md5=4155350d19be6489c160793e30c7ff55}
}

@ARTICLE{Bézivin2005171,
  author = {Bézivin, J.},
  title = {On the unification power of models},
  journal = {Software and Systems Modeling},
  year = {2005},
  volume = {4},
  pages = {171-188},
  number = {2},
  note = {cited By (since 1996) 176},
  abstract = {In November 2000, the OMG made public the MDA™ initiative, a particular
	variant of a new global trend called MDE (Model Driven Engineering).
	The basic ideas of MDA are germane to many other approaches such
	as generative programming, domain specific languages, model-integrated
	computing, generic model management, software factories, etc. MDA
	may be defined as the realization of MDE principles around a set
	of OMG standards like MOF, XMI, OCL, UML, CWM, SPEM, etc. MDE is
	presently making several promises about the potential benefits that
	could be reaped from a move from code-centric to model-based practices.
	When we observe these claims, we may wonder when they may be satisfied:
	on the short, medium or long term or even never perhaps for some
	of them. This paper tries to propose a vision of the development
	of MDE based on some lessons learnt in the past 30 years in the development
	of object technology. The main message is that a basic principle
	("Everything is an object") was most helpful in driving the technology
	in the direction of simplicity, generality and power of integration.
	Similarly in MDE, the basic principle that "Everything is a model"
	has many interesting properties, among others the capacity to generate
	a realistic research agenda. We postulate here that two core relations
	(representation and conformance) are associated to this principle,
	as inheritance and instantiation were associated to the object unification
	principle in the class-based languages of the 80's. We suggest that
	this may be most useful in understanding many questions about MDE
	in general and the MDA approach in particular. We provide some illustrative
	examples. The personal position taken in this paper would be useful
	if it could generate a critical debate on the research directions
	in MDE. © Springer-Verlag 2004.},
  affiliation = {ATLAS Group, INRIA and LINA, University of Nantes, 2, rue de la Houssinière,
	44322 Nantes Cedex 3, France},
  author_keywords = {MDA; MDE; Metamodels; Models},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-19644394108&partnerID=40&md5=aa73f144a11d70c3a4025b67a1245ad5}
}

@ARTICLE{Bézivin200669,
  author = {Bézivin, J., Jouault, F.},
  title = {Using ATL for checking models},
  journal = {Electronic Notes in Theoretical Computer Science},
  year = {2006},
  volume = {152},
  pages = {69-81},
  number = {1-2},
  note = {cited By (since 1996) 3},
  abstract = {Working with models often requires the ability to assert the compliance
	of a given model to a given set of constraints. Some tools are able
	to check OCL invariants on UML models. However, there are very few
	tools able to do the same for any metamodel. This is quite penalizing
	for the DSL (Domain Specific Language) approach to model engineering.
	In this paper we propose a metamodel-independent solution to this
	problem that uses ATL (Atlas Transformation Language). This solution
	has been implemented as an Eclipse-based plugin. © 2006 Elsevier
	B.V. All rights reserved.},
  affiliation = {ATLAS Group, INRIA and LINA, University of Nantes, France},
  author_keywords = {ATL; Checking models; Model Engineering; OCL},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-33644920383&partnerID=40&md5=b8ad52928f45d3aac9e06a182b7d29cb}
}

@ARTICLE{Büchner201070,
  author = {Büchner, T., Matthes, F., Neubert, C.},
  title = {Data model driven implementation of web cooperation systems with
	Tricia},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2010},
  volume = {6348 LNCS},
  pages = {70-84},
  note = {cited By (since 1996) 1},
  abstract = {We present the data modeling concepts of Tricia, an open-source Java
	platform used to implement enterprise web information systems as
	well as social software solutions including wikis, blogs, file shares
	and social networks. Tricia follows a data model driven approach
	to system implementation where substantial parts of the application
	semantics are captured by domain-specific models (data model, access
	control model and interaction model). In this paper we give an overview
	of the Tricia architecture and development process and present the
	concepts of its data model: plugins, entities, properties, roles,
	mixins, validators and change listeners are motivated and described
	using UML class diagrams and concrete examples from Tricia projects.
	We highlight the benefits of this data modeling framework for application
	developers (expressiveness, modularity, reuse, separation of concerns)
	and show its impact on user-related services (content authoring,
	integrity checking, link management, queries and search, access control,
	tagging, versioning, schema evolution and multilingualism). This
	provides the basis for a comparison with other model based approaches
	to web information systems. © 2010 Springer-Verlag.},
  affiliation = {Technische Universität München, Institute for Informatics, Boltzmannstr.
	3, 85748 Garching, Germany},
  author_keywords = {Data modeling; domain specific language; software architecture; software
	engineering; web application; web framework},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-78249239156&partnerID=40&md5=e47154db5b5a34a9b0b14d974ed4230c}
}

@ARTICLE{Cabot2010256,
  author = {Cabot, J.a , Chimiak-Opoka, J.b , Gogolla, M.d , Jouault, F.c , Knapp,
	A.e },
  title = {Ninth international workshop on the pragmatics of OCL and other textual
	specification languages},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2010},
  volume = {6002 LNCS},
  pages = {256-260},
  note = {cited By (since 1996) 0},
  abstract = {This paper reports on the 9th OCL workshop held at the MODELS conference
	in 2009. The workshop focused on the challeges of using OCL in a
	variety of new scenarios (e.g., model verification and validation,
	code generation, test-driven development, transformations) and application
	domains (e.g., domain-specific languages, web semantics) in which
	OCL is now being used due to the increasing popularity of model-driven
	development processes and the important role OCL play in them. The
	workshop included sessions with paper presentations and a final round
	discussion. © Springer-Verlag Berlin Heidelberg 2010.},
  affiliation = {Open University of Catalonia, Spain; University of Innsbruck, Austria;
	University of Bremen, Germany; INRIA-École des Mines de Nantes, France;
	University of Augsburg, Germany},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-78650312837&partnerID=40&md5=4a16f91df96e4c1ab30036bdf1619206}
}

@ARTICLE{Calcagno200357,
  author = {Calcagno, C.a , Taha, W.b , Huang, L.c , Leroy, X.d },
  title = {Implementing multi-stage languages using ASTs, gensym, and reflection},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2003},
  volume = {2830},
  pages = {57-76},
  note = {cited By (since 1996) 12},
  abstract = {The paper addresses theoretical and practical aspects of implementing
	multi-stage languages using abstract syntax trees (ASTs), gensym,
	and reflection. We present an operational account of the correctness
	of this approach, and report on our experience with a bytecode compiler
	called MetaOCaml that is based on this strategy. Current performance
	measurements reveal interesting characteristics of the underlying
	OCaml compiler, and illustrate why this strategy can be particularly
	useful for implementing domain-specific languages in a typed, functional
	setting. © Springer-Verlag Berlin Heidelberg 2003.},
  affiliation = {Imperial College London, United Kingdom; Rice University, Houston,
	TX, United States; Yale University, New Haven, CT, United States;
	INRIA, Roquencourt, France},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-35248851156&partnerID=40&md5=fd7a79ffc52d9a73ea7007f03d50852d}
}

@ARTICLE{Campos200945,
  author = {Campos, M.D.a , Barbosa, L.S.b },
  title = {Implementation of an Orchestration Language as a Haskell Domain Specific
	Language},
  journal = {Electronic Notes in Theoretical Computer Science},
  year = {2009},
  volume = {255},
  pages = {45-64},
  note = {cited By (since 1996) 1},
  abstract = {Even though concurrent programming has been a hot topic of discussion
	in Computer Science for the past 30 years, the community has yet
	to settle on a, or a few standard approaches to implement concurrent
	programs. But as more and more cores inhabit our CPUs and more and
	more services are made available on the web the problem of coordinating
	different tasks becomes increasingly relevant. The present paper
	addresses this problem with an implementation of the orchestration
	language Orc as a domain specific language in Haskell. Orc was, therefore,
	realized as a combinator library using the lightweight threads and
	the communication and synchronization primitives of the Concurrent
	Haskell library. With this implementation it becomes possible to
	create orchestrations that re-use existing Haskell code and, conversely,
	re-use orchestrations inside other Haskell programs. The complexity
	inherent to distributed computation, entails the need for the classification
	of efficient, reusable, concurrent programming patterns. The paper
	discusses how the calculus of recursive schemes used in the derivation
	of functional programs, scales up to a distributed setting. It is
	shown, in particular, how to parallelize the entire class of binary
	tree hylomorphisms. © 2009 Elsevier B.V. All rights reserved.},
  affiliation = {Nordic DataGrid Facility, Copenhagen, Denmark; DI-CCTC, Universidade
	do Minho, Braga, Portugal},
  author_keywords = {Coordination Languages; Haskell; Orc; Parallel Divide-and-Conquer
	Algorithms; Thread-based Programming},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-71849105397&partnerID=40&md5=16e4a468b0c99fac5ae897d4de8a7070}
}

@CONFERENCE{Canfora199695,
  author = {Canfora, G., Cimitile, A., De Lucia, A.},
  title = {Specifying code analysis tools},
  year = {1996},
  pages = {95-103},
  note = {cited By (since 1996) 1},
  abstract = {Customised code analysis tools for the maintenance and evolution of
	existing software systems can be created by storing program information
	into a database, and using an application generator to translate
	the high level specifications of the analyses the tools are intended
	to perform. We present a high level domain specific language for
	the specification of program analysis tools that exploit an algebraic
	program representation called F(p). The algebraic representation
	is a compact program view which describes the static composition
	of the control structures and the set of the resulting potential
	executions. Operands of the algebraic expression (that represent
	the program's constructs) are used as indexes to access information
	stored into a database. The specification language provides facilities
	for the traversal of the program representation and access to the
	associated information into the database. The program model and the
	analyses' results are integrated into a unique conceptual model,
	thus simplifying the reuse of the results of an analysis and the
	integration of tools.},
  affiliation = {Univ of Salerno},
  document_type = {Conference Paper},
  journal = {Conference on Software Maintenance},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-0030412190&partnerID=40&md5=8ac0d95daea12892f27e4a8e10155006}
}

@CONFERENCE{Cao2003944,
  author = {Cao, F.a , Bryant, B.R.a , Burt, C.C.a , Huang, Z.b , Raje, R.R.b
	, Olson, A.M.b , Auguston, M.c },
  title = {Automating Feature-Oriented Domain Analysis},
  year = {2003},
  volume = {2},
  pages = {944-949},
  note = {cited By (since 1996) 5},
  abstract = {Feature modeling is commonly used to capture the commonalities and
	variabilities of systems in a domain during Domain Analysis. The
	output of feature modeling will be some reusable assets (components,
	patterns, domain-specific language, etc.) to be fed into the application
	engineering phase for ultimate software products. But current practice
	lacks an automatic approach for seamless generation of reusable assets
	from feature models. This paper presents an algorithm for generating
	sets of instance descriptions (feature instances) from feature models
	of a domain and applies this algorithm in creating a Generic Feature
	Modeling Environment for automating Feature-Oriented Domain Analysis.},
  affiliation = {Department of Computer Science, University of Alabama, Birmingham;
	Department of Computer Science, Indiana University, Purdue University,
	Indianapolis; Computer Science Department, Naval Postgraduate School},
  author_keywords = {Domain Analysis; Feature Modeling; Generative Programming},
  document_type = {Conference Paper},
  journal = {Proceedings of the International Conference on Software Engineering
	Research and Practise},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-1642587803&partnerID=40&md5=9589a62d9df7de7123229d11cd83be28}
}

@ARTICLE{Cao2005119,
  author = {Cao, F.a , Bryant, B.R.a , Burt, C.C.a , Raje, R.R.b , Olson, A.M.b
	, Auguston, M.c },
  title = {A component assembly approach based on aspect-oriented generative
	domain modeling},
  journal = {Electronic Notes in Theoretical Computer Science},
  year = {2005},
  volume = {114},
  pages = {119-136},
  number = {SPEC. ISS.},
  note = {cited By (since 1996) 8},
  abstract = {We present an approach towards automatic component assembly based
	on aspect-oriented generative domain modeling. It involves the lifecycle
	covering the component specification generation, and subsequent assembly
	of implementation components to produce the final software system.
	Aspect-oriented techniques are applied to capture the crosscutting
	concerns that emerge during the assembly process. Subsequently, those
	concerns are woven to generate glue/wrapper code for assembling heterogeneous
	components to construct a single integrated system. © 2004 Elsevier
	B.V.},
  affiliation = {Dept. of Comp. and Info. Sciences, University of Alabama at Birmingham,
	Birmingham, AL, United States; Dept. of Comp. and Info. Science,
	Indiana Univ. Purdue Univ. I., Indianapolis, IN, United States; Computer
	Science Department, Naval Postgraduate School, Monterey, CA, United
	States},
  author_keywords = {Aspect Orientation; Component Assembly; Component Specification; Generative
	Domain Model; Generative Programming; Two-Level Grammar; UniFrame},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-12344262304&partnerID=40&md5=aed724ce8a0270ec47d7764bc8e5f075}
}

@ARTICLE{Cao2009127,
  author = {Cao, J.a , Goyal, A.b , Novstrup, K.A.b , Midkiff, S.P.a , Caruthers,
	J.M.b },
  title = {An Optimizing Compiler for Parallel Chemistry Simulations},
  journal = {International Journal of Parallel Programming},
  year = {2009},
  volume = {37},
  pages = {127-152},
  number = {2},
  note = {cited By (since 1996) 1},
  abstract = {Well designed domain specific languages have three important benefits:
	(1) the easy expression of problems, (2) the application of domain
	specific optimizations (including parallelization), and (3) dramatic
	improvements in productivity for their users. In this paper we describe
	a compiler and parallel runtime system for modeling the complex kinetics
	of rubber vulcanization and olefin polymerization that achieves all
	of these goals. The compiler allows the development of a system of
	ordinary differential equations describing a complex vulcanization
	reaction or single-site olefin polymerization reaction-a task that
	used to require months-to be done in hours. A specialized common
	sub-expression elimination and other algebraic optimizations sufficiently
	simplify the complex machine generated code to allow it to be compiled-eliminating
	all but 8.0% of the operations in our largest program and enabling
	over 60 times faster execution on our largest benchmark codes. The
	parallel runtime and dynamic load balancing scheme enables fast simulations
	of the model. © 2008 Springer Science+Business Media, LLC.},
  affiliation = {School of Electrical and Computer Engineering, Purdue University,
	West Lafayette, IN 47907, United States; School of Chemical Engineering,
	Purdue University, West Lafayette, IN 47907, United States},
  author_keywords = {Chemistry modeling; Common elimination subexpression; Compilers; Domain
	specific languages; Domain specific optimizations; Parallelism},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-63749105680&partnerID=40&md5=b28e3474256a4949d6ffd14c9ab7e865}
}

@CONFERENCE{Cao2011511,
  author = {Cao, Y., Xu, T., Tang, T., Wang, H., Zhao, L.},
  title = {Automatic generation and verification of interlocking tables based
	on Domain Specific Language for Computer Based Interlocking Systems
	(DSL-CBI)},
  year = {2011},
  volume = {2},
  pages = {511-515},
  note = {cited By (since 1996) 0},
  abstract = {Interlocking tables, as the function specification of the Computer
	Based Interlocking System (CBI), play an important role in ensuring
	safe train movements at a railway station. The development and verification
	of interlocking tables is entirely manual process currently, which
	is inefficient and error-prone due to the complexity of the CBI and
	the human interferences. In order to tackle these problems, we introduce
	a toolset based on Domain Specific Language for Computer Based Interlocking
	Systems (DSL-CBI) to automatically generate and verify the interlocking
	table. In this paper, we address how to use the algorithm to automatically
	generate the interlocking table by inputting the XML file of the
	railway station designed by DSL-CBI, and how to use model checking
	to verify whether there are any conflicting settings in it. We also
	discuss the advantages of the toolset and the significant contribution
	in developing CBI based on the proposed toolset. © 2011 IEEE.},
  affiliation = {State Key Laboratory of Rail Traffic Control and Safety, Beijing Jiaotong
	University, Beijing 100044, China},
  art_number = {5952519},
  author_keywords = {Computer Based Interlocking System (CBI); Domain Specific Language
	for Computer Based Interlocking Systems (DSL-CBI); interlocking table;
	model checking; route information search algorithm},
  document_type = {Conference Paper},
  journal = {Proceedings - 2011 IEEE International Conference on Computer Science
	and Automation Engineering, CSAE 2011},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-80051886086&partnerID=40&md5=328152ed534983424a2507ae007e2e0c}
}

@CONFERENCE{Cao2011136,
  author = {Cao, Y.a , Lu, Q.a , Xu, T.a , Tang, T.a , Wang, H.a , Xu, Y.b },
  title = {Integrating DSL-CBI and NuSMV for modeling and verifiying interlocking
	systems},
  year = {2011},
  pages = {136-143},
  note = {cited By (since 1996) 0},
  abstract = {The Computer Based Interlocking System (CBI) is used to ensure safe
	train movements at a railway station. For a given station, all the
	train routes and the concrete safety rules associated with these
	are defined in the interlocking table. Currently, the development
	and verification of interlocking tables is entirely manual process,
	which is inefficient and error-prone due to the complexity of the
	CBI and the human interferences. Besides, the complexity and volume
	of the verification results tend to make users feel extremely non-understandable.
	In order to tackle these problems, we introduce a toolset based on
	Domain Specific Language for Computer Based Interlocking Systems
	(DSL-CBI) to automatically generate and verify the interlocking table,
	and then mark the conflicting routes in the railway station. In this
	paper, we also discuss the advantages of the toolset and the significant
	contribution in developing CBI based on the proposed toolset. © 2011
	IEEE.},
  affiliation = {State Key Laboratory of Rail Traffic Control and Safety, Beijing Jiaotong
	University, Beijing 100044, China; Taffic Control Technology Co.
	Ltd., Beijing 100070, China},
  art_number = {6004515},
  author_keywords = {Computer based interlocking system (CBI); Counter-example visualization;
	Domain specific language for computer based interlocking systems
	(DSL-CBI); Interlocking table; Railway station},
  document_type = {Conference Paper},
  journal = {2011 5th International Conference on Secure Software Integration
	and Reliability Improvement - Companion, SSIRI-C 2011},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-80053040347&partnerID=40&md5=27eb8fae9403707afa4dc6620d6caab8}
}

@ARTICLE{Carette200824,
  author = {Carette, J., Smith, S., McCutchan, J., Anand, C., Korobkine, A.},
  title = {Case studies in model manipulation for scientific computing},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2008},
  volume = {5144 LNAI},
  pages = {24-37},
  note = {cited By (since 1996) 1},
  abstract = {The same methodology is used to develop 3 different applications.
	We begin by using a very expressive, appropriate Domain Specific
	Language, to write down precise problem definitions, using their
	most natural formulation. Once defined, the problems form an implicit
	definition of a unique solution. From the problem statement, our
	model, we use mathematical transformations to make the problem simpler
	to solve computationally. We call this crucial step "model manipulation."
	With the model rephrased in more computational terms, we can also
	derive various quantities directly from this model, which greatly
	simplify traditional numeric solutions, our eventual goal. From all
	this data, we then use standard code generation and code transformation
	techniques to generate lower-level code to perform the final numerical
	steps. This methodology is very flexible, generates faster code,
	and generates code that would have been all but impossible for a
	human programmer to get correct. © 2008 Springer-Verlag Berlin Heidelberg.},
  affiliation = {Computing and Software Department, McMaster University, Hamilton,
	ON, Canada},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-51049088649&partnerID=40&md5=1a3338fd61e02c354732aace5dd53670}
}

@CONFERENCE{Carreira2004915,
  author = {Carreira, P.a , Galhardas, H.b },
  title = {Efficient development of data migration transformations},
  year = {2004},
  pages = {915-916},
  note = {cited By (since 1996) 4},
  abstract = {In this paper, we present a data migration tool named DATA FUSION.
	Its main features are: A domain specific language designed to conveniently
	model complex data transformations; an integrated development environment
	that assists users on managing complex data transformation projects
	and an auditing facility that provides relevant information to project
	managers and external auditors.},
  affiliation = {Oblog Consulting, FCUL; INESC-ID, IST},
  document_type = {Conference Paper},
  journal = {Proceedings of the ACM SIGMOD International Conference on Management
	of Data},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-3142749873&partnerID=40&md5=d9ecb5c3e8ca8cdd6f92f0e124d6bda9}
}

@ARTICLE{Cassou2010137,
  author = {Cassou, D., Bertran, B., Loriant, N., Consel, C.},
  title = {A generative programming approach to developing pervasive computing
	systems},
  journal = {ACM SIGPLAN Notices},
  year = {2010},
  volume = {45},
  pages = {137-146},
  number = {2},
  note = {cited By (since 1996) 0},
  abstract = {Developing pervasive computing applications is a difficult task because
	it requires to deal with a wide range of issues: heterogeneous devices,
	entity distribution, entity coordination, low-level hardware knowledge
	⋯ Besides requiring various areas of expertise, programming such
	applications involves writing a lot of administrative code to glue
	technologies together and to interface with both hardware and software
	components. This paper proposes a generative programming approach
	to providing programming, execution and simulation support dedicated
	to the pervasive computing domain. This approach relies on a domain-specific
	language, named DiaSpec, dedicated to the description of pervasive
	computing systems. Our generative approach factors out features of
	distributed systems technologies, making DiaSpec-specified software
	systems portable. The DiaSpec compiler is implemented and has been
	used to generate dedicated programming frameworks for a variety of
	pervasive computing applications, including detailed ones to manage
	the building of an engineering school. Copyright © 2009 ACM.},
  affiliation = {INRIA/LaBRI/ENSEIRB, France},
  author_keywords = {DSL; Generative programming; Pervasive computing},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-77957587099&partnerID=40&md5=997d173a2ca3e81186fae10c730290f9}
}

@CONFERENCE{Cassou2009137,
  author = {Cassou, D., Bertran, B., Loriant, N., Consel, C.},
  title = {A generative programming approach to developing pervasive computing
	systems},
  year = {2009},
  pages = {137-146},
  note = {cited By (since 1996) 7},
  abstract = {Developing pervasive computing applications is a difficult task because
	it requires to deal with a wide range of issues: heterogeneous devices,
	entity distribution, entity coordination, low-level hardware knowledge.
	Besides requiring various areas of expertise, programming such applications
	involves writing a lot of administrative code to glue technologies
	together and to interface with both hardware and software components.
	This paper proposes a generative programming approach to providing
	programming, execution and simulation support dedicated to the pervasive
	computing domain. This approach relies on a domain-specific language,
	named DiaSpec, dedicated to the description of pervasive computing
	systems. Our generative approach factors out features of distributed
	systems technologies, making DiaSpec-specified software systems portable.
	The DiaSpec compiler is implemented and has been used to generate
	dedicated programming frameworks for a variety of pervasive computing
	applications, including detailed ones to manage the building of an
	engineering school. Copyright © 2009 ACM.},
  affiliation = {INRIA/LaBRI/ENSEIRB},
  author_keywords = {DSL; Generative programming; Pervasive computing},
  document_type = {Conference Paper},
  journal = {GPCE'09 - Proceedings of the 8th International ACM SIGPLAN Conference
	on Generative Programming and Component Engineering},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-70450195382&partnerID=40&md5=8087d46267e48cc0cc5ae7b51f4e06a4}
}

@CONFERENCE{Cassou2010247,
  author = {Cassou, D., Bruneau, J., Mercadal, J., Enard, Q., Balland, E., Loriant,
	N., Consel, C.},
  title = {Towards a tool-based development methodology for sense/compute/control
	applications},
  year = {2010},
  pages = {247-248},
  note = {cited By (since 1996) 0},
  abstract = {This poster presents a design language and a tool suite covering the
	development life-cycle of a Sense/Compute/Control (SCC) application.
	This language makes it possible to define the architecture of an
	application, following an architectural pattern commonly used in
	SCC applications. Our underlying methodology assigns roles to the
	stakeholders, providing separation of concerns. Our tool suite includes
	a compiler that takes design artifacts written in our language as
	input. The compiler generates customized support for subsequent development
	stages, namely implementation and test. In doing so, it ensures the
	conformance between the architecture and the code. Our tool suite
	also includes a simulator for testing SCC applications, without requiring
	code modification. Our methodology has been applied to a wide spectrum
	of areas, such as building automation, advanced telecommunications,
	and health-care.},
  affiliation = {University of Bordeaux, INRIA, LaBRI, France},
  author_keywords = {Architecture description languages; Domain-specific languages; Generative
	programming; Methodology},
  document_type = {Conference Paper},
  journal = {Proceedings of the ACM International Conference Companion on Object
	Oriented Programming Systems Languages and Applications Companion,
	SPLASH '10},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-78650120939&partnerID=40&md5=6835f64ba53388ea3f6a27871759bce5}
}

@CONFERENCE{Cassou2011431,
  author = {Cassou, D.a , Balland, E.a , Consel, C.a , Lawall, J.b },
  title = {Leveraging software architectures to guide and verify the development
	of sense/compute/control applications},
  year = {2011},
  pages = {431-440},
  note = {cited By (since 1996) 0},
  abstract = {A software architecture describes the structure of a computing system
	by specifying software components and their interactions. Mapping
	a software architecture to an implementation is a well known challenge.
	A key element of this mapping is the architecture's description of
	the data and control-flow interactions between components. The characterization
	of these interactions can be rather abstract or very concrete, providing
	more or less implementation guidance, programming support, and static
	verification. In this paper, we explore one point in the design space
	between abstract and concrete component interaction specifications.
	We introduce a notion of interaction contract that expresses allowed
	interactions between components, describing both data and control-flow
	constraints. This declaration is part of the architecture description,
	allows generation of extensive programming support, and enables various
	verifications. We instantiate our approach in an architecture description
	language for Sense/Compute/Control applications, and describe associated
	compilation and verification strategies © 2011 ACM.},
  affiliation = {INRIA/University of Bordeaux, Bordeaux, France; DIKU/INRIA/LIP6, Bordeaux,
	France},
  author_keywords = {architectural conformance; generative programming},
  document_type = {Conference Paper},
  journal = {Proceedings - International Conference on Software Engineering},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-79959902128&partnerID=40&md5=ca6619280c956591800a0fbc6b81491b}
}

@ARTICLE{Castro2002664,
  author = {Castro, M.J., Sanchis, E.},
  title = {A simple connectionist approach to language understanding in a dialogue
	system},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2002},
  volume = {2527 LNAI},
  pages = {664-673},
  note = {cited By (since 1996) 1},
  abstract = {A contribution to the understanding module of a domain-specific dialogue
	system is presented in this work. The task consists of answering
	telephone queries about train timetables, prices and services for
	long distance trains in Spanish. In this system, the representation
	of the meaning of the user utterances is made by means of frames,
	which determine the type of communication of the user turn, and by
	their associated cases, which supply the data of the utterance. We
	focus on the classification of a user turn given in natural language
	in a specific class of frame. We used multilayer perceptrons to classify
	a user turn as belonging to a frame class. This classification can
	help in the posterior processes of understanding and dialogue management.
	© Springer-Verlag 2002.},
  affiliation = {Departament de Sistemes Informàtics I Computació, Universitat Politècnica
	de València, Camí de Vera s/n, 46022 València, Spain},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-35248900035&partnerID=40&md5=d345f2ffe5cb82f48c9363b8203a9f5f}
}

@CONFERENCE{Cazzola200911,
  author = {Cazzola, W., Speziale, I.},
  title = {Sectional domain specific languages},
  year = {2009},
  pages = {11-14},
  note = {cited By (since 1996) 1},
  abstract = {Nowadays, many problems are solved by using a domain specific language
	(DSL), i.e., a programming language tailored to work on a particular
	application domain. Normally, a new DSL is designed and implemented
	from scratch requiring a long time-to-market due to implementation
	and testing issues. Whereas when the DSL simply extends another language
	it is realized as a source-to-source transformation or as an external
	library with limited flexibility. The Hive framework is developed
	with the intent of overcoming these issues by providing a mechanism
	to compose different programming features together forming a new
	DSL, what we call a sectional DSL. The support (both at compiler
	and interpreter level) of each feature is separately described and
	easily composed with the others. This approach is quite flexible
	and permits to build up a new DSL from scratch or simplifying an
	existing language without penalties. Moreover, it has the desirable
	side-effect that each DSL can be extended at any time potentially
	also at run-time. Copyright 2009 ACM.},
  affiliation = {DICo, University of Milano, Italy},
  author_keywords = {aosd; compilers; dsl; modularity},
  document_type = {Conference Paper},
  journal = {Proceedings of the 4th Workshop on Domain-Specific Aspect Languages,
	DSAL '09, Co-located with the 8th International Conference on Aspect-Oriented
	Software Development, AOSD.09},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-77951548255&partnerID=40&md5=566b688dc0006920093a931bdf13311d}
}

@ARTICLE{Cechticky2003267,
  author = {Cechticky, V.a , Chevalley, P.b , Pasetti, A.c , Schaufelberger,
	W.a },
  title = {A generative approach to framework instantiation},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2003},
  volume = {2830},
  pages = {267-286},
  note = {cited By (since 1996) 3},
  abstract = {This paper describes the OBS Instantiation Environment, which demonstrates
	a generative approach to automating the instantiation process of
	a component-based framework. The process is automated in the sense
	that designers configure and assemble the framework components using
	intuitive visual operations in a GUI-based environment. Their configuration
	actions are then used to automatically generate the framework instantiation
	code. Generative techniques for framework instantiation are not new
	but tend to rely on domain-specific languages or on bespoke specification
	encoding and compilation techniques. Though effective and powerful,
	they are comparatively complex and present a high barrier to entry
	for general users. The distinctive feature of the approach proposed
	here is instead its simplicity and its reliance on mainstream technology
	and tools. © Springer-Verlag Berlin Heidelberg 2003.},
  affiliation = {Institut für Automatik, ETH-Zürich, Physikstr. 3, CH-8092, Zürich,
	Switzerland; European Space Agency, ESTEC, PO Box 299, 2200 AG Noordwijk,
	Netherlands; P and P Software, Peter-Thumb Str. 46, D-78464, Germany},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-26944469748&partnerID=40&md5=d931f0413e6cf084595fa895b9896ed1}
}

@ARTICLE{Cepa2004283,
  author = {Cepa, V., Mezini, M.},
  title = {Declaring and enforcing dependencies between.NET custom attributes},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2004},
  volume = {3286},
  pages = {283-297},
  note = {cited By (since 1996) 3},
  abstract = {Custom attributes as e.g., supported by the .NET framework complemented
	by pre- or post-processing tools can be used to integrate domain-specific
	concepts into general-purpose language technology, representing an
	interesting alternative to domain-specific languages in supporting
	model-driven development. For this purpose, it is important that
	dependency relationships between custom attributes, e.g., stating
	that a certain attribute requires or excludes another attribute,
	can be specified and checked for during model processing (compilation).
	Such dependencies can be viewed as an important part of expressing
	the meta-model of the domain-specific concepts represented by custom
	attributes. In this paper, we present an approach to specifying and
	enforcing dependencies between .NET custom attributes, which naturally
	extends the built-in .NET support. In this approach, dependencies
	are specified declaratively by using custom attributes to decorate
	other custom attributes. Once the dependency declaration is made
	part of the custom attribute support, one can write tools that enforce
	dependencies based on .NET meta-program API-s like CodeDom or Reflection.
	In this paper, we present such a tool, called ADC (for attribute
	dependency checker). © Springer-Verlag 2004.},
  affiliation = {Software Technology Group, Department of Computer Science, Darmstadt
	University of Technology, Germany},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-35048833260&partnerID=40&md5=e6d6317db43e76b2b5987c10a32d9d01}
}

@CONFERENCE{Cervelle2009651,
  author = {Cervelle, J.b , Črepinšek, M.a , Forax, R.b , Kosar, T.a , Mernik,
	M.a , Roussel, G.b },
  title = {On defining quality based grammar metrics},
  year = {2009},
  volume = {4},
  pages = {651-658},
  note = {cited By (since 1996) 0},
  abstract = {Grammar metrics have been introduced to measure the quality and the
	complexity of the formal grammars. The aim of this paper is to explore
	the meaning of these notions and to experiment, on several grammars
	of domain specific languages and of general purpose languages, existing
	grammar metrics together with new metrics based on grammar LR automaton
	and on the produced language. We discuss the results of this experiment
	and focus on the comparison between domain specific languages and
	general purpose languages grammars and on the evolution of the metrics
	between several versions of the same language. © 2009 IEEE.},
  affiliation = {Faculty of Electrical Engineering and Computer Science, University
	of Maribor, Smetanova 17, 2000 Maribor, Slovenia; Laboratoire d'Informatique
	Gaspard-Monge, Université Paris-Est, 77454 Marne-la-Vallée, France},
  art_number = {5352768},
  author_keywords = {Grammar engineering; Grammar metrics; Grammarware; Software language
	engineering},
  document_type = {Conference Paper},
  journal = {Proceedings of the International Multiconference on Computer Science
	and Information Technology, IMCSIT '09},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-78649743553&partnerID=40&md5=d433db02d0bcd7c33acf334faa15caee}
}

@ARTICLE{Chafi201135,
  author = {Chafi, H., Lee, H., Sujeeth, A.K., Atreya, A.R., Brown, K.J., Olukotun,
	K.},
  title = {A domain-specific approach to heterogeneous parallelism},
  journal = {ACM SIGPLAN Notices},
  year = {2011},
  volume = {46},
  pages = {35-45},
  number = {8},
  note = {cited By (since 1996) 0},
  abstract = {Exploiting heterogeneous parallel hardware currently requires mapping
	application code to multiple disparate programming models. Unfortunately,
	general-purpose programming models available today can yield high
	performance but are too low-level to be accessible to the average
	programmer. We propose leveraging domainspecific languages (DSLs)
	to map high-level application code to heterogeneous devices. To demonstrate
	the potential of this approach we present OptiML, a DSL for machine
	learning. OptiML programs are implicitly parallel and can achieve
	high performance on heterogeneous hardware with no modification required
	to the source code. For such a DSL-based approach to be tractable
	at large scales, better tools are required for DSL authors to simplify
	language creation and parallelization. To address this concern, we
	introduce Delite, a system designed specifically for DSLs that is
	both a framework for creating an implicitly parallel DSL as well
	as a dynamic runtime providing automated targeting to heterogeneous
	parallel hardware. We show that OptiML running on Delite achieves
	single-threaded, parallel, and GPU performance superior to explicitly
	parallelized MATLAB code in nearly all cases. Copyright © 2011 ACM.},
  affiliation = {Pervasive Parallelism Laboratory, Stanford University, United States},
  author_keywords = {Domain-Specific Languages; Dynamic Optimizations; Parallel Programming},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-80053990340&partnerID=40&md5=4fd5dd0df3000fd2e55cecc4493ceaa3}
}

@CONFERENCE{Chafi2010,
  author = {Chafi, H.a , DeVito, Z.a , Moors, A.b , Rompf, T.b , Sujeeth, A.K.a
	, Hanrahan, P.a , Odersky, M.b , Olukotun, K.a },
  title = {Language virtualization for heterogeneous parallel computing},
  year = {2010},
  pages = {835-847},
  note = {cited By (since 1996) 1},
  abstract = {As heterogeneous parallel systems become dominant, application developers
	are being forced to turn to an incompatible mix of low level programming
	models (e.g. OpenMP, MPI, CUDA, OpenCL). However, these models do
	little to shield developers from the difficult problems of parallelization,
	data decomposition and machine-specific details. Most programmers
	are having a difficult time using these programming models effectively.
	To provide a programming model that addresses the productivity and
	performance requirements for the average programmer, we explore a
	domain-specific approach to heterogeneous parallel programming. We
	propose language virtualization as a new principle that enables the
	construction of highly efficient parallel domain specific languages
	that are embedded in a common host language. We define criteria for
	language virtualization and present techniques to achieve them. We
	present two concrete case studies of domain-specific languages that
	are implemented using our virtualization approach. © 2010 ACM.},
  affiliation = {Stanford University, United States; EPFL, Switzerland},
  author_keywords = {Domain specific languages; Dynamic optimizations; Parallel programming},
  document_type = {Conference Paper},
  journal = {Proceedings of the Conference on Object-Oriented Programming Systems,
	Languages, and Applications, OOPSLA},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-78650079065&partnerID=40&md5=6e93b70856db715cf1617207b097f0e9}
}

@ARTICLE{Chafi2010835,
  author = {Chafi, H.a , Devito, Z.a , Moors, A.b , Rompf, T.b , Sujeeth, A.K.a
	, Hanrahan, P.a , Odersky, M.b , Olukotun, K.a },
  title = {Language virtualization for heterogeneous parallel computing},
  journal = {ACM SIGPLAN Notices},
  year = {2010},
  volume = {45},
  pages = {835-847},
  number = {10},
  note = {cited By (since 1996) 1},
  abstract = {As heterogeneous parallel systems become dominant, application developers
	are being forced to turn to an incompatible mix of low level programming
	models (e.g. OpenMP, MPI, CUDA, OpenCL). However, these models do
	little to shield developers from the difficult problems of parallelization,
	data decomposition and machine-specific details. Most programmers
	are having a difficult time using these programming models effectively.
	To provide a programming model that addresses the productivity and
	performance requirements for the average programmer, we explore a
	domainspecific approach to heterogeneous parallel programming. We
	propose language virtualization as a new principle that enables the
	construction of highly efficient parallel domain specific languages
	that are embedded in a common host language. We define criteria for
	language virtualization and present techniques to achieve them. We
	present two concrete case studies of domain-specific languages that
	are implemented using our virtualization approach. Copyright © 2010
	ACM.},
  affiliation = {Stanford University, United States; EPFL, Switzerland},
  author_keywords = {Domain specific languages; Dynamic optimizations; Parallel programming},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-79551710254&partnerID=40&md5=4071974785084fd97fe03e7cc43d88fa}
}

@ARTICLE{Chan2005175,
  author = {Chan, Z.E.a , Paige, R.F.b },
  title = {Designing a domain-specific contract language: A metamodelling approach},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2005},
  volume = {3748 LNCS},
  pages = {175-189},
  note = {cited By (since 1996) 0},
  abstract = {Domain-specific languages are of increasing importance in software
	engineering. Little attention has been paid to the systematic production
	of domain-specific contract languages (DSCLs). In this paper, we
	present a metamodel-based approach for designing DSCLs. An extensible
	metamodel for software contracts is presented, and a process for
	building DSCLs is sketched. Finally, an example of building a DSCL
	is demonstrated, using the metamodel and process. © Springer-Verlag
	Berlin Heidelberg 2005.},
  affiliation = {Department of Computer Science, University of Warwick, United Kingdom;
	Department of Computer Science, University of York, United Kingdom},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-33646527148&partnerID=40&md5=41e6df8a9a208fc6060f6e5bf1dba36d}
}

@ARTICLE{Chandra1996,
  author = {Chandra, S., Richards, B., Larus, J.R.},
  title = {Teapot: Language support for writing memory coherence protocols},
  journal = {SIGPLAN Notices (ACM Special Interest Group on Programming Languages)},
  year = {1996},
  volume = {31},
  pages = {237-248},
  number = {5},
  note = {cited By (since 1996) 2},
  abstract = {Recent shared-memory parallel computer systems offer the exciting
	possibility of customizing memory coherence protocols to fit an application's
	semantics and sharing patterns. Custom protocols have been used to
	achieve message-passing performance - while retaining the convenient
	programming model of a global address space - and to implement high-level
	language constructs. Unfortunately, coherence protocols written in
	a conventional language such as C are difficult to write, debug,
	understand, or modify. This paper describes Teapot, a small, domain-specific
	language for writing coherence protocols. Teapot uses continuations
	to help reduce the complexity of writing protocols. Simple static
	analysis in the Teapot compiler eliminates much of the overhead of
	continuations and results in protocols that run nearly as fast as
	hand-written C code. A Teapot specification can be compiled both
	to an executable coherence protocol and to input for a model checking
	system, which permits the specification to be verified. We report
	our experiences coding and verifying several protocols written in
	Teapot, along with measurements of the overhead incurred by writing
	a protocol in a higher-level language. © 1996 ACM.},
  affiliation = {Computer Sciences Department, University of Wisconsin-Madison, 1210
	West Dayton St., Madison, WI 53706, United States},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-17144399607&partnerID=40&md5=3c68e6f646b2638ff7e0339ed2e25078}
}

@ARTICLE{Chandra1999317,
  author = {Chandra, S.a , Richards, B.b , Larus, J.R.c },
  title = {Teapot: A domain-specific language for writing cache coherence protocols},
  journal = {IEEE Transactions on Software Engineering},
  year = {1999},
  volume = {25},
  pages = {317-333},
  number = {3},
  note = {cited By (since 1996) 9},
  abstract = {In this paper, we describe Teapot, a domain-specific language for
	writing cache coherence protocols. Cache coherence is of concern
	when parallel and distributed systems make local replicas of shared
	data to improve scalability and performance. In both distributed
	shared memory systems and distributed file systems, a coherence protocol
	maintains agreement among the replicated copies as the underlying
	data are modified by programs running on the system. Cache coherence
	protocols are notoriously difficult to implement, debug, and maintain.
	Moreover, protocols are not off-the-shelf, reusable components, because
	their details depend on the requirements of the system under consideration.
	The complexity of engineering coherence protocols can discourage
	users from experimenting with new, potentially more efficient protocols.
	We have designed and implemented Teapot, a domain-specific language
	that attempts to address this complexity. Teapot's language constructs,
	such as a state-centric control structure and continuations, are
	better suited to expressing protocol code than those of a typical
	systems programming language. Teapot also facilitates automatic verification
	of protocols, so hard to find protocol bugs, such as deadlocks, can
	be detected and fixed before encountering them on an actual execution.
	We describe the design rationale of Teapot, present an empirical
	evaluation of the language using two case studies, and relate the
	lessons that we learned in building a domain-specific language for
	systems programming.},
  affiliation = {Bell Laboratories, Lucent Technologies, Naperville IL 60566., United
	States; Department of Computer Science, Vassar College, Poughkeepsie,
	NY 12604., United States; Microsoft Research, One Microsoft Way,
	Redmond, WA 98052., United States},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-0032594250&partnerID=40&md5=2bfddc24a9c5b7efff10eec45f50e6c2}
}

@CONFERENCE{Chandra1996237,
  author = {Chandra, Satish, Richards, Brad, Larus, James R.},
  title = {Teapot: language support for writing memory coherence protocols},
  year = {1996},
  pages = {237-248},
  note = {cited By (since 1996) 5},
  abstract = {Recent shared-memory parallel computer systems offer the exciting
	possibility of customizing memory coherence protocols to fit an application's
	semantics and sharing patterns. Custom protocols have been used to
	achieve message-passing performance - while retaining the convenient
	programming model of a global address space - and to implement high-level
	language constructs. Unfortunately, coherence protocols written in
	a conventional language such as C are difficult to write, debug,
	understand, or modify. This paper describes Teapot, a small, domain-specific
	language for writing coherence protocols. Teapot uses continuations
	to help reduce the complexity of writing protocols. Simple static
	analysis in the Teapot compiler eliminates much of the overhead of
	continuations and results in protocols that run nearly as fast as
	hand-written C code. A Teapot specification can be compiled both
	to an executable coherence protocol and to input for a model checking
	system, which permits the specification to be verified. We report
	our experiences coding and verifying several protocols written in
	Teapot, along with measurements of the overhead incurred by writing
	a protocol in a higher-level language.},
  affiliation = {Univ of Wisconsin-Madison, Madison, United States},
  document_type = {Conference Paper},
  journal = {Proceedings of the ACM SIGPLAN Conference on Programming Language
	Design and Implementation (PLDI)},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-0029703705&partnerID=40&md5=626a07851f1ac5920bfc7aab6618c3de}
}

@CONFERENCE{Chang2007517,
  author = {Chang, F., Ren, J.},
  title = {Validating system properties exhibited in execution traces},
  year = {2007},
  pages = {517-520},
  note = {cited By (since 1996) 5},
  abstract = {Execution traces produced by software systems during their operation
	can capture important runtime information, and thus are valuable
	sources for validating software functional properties. Automating
	the validation of such properties is currently achieved by writing
	test scripts, where most of the effort focuses on programming operations
	rather than specifying properties clearly. Improving this practice
	calls for domain-specific languages that can capture properties exhibited
	in traces at a higher abstract level. This paper presents a Test
	Behavior Language (TBL) that uses parameterized patterns as logical
	predicates to specify and validate trace-based properties abstractly
	but precisely. TBL has been used to automate the testing of several
	software systems, including a large telecommunication system. Initial
	results show that TBL is powerfulfor validating complex properties
	of these systems in real time, resulting in a big increase in the
	thoroughness of behavioral analysis and the number of bugs revealed.
	TBL also reduces the effort of script writing. TBL specifications
	range from 1/2 to 1/5 the size of their Tcl script counterparts,
	with a greater benefit realized where thorough trace analysis is
	needed. Copyright 2007 ACM.},
  affiliation = {Bell Labs., Alcatel-Lucent, 600 Mountain Av, Murray Hill, NJ 07974,
	United States},
  author_keywords = {system testing automation; trace analysis},
  document_type = {Conference Paper},
  journal = {ASE'07 - 2007 ACM/IEEE International Conference on Automated Software
	Engineering},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-67650098398&partnerID=40&md5=01ea0a47fdf7dc3478d10abf0d2c2994}
}

@CONFERENCE{Chang20071286,
  author = {Chang, P.-H.a , Agha, G.b },
  title = {Supporting reconfigurable object distribution for customized web
	applications},
  year = {2007},
  pages = {1286-1292},
  note = {cited By (since 1996) 3},
  abstract = {In current practice, Web applications are tightly coupled with the
	platforms that a particular service provider intends to support and
	the execution scenario envisioned at the design time. The resulting
	applications do not adapt well to all clients and runtime execution
	contexts. The goal of our research is to develop methods and software
	to support recon-figurable distributed applications which can be
	customized to specific requirements. We view a Web application as
	a composition of actors, i.e. distributed active objects, and apply
	techniques of generative programming to develop a virtual application
	framework which separates the logic of objects from aspects relevant
	to object distribution on different platforms. We describe ActorSpec,
	a specification system allowing programmers to express desired object
	distribution and assisting application generators to produce highly
	customized versions of an application. The resulting flexibility
	facilitates the development of customizable Web applications on an
	increasingly complex Web infrastructure. Copyright 2007 ACM.},
  affiliation = {RiverGlass, Inc., 60 Hazelwood Dr., Champaign, IL 61820; University
	of Illinois at Urbana-Champaign, 201 North Goodwin Avenue, Urbana,
	IL 61801},
  document_type = {Article},
  journal = {Proceedings of the ACM Symposium on Applied Computing},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-35248820078&partnerID=40&md5=deb6b5c0c030362b1ddf2dbcbc141d35}
}

@CONFERENCE{Charles2007485,
  author = {Charles, P., Fuhrer, R.M., Sutton Jr., S.M.},
  title = {IMP: A meta-tooling platform for creating language-specific IDEs
	in eclipse},
  year = {2007},
  pages = {485-488},
  note = {cited By (since 1996) 13},
  abstract = {Programming language design remains a vital field, with interest in
	languages targeting concurrency, scripting, and aspects, as well
	as in domain-specific languages. Full-featured integrated development
	environments (IDEs) have become critical to the adoption of new languages.
	A key factor in the success of these IDEs is the provision of services
	specifically tailored to the language. However, modern IDE frameworks
	are large and complex, and the cost of constructing a language-specific
	IDE from scratch remains prohibitive IMP is an IDE meta-tooling platform
	intended to relieve much of the burden of IDE development in Eclipse.
	IMP combines a language-independent framework, generators for partial
	implementations of language-specific services, and support for the
	completion of service implementations by programming at various levels
	of abstraction. Unlike much of the previous work, IMP permits signigicant
	customization of IDE appearance and behavior and accommodates incremental
	elaboration of the IDE; it also makes significant reuse of code and
	assists during the IDE development process. IMP-based IDEs are in
	use in research projects in IBM, including within IMP itself. IMP
	is available as an open-source release from SourceForge.net. Copyright
	2007 ACM.},
  affiliation = {IBM T.J. Watson Research, P.O. Box 704, Yorktown Heights, NY 10598,
	United States},
  author_keywords = {eclipse; generation; IDE; IDE workbench; meta-tooling},
  document_type = {Conference Paper},
  journal = {ASE'07 - 2007 ACM/IEEE International Conference on Automated Software
	Engineering},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-67649981075&partnerID=40&md5=3dd8ad66501cfa6651754d3165011c1b}
}

@CONFERENCE{Chatley2010460,
  author = {Chatley, R.a , Ayres, J.b , White, T.c },
  title = {LiFT: Driving development using a business-readable DSL for web testing},
  year = {2010},
  pages = {460-468},
  note = {cited By (since 1996) 0},
  abstract = {This paper describes the development and evolution of LiFT, a framework
	for writing automated tests in a style that makes them very readable,
	even for non-programmers. We call this style 'literate testing'.
	By creating a domain-specific language embedded within Java, we were
	able to write automated tests that read almost like natural language,
	allowing business requirements to be expressed very clearly. This
	allows development to be driven from tests that are created by developers
	and customers together, helping give all stakeholders confidence
	that the right things are being tested and hence a correct system
	being built. We discuss the experiences of a team using these tools
	and techniques in a large commercial project, and the lessons learned
	from the experience. © 2010 IEEE.},
  affiliation = {Develogical Ltd., 95 Muswell Hill Broadway, London, N10 3RS, Canada;
	MetaBroadcast Ltd., 33 Fitzroy Street, London, W1T 6DU, Canada; Cloudera
	Inc., 1409 Chapin Avenue, Burlingame, CA 94010, United States},
  art_number = {5463692},
  document_type = {Conference Paper},
  journal = {ICSTW 2010 - 3rd International Conference on Software Testing, Verification,
	and Validation Workshops},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-77953796808&partnerID=40&md5=854b13f30e9c0c323daef24d4e31f6a4}
}

@ARTICLE{Chavarriaga20091329,
  author = {Chavarriaga, E., Macías, J.A.},
  title = {A model-driven approach to building modern Semantic Web-Based User
	Interfaces},
  journal = {Advances in Engineering Software},
  year = {2009},
  volume = {40},
  pages = {1329-1334},
  number = {12},
  note = {cited By (since 1996) 4},
  abstract = {The Semantic Web has widely spread in the last 10 years as a suitable
	web platform to support semantics and expressive information seeking.
	However, one of the main problems with this paradigm is still the
	representation and manipulation of ontologies as well as the complex
	relationships that they implicitly represent. Actually, this remains
	a challenge when unskilled users have to deal with this abstract
	representation in order to carry out daily solving-problem activities
	(e.g., designing web applications based on ontologies). This probably
	made the Semantic Web to decrease in popularity, also being commercially
	unsupported and overcame by recent technologies and services based
	on the Web 2.0, the emerging end-user-focused web concept. All in
	all, the specification of Model-Based User Interfaces fits very well
	to both paradigms. Accordingly, the aim of this work is to provide
	new ways of modeling user interfaces based on semantic models that
	better fit the domain problem. At the same time, we think of exploiting
	interactive features through current and modern end-user programming
	elements based on the Web 2.0, finally contributing to an architecture
	that supports higher interactive end-user interfaces on the web.
	© 2009 Elsevier Ltd. All rights reserved.},
  affiliation = {EPS, Autónoma University of Madrid, Spain},
  author_keywords = {End-User Development; Model-Based User Interface Design; Model-driven
	architectures; User interfaces for the Semantic Web and Web 2.0;
	Visual Domain-Specific Languages},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-68649102757&partnerID=40&md5=47a45cec60a1e4620d98d377b9f3a876}
}

@CONFERENCE{Chellappa200926,
  author = {Chellappa, S., Franchetti, F., Püschel, M.},
  title = {Computer generation of fast Fourier transforms for the cell broadband
	engine},
  year = {2009},
  pages = {26-35},
  note = {cited By (since 1996) 3},
  abstract = {The Cell BE is a multicore processor with eight vector accelerators
	(called SPEs) that implement explicit cache management through direct
	memory access engines. While the Cell has an impressive floating
	point peak performance, programming and optimizing for it is difficult
	as it requires explicit memory management, multi-threading, streaming,
	and vectorization. We address this problem for the discrete Fourier
	transform (DFT) by extending Spiral, a program generation system,
	to automatically generate highly optimized implementations for the
	Cell. The extensions include multi-SPE parallelization and explicit
	memory streaming, both performed at a high abstraction level using
	rewriting systems operating on Spiral's internal domain-specific
	language. Further, we support latency and throughput optimizations,
	single and double precision, and different data formats. The performance
	of Spiral's computer generated code is comparable with and sometimes
	better than existing DFT implementations, where available. Copyright
	2009 ACM.},
  affiliation = {Department of Electrical and Computer Engineering, Carnegie Mellon
	University, Pittsburgh, PA 15213, United States},
  art_number = {1542285},
  author_keywords = {Automatic performance tuning; Cell BE; DFT; Fast Fourier transform;
	Multibuffering; Multicore; Parallelization; Performance library;
	Program generation; Streaming},
  document_type = {Conference Paper},
  journal = {Proceedings of the International Conference on Supercomputing},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-70350705613&partnerID=40&md5=47c830fceb3c15e3530bed9bb982dc1f}
}

@ARTICLE{Chen2005115,
  author = {Chen, K., Sztipanovits, J., Abdelwalhed, S., Jackson, E.},
  title = {Semantic anchoring with model transformations},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2005},
  volume = {3748 LNCS},
  pages = {115-129},
  note = {cited By (since 1996) 26},
  abstract = {Model-Integrated Computing (MIC) is an approach to Model-Driven Architecture
	(MDA), which has been developed primarily for embedded systems. MIC
	places strong emphasis on the use of domain-specific modeling languages
	(DSML-s) and model transformations. A metamodeling process facilitated
	by the Generic Modeling Environment (GME) tool suite enables the
	rapid and inexpensive development of DSML-s. However, the specification
	of semantics lor DSML-s is still a hard problem. In order to simplify
	the DSML semantics, this paper discusses semantic anchoring, which
	is based on the transformational specification of semantics. Using
	a mathematical model, Abstract State Machine (ASM), as a common semantic
	framework, we have developed formal operational semantics for a set
	of basic models of computations, called semantic units. Semantic
	anchoring of DSML-s means the specification of model transformations
	between DSML-s (or aspects of complex DSML-s) and selected semantic
	units. The paper describes the semantic anchoring process using the
	meta-programmable MIC tool suite. © Springer-Verlag Berlin Heidelberg
	2005.},
  affiliation = {Institute for Software Integrated Systems, Vanderbilt University,
	P.O. Box 1829 Sta. B, Nashville, TN 37235, United States},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-33646499415&partnerID=40&md5=4101c8107b979711dcec767901015354}
}

@CONFERENCE{Chiao2006,
  author = {Chiao, H.-T.a , Hsu, K.-S.a , Chen, Y.-K.a , Yuan, S.-M.b },
  title = {A template-based MHP authoring tool},
  year = {2006},
  note = {cited By (since 1996) 0},
  abstract = {In this paper, we propose a template-based MHP (Multimedia Home Platform)
	authoring tool. The temporal and spatial behavior of an MHP application
	can be authored and stored in an XML-based instance description file.
	The MHP authoring tool generates the target MHP Java source codes
	by utilizing the "real programs generators" for the modules used
	inside the MHP application being authored. The real program generator
	for a module is generated by a "meta program generator" according
	to the XML template description for the module. The Java source codes
	of an instance of the module are generated by the real program generator
	according to the XML description for the instance. The proposed design
	on code generation can simplify the way to extend the MHP authoring
	tool to support new features, such as DRM or PVR. In addition, the
	MHP applications generated by the authoring tool are also reconfigurable.
	They can adapt to both the MHP set-top box resource change and the
	change on transmission bandwidth of a DVB object carousel. © 2006
	IEEE.},
  affiliation = {Digital Video and Optical Communications Technologies Division, Information
	and Communications Research Laboratories, Industrial Technology Research
	Institute, Chutung, Hsinchu, Taiwan; Dept. of Computer Science, National
	Chiao Tung University, Taiwan},
  art_number = {4019935},
  author_keywords = {Aspectoriented programming; Generative programming; IDTV; Java; XML},
  document_type = {Conference Paper},
  journal = {Proceedings - Sixth IEEE International Conference on Computer and
	Information Technology, CIT 2006},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-34547323618&partnerID=40&md5=ec7c95169ed7388747c571b00e7827ed}
}

@CONFERENCE{Chiba2005355,
  author = {Chiba, S.},
  title = {Generative programming from a post object-oriented programming viewpoint},
  year = {2005},
  volume = {3566},
  pages = {355-366},
  note = {cited By (since 1996) 0},
  abstract = {This paper presents an application of generative programming to reduce
	the complications of the protocol for using an application framework
	written in an object-oriented language. It proposes that a programmable
	program translator could allow framework users to write a simple
	program, which is automatically translated by the translator into
	a program that fits the framework protocol. Then it mentions the
	author's experience with Javassist, which is a translator toolkit
	for Java, and discusses a research issue for applying this idea to
	real-world software development. © Springer-Verlag Berlin Heidelberg
	2005.},
  affiliation = {Dept. of Mathematical and Computing Sciences, Tokyo Institute of Technology},
  document_type = {Conference Paper},
  journal = {Lecture Notes in Computer Science},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-26444484457&partnerID=40&md5=6a7a5585dae24ea937840076fb6304b1}
}

@ARTICLE{Chiba2003364,
  author = {Chiba, S., Nishizawa, M.},
  title = {An easy-to-use toolkit for efficient Java bytecode translators},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2003},
  volume = {2830},
  pages = {364-376},
  note = {cited By (since 1996) 20},
  abstract = {This paper presents our toolkit for developing a Java-byte-code translator.
	Bytecode translation is getting important in various domains such
	as generative programming and aspect-oriented programming. To help
	the users easily develop a translator, the design of our toolkit
	is based on the reflective architecture. However, the previous implementations
	of this architecture involved serious runtime penalties. To address
	this problem, our toolkit uses a custom compiler so that the runtime
	penalties are minimized. Since the previous version of our toolkit
	named Javassist has been presented in another paper, this paper focuses
	on this new compiler support for performance improvement. This feature
	was not included in the previous version. © Springer-Verlag Berlin
	Heidelberg 2003.},
  affiliation = {Dept. of Mathematical and Computing Sciences, Tokyo Institute of Technology},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-35248825966&partnerID=40&md5=4bd35a758c0cdfec30960b9319c97fa6}
}

@ARTICLE{Chiorean2007152,
  author = {Chiorean, D.a , Demuth, B.b , Gogolla, M.c , Warmer, J.d },
  title = {OCL for (meta-)models in multiple application domains},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2007},
  volume = {4364 LNCS},
  pages = {152-158},
  note = {cited By (since 1996) 0},
  abstract = {The workshop OCLApps 2006 was organized as a part of MoDELS/UML Conference
	in Genova, Italy. It continues the series of five OCL (Object Constraint
	Language) workshops held at previous UML/MoDELS conferences between
	2000 - 2005. Similar to its predecessors, the workshop addressed
	both people from academia and industry. The advent of the MDA (Model
	Driven Architecture) vision and the rapid acceptance of MDE (Model
	Driven Engineering) approaches emphasize new application domains
	(like Semantic Web or Domain Specific Languages) and call for new
	OCL functionalities. In this context, the OCLApps 2006 Workshop,
	was conceived as a forum enabling researchers and industry experts
	to present and debate how the OCL could support these new requirements.
	© Springer-Verlag Berlin Heidelberg 2007.},
  affiliation = {Babeş-Bolyai University of Cluj-Napoca, Romania; Technische Universität
	Dresden, Germany; University of Bremen, Germany},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-38149008053&partnerID=40&md5=5ab62ae9741eb62a0145f362d57e6c92}
}

@CONFERENCE{Chiprianov201123,
  author = {Chiprianov, V.a b , Alloush, I.a c , Kermarrec, Y.a b , Rouvrais,
	S.a },
  title = {Telecommunications service creation: Towards extensions for Enterprise
	Architecture modeling languages},
  year = {2011},
  volume = {1},
  pages = {23-28},
  note = {cited By (since 1996) 0},
  abstract = {From the 90's, the telecommunications service creation industry has
	undergone radical change. Services have shifted from being based
	on a switching environment to being mainly based on software. To
	remain competitive in these new dynamic conditions of an open market,
	telecommunications organizations need to produce high quality services
	at low prices within short periods of time. Concerning Service Providers,
	they need an overall representation of service creation taking in
	all business, management, and technical activities. To reduce their
	concept-to-market time for new services, they also need tools specialized
	for their tasks and domain. In this position paper, we argue that
	a telecommunications profile for an Enterprise Architecture modeling
	language answers these needs. We also design a telecommunications
	profile for ArchiMate that offers conformity to standards through
	the reuse of a recognized Enterprise Architecture modeling language.
	Moreover, this profile provides easier adoption by Service Providers
	due to inclusion of domain specific concepts. The profiling mechanism
	we propose may be used for defining language extensions specific
	to other industries as well.},
  affiliation = {Institut Telecom, Telecom Bretagne, Université Européenne de Bretagne
	Technopole Brest Iroise, CS 83818, 29238, Brest Cedex 3, France;
	UMR CNRS 3192, Lab-STICC, Brest, France; Faculty of Information Technology
	Engineering, Damascus University, Damascus, Syrian Arab Republic},
  author_keywords = {Domain specific modeling language; Enterprise Architecture; Model
	driven engineering},
  document_type = {Conference Paper},
  journal = {ICSOFT 2011 - Proceedings of the 6th International Conference on
	Software and Database Technologies},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-80052607691&partnerID=40&md5=42ea5ed686b169cf40163fc7dd470cde}
}

@CONFERENCE{Cho2011211,
  author = {Cho, H.},
  title = {Creating domain-specific modeling languages using a by-demonstration
	technique},
  year = {2011},
  pages = {211-212},
  note = {cited By (since 1996) 0},
  abstract = {Domain-Specific Modeling Languages (DSMLs) have been widely used in
	several domains (e.g., finance, combat simulation, and image manipulation)
	because they aid to improve productivity and quality by reducing
	the gap between domain abstractions and computational expression
	within specific domains. However, DSMLs are developed when they are
	absolutely necessary because DSMLs engineered by iterating complex
	and mundane language creation tasks and DSML development requires
	domain knowledge and language development expertise. To tackle the
	challenges of DSML development, this poster abstract outlines a new
	approach for specifying and generating the abstract and concrete
	syntax of a DSML based on user demonstration. The goal of the proposed
	research is to develop the underlying science and tool support to
	enable end-users to assist in designing a DSML for their domain,
	while minimizing the typical mundane tasks of DSML development involving
	many accidental complexities.},
  affiliation = {Department of Computer Science, University of Alabama, Box 870290,
	Tuscaloosa, AL, United States},
  author_keywords = {By- Demonstration; Domain-Specific Modeling Language; Flexible Modeling
	Tools},
  document_type = {Conference Paper},
  journal = {SPLASH'11 Compilation - Proceedings of OOPSLA'11, Onward! 2011, GPCE'11,
	DLS'11, and SPLASH'11 Companion},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-81355135443&partnerID=40&md5=df634f839cbdb623faa40acb908a85a9}
}

@CONFERENCE{Cho201151,
  author = {Cho, H.},
  title = {A demonstration-based approach for designing domain-specific modeling
	languages},
  year = {2011},
  pages = {51-53},
  note = {cited By (since 1996) 0},
  abstract = {Domain-Specific Modeling Languages (DSMLs) have been recognized as
	a viable solution for reducing the gap between domain abstractions
	and computational expression within specific domains. In several
	domains and contexts, DSMLs have been applied successfully to various
	areas (e.g., finance, combat simulation, and image manipulation)
	and have shown improvements to productivity and quality. However,
	development of a new DSML is not an easy task for either computer
	scientists or end-users because designing and implementing a DSML
	requires profound knowledge of the domain and deep experience in
	modeling language development. To address the challenges of DSML
	development, this doctoral symposium abstract outlines a new approach
	for building DSMLs that represents a demonstration-based technique
	for specifying the details of a new modeling language. The approach
	provides an environment for describing and generating the abstract
	and concrete syntax of a DSML. Initial work on describing the semantics
	of a new DSML is also a focus of the work. The research represents
	an investigation into a technique that allows end-users to sketch
	(or demonstrate) a domain model with free-form shapes. The goal of
	the proposed research is to develop the underlying science and tool
	support to enable end-users to assist in designing a DSML for their
	domain, while minimizing the typical mundane tasks of DSML development
	involving many accidental complexities.},
  affiliation = {Department of Computer Science, University of Alabama, Box 870290,
	Tuscaloosa, AL, United States},
  author_keywords = {By- demonstration; Domain-specific modeling language; Flexible modeling
	tools},
  document_type = {Conference Paper},
  journal = {SPLASH'11 Compilation - Proceedings of OOPSLA'11, Onward! 2011, GPCE'11,
	DLS'11, and SPLASH'11 Companion},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-81355123391&partnerID=40&md5=ca2670dfadc94301b6c963a915ea1476}
}

@CONFERENCE{Cho2010,
  author = {Cho, H.a , Gray, J.b },
  title = {A domain-specific modeling language for scientific data composition
	and interoperability},
  year = {2010},
  note = {cited By (since 1996) 0},
  abstract = {Domain-Specific Modeling Languages (DSMLs) can offer assistance to
	domain experts, who may not be computer scientists, by providing
	notations and semantic constructs that align with abstractions from
	a particular domain. In this paper, we describe our design and application
	of a DSML in the area of data composition and interoperability. In
	particular, we introduce our recent effort to design a DSML to assist
	with interoperability issues across scientific software applications
	(e.g., composing scientific data in different file structures and
	integrating scientific data with data gathering devices). Currently,
	several different scientific data file specifications have been proposed
	(e.g., CID, netCDF, and HDF). Each file specification is optimized
	to manage a specific data type efficiently. Thus, each file specification
	has evolved with slightly different notions and implementation technologies.
	These differences led to the need for an environment that provides
	interoperability among the different specification formats. In this
	paper, we introduce our framework, supported by a DSML, that provides
	functionality to visually model the data composition and integration
	concepts independent from a particular data file specification. Copyright
	© 2010 ACM.},
  affiliation = {University of Alabama at Birmingham, Department of Computer and Information
	Science, Birmingham, AL 35294, United States; University of Alabama,
	Department of Computer Science, Tuscaloosa, AL 35487, United States},
  art_number = {107},
  author_keywords = {Data composition; Data integration; Domain-Specific modeling language
	(DSML); File format; Metamodeling; Verification},
  document_type = {Conference Paper},
  journal = {Proceedings of the Annual Southeast Conference},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-79951831800&partnerID=40&md5=9665744cef1bed3f9ac204dc1217568c}
}

@ARTICLE{Cicchetti2008311,
  author = {Cicchetti, A., Di Ruscio, D., Pierantonio, A.},
  title = {Managing model conflicts in distributed development},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2008},
  volume = {5301 LNCS},
  pages = {311-325},
  note = {cited By (since 1996) 10},
  abstract = {The growing complexity of current software systems naturally conveyed
	their development toward incremental and distributed approaches to
	speed up the process. Several developers update the same artefact
	operating concurrent manipulations which need to be coherently combined.
	The interaction among those changes inevitably involves conflicts
	which must be detected and reconciled. This paper proposes a domain
	specific language able to define and manage conflicts caused by cooperative
	updates over the same model elements. The approach relies on a model-based
	representation of model differences and enables the specification
	and the detection of both syntactical and semantic conflicts. © 2008
	Springer-Verlag Berlin Heidelberg.},
  affiliation = {Dipartimento di Informatica, Università degli Studi dell'Aquila, via
	Vetoio, Coppito I-67010, L'Aquila, Italy},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-56649103524&partnerID=40&md5=1845d5491e06195f0ddbd6134d6b286f}
}

@ARTICLE{Cirilo20081344,
  author = {Cirilo, E.a , Kulesza, U.b c , De Lucena, C.J.P.a },
  title = {A product derivation tool based on model-driven techniques and annotations},
  journal = {Journal of Universal Computer Science},
  year = {2008},
  volume = {14},
  pages = {1344-1367},
  number = {8},
  note = {cited By (since 1996) 19},
  abstract = {In this paper, we present a model-based tool for product derivation.
	Our tool is centered on the definition of three models (feature,
	architecture and configuration models) which enable the automatic
	instantiation of software product lines (SPLs) or frameworks. The
	Eclipse platform and EMF technology are used as the base for the
	implementation of our tool. A set of specific Java annotations are
	also defined to allow generating automatically many of our models
	based on existing implementations of SPL architectures. We illustrated
	the use and validation of our tool in the preparation of the automatic
	derivation of the JUnit framework and a J2ME games product line.
	© J.UCS.},
  affiliation = {Pontifical Catholic University, Rio de Janeiro, Brazil; CITI/DI/FCT,
	New University of Lisbon, Portugal; Recife Center for Advanced Studies
	and Systems, Brazil},
  author_keywords = {Generative programming; Model-driven development; Product derivation
	tools; Software product lines},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-45949101020&partnerID=40&md5=8a6f9de1d6f6b3d9df3107e2d13ddad4}
}

@CONFERENCE{Clark2008229,
  author = {Clark, T., Sammut, P., Willans, J.},
  title = {Beyond Annotations: A proposal for extensible Java (XJ)},
  year = {2008},
  pages = {229-238},
  note = {cited By (since 1996) 1},
  abstract = {Annotations provide a limited way of extending Java in order to tailor
	the language for specific tasks. This paper describes a proposal
	for a Java extension which generalises Annotations to allow Java
	to be a platform for developing Domain Specific Languages. © 2008
	IEEE.},
  affiliation = {Ceteva Ltd.},
  art_number = {4637555},
  document_type = {Conference Paper},
  journal = {Proceedings - 8th IEEE International Working Conference on Source
	Code Analysis and Manipulation, SCAM 2008},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-56349111405&partnerID=40&md5=31ee7702d66de244a64a9847a8c2f545}
}

@ARTICLE{Clark201075,
  author = {Clark, T.a , Tratt, L.b },
  title = {Formalizing homogeneous language embeddings},
  journal = {Electronic Notes in Theoretical Computer Science},
  year = {2010},
  volume = {253},
  pages = {75-88},
  number = {7},
  note = {cited By (since 1996) 0},
  abstract = {The cost of implementing syntactically distinct Domain Specific Languages
	(DSLs) can be reduced by homogeneously embedding them in a host language
	in cooperation with its compiler. Current homogeneous embedding approaches
	either restrict the embedding of multiple DSLs in order to provide
	safety guarantees, or allow multiple DSLs to be embedded but force
	the user to deal with the interoperability burden. In this paper
	we present the μ-calculus which allows parameterisable language embeddings
	to be specified and analysed. By reducing the problem to its core
	essentials we are able to show how multiple, expressive language
	embeddings can be defined in a homogeneous embedding context. We
	further show how variant calculi with safety guarantees can be defined.
	© 2010 Elsevier B.V. All rights reserved.},
  affiliation = {Thames Valley University, St. Mary's Road, Ealing, London, W5 5RF,
	United Kingdom; Bournemouth University, Poole, Dorset, BH12 5BB,
	United Kingdom},
  author_keywords = {Domain specific languages; formal language specification; language
	embeddings},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-77956417771&partnerID=40&md5=a2f61f68b7ddb1155ee30c6979ac189e}
}

@CONFERENCE{Clark2009949,
  author = {Clark, T.a , Tratt, L.b },
  title = {Language factories},
  year = {2009},
  pages = {949-956},
  note = {cited By (since 1996) 0},
  abstract = {Programming languages are the primary mechanism by which software
	is created, yet most of us have access to only a few, fixed, programming
	languages. Any problem we wish to express must be framed in terms
	of the concepts the programming language provides for us, be they
	suitable for the problem or not. Domain Specific Languages (DSLs)
	suggest an appealing escape route from this fate, but since there
	is no real technology or theory underpinning them, new DSLs are rare.
	In this paper we present the Language Factories vision, which aims
	to bring together the theory and practice necessary to realise DSLs
	in a systematic way. In so doing, we hope to lower the barrier for
	language creation significantly, ultimately allowing software creators
	to use the languages most suited to them and their needs. Copyright
	© 2009 ACM.},
  affiliation = {Thames Valley University, St. Mary's Road, Ealing, London, W5 5RF,
	United Kingdom; Bournemouth University, Poole, Dorset, BH12 5BB,
	United Kingdom},
  author_keywords = {Domain specific languages},
  document_type = {Conference Paper},
  journal = {Proceedings of the Conference on Object-Oriented Programming Systems,
	Languages, and Applications, OOPSLA},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-72249110523&partnerID=40&md5=1be00d5b6ac43bf8648560ef7c05d288}
}

@CONFERENCE{Claypool2009157,
  author = {Claypool, D.J., McNevin, T.J., Liu, W., McNeill, K.M.},
  title = {Automated software defined radio deployment using domain specific
	modeling languages},
  year = {2009},
  pages = {157-162},
  note = {cited By (since 1996) 0},
  abstract = {Model-Integrated Computing (MIC) is a development approach that advocates
	the use of Domain Specific Modeling throughout the system development
	process and lifecycle. In this work we have applied model-driven
	development to an existing software architecture, created an instantiation
	of the models, and observed how such a system can deploy automatically
	generated configurations to hardware. We hypothesize that this method
	of model driven development yields improved workflow with fewer opportunities
	for errors, increased flexibility, and faster deployment times. This
	paper describes and summarizes the process by which we applied these
	tools to an existing development project and describe the generic
	and reusable software tools that support MIC, which can be tailored
	to provide a wide variety of modeling, analysis, and code generation
	needs. © 2009 IEEE.},
  affiliation = {BAE Systems, Reston, VA, United States},
  art_number = {5277862},
  document_type = {Conference Paper},
  journal = {Proceedings - 2009 IEEE Mobile WiMAX Symposium, MWS 2009},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-71249098706&partnerID=40&md5=6bc9f068f8ba0d8d82c18b9adc79bca6}
}

@ARTICLE{Cleenewerck2003245,
  author = {Cleenewerck, T.},
  title = {Component-based DSL development},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2003},
  volume = {2830},
  pages = {245-264},
  note = {cited By (since 1996) 4},
  abstract = {Domain specific languages (DSLs) have proven to be a very adequate
	mechanism to encapsulate and hide the complex implementation details
	of component-based software development. Since evolution lies at
	the heart of any software system the DSLs that were built around
	them must evolve as well. In this paper we identify important issues
	that cause a DSL implementation to be very rigid in which all phases
	are tightly coupled and highly dependent upon one another. To increase
	the poor evolvability of current day DSL development environments
	a new development environment Keyword based programming (KBP) is
	proposed where DSLs are built by using a language specification to
	compose and glue loosely coupled and independent language components
	(called keywords). © Springer-Verlag Berlin Heidelberg 2003.},
  affiliation = {Programming Technology Lab., Vrije Universiteit Brussel, Pleinlaan
	2, 1050 Brussel, Belgium},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-28444455152&partnerID=40&md5=2ce6458b2240737028e1c091ab455779}
}

@CONFERENCE{Cleenewerck2008,
  author = {Cleenewerck, T., D'Hondt, T.},
  title = {Modularizing invasive aspect languages},
  year = {2008},
  note = {cited By (since 1996) 0},
  abstract = {In domain-specific aspect languages we observe that aspects are translated
	to base code and subsequently require a complex integration into
	base code while guaranteeing the correctness of the aspect and the
	base code in the woven code. We call this phenomenon invasively composed
	aspects. Weavers for invasive aspect languages operate on the base
	language level and offer dedicated support for crosscutting code.
	Unfortunately, current implementations poorly modularize the implementation
	of invasive aspect languages. This hampers their (unanticipated)
	evolution and severely reduces the reusability of their constructs.
	We suggest an approach where the specification of the crosscutting
	behavior is expressed on a higher semantic level. To this end, we
	raise the abstraction level of base languages towards the specific
	domain of the aspect languages. As such, we enable a modular, declarative
	approach. We illustrate our approach with KALA, a domain-specific
	aspect language. © 2008 ACM.},
  affiliation = {Vrije Universiteit Brussel},
  art_number = {4},
  author_keywords = {Aspect-oriented programming; Domain-specific languages; Generative
	programming; KALA; Language engineering; Linglets; Modularity},
  document_type = {Conference Paper},
  journal = {DSAL'08: Proceedings of the 2008 AOSD Workshop on Domain-specific
	Aspect Languages},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-65249096033&partnerID=40&md5=87893e4abc4df974fff56b97da0e95e2}
}

@CONFERENCE{Cleenewerck20051398,
  author = {Cleenewerck, T., D'Hondt, T.},
  title = {Disentangling the implementation of local-to-global transformations
	in a rewrite rule transformation system},
  year = {2005},
  volume = {2},
  pages = {1398-1403},
  note = {cited By (since 1996) 3},
  abstract = {Transformation rules are often used to implement compilers for domain-specific
	languages. In an ideal situation, each transformation rule is a modular
	unit transforming one input element of the source program into a
	new element of the output program. However, in practice, transformation
	rules must be written which take one input element and produce several
	new elements belonging to various locations in the output program,
	the so-called local-to-global transformations. The implementation
	of such transformations is very complex and tightly coupled which
	imposes severe constraints on maintenance and evolvability. In this
	paper, we propose a transformation architecture on top of rewrite
	rules to loosen this coupling. The resulting transformation system
	combines the simplicity and modularity properties of rewrite rules
	with a new semi-automatic composition system that enables the implementation
	of local-to-global transformations without hampering maintenance
	and future evolutions. Copyright 2005 ACM.},
  affiliation = {Vrije Universiteit Brussel, Brussel, Belgium},
  author_keywords = {Evolvability; Maintainability; Program Transformations; Rewrite rules},
  document_type = {Conference Paper},
  journal = {Proceedings of the ACM Symposium on Applied Computing},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-33644517520&partnerID=40&md5=7b4cefbfe6e7f6b9de445970a05b15a6}
}

@CONFERENCE{Cleenewerck2007985,
  author = {Cleenewerck, T.a , Kurtev, I.b c },
  title = {Separation of concerns in translational semantics for DSLs in model
	engineering},
  year = {2007},
  pages = {985-992},
  note = {cited By (since 1996) 2},
  abstract = {Development of Domain Specific Languages (DSLs) in the context of
	Model Driven Engineering is gaining more and more popularity. As
	evolution lies in the heart of every software system, the major requirement
	for DSLs is that they should be modular and resilient to changes.
	MDE-based DSL frameworks should enable a modular specification of
	language translational semantics and the composition of the modules
	into languages. Ultimately, the availability of such techniques should
	make the DSL development faster. Separation of concerns is a sound
	software engineering principle used to obtain better modularity,
	reusability, and adaptability of systems. However, this principle
	must be supported by proper tools that allow the separation achieved
	at a conceptual level to be preserved in the language specification.
	In MDE, the mainstream tools for specifying translations are model
	transformation languages. In this paper we evaluate a class of model
	transformation languages regarding their applicability for capturing
	the translational semantics of DSLs in a modular way. We found that
	the concepts in the domain of translational semantics significantly
	mismatch with the language constructs of the transformation language.
	We suggest that this problem may be better approached by a domain-specific
	transformation language. Copyright 2007 ACM.},
  affiliation = {PROG, Vrije Universiteit Brussel, Brussels, Belgium; ATLAS Group,
	INRIA, France; SE Group, University of Twente, Netherlands},
  author_keywords = {Model engineering; Model transformations; Model-based DSLs; Modular
	translational semantics; Separation of concerns},
  document_type = {Article},
  journal = {Proceedings of the ACM Symposium on Applied Computing},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-35248821232&partnerID=40&md5=479f49a103979240e866fad1de698478}
}

@CONFERENCE{Clemente200913,
  author = {Clemente, P.J.a , Conejero, J.M.b , Hernández, J.a , Sánchez, L.c
	},
  title = {HAAIS-DSL: DSL to develop home Automation and Ambient Intelligence
	systems},
  year = {2009},
  pages = {13-18},
  note = {cited By (since 1996) 1},
  abstract = {Domain Specific Language (DSL) is an emergent software engineering
	discipline that allows software architects to model systems based
	on the elements of a specific domain. Home Automation (HA) and Ambient
	Intelligence (AmI) are examples of specific domains and they are
	considered the key elements in the future of home development. However,
	software for these domains is usually hand coded based on embedded
	devices and specific implementation technologies and frameworks.
	In this paper we present a Model Driven Development (MDD) approach
	to develop software systems for HA and AmI. A Domain Specific Language
	has been designed to model the architecture of these kinds of systems.
	Then, taking as input the architecture models, a set of model transformations
	allows code and configuration generation for a specific device platform
	like KNX/EIB (European Installation Bus). Copyright 2009 ACM.},
  affiliation = {University of Extremadura, QuercusSE Group; University of Extremadura;
	University of Extremadura, Av. Universidad s/n, Cáceres, Spain},
  author_keywords = {Ambient Intelligence; Code generation; Dsl; Embedded devices; Home
	Automation; Model Driven Development},
  document_type = {Conference Paper},
  journal = {Proceedings of the 2nd Workshop on Isolation and Integration in Embedded
	Systems, IIES'09},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-70349087615&partnerID=40&md5=be04d0fa5fca2bfbaeff443be468d2b9}
}

@ARTICLE{Coden2005422,
  author = {Coden, A.R.a , Pakhomov, S.V.b , Ando, R.K.a , Duffy, P.H.b , Chute,
	C.G.b },
  title = {Domain-specific language models and lexicons for tagging},
  journal = {Journal of Biomedical Informatics},
  year = {2005},
  volume = {38},
  pages = {422-430},
  number = {6},
  note = {cited By (since 1996) 9},
  abstract = {Accurate and reliable part-of-speech tagging is useful for many Natural
	Language Processing (NLP) tasks that form the foundation of NLP-based
	approaches to information retrieval and data mining. In general,
	large annotated corpora are necessary to achieve desired part-of-speech
	tagger accuracy. We show that a large annotated general-English corpus
	is not sufficient for building a part-of-speech tagger model adequate
	for tagging documents from the medical domain. However, adding a
	quite small domain-specific corpus to a large general-English one
	boosts performance to over 92% accuracy from 87% in our studies.
	We also suggest a number of characteristics to quantify the similarities
	between a training corpus and the test data. These results give guidance
	for creating an appropriate corpus for building a part-of-speech
	tagger model that gives satisfactory accuracy results on a new domain
	at a relatively small cost. © 2005 Elsevier Inc. All rights reserved.},
  affiliation = {IBM, T.J. Watson Research Center, 19 Skyline Drive, Hawthorne, NY
	10532, United States; Division of Medical Informatics Research, Department
	of Health Sciences Research, Mayo Clinic, Rochester, MN 55905, United
	States},
  author_keywords = {Biomedical domain; Clinical information systems; Clinical report analysis;
	Corpus linguistics; Domain adaptation; Hidden Markov Model; Part-of-speech
	tagging accuracy; Statistical part-of-speech tagging},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-28744437703&partnerID=40&md5=37ba1663e8bdd8f4528a1832bc33bf3a}
}

@ARTICLE{Cohen200625,
  author = {Cohen, A.a , Donadio, S.b , Garzaran, M.-J.c , Herrmann, C.d , Kiselyov,
	O.e , Padua, D.c },
  title = {In search of a program generator to implement generic transformations
	for high-performance computing},
  journal = {Science of Computer Programming},
  year = {2006},
  volume = {62},
  pages = {25-46},
  number = {1},
  note = {cited By (since 1996) 7},
  abstract = {The quality of compiler-optimized code for high-performance applications
	is far behind what optimization and domain experts can achieve by
	hand. Although it may seem surprising at first glance, the performance
	gap has been widening over time, due to the tremendous complexity
	increase in microprocessor and memory architectures, and to the rising
	level of abstraction of popular programming languages and styles.
	This paper explores in-between solutions, neither fully automatic
	nor fully manual ways to adapt a computationally intensive application
	to the target architecture. By mimicking complex sequences of transformations
	useful to optimize real codes, we show that generative programming
	is a practical means to implement architecture-aware optimizations
	for high-performance applications. This work explores the promises
	of generative programming languages and techniques for the high-performance
	computing expert. We show that complex, architecture-specific optimizations
	can be implemented in a type-safe, purely generative framework. Peak
	performance is achievable through the careful combination of a high-level,
	multi-stage evaluation language-MetaOCaml-with low-level code generation
	techniques. Nevertheless, our results also show that generative approaches
	for high-performance computing do not come without technical caveats
	and implementation barriers concerning productivity and reuse. We
	describe these difficulties and identify ways to hide or overcome
	them, from abstract syntaxes to heterogeneous generators of code
	generators, combining high-level and type-safe multi-stage programming
	with a back-end generator of imperative code. © 2006 Elsevier B.V.
	All rights reserved.},
  affiliation = {ALCHEMY group, INRIA Futurs, Orsay, France; PRiSM, University of Versailles,
	France; DCS, University of Illinois at Urbana, Champaign, IL, United
	States; FMI, University of Passau, Germany; FNMOC, Monterey, CA,
	United States},
  author_keywords = {Adaptive libraries; Application-specific program generators; Loop
	transformations; Multi-stage programming},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-33745665061&partnerID=40&md5=6091149108e8b627e112d9f82f0e36d3}
}

@CONFERENCE{Cointe2005315,
  author = {Cointe, P.},
  title = {Towards generative programming},
  year = {2005},
  volume = {3566},
  pages = {315-325},
  note = {cited By (since 1996) 1},
  abstract = {Generative Programming (GP) is an attempt to manufacture software
	components in an automated way by developing programs that synthesize
	other programs. Our purpose is to introduce the what and the how
	of the GP approach from a programming language point of view. For
	the what we discuss the lessons learned from object-oriented languages
	seen as general purpose languages to develop software factories.
	For the how we compare a variety of approaches and techniques based
	on program transformation and generation. On the one hand, we present
	the evolution of open-ended languages from metalevel programming
	to aspect-oriented programming. On the other hand, we introduce domain-specific
	languages as a way to bridge the gap between conceptual models and
	programming languages. © Springer-Verlag Berlin Heidelberg 2005.},
  affiliation = {OBASCO Group, EMN-INRIA, École des Mines de Nantes, 4 rue Alfred Kastler,
	La Chantrerie, 44307 Nantes Cedex 3, France},
  document_type = {Conference Paper},
  journal = {Lecture Notes in Computer Science},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-26444552363&partnerID=40&md5=e13a77cd746edd6087eb44bb51873b34}
}

@CONFERENCE{Collet20061798,
  author = {Collet, P.a , Ozanne, A.b , Rivierre, N.b },
  title = {On contracting different behavioral properties in component-based
	systems},
  year = {2006},
  volume = {2},
  pages = {1798-1799},
  note = {cited By (since 1996) 0},
  abstract = {Using different specification formalisms together is necessary to
	leverage better reliability on component-based systems. The ConFract
	system provides a contracting system for hierarchical software components,
	but currently, only executable assertions are supported. In this
	paper, we describe how to integrate other kinds of formalism in ConFract.
	We propose a domain specific language and integration tools that
	enable designers to describe the observations needed to appropriately
	verify their specifications. Copyright 2006 ACM.},
  affiliation = {University of Nice, 13S Laboratory, Sophia Antipolis, France; France
	Telecom R and D Division, MAPS/AMS Laboratory, Issy les Moulineaux,
	France},
  author_keywords = {Assertion; Component; Contract; TLA; Verification},
  document_type = {Conference Paper},
  journal = {Proceedings of the ACM Symposium on Applied Computing},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-33751030047&partnerID=40&md5=a4b7dd82ad1cbf7b7a55a3c3afbd3f4e}
}

@ARTICLE{Collet200650,
  author = {Collet, P.a , Ozanne, A.b , Rivierre, N.b },
  title = {Enforcing different contracts in hierarchical component-based systems},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2006},
  volume = {4089 LNCS},
  pages = {50-65},
  note = {cited By (since 1996) 2},
  abstract = {Using different specification formalisms together is necessary to
	leverage better reliability on component-based systems. The ConFract
	system provides a contracting system for hierarchical software components,
	but currently, only executable assertions are supported. In this
	paper, we describe how TLA, taken as an instance of behavioral sequence-based
	formalism, was integrated in ConFract. A domain specific language
	is proposed in order to enable designers to describe the observations
	needed to appropriately verify their specifications. These observations
	are automatically generated for assertions and in the case of TLA,
	we show what kind of observations must be provided to link the specifications
	to the concrete application. © Springer-Verlag Berlin Heidelberg
	2006.},
  affiliation = {University of Nice, I3S Laboratory, Sophia Antipolis, France; France
	Telecom R and D, MAPS/AMS Laboratory, Issy les Moulineaux, France},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-33749378977&partnerID=40&md5=e207e1e0f0900de1ef98832b24b8bc1d}
}

@ARTICLE{Combemale2009943,
  author = {Combemale, B.a , Crégut, X.b , Garoche, P.c , Thirioux, X.b },
  title = {Essay on semantics definition in MDE: An instrumented approach for
	model verification},
  journal = {Journal of Software},
  year = {2009},
  volume = {4},
  pages = {943-958},
  number = {9},
  note = {cited By (since 1996) 2},
  abstract = {In the context of MDE (Model-Driven Engineering), our objective is
	to define the semantics for a given DSL (Domain Specific Language)
	either to simulate its models or to check properties on them using
	model-checking techniques. In both cases, the purpose is to formalize
	the DSL semantics as it is known by the DSL designer but often in
	an informal way. After several experiments to define operational
	semantics on the one hand, and translational semantics on the other
	hand, we discuss both approaches and we specify in which cases these
	semantics seem to be judicious. As a second step, we introduce a
	pragmatic and instrumented approach to define a translational semantics
	and to validate it against a reference operational semantics expressed
	by the DSL designer. We apply this approach to the XSPEM process
	description language in order to verify process models. © 2009 Academy
	Publisher.},
  affiliation = {Institut National de Recherche en Informatique et en Automatique (INRIA),
	France; Institut de Recherche en Informatique de Toulouse (IRIT),
	France; Office National d' Étude et de Recherche en Aérospatiale
	(ONERA), France},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-78651569557&partnerID=40&md5=689375ec2e3b13fa86da3682fd1ff8a5}
}

@ARTICLE{Combemale201135,
  author = {Combemale, B.a , Gonnord, L.b , Rusu, V.b },
  title = {A generic tool for tracing executions back to a DSML's operational
	semantics},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2011},
  volume = {6698 LNCS},
  pages = {35-51},
  note = {cited By (since 1996) 0},
  abstract = {The increasing complexity of software development requires rigorously
	defined domain specific modeling languages (dsml). Model-driven engineering
	(mde) allows users to define a dsml's syntax in terms of metamodels.
	The behaviour of a language can also be described, either operationally,
	or via transformations to other languages (e.g., by code generation).
	If the first approach requires to redefine analysis tools for each
	dsml (simulator, model-checker...), the second approach allows to
	reuse existing tools in the targeted language. However, the second
	approach (also called translational semantics) imply that the results
	(e.g., a program crash log, or a counterexample returned by a model
	checker) may not be straightforward to interpret by the users of
	a dsml. We propose in this paper a generic tool for formally tracing
	such analysis/execution results back to the original dsml's syntax
	and operational semantics, and we illustrate it on xSPEM, a timed
	process modeling language. © 2011 Springer-Verlag.},
  affiliation = {University of Rennes 1, Campus de Beaulieu, INRIA Rennes - Bretagne
	Atlantique (Triskell Project), Rennes, France; LIFL, UMR CNRS/USTL
	8022, INRIA Lille - Nord Europe (DaRT Project), 40 avenue Halley,
	59650 Villeneuve d'Ascq, France},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-79959205413&partnerID=40&md5=692cb2ff4ffaf622c54f6dbac1981a9c}
}

@CONFERENCE{Combemale200780,
  author = {Combemale, B.a , Garoche, P.-L.a , Crégut, X.a , Thirioux, X.a ,
	Vernadat, F.b },
  title = {Towards a formal verification of process model's properties : Simple
	PDL and TOCL case study},
  year = {2007},
  volume = {ISAS},
  pages = {80-89},
  note = {cited By (since 1996) 1},
  abstract = {More and more, models, through Domain Specific Languages (DSL), tend
	to be the solution to define complex systems. Expressing properties
	specific to these metamodels and checking them appear as an urgent
	need. Until now, the only complete industrial solutions that are
	available consider structural properties such as the ones that could
	be expressed in OCL. There are although some attempts on behavioural
	properties for DSL. This paper addresses a method to specify and
	then check temporal properties over models. The case study is SIMPLEPDL,
	a process metamodel. We propose a way to use a temporal extension
	of OCL, TOCL, to express properties. We specify a models transformation
	to Petri Nets and LTL formulae for both the process model and its
	associated temporal properties. We check these properties using a
	model checker and enrich the model with the analysis results. This
	work is a first step towards a generic framework to specify and effectively
	check temporal properties over arbitrary models.},
  affiliation = {Institut de Recherche en Informatique de Toulouse (CNRS UMR 5505),
	Toulouse, France; Laboratoire d'Analyse et d'Architecture des Systemes
	(CNRS), Toulouse, France},
  author_keywords = {LTL; Metamodelling; Model transformation; Models semantics; Petri
	nets; Process model; Properties validation; Temporal OCL; Verification},
  document_type = {Conference Paper},
  journal = {ICEIS 2007 - 9th International Conference on Enterprise Information
	Systems, Proceedings},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-64849115023&partnerID=40&md5=1cfa50cd774f0b4bd50164ec520d8749}
}

@CONFERENCE{Comitz2007,
  author = {Comitz, P.H.},
  title = {A software factory for air traffic data},
  year = {2007},
  note = {cited By (since 1996) 0},
  abstract = {Modern information systems require a flexible, scalable, and upgradeable
	infrastructure that allows communication, and subsequently collaboration,
	between heterogeneous information processing and computing environments.
	Heterogeneous systems often use different data representations for
	the same data items, limiting collaboration and increasing the cost
	and complexity of system integration. Although this problem is conceptually
	straightforward, the process of data conversion is error prone, often
	dramatically underestimated, and surprisingly complex. The complexity
	is often the result of the non-standard data representations that
	are used by computing systems in the aviation domain. This paper
	describes work that is being done to address this challenge. A prototype
	software factory for air traffic data is being built and evaluated.
	The software factory provides the capability to create data and interface
	models for use in the air traffic domain. The model will allow the
	user to specify entities such as data items, scaling, units, headers
	and footers, representation, and coding. The factory automatically
	creates a machine usable data representation. A prototype for a Domain
	Specific Language to assist in this task is being developed. This
	paper describes the scope of the work and the overall approach. ©
	2007 IEEE.},
  affiliation = {Boeing Company, Herndon, VA},
  art_number = {4272181},
  document_type = {Conference Paper},
  journal = {Proceedings of the 2007 Integrated Communications, Navigation and
	Surveillance Conference, 7th ICNS Conference 2007},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-35348877297&partnerID=40&md5=132ca57c2fc5b56907f744a103aee486}
}

@ARTICLE{Consel20023,
  author = {Consel, C.},
  title = {Domain-specific languages: What, why, how},
  journal = {Electronic Notes in Theoretical Computer Science},
  year = {2002},
  volume = {65},
  pages = {3},
  number = {3},
  note = {cited By (since 1996) 0},
  abstract = {Domain-specific languages (DSLs) are being increasingly used as a
	realistic approach to address a program family. That is, a set of
	programs that shares enough commonalities to be considered as a whole.
	These programs may already exist or be expected to be developed.
	In this situation, in principle, software development can benefit
	from introducing a DSL in that (1) it offers concise and specific
	notations to express a member of the program family, and (2) it enables
	the development of safe code thanks to its restricted semantics and/or
	requirements for additional information. The Compose group has developed
	DSLs for various domains such as device drivers, active networking,
	and process scheduling, and built some experience in designing and
	implementing DSLs. In this talk we will report on the outcomes of
	this line of work. In particular, we will attempt to provide a practical
	definition of a DSL, and give the conditions to make this approach
	successful. We will discuss actual benefits of the DSL approach.
	Finally, we will outline a methodology to design and implement a
	DSL.},
  affiliation = {INRIA/LaBRI, Ecole Nationale Supérieure d'Electronique, Informatique
	et Radiocommunications de Bordeaux, Domaine Universitaire, 1, ave.
	du docteur Albert Schweitzer, F-33402 Talence Cedex, France},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-18944367352&partnerID=40&md5=4cf5790040adfe954f8e7e16f0c4a0a8}
}

@ARTICLE{Consel20031,
  author = {Consel, C.a , Hamdi, H.a , Réveillère, L.a , Singaravelu, L.b , Yu,
	H.a c , Pu, C.b },
  title = {Spidle: A DSL approach to specifying streaming applications},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2003},
  volume = {2830},
  pages = {1-17},
  note = {cited By (since 1996) 0},
  abstract = {Multimedia stream processing is a rapidly evolving domain which requires
	much software development and expects high performance. Developing
	a streaming application often involves low-level programming, critical
	memory management, and finely tuned scheduling of processing steps.
	To address these problems, we present a domain-specific language
	(DSL) named Spidle, for specifying streaming applications. Spidle
	offers high-level and declarative constructs; compared to general-purpose
	languages (GPL), it improves robustness by enabling a variety of
	verifications to be performed. To assess the expressiveness of Spidle
	in practice, we have used it to specify a number of standardized
	and special-purpose streaming applications. These specifications
	are up to 2 times smaller than equivalent programs written in a GPL
	such as C. We have implemented a compiler for Spidle. Preliminary
	results show that compiled Spidle programs are roughly as efficient
	as the compiled, equivalent C programs. © Springer-Verlag Berlin
	Heidelberg 2003.},
  affiliation = {INRIA/LaBRI, ENSEIRB, 1, ave. doct. A. Schw. Domaine univ., F-33402
	Talence Cedex, France; College of Computing, Georgia Institute of
	Technology, 801 Atlantic Drive, NW, Atlanta, GA 30332-0280, United
	States; Institute of Computing Technology, Chinese Academy of Sciences,
	P.O.Box 2704, 100080, Beijing, China},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-35248866946&partnerID=40&md5=ad8e39ac3ce72dc304ff37975bd23a5f}
}

@ARTICLE{Consel200529,
  author = {Consel, C.a , Latry, F.a , Réveillère, L.a , Cointe, P.b },
  title = {A generative programming approach to developing DSL compilers},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2005},
  volume = {3676 LNCS},
  pages = {29-46},
  note = {cited By (since 1996) 1},
  abstract = {Domain-Specific Languages (DSLs) represent a proven approach to raising
	the abstraction level of programming. They offer high-level constructs
	and notations dedicated to a domain, structuring program design,
	easing program writing, masking the intricacies of underlying software
	layers, and guaranteeing critical properties. On the one hand, DSLs
	facilitate a straightforward mapping between a conceptual model and
	a solution expressed in a specific programming language. On the other
	hand, DSLs complicate the compilation process because of the gap
	in the abstraction level between the source and target language.
	The nature of DSLs make their compilation very different from the
	compilation of common General-Purpose Languages (GPLs). In fact,
	a DSL compiler generally produces code written in a GPL; low-level
	compilation is left to the compiler of the target GPL. In essence,
	a DSL compiler defines some mapping of the high-level information
	and features of a DSL into the target GPL and underlying layers (e.g.,
	middleware, protocols, objects, ... ). This paper presents a methodology
	to develop DSL compilers, centered around the use of generative programming
	tools. Our approach enables the development of a DSL compiler to
	be structured on facets that represent dimensions of compilation.
	Each facet can then be implemented in a modular way, using aspects,
	annotations and specialization. Because these tools are high level,
	they match the needs of a DSL, facilitating the development of the
	DSL compiler, and making it modular and re-targetable. We illustrate
	our approach with a DSL for telephony services. The structure of
	the DSL compiler is presented, as well as practical uses of generative
	tools for some compilation facets. © Springer-Verlag Berlin Heidelberg
	2005.},
  affiliation = {INRIA/LaBRI, F-33402 Talence, France; École des Mines de Nantes, F-44070
	Nantes, France},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-33646162428&partnerID=40&md5=f1dff7d69e540aa43b181e81ed5125f5}
}

@CONFERENCE{Conway2004,
  author = {Conway, C.L., Edwards, S.A.},
  title = {NDL: A domain-specific language for device drivers},
  year = {2004},
  pages = {30-36},
  note = {cited By (since 1996) 2},
  abstract = {Device drivers are difficult to write and error-prone. They are usually
	written in C, a fairly low-level language with minimal type safety
	and little support for device semantics. As a result, they have become
	a major source of instability in operating system code. This paper
	presents NDL, a language for device drivers. NDL provides high-level
	abstractions of device resources and constructs tailored to describing
	common device driver operations. We show that NDL allows for the
	coding of a semantically correct driver with a code size reduction
	of more than 50% and a minimal impact on performance.},
  affiliation = {Department of Computer Science, Columbia University, 1214 Amsterdam
	Ave., New York, NY 10027},
  author_keywords = {Device drivers; Domain-specific languages; Systems programming},
  document_type = {Conference Paper},
  journal = {Proceedings of the ACM SIGPLAN Conference on Languages, Compilers,
	and Tools for Embedded Systems (LCTES)},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-4544376710&partnerID=40&md5=ae876e5fce65eb5963ac575aea1680be}
}

@ARTICLE{Conway200430,
  author = {Conway, C.L., Edwards, S.A.},
  title = {NDL: A domain-specific language for device drivers},
  journal = {ACM SIGPLAN Notices},
  year = {2004},
  volume = {39},
  pages = {30-36},
  number = {7},
  note = {cited By (since 1996) 5},
  abstract = {Device drivers are difficult to write and error-prone. They are usually
	written in C, a fairly low-level language with minimal type safety
	and little support for device semantics. As a result, they have become
	a major source of instability in operating system code. This paper
	presents NDL, a language for device drivers. NDL provides high-level
	abstractions of device resources and constructs tailored to describing
	common device driver operations. We show that NDL allows for the
	coding of a semantically correct driver with a code size reduction
	of more than 50% and a minimal impact on performance.},
  affiliation = {Department of Computer Science, Columbia University, 1214 Amsterdam
	Ave., New York, NY 10027},
  author_keywords = {Device drivers; Domain-specific languages; Systems programming},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-4544270317&partnerID=40&md5=1c19e551362e73f3e3f63b54a9afc656}
}

@ARTICLE{Cook20061,
  author = {Cook, S.},
  title = {Separating concerns with domain specific languages},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2006},
  volume = {4228 LNCS},
  pages = {1-3},
  note = {cited By (since 1996) 0},
  abstract = {I'll talk about the separation of concerns in the development of large
	distributed enterprise systems, how to manage it using domain specific
	languages, and how to build these languages. This brief note outlines
	some of the topics I'll cover. © Springer-Verlag Berlin Heidelberg
	2006.},
  affiliation = {Microsoft UK Ltd., Cambridge},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-33750739295&partnerID=40&md5=0bc2763c63dd4f408f3dbfd5fda32cf3}
}

@ARTICLE{Cooper2007,
  author = {Cooper, J., McKeever, S.},
  title = {Experience report: A Haskell interpreter for CellML},
  journal = {ACM SIGPLAN Notices},
  year = {2007},
  volume = {42},
  pages = {247-250},
  number = {9},
  note = {cited By (since 1996) 0},
  abstract = {In this paper we present our use of functional programming (FP), specifically
	Haskell, to provide an operational semantics for a domain-specific
	language, CellML, that describes mathematical models of biological
	processes. We analyse the benefits and shortcomings of this approach,
	in comparison with other semantic definitions for CellML. It is our
	claim that using FP for our semantics results in a more concise and
	useful artifact for describing what such a model means. The use of
	lazy evaluation removes the need to explicitly determine an evaluation
	order for the model, resulting in a more elegant interpreter. Crucially,
	using FP enablesustoprovethecorrectnessof optimisation techniques
	for such models. This gives us more confidence in scientific deductions
	from simulation results. We compare the Python implementation of
	these optimisation techniques with our use of Haskell in proving
	their correctness. © 2007 ACM.},
  affiliation = {Computing Laboratory, University of Oxford},
  author_keywords = {CellML; Haskell},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-67650022072&partnerID=40&md5=be6693bbd524e5aad99f547eeb0317e1}
}

@CONFERENCE{Cooper2007247,
  author = {Cooper, J., McKeever, S.},
  title = {Experience report: A Haskell interpreter for cellML},
  year = {2007},
  pages = {247-250},
  note = {cited By (since 1996) 2},
  abstract = {In this paper we present our use of functional programming (FP), specifically
	Haskell, to provide an operational semantics for a domain-specific
	language, CellML, that describes mathematical models of biological
	processes. We analyse the benefits and shortcomings of this approach,
	in comparison with other semantic definitions for CellML. It is our
	claim that using FP for our semantics results in a more concise and
	useful artifact for describing what such a model means. The use of
	lazy evaluation removes the need to explicitly determine an evaluation
	order for the model, resulting in a more elegant interpreter. Crucially,
	using FP enables us to prove the correctness of optimisation techniques
	for such models. This gives us more confidence in scientific deductions
	from simulation results. We compare the Python implementation of
	these optimisation techniques with our use of Haskell in proving
	their correctness. Copyright © 2007 ACM.},
  affiliation = {Computing Laboratory, University of Oxford},
  author_keywords = {CellML; Haskell},
  document_type = {Conference Paper},
  journal = {Proceedings of the ACM SIGPLAN International Conference on Functional
	Programming, ICFP},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-38849150946&partnerID=40&md5=8d7ae5b03d9492c114c8335a8d0b1378}
}

@ARTICLE{Correia201085,
  author = {Correia, A.a b , Brito E Abreu, F.a },
  title = {Model-driven service level management},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2010},
  volume = {6155 LNCS},
  pages = {85-88},
  note = {cited By (since 1996) 0},
  abstract = {Service-level agreements (SLA) definition and monitoring are open
	issues within the IT Service Management (ITSM) domain. Our main goals
	are to propose a model-based approach to IT services SLA specification
	and compliance verification. The specification will be accomplished
	by proposing a SLA language-a domain specific language for defining
	quality attributes as non functional requirements (NFRs) in the context
	of ITSM. This will allow that SLA monitoring and compliance validation
	at a level of abstraction that is understood by the stakeholders
	involved in the service specification. © 2010 Springer-Verlag Berlin
	Heidelberg.},
  affiliation = {QUASAR/CITI, Faculdade de Ciências e Tecnologia, Universidade Nova
	Lisboa, Caparica, Portugal; Escola Superior de Tecnologia, Instituto
	Politécnico de Setúbal, Setúbal, Portugal},
  author_keywords = {BPMN; DSL; IT Service Management; ITIL; MDA; NFR; SLA},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-77954875330&partnerID=40&md5=64fe770cf88eca31e182134260126c09}
}

@CONFERENCE{Correia2010165,
  author = {Correia, A.a b , E Abreu, F.B.a },
  title = {Defining and observing the compliance of service level agreements:
	A model driven approach},
  year = {2010},
  pages = {165-170},
  note = {cited By (since 1996) 1},
  abstract = {IT Service Management (ITSM) is the set of processes that allow planning,
	organizing, directing and controlling the provisioning of IT services.
	Among the concerns of ITSM, namely within the service level management
	process, are the requirements for services availability, performance,
	accuracy, capacity and security, which are specified in terms of
	service-level agreements (SLA). SLA definition and monitoring are
	open issues within the ITSM domain. This paper overviews an ongoing
	research initiative concerned with three specific problems in this
	context: (1) SLAs in the context of ITSM are informally specified
	in natural language; (2) SLAs specifications are not grounded on
	models of ITSM processes; (3) SLAs compliance verification in IT
	services is not performed at the same level of abstraction as service
	design. To mitigate those problems, we propose a model-based approach
	to IT services SLA specification and compliance verification. The
	specification part will be based on a SLA language - a domain specific
	language (DSL) for defining quality attributes as non functional
	requirements (NFRs) in the context of ITSM. Its metamodel will be
	an extension of the metamodel of the adopted process modeling language.
	As such, it will be possible to ground SLA definition on the corresponding
	IT service model constructs. SLA monitoring and compliance validation
	will occur at the same abstraction level as service specification,
	therefore being understood by all stakeholders. © 2010 IEEE.},
  affiliation = {QUASAR, CITI, Universidade Nova de Lisboa, Caparica, Portugal; EST,
	IPS, Setúbal, Portugal},
  art_number = {5655259},
  author_keywords = {BPMN; Domain specific language; IT service management; ITIL; MDA;
	Metamodels; Process model; Service level agreements; Service level
	management},
  document_type = {Conference Paper},
  journal = {Proceedings - 7th International Conference on the Quality of Information
	and Communications Technology, QUATIC 2010},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-78751475851&partnerID=40&md5=95d2703b81820048e4532e05a66ac607}
}

@ARTICLE{Cortes2004301,
  author = {Cortes, C.a b , Fisher, K.a , Pregibon, D.a b , Rogers, A.a c , Smith,
	F.a d },
  title = {Hancock: A language for analyzing transactional data streams},
  journal = {ACM Transactions on Programming Languages and Systems},
  year = {2004},
  volume = {26},
  pages = {301-338},
  number = {2},
  note = {cited By (since 1996) 10},
  abstract = {Massive transaction streams present a number of opportunities for
	data mining techniques. The transactions in such streams might represent
	calls on a telephone network, commercial credit card purchases, stock
	market trades, or HTTP requests to a web server. While historically
	such data have been collected for billing or security purposes, they
	are now being used to discover how the transactors, for example,
	credit-card number or IP addresses, uses the associated services.
	Over the past 5 years, we have computed evolving profiles (called
	signatures) of transactors in several very large data streams. The
	signature for each transactor captures the salient features of his
	or her behavior through time. Programs for processing signatures
	must be highly optimized because of the size of the data stream (several
	gigabytes per day) and the number of signatures to maintain (hundreds
	of millions). Originally, we wrote such programs directly in C, but
	because these programs often sacrificed readability for performance,
	they were difficult to verify and maintain. Hancock is a domain-specific
	language we created to express computationally efficient signature
	programs cleanly. In this paper, we describe the obstacles to computing
	signatures from massive streams and explain how Hancock addresses
	these problems. For expository purpose, we present Hancock using
	a running example from the telecommunications industry; however,
	the language itself is general and applies equally well to other
	data sources.},
  affiliation = {AT and T Labs, Shannon Laboratory, 180 Park Avenue, Florham Park,
	NJ 07932, United States; Google Labs, 1440 Broadway, New York, NY
	10018, United States; University of Chicago, 1100 E. 58 St., Chicago,
	IL 606637, United States; The Mathworks, 3 Apple Hill Drive, Natick,
	MA 01760, United States},
  author_keywords = {Data mining; Domain-specific languages; Statistical models},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-1842735907&partnerID=40&md5=c66a3a10604ea6ff68279d3ae90b4bba}
}

@CONFERENCE{Costache2011464,
  author = {Costache, D., Kalus, G., Kuhrmann, M.},
  title = {Design and validation of feature-based process model tailoring -
	A sample implementation of PDE},
  year = {2011},
  pages = {464-467},
  note = {cited By (since 1996) 0},
  abstract = {A comprehensive software development process needs some adjustment
	before it can be used: It needs to be tailored to the particular
	organization's and project's setting. The definition of an appropriate
	tailoring model is a critical task. Process users need tailoring
	that enables them to trim the process to reflect the actual needs.
	Process engineers need a method and a tool to define a valid model.
	The SE Book of T-Systems contains a feature model to describe variable
	parts of the process model and relations and constraints between
	these parts. The notation and semantics of feature models can be
	used to visually author a consistent and valid tailoring model. In
	this paper we present a tool for visual modeling and validation of
	process model tailoring based on feature models using the SE Book
	of T-Systems as an example. The tool is based on a domain-specific
	language that represents the process model. It leverages the semantics
	of feature models to provide an easy-to-use editor for tailoring-enabled
	process models. © 2011 ACM.},
  affiliation = {Technische Universität München - Software and Systems Engineering,
	Munich, Germany},
  author_keywords = {Development process; Feature-model; Visual modeling},
  document_type = {Conference Paper},
  journal = {Proceedings of the ACM SIGSOFT Symposium on the Foundations of Software
	Engineering},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-80053207576&partnerID=40&md5=d16df1299dbb4c12d988d6983ad9f9b2}
}

@ARTICLE{Courbis2006170,
  author = {Courbis, C., Lesaint, D., Mihailescu, P.},
  title = {Three applications of aspect technology},
  journal = {BT Technology Journal},
  year = {2006},
  volume = {24},
  pages = {170-174},
  number = {3},
  note = {cited By (since 1996) 0},
  abstract = {The emergence of converged services is driving communication service
	providers to cut back on software engineering costs, shorten time-to-market
	and build personalisable services. As illustrated by BT's 21CN architecture
	initiative, the industry is responding with the vision of next-generation
	service delivery platforms (SDPs). The move towards SDPs demands
	a principled approach to achieve reuse, modularity, and evolvability
	of software artefacts, ranging from business processes to application
	components. To this end, new proposals, such as generative programming,
	aspect-oriented programming, and model-driven engineering, are put
	forward to complement traditional object-oriented and component programming
	paradigms. Aspect-oriented programming - the focus of this paper
	- endorses the principle of separation of concerns. Originally devoted
	to the modularisation of crosscutting concerns (e.g. synchronisation,
	security, debugging, monitoring), it has grown from an aspect-oriented
	extension to Java (AspectJ) into a general approach for the development
	of adaptive software artefacts. The purpose of this paper is to introduce
	aspect technology and demonstrate its versatility across three different
	application domains. Specifically, we present an aspect-based extension
	to a process execution language (BPEL) for developing adaptable workflows,
	an AspectJ-based instrumentation of a field resource scheduling system,
	and a proposal to customise mobile services using aspects. While
	the technology is still maturing, we hope this paper will raise the
	level of awareness on the potential of aspects across BT. © Springer
	Science+Business Media, Inc. 2006.},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-33845216708&partnerID=40&md5=17ce699fc52201720887905b6bba32bf}
}

@CONFERENCE{Coz2008421,
  author = {Coz, J.R., Heradio Gil, R., Cerrada Somolinos, J.A., López Ruiz,
	J.C.},
  title = {A generative approach to improve the abstraction level to build applications
	based on the notification of changes in databases},
  year = {2008},
  volume = {DISI},
  pages = {421-424},
  note = {cited By (since 1996) 0},
  abstract = {This paper highlights the benefits, in terms of quality, productivity
	and time-to-market, of applying a generative approach to increase
	the abstraction level to build applications based on the notification
	of changes in databases. Most of the databases maintain meta-tables
	with information about all stored tables; this information is used
	in an automatic process to define the software product line (SPL)
	variability. The remaining variability can be specified by means
	of domain specific languages. Code generators can automatically query
	the meta-tables, analyze the input specifications and configure the
	current product. The paper also introduces the Exemplar Driven Development
	process to incrementally develop code generators and the Exemplar
	Flexibilization Language that supports the process implementation.},
  affiliation = {Departamento de Ingeniería de Software y Sistemas Informáticos, Universidad
	Nacional de Educatión a Distancia, Ciudad Universitaria, Juan del
	Rosal 16, E-28040. Madrid, Spain},
  author_keywords = {Generative programming; Software product line (SPL); SQL procedural
	extension language},
  document_type = {Conference Paper},
  journal = {ICEIS 2008 - Proceedings of the 10th International Conference on
	Enterprise Information Systems},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-55849118120&partnerID=40&md5=e3a510e48c76c051dde5d455d19ce8e7}
}

@CONFERENCE{Cruz2008308,
  author = {Cruz, F.a , Barreto, R.b , Cordeiro, L.b },
  title = {Towards a model-driven engineering approach for developing embedded
	hard real-time software},
  year = {2008},
  pages = {308-314},
  note = {cited By (since 1996) 1},
  abstract = {Model-Driven Engineering (MDE) has been advocated as an effective
	way to deal with today's software complexity. MDE can be seen as
	an integrative approach combining existing techniques Buch as Domain-Specific
	Modeling Languages (DSML) and Transformation Engines. ThiB paper
	presents the ezRealtime. an MDE-based tool that relies on the Time
	Petri Net (TPN) formalism and defines a DSML to provide an easy-to-use
	environment for specifying Embedded Hard Real-Time (EHRT) systems
	and for synthesizing timely and predictable scheduled C code. The
	ezRealtime adopts the universal XML-based transfer syntax for Petri
	nets, named as PNML. The main idea of this work is to propose a generative
	programming method and tool to boost code quality and improve developer
	productivity with automated software synthesis. The ezRealtime tool
	reads and automatically translates the specification to a time Petri
	net model through composition of building blocks with the purpose
	of providing a complete model of all tasks in the system. Therefore,
	this model is used to find a feasible schedule by applying a depth-first
	search algorithm. Finally, the scheduled code is generated by traversing
	the feasible schedule, and replacing transition's instances by the
	respective code segments. We also present the application of the
	proposed method in a case study. Copyright 2008 ACM.},
  affiliation = {Nokia Institute of Technology (INdT), Universidade Federal do Amazonas;
	Departamento de Ciência da Computação, Universidade Federal do Amazonas},
  author_keywords = {DSL engineering; Embedded hard real-time systems; Model-driven engineering;
	Petri nets; Software synthesis; Tool-based approaches},
  document_type = {Conference Paper},
  journal = {Proceedings of the ACM Symposium on Applied Computing},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-56749170137&partnerID=40&md5=6d5c4d4fe46395c1d591a1e0b37008cb}
}

@ARTICLE{Crégut201090,
  author = {Crégut, X.a , Combemale, B.b , Pantel, M.a , Faudoux, R.c , Pavei,
	J.a d },
  title = {Generative technologies for model animation in the TopCased platform},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2010},
  volume = {6138 LNCS},
  pages = {90-103},
  note = {cited By (since 1996) 1},
  abstract = {Domain Specific Modeling Languages (DSML) are more and more used to
	handle high level concepts, and thus bring complex software development
	under control. The increasingly recurring definition of new languages
	raises the problem of the definition of support tools such as editor,
	simulator, compiler, etc. In this paper we propose generative technologies
	that have been designed to ease the development of model animation
	tools inside the TopCased platform. These tools rely on the automatically
	generated graphical editors of TopCased and provide additional generators
	for building model animator graphical interface. We also rely on
	an architecture for executable metamodel (i.e., the TopCased model
	execution metamodeling pattern) to bind the behavioral semantics
	of the modeling language. These tools were designed in a pragmatic
	manner by abstracting the various model animators that had been hand-coded
	in the TopCased project, and then validated by refactoring these
	animators. © 2010 Springer-Verlag.},
  affiliation = {Université de Toulouse, IRIT, France; Université de Rennes 1, IRISA,
	France; ATOS Origin, Toulouse, France; Universidade Federal de Santa
	Catarina, Brazil},
  author_keywords = {Generative technologies; Metamodeling pattern; Model animation; Model
	execution},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-77954630645&partnerID=40&md5=0aeeffca89f6693ae5fb0c70c48b13aa}
}

@ARTICLE{Cuadrado200748,
  author = {Cuadrado, J.S., Molina, J.G.},
  title = {Building domain-specific languages for model-driven development},
  journal = {IEEE Software},
  year = {2007},
  volume = {24},
  pages = {48-55},
  number = {5},
  note = {cited By (since 1996) 18},
  abstract = {The emergence of the model-driven development paradigm has revitalized
	interest in domain-specific languages. Embedding a DSL in a dynamic
	language facilitates rapid development. This article illustrates
	dynamic-language features and techniques that the authors found useful
	while developing embedded DSLs in Ruby for a model-driven development
	tool. For this domain, it's possible to achieve a runtime performance
	comparable to existing tools while shortening development time. This
	article is part of a special issue on dynamically typed languages.
	© 2007 IEEE.},
  affiliation = {Dept. of Computers and Systems, Facultad de Informática, Univ. of
	Murcia, Murcia 30071, Spain},
  author_keywords = {Development tools; Domain-specific language; Dynamically typed language;
	Model-driven development; Specialized application languages},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-34648817304&partnerID=40&md5=f2b074ae272b0fe7dc06a74a4257ee1e}
}

@ARTICLE{Cuadrado2006336,
  author = {Cuadrado, J.S., Molina, J.G.},
  title = {A plugin-based language to experiment with model transformation},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2006},
  volume = {4199 LNCS},
  pages = {336-350},
  note = {cited By (since 1996) 3},
  abstract = {Model transformation is a key technology of model driven software
	development approaches. Several transformation languages have appeared
	in the last few years, but more research is still needed for an in-depth
	understanding of the nature of model transformations and to discover
	desirable features of transformation languages. Research interest
	is primarily focused on experimentation with languages by writing
	transformations for real problems. RubyTL is a hybrid transformation
	language defined as a Ruby internal domain specific language, and
	is designed as an extensible language: a plugin mechanism allows
	new features to be added to core features. In this paper, we describe
	this plugin mechanism, devised to facilitate the experimentation
	with possible features of RubyTL. Through an example, we show how
	to add a new language feature, specifically we will develop a plugin
	to organize a transformation in several phases. Finally, we discuss
	the advantages of this extensible language design. © Springer-Verlag
	Berlin Heidelberg 2006.},
  affiliation = {University of Murcia, Spain},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-33750379820&partnerID=40&md5=63a7c5a1253aa47670ae2fcdc45962b2}
}

@ARTICLE{Cuadrado2006158,
  author = {Cuadrado, J.S., Molina, J.G., Tortosa, M.M.},
  title = {RubyTL: A practical, extensible transformation language},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2006},
  volume = {4066 LNCS},
  pages = {158-172},
  note = {cited By (since 1996) 14},
  abstract = {Model transformation is a key technology of model driven development
	approaches. A lot of research therefore is being carried out to understand
	the nature of model transformations and find out desirable characteristics
	of transformation languages. In recent years, several transformation
	languages have been proposed. We present the RubyTL transformation
	language which has been designed as an extensible language - a set
	of core features along with an extension mechanism. RubyTL provides
	a framework for experimenting with features of hybrid transformation
	languages. In addition, RubyTL has been created as a domain specific
	language embedded in the Ruby programming language. In this paper
	we show the core features of the language through a simple example
	and explain how the language can be extended to provide more features.
	© Springer-Verlag Berlin Heidelberg 2006.},
  affiliation = {University of Murcia, Spain},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-33746389743&partnerID=40&md5=af66be8199a7a74997db90c4353456b6}
}

@CONFERENCE{Culpepper2010235,
  author = {Culpepper, R.a b , Felleisen, M.a },
  title = {Fortifying macros},
  year = {2010},
  pages = {235-246},
  note = {cited By (since 1996) 1},
  abstract = {Existing macro systems force programmers to make a choice between
	clarity of specification and robustness. If they choose clarity,
	they must forgo validating significant parts of the specification
	and thus produce low-quality language extensions. If they choose
	robustness, they must write in a style that mingles the implementation
	with the specification and therefore obscures the latter. This paper
	introduces a new language for writing macros. With the new macro
	system, programmers naturally write robust language extensions using
	easy-to-understand specifications. The system translates these specifications
	into validators that detect misuses - including violations of context-sensitive
	constraints - and automatically synthesize appropriate feedback,
	eliminating the need for ad hoc validation code. © 2010 ACM.},
  affiliation = {Northeastern University, Boston, MA, United States; School of Computing,
	50 Central Campus Drive, Salt Lake City, UT 84112-9205, United States},
  author_keywords = {domain-specific languages; macros},
  document_type = {Conference Paper},
  journal = {Proceedings of the ACM SIGPLAN International Conference on Functional
	Programming, ICFP},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-78249260009&partnerID=40&md5=fe81fc0c7f796f58c99467293558d7f0}
}

@CONFERENCE{Cunningham2008282,
  author = {Cunningham, H.C.},
  title = {A little language for surveys: Constructing an internal DSL in Ruby},
  year = {2008},
  pages = {282-287},
  note = {cited By (since 1996) 3},
  abstract = {Using a problem domain motivated by Bentley's "Little Languages" column
	[1], this paper explores the use of the Ruby programming language's
	flexible syntax, dynamic nature, and reflexive metaprogramming facilities
	to implement an internal domain-specific language (DSL) for surveys.
	Copyright 2008 ACM.},
  affiliation = {Department of Computer and Information Science, University of Mississippi,
	University, MS 38677, United States},
  art_number = {1593181},
  author_keywords = {Domain specific language; Reflexive metaprogramming; Ruby},
  document_type = {Conference Paper},
  journal = {Proceedings of the 46th Annual Southeast Regional Conference on XX,
	ACM-SE 46},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-70449937631&partnerID=40&md5=a21cf4781eea0569c4d0ec31b7f9ae30}
}

@CONFERENCE{Curry2004226,
  author = {Curry, E., Chambers, D., Lyons, G.},
  title = {ARMAdA: Creating a reflective fellowship (options for interoperability)},
  year = {2004},
  volume = {80},
  pages = {226-231},
  note = {cited By (since 1996) 0},
  abstract = {With the development of numerous adaptive and reflective middleware
	platforms, inter-platform interoperability is a desirable next step.
	At present, little or no interoperability is possible at the meta-layer
	of reflective middleware. The emergence of an open standard for meta-layer
	interaction is imperative to support the development of next-generation
	middleware that can express their needs and capabilities to platforms
	with which they interact. In this paper, we describe the foundations
	of the ARMAdA interaction standard for adaptive and reflective middleware
	platforms. Copyright 2004 ACM.},
  affiliation = {Department of Information Technology, National University of Ireland,
	Galway, Ireland},
  author_keywords = {Adaptive and reflective middleware; Domain specific languages; Interaction
	standard},
  document_type = {Conference Paper},
  journal = {ACM International Conference Proceeding Series},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-77952965414&partnerID=40&md5=3c2845fc546823553ecc7ad599b28101}
}

@CONFERENCE{Curé2010255,
  author = {Curé, O.a , Forax, R.a , Degenne, P.b , Seen, D.L.b , Parigot, D.c
	, Lahcen, A.A.c },
  title = {Ocelet: An ontology-based domain specific language to model complex
	domains},
  year = {2010},
  pages = {255-260},
  note = {cited By (since 1996) 0},
  abstract = {In this work, we consider that the modeling of complex domains can
	be performed using Domain Specific Languages (DSL). The main principle
	of this approach consists in developing DSL primitives and to assemble
	them to model a certain domain. The ability to add new primitives
	into an existing model and to fine-tune it by replacing some of them
	provides a flexibility that is highly desirable in simulation intense
	fields. We have designed such a language, named Ocelet, which is
	tailored for dynamic landscape modeling. We consider that three important
	components may influence the adoption of this approach: a graphical
	user interface to build models in an efficient and user-friendly
	way, a solution to reason, e.g., consistency checking, about model
	primitives and a tool to facilitate the development of primitives
	repositories. In this paper, we emphasize that an ontology-based
	approach is adapted to design all these components. Moreover, a mapping
	between ontology and Ocelet elements is sufficient for its achievement
	and supports automatic transformations from one model to the other.
	© 2010 IEEE.},
  affiliation = {Université Paris-Est, LIGM - UMR CNRS 8049, Marne-la-Vallée, France;
	CIRAD, UMR TETIS, Montpellier, France; INRIA, Sophia, Antipolis,
	France},
  art_number = {5532752},
  author_keywords = {DSL; Models; Ocelet; Ontologies; Reasoning},
  document_type = {Conference Paper},
  journal = {3rd Int. Conf. on Communication Theory, Reliability, and Quality
	of Service, CTRQ 2010, Includes MOPAS 2010: 1st Int. Conf. on Models
	and Ontology-Based Design of Protocols, Architecture and Services},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-77956484524&partnerID=40&md5=837000317c9a472b67f3898edd63fbf0}
}

@CONFERENCE{Czarnecki2007575,
  author = {Czarnecki, K.},
  title = {Software reuse and evolution with generative techniques},
  year = {2007},
  pages = {575},
  note = {cited By (since 1996) 0},
  abstract = {Generative software development aims at modeling and implementing
	product lines in such a way that all or a substantial part of the
	desired system can be automatically generated from a specification
	written in one or more domain-specific languages (DSLs). The tutorial
	will explore several techniques of generative software development
	and show how they can help address software evolution and reuse challenges.},
  affiliation = {University of Waterloo, 200 University Ave. West, Waterloo, ON, Canada},
  author_keywords = {domain-specific languages; generative software development; model-driven
	software engineering; software product lines},
  document_type = {Conference Paper},
  journal = {ASE'07 - 2007 ACM/IEEE International Conference on Automated Software
	Engineering},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-77953964808&partnerID=40&md5=c10f73177e09c544f562903de9228c79}
}

@CONFERENCE{Czarnecki2006225,
  author = {Czarnecki, K.},
  title = {Tutorial on generative software development},
  year = {2006},
  pages = {225},
  note = {cited By (since 1996) 0},
  abstract = {Software product line engineering (SPLE) [5] seeks to exploit the
	commonalities among systems from a given problem domain while managing
	the variabilities among them in a systematic way. In SPLE, new system
	variants can be rapidly created based on a set of reusable assets,
	such as a common architecture, components, and models. Generative
	software development [6] aims at modeling and implementing product
	lines in such a way that a given system can be automatically generated
	from a specification written in one or more textual or graphical
	domain-specific languages (DSLs) [13, 4, 15, 8, 3, 1, 12, 14]. In
	this tutorial, participants will learn how to perform (1) domain
	analysis, i.e., capturing the commonalities and variabilities within
	a product line using, among others, feature modeling, (2) domain
	design, i.e., developing a common architecture for a product line,
	and (3) implementing software generators using multiple technologies,
	such as template-based code generation and model transformations.
	I will describe recent progress in feature modeling, including staged
	configuration [9], constraint support for feature modeling and configuration
	[10, 2], and feature models as views on ontologies [11]. Furthermore,
	I will survey and compare available tools for feature modeling and
	implementing DSLs as well as related approaches such as Software
	Factories and Model-Driven Architecture. Among others, I will demonstrate
	tool support for mapping features to UML models and model configuration
	[7]. The presented concepts and methods will be explained using a
	sample case study of an e-commerce platform. © 2006 IEEE.},
  affiliation = {University of Waterloo, Canada},
  art_number = {1691609},
  document_type = {Conference Paper},
  journal = {Proceedings - 10th International Software Product Line Conference,
	SPLC 2006},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-34547332929&partnerID=40&md5=3d08ef2226695ff990aae814f2ec8733}
}

@CONFERENCE{Czarnecki2005326,
  author = {Czarnecki, K.},
  title = {Overview of generative software development},
  year = {2005},
  volume = {3566},
  pages = {326-341},
  note = {cited By (since 1996) 13},
  abstract = {System family engineering seeks to exploit the commonalities among
	systems from a given problem domain while managing the variabilities
	among them in a systematic way. In system family engineering, new
	system variants can be rapidly created based on a set of reusable
	assets (such as a common architecture, components, models, etc.).
	Generative software development aims at modeling and implementing
	system families in such a way that a given system can be automatically
	generated from a specification written in one or more textual or
	graphical domain-specific languages. This paper gives an overview
	of the basic concepts and ideas of generative software development
	including DSLs, domain and application engineering, generative domain
	models, networks of domains, and technology projections. The paper
	also discusses the relationship of generative software development
	to other emerging areas such as Model Driven Development and Aspect-Oriented
	Software Development. © Springer-Verlag Berlin Heidelberg 2005.},
  affiliation = {University of Waterloo, Canada},
  document_type = {Conference Paper},
  journal = {Lecture Notes in Computer Science},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-26444529404&partnerID=40&md5=f35ebabaac5bbb9a072388d35ecee2a1}
}

@ARTICLE{CánovasIzquierdo200992,
  author = {Cánovas Izquierdo, J.L., Molina, J.G.},
  title = {A domain specific language for extracting models in software modernization},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2009},
  volume = {5562 LNCS},
  pages = {92-97},
  note = {cited By (since 1996) 0},
  abstract = {Model-Driven Engineering techniques can be used both to create new
	software and to modernize existing software systems. Model-Driven
	Software Modernization requires a first step for the extraction of
	models. Most modernization scenarios involve dealing with the GPL
	source code of the existing system. Techniques and tools providing
	efficient means to extract models from source code are therefore
	needed. In this paper, we analyze the difficulties encountered when
	using the existing approaches and we propose a language, called Gra2MoL,
	which is especially tailored to address the problem of model extraction.
	This provides a powerful query language for concrete syntax trees,
	and mappings between source grammar elements and target metamodel
	elements are expressed by rules similar to those found in model transformation
	languages. Moreover, the approach also allows reusing existing grammars.
	© 2009 Springer Berlin Heidelberg.},
  affiliation = {University of Murcia},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-70350662765&partnerID=40&md5=b2078deb1d46c645301e48b7691b4767}
}

@CONFERENCE{DaSilvaSantos200737,
  author = {Da Silva Santos, L.O.B.a , Van Wijnen, R.P.b , Vink, P.c },
  title = {A service-oriented middleware for context-aware applications},
  year = {2007},
  pages = {37-42},
  note = {cited By (since 1996) 2},
  abstract = {Context awareness has emerged as an important element in distributed
	computing. It offers mechanisms that allow applications to be aware
	of their environment and enable these applications to adjust their
	behavior to the current context. Considering the dynamic nature of
	context, the data flow of relevant contextual information can be
	significant. In order to keep track of this information flow, a flexible
	service mechanism should be available for the client applications.
	In this document we present a service-oriented middleware for context-aware
	applications. This middleware provides support to leverage the development
	of context-aware applications by providing a scripting-like approach
	for context-aware application development; allowing the subscription
	of rules containing context-based events and conditions and a notification
	to be sent when the specified context holds. Moreover, a domain-specific
	language has been developed to express these context-based rules.
	Copyright 2007 ACM.},
  affiliation = {University of Twente, P.O. Box 217, 7500AE Enschede, Netherlands;
	Telematica Instituut, P.O. Box 589, 7500AN Enschede, Netherlands;
	Philips Research, P.O Box WB61, 5656AA Eindhoven, Netherlands},
  author_keywords = {Design; Experimentation; Human factors},
  document_type = {Conference Paper},
  journal = {Proceedings of the 5th International Workshop on Middleware for Pervasive
	and Ad-hoc Computing, MPAC 2007 held at the ACM/IFIP/USENIX 8th International
	Middleware Conference},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-57349148170&partnerID=40&md5=c766fdd6dabec31d43505010b89bd2ff}
}

@CONFERENCE{DaSilva2003236,
  author = {Da Silva, A.R., Lemos, G., Matias, T., Costa, M.},
  title = {The XIS Generative Programming Techniques},
  year = {2003},
  pages = {236-241},
  note = {cited By (since 1996) 0},
  abstract = {XIS' is a R&D project which main mission is to analyze, develop and
	evaluate mechanisms and tools to produce information systems from
	a more abstract, high-level, efficient and productive way than it
	is done currently. XIS project is Influenced by MDA reference model,
	and is mainly based on three principles: namely high-level models
	specification; generative programming techniques; and it is component-based
	architecture-centric. XIS is not a conceptual research plan, it is
	a working on project with concrete results and produced systems.
	In this paper we detail the generative programming techniques used
	in the XIS project as well as the discussions and main decisions
	tackled on. Finally, we present the main conclusions, the relationship
	between XIS and MDA, and the work that will be handled in the near
	future.},
  affiliation = {INESC/IST (Technical Univ of Lisbon), Rua Alves Redol, no 9, 1000-029
	Lisboa, Portugal},
  document_type = {Conference Paper},
  journal = {Proceedings - IEEE Computer Society's International Computer Software
	and Applications Conference},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-0344666707&partnerID=40&md5=a027de3e65be79ddbdf2d2e4c1b1527d}
}

@ARTICLE{DaSilva2007294,
  author = {Da Silva, A.R., Saraiva, J., Ferreira, D., Silva, R., Videira, C.},
  title = {Integration of RE and MDE paradigms: The ProjectIT approach and tools},
  journal = {IET Software},
  year = {2007},
  volume = {1},
  pages = {294-314},
  number = {6},
  note = {cited By (since 1996) 6},
  abstract = {The suggestion that in software development projects the emphasis
	must be on the project management (RE), requirements engineering,
	and design activities, and consequently efforts in production activities
	- such as traditional software programming and testing - should be
	minimised and performed as automatically as possible is discussed.
	The ProjectIT approach that integrates contributions from the RE
	and model-driven engineering communities is also discussed. The goal
	with requirement specification is not just in managing textual specifications,
	but also to obtain a consistent requirements document that is in
	conformance with a domain-specific language, and that can be re-used
	to increase the design and development activities in the context
	of model driven and code generation techniques. Furthermore, the
	feasibility and benefits of this approach by presenting a proof-of-concept
	case study are discussed, in which the orchestration of the concepts
	and concrete components related with the ProjectIT approach, the
	PIT-RSL, XIS and PIT-TSL languages and the ProjectIT-Studio CASE
	tool is emphasised. A practical demonstration of the approach including
	the description of the system requirements, the design of the system,
	the use of code generation techniques, and how they integrate to
	improve and accelerate the software engineering lifecycle is presented.
	© The Institution of Engineering and Technology 2007.},
  affiliation = {INESC-ID, Instituto Superior Técnico, Rua Alves Redol, No. 9, 1000-029
	Lisboa, Portugal},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-38649110151&partnerID=40&md5=5af1ae7e118dbeaa355eb4891f31bd41}
}

@CONFERENCE{Dagand2009,
  author = {Dagand, P.-E.a , Baumann, A.b , Roscoe, T.b },
  title = {Filet-o-Fish: Practical and dependable domain-specific languages
	for OS development},
  year = {2009},
  note = {cited By (since 1996) 0},
  abstract = {We address a persistent problem with using domain-specific languages
	to write operating systems: the effort of implementing, checking,
	and debugging the DSL usually outweighs any of its benefits. Because
	these DSLs generate C by templated string concatenation, they are
	tedious to write, fragile, and incompatible with automated verification
	tools. We present Filet-o-Fish (FoF), a semantic language to ease
	DSL construction. Building a DSL using FoF consists of safely composing
	semantically-rich building blocks. This has several advantages: input
	files for the DSL are formal specifications of the system's functionality,
	automated testing of the DSL is possible via existing tools, and
	we can prove that the C code generated by a given DSL respects the
	semantics expected by the developer. Early experience has been good:
	FoF is in daily use as part of the tool chain of the Barrelfish multicore
	OS, which makes extensive use of domain-specific languages to generate
	low-level OS code. We have found that the ability to rapidly generate
	DSLs we can rely on has changed how we have designed the OS. © 2010
	ACM.},
  affiliation = {ENS Cachan-Bretagne, France; Systems Group, ETH Zurich, Switzerland},
  art_number = {1745446},
  document_type = {Conference Paper},
  journal = {Proceedings of the 5th Workshop on Programming Languages and Operating
	Systems, PLOS 2009, in Conjunction with the 22nd ACM Symposium on
	Operating Systems Principles, SOSP 2009},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-77954599554&partnerID=40&md5=daa9d138494afb5ecc13ab090f72c19f}
}

@CONFERENCE{Dagand200965,
  author = {Dagand, P.-E.a , Kostić, D.b , Kuncak, V.b },
  title = {Opis: Reliable Distributed Systems in OCaml},
  year = {2009},
  pages = {65-77},
  note = {cited By (since 1996) 2},
  abstract = {Concurrency and distribution pose algorithmic and implementation in
	developing reliable distributed systems, the field an excellent testbed
	for evaluating language and verification paradigms. Several domain-specific
	languages and extensions of unsafe languages were proposed to aid
	distributed development. We present an alternative to these, showing
	that modern, higher-order, strongly, memory safe languages provide
	an excellent vehicle developing and debugging distributed systems.
	present Opis, a functional-reactive approach for developing systems
	in Objective Caml. An Opis description consists of a reactive function
	(called function) describing the behavior of a distributed system.
	The event functions in Opis are built from pure as building blocks,
	composed using the Arrow combinators. architecture aids reasoning
	about event functions informally and using interactive theorem provers.
	example, it facilitates simple termination arguments. a protocol
	description, a developer can use higherorder functions of Opis to
	1) deploy the distributed, 2) run the distributed system in a network
	simulator full-replay capabilities, 3) apply explicit-state model
	to the distributed system, detecting undesirable behaviors, 4) do
	performance analysis on the system. We the design and implementation
	of Opis, and present experience in using Opis to develop peer-to-peer
	overlay, including the Chord distributed hash table and Cyclon random
	gossip protocol. We found that using results in high programmer productivity
	and leads to composable protocol descriptions. Opis tools were effective
	helping identify and eliminate correctness and performanceduring
	distributed system development. © 2009 ACM.},
  affiliation = {ENS Cachan-Bretagne, France; EPFL, Switzerland},
  author_keywords = {Arrows, Distributed Systems, Functional Programming,Model-checking},
  document_type = {Conference Paper},
  journal = {Proceedings of the 2009 ACM SIGPLAN Workshop on Types in Language
	Design and Implementation, TLDI'09},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-67650085320&partnerID=40&md5=ba741b156c7b9e156b86409c66b35299}
}

@CONFERENCE{Dahman2011267,
  author = {Dahman, K., Charoy, F., Godart, C.},
  title = {Towards consistency management for a business-driven development
	of SOA},
  year = {2011},
  pages = {267-275},
  note = {cited By (since 1996) 0},
  abstract = {The usage of the Service Oriented Architecture (SOA) along with the
	Business Process Management has emerged as a valuable solution for
	the complex (business process driven) system engineering. With a
	Model Driven Engineering where the business process models drive
	the supporting service component architectures, less effort is gone
	into the Business/IT alignment during the initial development activities,
	and the IT developers can rapidly proceed with the SOA implementation.
	However, the difference between the design principles of the emerging
	domainspecific languages imposes serious challenges in the following
	re-design phases. Moreover, enabling evolutions on the business process
	models while keeping them synchronized with the underlying software
	architecture models is of high relevance to the key elements of any
	Business Driven Development (BDD). Given a business process update,
	this paper introduces an incremental model transformation approach
	that propagates this update to the related service component configurations.
	It, therefore, supports the change propagation among heterogenous
	domainspecific languages, e.g., the BPMN and the SCA. As a major
	contribution, our approach makes model transformation more tractable
	to reconfigure system architecture without disrupting its structural
	consistency. We propose a synchronizer that provides the BPMN-to-SCA
	model synchronization with the help of the conditional graph rewriting.
	© 2011 IEEE.},
  affiliation = {Université de Lorraine, UHP, LORIA, BP 239, 54506 Vandoeuvre-lès-Nancy
	Cedex, France},
  art_number = {6037580},
  author_keywords = {Business-IT alignment; Incremental model transformation; Structural
	consistency management},
  document_type = {Conference Paper},
  journal = {Proceedings - IEEE International Enterprise Distributed Object Computing
	Workshop, EDOC},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-80054925377&partnerID=40&md5=6e9653d91214adb4a627493951433f0c}
}

@CONFERENCE{Dai2002153,
  author = {Dai, X., Hager, G., Peterson, J.},
  title = {Specifying behavior in C++},
  year = {2002},
  volume = {1},
  pages = {153-160},
  note = {cited By (since 1996) 1},
  abstract = {Most robot programming takes place in the "time domain". That is,
	the goal is to specify the behavior of a system that is acquiring
	a continual temporal stream of inputs, and is required to provide
	a continual, temporal stream of outputs. We present a reactive programming
	language, based on the Functional Reactive Programming paradigm,
	for specifying such behavior. The major attributes of this language
	are: 1) it provides for both synchronous and asynchronous definitions
	of behavior, 2) specification is equational in nature, 3) it is type
	safe, and 4) it is embedded in C++. In particular the latter makes
	it simple to "lift" existing C++ libraries into the language.},
  affiliation = {Department of Computer Science, The Johns Hopkins University, Baltimore,
	MD, United States},
  document_type = {Conference Paper},
  journal = {Proceedings - IEEE International Conference on Robotics and Automation},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-0036055521&partnerID=40&md5=76a929f31cc81976846e7a508fd98301}
}

@CONFERENCE{Dalpez2010116,
  author = {Dalpez, S.a , Passerone, R.a , Cancila, D.b , Terrier, F.b },
  title = {An industrial case study using an MBE approach: From architecture
	to safety analysis},
  year = {2010},
  volume = {2},
  pages = {116-122},
  note = {cited By (since 1996) 0},
  abstract = {We discuss the initial phases of software development of a real industrial
	safety-related device in the railway application domain. In particular,
	to achieve greater confidence in the system, we illustrate the development
	of the system architecture (using a standard model domain-specific
	language), the computation of the safety integrity level and the
	calculation of the reliability of the whole system. We reiterate
	the safety analysis on the sub-systems. The proposed methodology
	has found immediate industrial applications. © 2010 IEEE.},
  affiliation = {Dipartimento di Ingegneria e Scienza dell'Informazione, University
	of Trento, Italy; Laboratory of Model Driven Engineering for Embedded
	Systems, Point Courrier 94, Gif-sur-Yvette, 91191, France},
  art_number = {5479518},
  author_keywords = {Model-based safety engineering; Preliminary hazard analysis; Railway
	application domain; Reliability analysis},
  document_type = {Conference Paper},
  journal = {ISORC Workshops 2010 - 2010 13th IEEE International Symposium on
	Object/Component/Service-Oriented Real-Time Distributed Computing
	Workshops},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-77954797156&partnerID=40&md5=80e279122ea8d6a093baff58cce2ec5e}
}

@ARTICLE{Damaševičius2010770,
  author = {Damaševičius, R., Štuikys, V.},
  title = {Metrics for evaluation of metaprogram complexity},
  journal = {Computer Science and Information Systems},
  year = {2010},
  volume = {7},
  pages = {770-787},
  number = {4},
  note = {cited By (since 1996) 0},
  abstract = {The concept of complexity is used in many areas of computer science
	and software engineering. Software complexity metrics can be used
	to evaluate and compare quality of software development and maintenance
	processes and their products. Complexity management and measurement
	is especially important in novel programming technologies and paradigms,
	such as aspect-oriented programming, generative programming, and
	metaprogramming, where complex multi- language and multi-aspect program
	specifications are developed and used. This paper analyzes complexity
	management and measurement techniques, and proposes five complexity
	metrics (Relative Kolmogorov Complexity, Metalanguage Richness, Cyclomatic
	Complexity, Normalized Difficulty, Cognitive Difficulty) for measuring
	complexity of metaprograms at information, metalanguage, graph, algorithm,
	and cognitive dimensions.},
  affiliation = {Kaunas University of Technology, Software Engineering Department,
	Studentu 50, LT-51368, Kaunas, Lithuania},
  author_keywords = {Complexity evaluation; Metaprogram metric; Metaprogramming},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-79551493942&partnerID=40&md5=6a6e5362673d8f28bec5331ac8e80293}
}

@CONFERENCE{Damjanovic2010388,
  author = {Damjanovic, V.a , Djuric, D.b },
  title = {Functional programming way to interact with software attacks and
	vulnerabilities},
  year = {2010},
  pages = {388-393},
  note = {cited By (since 1996) 0},
  abstract = {This paper proposes using functional programming style in a way to
	respond to detection of and interaction with the software attacks
	and vulnerabilities. Additionally, our approach considers involving
	Description Logics, as a basis for the use of the Semantic Web and
	meta-programming to produce executable ontologies and to enable semantic
	reasoning over behavior and interaction with software attacks and
	vulnerabilities. Accordingly, we introduce Magic Potion, a recently
	defined Domain Specific meta-Language that uses Modeling Spaces framework
	to study heterogeneous modeling and meta-modeling problems inspired
	by Model Driven Architecture. As an example of formalism for modeling
	software attacks and vulnerabilities, we explore Attack Tree, which
	provides a formal methodology for analyzing the security of the system.
	Based on Attack Tree, which is herein specified for a particular
	problem of dealing with known attacks and vulnerabilities of the
	security layer of the Wireless Application Protocol, and which is
	particularly built on top of Magic Potion specification, we define
	our specific Domain Specific Language that we call Attack Tree Domain
	Specific Language. It is envisioned as a tool for modeling and interacting
	with software attacks and vulnerabilities. © 2010 IEEE.},
  affiliation = {Salzburg Research, Knowledge-based Information Systems, Jakob Haringer
	Strasse 5/III, 5020 Salzburg, Austria; Department of Software Engineering,
	University of Belgrade, Jove Ilica 154, 11000 Belgrade, Serbia},
  art_number = {5463677},
  author_keywords = {Attack trees; Description logics; Domain specific language; Functional
	programming; Model driven architecture; Software vulnerability},
  document_type = {Conference Paper},
  journal = {ICSTW 2010 - 3rd International Conference on Software Testing, Verification,
	and Validation Workshops},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-77953781743&partnerID=40&md5=5c6fc2ad9c81b7f4f2e20b9cb731d862}
}

@ARTICLE{Daniele200733,
  author = {Daniele, L., Costa, P.D., Pires, L.F.},
  title = {Towards a rule-based approach for context-aware applications},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2007},
  volume = {4606 LNCS},
  pages = {33-43},
  note = {cited By (since 1996) 1},
  abstract = {Context-aware applications can sense and explore the users' context
	in order to provide proper and useful services to these users. These
	applications can react intelligently upon changes in the user's context,
	performing actions relevant to the user, the application itself,
	and the interaction between user and application. Context-aware reactive
	behaviors can be expressed by using rules written in a Domain-specific
	Language, coined ECA-DL, specially developed for context-aware applications.
	This paper proposes support for the development of a generic component
	capable of executing rules written using ECA-DL. This component executes
	these rules by using Jess, which is a well-known tool for developing
	rule-based systems. © Springer-Verlag Berlin Heidelberg 2007.},
  affiliation = {Centre for Telematics and Information Technology, University of Twente,
	Enschede, Netherlands},
  author_keywords = {Context-awareness; ECA pattern; ECA-DL; Rule-based systems},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-37849024365&partnerID=40&md5=dfe0109336ad69ef255b3b80897b51bd}
}

@ARTICLE{Danvy20091,
  author = {Danvy, O.a , Shan, C.-C.b , Zerny, I.a },
  title = {J is for javaScript: A direct-style correspondence between algol-like
	languages and javascript using first-class continuations},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2009},
  volume = {5658 LNCS},
  pages = {1-19},
  note = {cited By (since 1996) 0},
  abstract = {It is a time-honored fashion to implement a domain-specific language
	(DSL) by translation to a general-purpose language. Such an implementation
	is more portable, but an unidiomatic translation jeopardizes performance
	because, in practice, language implementations favor the common cases.
	This tension arises especially when the domain calls for complex
	control structures. We illustrate this tension by revisiting Landin's
	original correspondence between Algol and Church's lambda-notation.
	We translate domain-specific programs with lexically scoped jumps
	to JavaScript. Our translation produces the same block structure
	and binding structure as in the source program, à la Abdali. The
	target code uses a control operator in direct style, à la Landin.
	In fact, the control operator used is almost Landin's J-hence our
	title. Our translation thus complements a continuation-passing translation
	à la Steele. These two extreme translations require JavaScript implementations
	to cater either for first-class continuations, as Rhino does, or
	for proper tail recursion. Less extreme translations should emit
	more idiomatic control-flow instructions such as for, break, and
	throw. The present experiment leads us to conclude that translations
	should preserve not just the data structures and the block structure
	of a source program, but also its control structure. We thus identify
	a new class of use cases for control structures in JavaScript, namely
	the idiomatic translation of control structures from DSLs. © IFIP
	International Federation for Information Processing 2009.},
  affiliation = {Department of Computer Science, Aarhus University, Aabogade 34, Aarhus
	N, DK-8200, Denmark; Department of Computer Science, Rutgers University,
	110 Frelinghuysen Road, Piscataway, NJ 08854, United States},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-69049085670&partnerID=40&md5=8973d964a39d435bf59192caf5d2d588}
}

@ARTICLE{David2008106,
  author = {David, P.-C.a , Léger, M.b , Grall, H.a , Ledoux, T.a , Coupaye,
	T.b },
  title = {A multi-stage approach for reliable dynamic reconfigurations of component-based
	systems},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2008},
  volume = {5053 LNCS},
  pages = {106-111},
  note = {cited By (since 1996) 1},
  abstract = {In this paper we present an end-to-end solution to define and execute
	reliable dynamic reconfigurations of open component-based systems
	while guaranteeing their continuity of service. It uses a multi-stage
	approach in order to deal with the different kinds of possible errors
	in the most appropriate way; in particular, the goal is to detect
	errors as early as possible to minimize their impact on the target
	system. Reconfigurations are expressed in a restricted, domain-specific
	language in order to allow different levels of static and dynamic
	validation, thus detecting errors before executing the reconfiguration
	where possible. For errors that can not be detected early (including
	software and hardware faults), a runtime environment provides transactional
	semantics to the reconfigurations. © 2008 Springer-Verlag Berlin
	Heidelberg.},
  affiliation = {OBASCO Group, EMN / INRIA, Lina, École des Mines de Nantes, 4 rue
	Alfred Kastler, Nantes Cedex 3 F-44307, France; France Télécom, Recherche
	and Développement, 28, chemin du vieux chêne, F-38243 Meylan, France},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-45749114994&partnerID=40&md5=d10ec3bb68f966c51d1cc404ea50e0d2}
}

@ARTICLE{Davis200813,
  author = {Davis, K.a , Striegnitz, J.b },
  title = {Multiparadigm programming in object-oriented languages},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2008},
  volume = {4906 LNCS},
  pages = {13-26},
  note = {cited By (since 1996) 0},
  abstract = {While OO has become ubiquitously employed for design, implementation,
	and even conceptualization, many practitioners recognize the concomitant
	need for other programming paradigms according to problem domain.
	Nevertheless, the choice of a programming paradigm is strongly influenced
	by the supporting programming language facilities. In turn, choice
	of programming language is usually highly constrained by practical
	considerations. We seek answers to the question of how to address
	the need for other programming paradigms, or even domain specific
	languages, in the general context of OO languages. It is clear that
	this field is yet nascent: novel, disparate approaches and techniques
	are still being discovered or invented, and this very novelty adds
	a significant element of intellectual entertainment. This article
	describes the cross section of research efforts reported at the workshop
	on Multiparadigm Programming in Object-Oriented Languages held at
	the 2007 European Conference on Object-Oriented Programming. © 2008
	Springer-Verlag Berlin Heidelberg.},
  affiliation = {Los Alamos National Laboratory, Los Alamos, NM 87545, United States;
	University of Applied Sciences Regensburg, 93053 Regensburg, Germany},
  author_keywords = {Multiparadigm; Object-oriented; Programming},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-45449105555&partnerID=40&md5=72842fd954ec3ec38dcb29e99329df41}
}

@CONFERENCE{Davis20052237,
  author = {Davis, V.a , Gray, J.a , Jones, J.b },
  title = {Generative approaches for application tailoring of mobile devices},
  year = {2005},
  volume = {2},
  pages = {2237-2241},
  note = {cited By (since 1996) 0},
  abstract = {The popularity of mobile devices has propelled the development of
	many useful location-aware applications. However, the heterogeneity
	of mobile devices necessitates that the software be customized and
	tailored for each device. The research described in this paper demonstrates
	the possibilities of generative programming applied to application
	tailoring. This is done in order to assist in porting software to
	specific devices without manually rewriting code. The Java 2 Micro
	Edition (J2ME) is an integral part of the application tailoring solution.
	Many mobile devices are capable of using J2ME, but require the code
	to be packaged specifically to run in each different mobile environment.
	J2ME applications alone are not sufficient for porting the code to
	different mobile devices. The first solution that will be presented
	uses a specifically structured VoiceXML file as input to an XSL transformation.
	The transformation produces J2ME source code. Java servlets are used
	to compile the resulting code and package it with respect to a specific
	device. This first solution works well for users who have programming
	experience and are comfortable with editing XML files. However, a
	different solution is needed to enable users with limited programming
	experience to specify the essential properties of the mobile application.
	A second solution to application tailorability uses a metamodeling
	tool (we use the Generic Modeling Environment - GME) to create a
	domain-specific modeling language. This environment allows an end-user
	to capture the essence of a design in a notation that is familiar
	to the users. From the specified models, an application can be generated
	directly from a model interpreter. The modeling approach provides
	a higher-level of abstraction, which removes the user from the accidental
	complexities regarding the details of the mobile application implementation.
	A case study is presented that enables a restaurateur to create an
	online menu for use on several different mobile devices. Copyright
	2005 ACM.},
  affiliation = {Dept. of Computer and Info. Sciences, University of Alabama at Birmingham,
	Birmingham, AL 35294-1170, United States; Department of Computer
	Science, University of Alabama, Tuscaloosa, AL 35487-0290, United
	States},
  document_type = {Conference Paper},
  journal = {Proceedings of the Annual Southeast Conference},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-77953803981&partnerID=40&md5=40e00abb2ce761e45feaa09624946ecc}
}

@CONFERENCE{DeFarias200763,
  author = {De Farias, C.R.G.a , Pires, L.F.b , Van Sinderen, M.b },
  title = {A case study on the transformation of context-aware domain data onto
	XML schemas},
  year = {2007},
  pages = {63-72},
  note = {cited By (since 1996) 1},
  abstract = {In order to accelerate the development of context-aware applications,
	it would be convenient to have a smooth path between the context
	models and the automated services that support these models. This
	paper discusses how MDA technology (metamodelling and the QVT standard)
	can support the transformation of high-level models of context-aware
	services onto the implementation of these services using web services.
	The total transformation process from context-aware services onto
	web services involves the following aspects: 1. service signatures,
	which should be translated onto WSDL definitions; 2. contextaware
	domain data used as input and output data in service operations,
	which should be translated onto XML schemas; and 3. service behaviours,
	which should be used to generate the service implementation. This
	paper concentrates on the modelling and transformation of the context-aware
	domain data. The results of this paper are generally applicable to
	the transformation of elements of any domain-specific language expressed
	in terms of a metamodel onto XML Schema data.},
  affiliation = {Department of Physics and Mathematics, University of São Paulo, Av.
	Bandeirantes 3900, 14040-901, Ribeirão Preto (SP), Brazil; Centre
	for Telematics and Information Technology, University of Twente,
	PO Box 217, 7500 AE, Enschede, Netherlands},
  document_type = {Conference Paper},
  journal = {Proceedings of the 3rd International Workshop on Model-Driven Enterprise
	Information Systems - MDEIS 2007; In Conjunction with ICEIS 2007},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-58149131837&partnerID=40&md5=5fc550710b29b870cf1759f00c2a9929}
}

@CONFERENCE{DeGeest2008197,
  author = {De Geest, G.a , Vermolen, S.b , Van Deursen, A.b , Visser, E.b },
  title = {Generating version convertors for domain-specific languages},
  year = {2008},
  pages = {197-201},
  note = {cited By (since 1996) 0},
  abstract = {Domain-specific languages (DSLs) improve programmer productivity by
	providing high-level abstractions for the development of applications
	in a particular domain. However, the smaller distance to the application
	domain entails more frequent changes to the language. As a result,
	existing DSL models need to be converted to the new version. Manual
	conversion is tedious and error prone. This paper presents an approach
	to support DSL evolution by generation of convertors between DSLs.
	By analyzing the differences between DSL meta-models, a mapping is
	reverse engineered which can be used to generate reengineering tools
	to automatically convert models between different versions of a DSL.
	The approach has been implemented for the Microsoft DSL Tools infrastructure
	in two tools called DSLCompare and ConverterGenerator. The approach
	has been evaluated by means of three case studies taken from the
	software development practice at the company Avanade. © 2008 IEEE.},
  affiliation = {Avanade Netherlands B.V., Netherlands; Delft University of Technology,
	Netherlands},
  art_number = {4656410},
  document_type = {Conference Paper},
  journal = {Proceedings - Working Conference on Reverse Engineering, WCRE},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-57749199710&partnerID=40&md5=b9d616b80f27836a02197ced8615c910}
}

@ARTICLE{DeMesmay2010353,
  author = {De Mesmay, F., Chellappa, S., Franchetti, F., Püschel, M.},
  title = {Computer generation of efficient software viterbi decoders},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2010},
  volume = {5952 LNCS},
  pages = {353-368},
  note = {cited By (since 1996) 0},
  abstract = {This paper presents a program generator for fast software Viterbi
	decoders for arbitrary convolutional codes. The input to the generator
	is a specification of the code and a single-instruction multiple-data
	(SIMD) vector length. The output is an optimized C implementation
	of the decoder that uses explicit Intel SSE vector instructions.
	At the heart of the generator is a small domain-specific language
	called VL to express the structure of the forward pass. Vectorization
	is done by rewriting VL expressions, which a compiler then translates
	into actual code in addition to performing further optimizations
	specific to the vector instruction set. Benchmarks show that the
	generated decoders match the performance of available expert hand-tuned
	implementations, while spanning the entire space of convolutional
	codes. An online interface to the generator is provided at www.spiral.net.
	© 2010 Springer-Verlag.},
  affiliation = {Electrical and Computer Engineering, Carnegie Mellon University, Pittsburgh,
	PA 15213, United States},
  author_keywords = {Domain-specific language; High performance software; Library generation;
	Vectorization; Viterbi algorithm},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-77949643572&partnerID=40&md5=ab77e308886f83e3c7a9ed3198ef261d}
}

@ARTICLE{DeOliveira2004872,
  author = {De Oliveira, A.A.a , Braga, T.H.b , De Maia, M.A.b , Bigonha, R.D.S.a
	},
  title = {MetaJ: An extensible environment for metaprogramming in Java},
  journal = {Journal of Universal Computer Science},
  year = {2004},
  volume = {10},
  pages = {872-891},
  number = {7},
  note = {cited By (since 1996) 0},
  abstract = {MetaJ is a programming environment that supports metaprogramming in
	the Java language. The environment is designed to allow extensions
	via plug-ins which permit the user to manipulate programs written
	in different languages. This facilities concern only syntactic aspects.
	Semantics aspects are language-dependent and are not addressed here,
	but could be tackled with other tools, which could even be layered
	on the top of MetaJ. Accessing patterns by example inside ordinary
	Java programs is a major feature of MetaJ programming. This paper
	presents a conceptual description of the environment, implementation
	details and three applications on analysis, restructuring and generation
	of programs. © J.UCS.},
  affiliation = {Federal University of Minas Gerais, Brazil; Federal University of
	Ouro Preto, Brazil},
  author_keywords = {Generative programming; Java; Metaprogramming; Metaprogramming tools;
	Object-oriented frameworks; Program transformation; Refactoring},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-23844460189&partnerID=40&md5=73fa8465af6d12bbc0166e328fcb4ce2}
}

@CONFERENCE{DeRoo201141,
  author = {De Roo, A., S̈ozer, H., Akşit, M.},
  title = {Runtime verification of domain-specific models of physical characteristics
	in control software},
  year = {2011},
  pages = {41-50},
  note = {cited By (since 1996) 0},
  abstract = {Control logic of embedded systems is nowadays largely implemented
	in software. Such control software implements among others models
	of physical characteristics like heat exchange among system components.
	Due to evolution of system properties and increasing complexity faults
	can be left undetected in these models. Therefore their accuracy
	must be verified at runtime. Traditional runtime verification techniques
	that are based on states and events in software execution are inadequate
	in this case. The behavior suggested by models of physical characteristics
	cannot be mapped to behavioral properties of software. Moreover implementation
	in a general-purpose programming language makes these models hard
	to locate and verify. This paper presents a novel approach to explicitly
	specify models of physical characteristics using a domain-specific
	language to define monitors for inconsistencies by detecting and
	exploiting redundancy in these models and to realize these monitors
	using an aspect-oriented approach. The approach is applied to two
	industrial case studies. © 2011 IEEE.},
  affiliation = {Software Engineering Group, Faculty of Electrical Engineering, Mathematics
	and Computer Science, University of Twente, Netherlands},
  art_number = {5992002},
  document_type = {Conference Paper},
  journal = {Proceedings - 2011 5th International Conference on Secure Software
	Integration and Reliability Improvement, SSIRI 2011},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-80052953361&partnerID=40&md5=1ee09bc5c3d588df0581a5869dfa8250}
}

@ARTICLE{DeVolder200588,
  author = {De Volder, K.},
  title = {JQuery: A generic code browser with a declarative configuration language},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2005},
  volume = {3819 LNCS},
  pages = {88-102},
  note = {cited By (since 1996) 0},
  abstract = {Modern IDEs have an open-ended plugin architecture to allow customizability.
	However, developing a plugin is costly in terms of effort and expertise
	required by the customizer. We present a two-pronged approach that
	allows for open-ended customizations while keeping the customization
	cost low. First, we explicitly limit the portion of the design space
	targeted by the configuration mechanism. This reduces customization
	cost by simplifying the configuration interface. Second, we use a
	declarative programming language as our configuration language. This
	facilitates open-ended specification of behavior without burdening
	the user with operational details. © Springer-Verlag Berlin Heidelberg
	2006.},
  affiliation = {University of British Columbia, Vancouver, BC V6T 1Z4, Canada},
  author_keywords = {Domain-specific language; Integrated development environment; Logic
	programming; Program database},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-33745469860&partnerID=40&md5=abfdbc92d152d151c79e5174281e25ba}
}

@CONFERENCE{DeanPalmer201061,
  author = {Dean Palmer, J.},
  title = {Ficticious: MicroLanguages for interactive fiction},
  year = {2010},
  pages = {61-67},
  note = {cited By (since 1996) 0},
  abstract = {In this paper we provide an experience report where language oriented
	programming approaches are applied to complex game design. Ficticious
	is a G-expression based pidgin of several microlanguages designed
	for describing complex narrative worlds that exist within interactive
	fiction. G-expression language transformations convert code written
	in Ficticious to the general programming language Ginger, which is
	then translated into calls against the underlying machine. In this
	paper we explore Ficticious's unique object model and demonstrate
	how dynamic language transformations can be a powerful tool for implementing
	separation of concerns, rich text markup, complex virtual world design
	and character interaction. © 2010 ACM.},
  affiliation = {Northern Arizona University, United States},
  author_keywords = {Domain specific languages; Ginger; Interactive fiction; MicroLanguages},
  document_type = {Conference Paper},
  journal = {Proceedings of the ACM International Conference Companion on Object
	Oriented Programming Systems Languages and Applications Companion,
	SPLASH '10},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-78650162153&partnerID=40&md5=1391761b9ffd41ae50e64d69374ea869}
}

@ARTICLE{Dejanović2010409,
  author = {Dejanović, I., Milosavljević, G., Perišić, B., Tumbas, M.},
  title = {A domain-specific language for defining static structure of database
	applications},
  journal = {Computer Science and Information Systems},
  year = {2010},
  volume = {7},
  pages = {409-440},
  number = {3},
  note = {cited By (since 1996) 0},
  abstract = {In this paper we present DOMMLite - an extensible domain-specific
	language (DSL) for static structure definition of database-oriented
	applications. The model-driven engineering (MDE) approach, an emerging
	software development paradigm, has been used. The language structure
	is defined by the means of a metamodel supplemented by validation
	rules based on Check language and extensions based on Extend language,
	which are parts of the openArchitectureWare framework [1]. The metamodel
	has been defined along with the textual syntax, which enables creation,
	update and persistence of DOMMLite models using a common text editor.
	DSL execution semantics has been defined by the specification and
	implementation of the source code generator for a target platform
	with an already defined execution semantics. In order to enable model
	editing, a textual Eclipse editor has also been developed. DSL, defined
	in this way, has the capability of generating complete source code
	for GUI forms with CRUDS (Create-Read-Update-Delete-Search) and navigation
	operations [2,3,4,5].},
  affiliation = {Faculty of Technical Sciences, Trg D. Obradovića 6, 21000 Novi Sad,
	Serbia},
  author_keywords = {CRUD; Domain-specific; DSL; Generator; MDA; MDE; MDSD; Meta-modeling;
	Modeling},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-77957004471&partnerID=40&md5=f60bb17148d80de3d5c013470ced5405}
}

@ARTICLE{Delahaye200289,
  author = {Delahaye, D.},
  title = {A proof dedicated meta-language},
  journal = {Electronic Notes in Theoretical Computer Science},
  year = {2002},
  volume = {70},
  pages = {89-102},
  number = {2},
  note = {cited By (since 1996) 5},
  abstract = {We describe a proof dedicated meta-language, called ℒtac, in the context
	of the Coq proof assistant. This new layer of meta-language is quite
	appropriate to write small and local automations. ℒtac, is essentially
	a small functional core with recursors and powerful pattern-matching
	operators for Coq terms but also for proof contexts. As ℒtac, is
	not complete, we describe an interface between ℒtac, and the full
	programmable meta-language of the system (Objective CAML), which
	is also the implementation language. This interface is based on a
	quotation system where we can use ℒtac,'s syntax in ML files, and
	where it is possible to insert ML code in ℒtac, scripts by means
	of antiquotations. In that way, the two meta-languages are not opposed
	and we give an example where they fairly cooperate. Thus, this shows
	that a LCF-like system with a two-level meta-language is completely
	realistic. © 2002 Published by Elsevier Science B. V.},
  affiliation = {Programming Logic Group, Department of Computing Science, Chalmers
	University of Technology, S-412 96 Gothenburg, Sweden},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-18944388619&partnerID=40&md5=558eb23b3c553f529f428b34757495e0}
}

@ARTICLE{Delaval2007,
  author = {Delaval, G.a , Rutten, E.b },
  title = {A domain-specific language for multitask systems, applying discrete
	controller synthesis},
  journal = {Eurasip Journal on Embedded Systems},
  year = {2007},
  volume = {2007},
  note = {cited By (since 1996) 5},
  abstract = {We propose a simple programming language, called Nemo, specific to
	the domain of multitask real-time control systems, such as in robotic,
	automotive, or avionics systems. It can be used to specify a set
	of resources with usage constraints, a set of tasks that consume
	them according to various modes, and applications sequencing the
	tasks. We automatically obtain an application-specific task handler
	that correctly manages the constraints (if there exists one), through
	a compilation-like process including a phase of discrete controller
	synthesis. This way, this formal technique contributes to the safety
	of the designed systems, while being encapsulated in a tool that
	makes it usable by application experts. Our approach is based on
	the synchronous modelling techniques, languages, and tools.},
  affiliation = {INRIA Rhne-Alpes, Saint Ismier Cedex 38334, France; Laboratoire d'Informatique
	Fondamentale de Lille, INRIA Futurs, Villeneuve d'Ascq Cédex 59655,
	France},
  art_number = {84192},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-34247259625&partnerID=40&md5=0e9481380b21c19a7d56d2053e6e90ef}
}

@CONFERENCE{Delaval2006901,
  author = {Delaval, G.a , Rutten, É.b },
  title = {A domain-specific language for task handlers generation, applying
	discrete controller synthesis},
  year = {2006},
  volume = {1},
  pages = {901-905},
  note = {cited By (since 1996) 1},
  abstract = {We propose a simple programming language, called Nemo, specific to
	the domain of multi-task real-time embedded systems, such as in robotic,
	automotive or avionics systems. It can be used to specify a set of
	resources with usage constraints, a set of tasks that consume them
	according to various modes, and applications sequencing the tasks.
	We obtain automatically an application-specific task handler that
	correctly manages the constraints (if there exists one), through
	a compilation-like process including a phase of discrete controller
	synthesis. This way, this formal technique contributes to the safety
	of the designed systems, while being encapsulated in a tool that
	makes it usable by end-users and application experts. Our approach
	is based on the synchronous modelling techniques, languages and tools.
	Copyright 2006 ACM.},
  affiliation = {INRIA Rhône-Alpes, POP ART, 38330 Montbonnot, France; INRIA Futurs
	/ LIFL, DaRT / WEST USTL, 59655 Villeneuve d'Ascq, France},
  author_keywords = {Discrete control synthesis; Domain-specific language; Real-time systems;
	Safe design; Synchronous programming},
  document_type = {Conference Paper},
  journal = {Proceedings of the ACM Symposium on Applied Computing},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-33751049657&partnerID=40&md5=4fcbae4fdfbc66ef2ac4f88822d89c0b}
}

@CONFERENCE{DeLesley200338,
  author = {DeLesley, H.},
  title = {The power of symmetry: Unifying inheritance and generative programming},
  year = {2003},
  pages = {38-52},
  note = {cited By (since 1996) 0},
  abstract = {I present the Ohmu language, a unified object model which allows a
	number of "advanced" techniques such as aspects, mixin layers, parametric
	polymorphism, and generative components to be implemented cleanly
	using two basic concepts: block structure and inheritance. I argue
	that conventional ways of defining classes and objects have created
	artificial distinctions which limit their expressiveness. The Ohmu
	model unifies functions, classes, instances, templates, and even
	aspects into a single construct - the structure. Function calls,
	instantiation, aspect-weaving, and inheritance are likewise unified
	into a single operation - the structure transformation. This simplification
	eliminates the distinction between classes and instances, and between
	compiletime and run-time code. Instead of being compiled, programs
	are reduced using partial evaluation, during which the interpreter
	is invoked at compile-time. Within this architecture, standard OO
	inheritance becomes a natural vehicle for creating meta-programs
	and automatic code generators - the key to a number of recent domain-driven
	programming methodologies.},
  affiliation = {CISA, School of Informatics, University of Edinburgh, 11 Crichton
	Street, Edinburgh, EH8 9LE, United Kingdom},
  author_keywords = {Aspect-oriented programming; Aspects; Code generation; Covariant specialization;
	Generative components; Generative programming; Generic types; Join
	points; Meta-programming; Mixin layers; Mixins; Multiple inheritance;
	Parametric polymorphism; Partial evaluation; Prototypes; Transformation
	systems; Virtual classes; Virtual types},
  document_type = {Conference Paper},
  journal = {Proceedings of the Conference on Object-Oriented Programming Systems,
	Languages, and Applications, OOPSLA},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-79951647297&partnerID=40&md5=9391a906101cd49a9b65bbff317be7ce}
}

@ARTICLE{Demaille2009101,
  author = {Demaille, A., Durlin, R., Pierron, N., Sigoure, B.},
  title = {Semantics Driven Disambiguation: A Comparison of Different Approaches},
  journal = {Electronic Notes in Theoretical Computer Science},
  year = {2009},
  volume = {238},
  pages = {101-116},
  number = {5},
  note = {cited By (since 1996) 0},
  abstract = {Context-sensitive languages such as or can be parsed using a context-free
	but ambiguous grammar, which requires another stage, disambiguation,
	in order to select the single parse tree that complies with the language's
	semantical rules. Naturally, large and complex languages induce large
	and complex disambiguation stages. If, in addition, the parser should
	be extensible, for instance to enable the embedding of domain specific
	languages, the disambiguation techniques should feature traditional
	software-engineering qualities: modularity, extensibility, scalability
	and expressiveness. We evaluate three approaches to write disambiguation
	filters for SDF grammars: algebraic equations with ASF, rewrite-rules
	with programmable traversals for Stratego, and attribute grammars
	with TAG (TransformersAttribute Grammar), our system. To this end
	we introduce Phenix, a highly ambiguous language. Its "standard"
	grammar exhibits ambiguities inspired by those found in the and standard
	grammars. To evaluate modularity, the grammar is layered: it starts
	with a small core language, and several layers add new features,
	new production rules, and new ambiguities. © 2009 Elsevier B.V. All
	rights reserved.},
  affiliation = {EPITA Research and Development Laboratory (LRDE), 14-16, rue Voltaire,
	FR-94276 Le Kremlin-Bicetre Cedex, France},
  author_keywords = {ASF; attribute grammar; context-free grammar; disambiguation; parsing;
	program transformation; SDF; Stratego; term rewriting; Transformers},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-70349400462&partnerID=40&md5=c9055462f7afbbc46a82daf12f2c28db}
}

@CONFERENCE{Demirezen2009833,
  author = {Demirezen, Z.},
  title = {Semantic framework for DSLs},
  year = {2009},
  pages = {833-834},
  note = {cited By (since 1996) 0},
  abstract = {Domain-Specific Languages (DSLs) enable domain experts to participate
	in software development tasks and to specify their own programs using
	domain abstractions. To define programs using domain concepts, rather
	than programming language concepts, model-based syntax and semantic
	specification techniques may offer advantages over current approaches.
	The purpose of the research described in this paper is to provide
	a semantic framework that can be used visually by DSL designers,
	yet has formal underpinnings such that interoperation with verification
	tools is possible to realize model checking tasks. This research
	is focused on a visual technique based on activity diagrams and graph
	transformation rules to define the semantics of DSLs.},
  affiliation = {Department of Computer and Information Sciences, University of Alabama
	at Birmingham, Birmingham, AL 35294-1170, United States},
  author_keywords = {Activity diagram; Domain-specific languages; Graph transformation
	systems; Model checking; Operational semantics},
  document_type = {Conference Paper},
  journal = {Proceedings of the Conference on Object-Oriented Programming Systems,
	Languages, and Applications, OOPSLA},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-72249121494&partnerID=40&md5=0abc2fda1199c848a669ab9b9c4156e1}
}

@CONFERENCE{Demirezen2009,
  author = {Demirezen, Z.a , Mernik, M.a b , Gray, J.a , Bryant, B.a },
  title = {Verification of DSMLs using graph transformation: A case study with
	alloy},
  year = {2009},
  volume = {413},
  note = {cited By (since 1996) 1},
  abstract = {Domain-Specific Modeling Languages (DSMLs) enable domain experts to
	participate in software development tasks and to specify their own
	programs using domain abstractions. Many Model-Driven Engineering
	(MDE) platforms primarily concentrate on structural aspects of DSMLs
	and only provide techniques to define abstract and concrete syntax.
	Only a few platforms provide built-in support for specification of
	behavioral semantics and verification tasks. In this paper, we focus
	on how to specify the behavioral semantics of a DSML by a sequence
	of graph transformation rules. We also discuss how to transform a
	DSML specification into Alloy, a model checking tool. These transformations
	demonstrate that DSML models specified in a visual notation can be
	verified by means of existing model checking tools. Copyright © 2009
	ACM.},
  affiliation = {Department of Computer and Information Sciences, University of Alabama
	at Birmingham, Birmingham, AL 35294-1170, United States; Faculty
	of Electrical Engineering and Computer Science, University of Maribor,
	2000 Maribor, Slovenia},
  art_number = {3},
  author_keywords = {Activity diagram; Domain-specific modeling languages; Graph transformation
	systems; Model checking; Operational semantics; Verification},
  document_type = {Conference Paper},
  journal = {ACM International Conference Proceeding Series},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-74949086320&partnerID=40&md5=302f4195af299ac0b9d3b3c9ccffe36a}
}

@ARTICLE{Demirli2011336,
  author = {Demirli, E., Tekinerdogan, B.},
  title = {Software language engineering of architectural viewpoints},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2011},
  volume = {6903 LNCS},
  pages = {336-343},
  note = {cited By (since 1996) 0},
  abstract = {A common practice in software architecture design is to apply architectural
	views to design software architecture for the various stakeholder
	concerns. Architectural views are usually developed based on architectural
	viewpoints which define the conventions for constructing, interpreting
	and analyzing views. So far most architectural viewpoints seem to
	have been primarily used either to support the communication among
	stakeholders, or at the best to provide a blueprint for the detailed
	design. In this paper we provide a software language engineering
	approach to define viewpoints as domain specific languages. This
	enhances the formal precision of architectural viewpoints and leads
	to executable views that can be interpreted and analyzed by tools.
	We illustrate our approach for defining domain specific languages
	for the viewpoints of the Views and Beyond approach. © 2011 Springer-Verlag.},
  affiliation = {Department of Computer Engineering, Bilkent University, Ankara 06800,
	Turkey},
  author_keywords = {Architectural Viewpoints; Domain Specific Modeling; Software Language
	Engineering; Tool Support},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-80053190433&partnerID=40&md5=6fe2914c36d3e93d9e181865c1fdaca0}
}

@CONFERENCE{Deneke200849,
  author = {Deneke, W.a , Eno, J.a , Li, W.a , Thompson, C.a , Talburt, J.b ,
	Loghry, J.c , Nash, D.c , Stires, J.c },
  title = {Towards a domain-specific modeling language for customer data integration
	workflow},
  year = {2008},
  pages = {49-56},
  note = {cited By (since 1996) 0},
  abstract = {This paper describes the workflow specification problem, how workflows
	are specified today, requirements for improved workflow specification,
	and begins to sketch a new domain-specific modeling language (DSML)
	approach for specifying intent that can be used to constructively
	generate a complete workflow meeting a collection of intent requirements.
	This is an interim report on work in progress. © 2008 IEEE.},
  affiliation = {University of Arkansas, Fayetteville, AR, United States; University
	of Arkansas, Little Rock, AR, United States; Acxiom Corporation},
  art_number = {4539324},
  document_type = {Conference Paper},
  journal = {Proceedings - 3rd International Conference on Grid and Pervasive
	Computing Symposia/Workshops, GPC 2008},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-50649101722&partnerID=40&md5=a4b30d84d81dbed8fac7547d82436c28}
}

@CONFERENCE{Densmore2010557,
  author = {Densmore, D.a , Kittlesony, J.T.b , Bilitchenkoz, L.d , Liux, A.c
	, Andersony, J.C.b },
  title = {Rule based constraints for the construction of genetic devices},
  year = {2010},
  pages = {557-560},
  note = {cited By (since 1996) 0},
  abstract = {The construction of composite genetic devices from primitive parts
	is a key activity in synthetic biology. Currently there does not
	exist a formal method to specify constraints on the construction
	of these devices. These constraints would help enable an automated
	design flow from device specification to physical assembly. This
	paper examines the laboratory creation of variations of a particular
	genetic device called a phagemid. We illustrate how lessons learned
	empirically from the non-functional designs can be captured formally
	as constraints in a newly created domain specific language called
	"Eugene". These constraints will prevent many faulty constructions
	automatically in the future saving time and money while increasing
	design abstraction and productivity. ©2010 IEEE.},
  affiliation = {Synthetic Biology Engineering Research Center, Joint BioEnergy Institute,
	Emeryville, CA 94608, United States; Department of Bioengineering,
	University of California, Berkeley, CA 94720, United States; Department
	of EECS, University of California, Berkeley, CA 94720, United States;
	Department of Computer Science, Cal Poly Pomona, CA 91768, United
	States},
  art_number = {5537540},
  document_type = {Conference Paper},
  journal = {ISCAS 2010 - 2010 IEEE International Symposium on Circuits and Systems:
	Nano-Bio Circuit Fabrics and Systems},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-77956000821&partnerID=40&md5=215f20f6ce7180afab9647b33fd63da5}
}

@ARTICLE{Denton2008143,
  author = {Denton, T., Jones, E., Srinivasan, S., Owens, K., Buskens, R.W.},
  title = {NAOMI - An experimental platform for multi-modeling},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2008},
  volume = {5301 LNCS},
  pages = {143-157},
  note = {cited By (since 1996) 2},
  abstract = {Domain-specific modeling languages (DSMLs) are designed to provide
	precise abstractions of domain-specific constructs. However, models
	for complex systems typically do not fit neatly within a single domain
	and capturing all important aspects of such a system requires developing
	multiple models using different DSMLs. Combining these models into
	multi-models presents difficult challenges, most importantly those
	of integrating the various models and keeping both the models and
	their associated data synchronized. To this end, we present NAOMI,
	an experimental platform for enabling multiple models, developed
	in different DSMLs, to work together. NAOMI analyzes model dependencies
	to determine the impact of changes to one model on other dependent
	models and coordinates the propagation of necessary model changes.
	NAOMI also serves as a useful testbed for exploring how diverse modeling
	paradigms can be combined. © 2008 Springer-Verlag Berlin Heidelberg.},
  affiliation = {Lockheed Martin Advanced Technology Laboratories, Cherry Hill, NJ
	08002, United States},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-56649123106&partnerID=40&md5=99972ba2a8f33cef06ddb17a8bffe3c9}
}

@ARTICLE{Deus2011,
  author = {Deus, H.F.a b , Correa, M.C.c , Stanislaus, R.d , Miragaia, M.e ,
	Maass, W.f , De Lencastre, H.e g , Fox, R.a , Almeida, J.S.h },
  title = {S3QL: A distributed domain specific language for controlled semantic
	integration of life sciences data},
  journal = {BMC Bioinformatics},
  year = {2011},
  volume = {12},
  note = {cited By (since 1996) 0},
  abstract = {Background: The value and usefulness of data increases when it is
	explicitly interlinked with related data. This is the core principle
	of Linked Data. For life sciences researchers, harnessing the power
	of Linked Data to improve biological discovery is still challenged
	by a need to keep pace with rapidly evolving domains and requirements
	for collaboration and control as well as with the reference semantic
	web ontologies and standards. Knowledge organization systems (KOSs)
	can provide an abstraction for publishing biological discoveries
	as Linked Data without complicating transactions with contextual
	minutia such as provenance and access control.We have previously
	described the Simple Sloppy Semantic Database (S3DB) as an efficient
	model for creating knowledge organization systems using Linked Data
	best practices with explicit distinction between domain and instantiation
	and support for a permission control mechanism that automatically
	migrates between the two. In this report we present a domain specific
	language, the S3DB query language (S3QL), to operate on its underlying
	core model and facilitate management of Linked Data.Results: Reflecting
	the data driven nature of our approach, S3QL has been implemented
	as an application programming interface for S3DB systems hosting
	biomedical data, and its syntax was subsequently generalized beyond
	the S3DB core model. This achievement is illustrated with the assembly
	of an S3QL query to manage entities from the Simple Knowledge Organization
	System. The illustrative use cases include gastrointestinal clinical
	trials, genomic characterization of cancer by The Cancer Genome Atlas
	(TCGA) and molecular epidemiology of infectious diseases.Conclusions:
	S3QL was found to provide a convenient mechanism to represent context
	for interoperation between public and private datasets hosted at
	biomedical research institutions and linked data formalisms. © 2011
	Deus et al; licensee BioMed Central Ltd.},
  affiliation = {Digital Enterprise Research Institute, National University of Ireland
	at Galway, IDA Business Park, Lower Dangan, Galway, Ireland; Biomathematics,
	Instituto de Tecnologia Química e Biológica, Universidade Nova de
	Lisboa, Estação Agronómica Nacional, Av. da República, 2780-157 Oeiras,
	Portugal; Laboratório Nacional de Computação Ciêntifica, Av. Getúlio
	Vargas 333, Quitandinha, 25651-075 Petrópolis, Portugal; Sanofi Pasteur,
	38 Sidney Street, Cambridge, MA 02139, United States; Laboratory
	of Molecular Genetics, Instituto de Tecnologia Química e Biológica,
	Universidade Nova de Lisboa, Estação Agronómica Nacional, Av. da
	República, 2780-157 Oeiras, Portugal; Research Center for Intelligent
	Media, Furtwangen University, Furtwangen, Germany; Laboratory of
	Microbiology, The Rockefeller University, 10021 New York, United
	States; Division of Informatics, Department of Pathology, University
	of Alabama at Birmingham, 619 South 19th Street, Birmingham, AL,
	United States},
  art_number = {285},
  author_keywords = {BLinked Data; knowledge organization system; KOS; Policy; RDF; S3D;
	SPARQL},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-79960563809&partnerID=40&md5=698a92da0bafb423f76a436d12b597a6}
}

@ARTICLE{DiRuscio2004320,
  author = {Di Ruscio, D., Muccini, H., Pierantonio, A.},
  title = {A data-modelling approach to web application synthesis},
  journal = {International Journal of Web Engineering and Technology},
  year = {2004},
  volume = {1},
  pages = {320-337},
  number = {3},
  note = {cited By (since 1996) 6},
  abstract = {Most web applications are data-intensive, i.e. they rely heavily on
	dynamic contents usually stored in databases. Website design and
	maintenance can greatly benefit from conceptual descriptions of both
	data and hypermedia aspects, i.e. those design dimensions which distinguish
	this application class: the data upon which the content is based,
	the way dynamic contents are composed together to form pages, and
	how pages are linked together in order to move across the application
	content. The paper proposes Webile, a visual Domain-Specific Language
	based on UML, which enables a model-driven approach to high-level
	specification of web applications. In contrast with other approaches,
	Webile exploits the UML meta-model architecture by serialising the
	specifications in the XMI interchange format. This representation
	provides interoperability amongst different operative platforms and
	enables an XSL transformation-based automatic generation of the applications
	that are being designed.},
  affiliation = {Dipartimento di Informatica, Univ. degli Studi dell'Aquila, I-67100
	L'Aquila, Italy},
  author_keywords = {Conceptual modeling; Data-intesive web applications; Development;
	Internet; Modelling methodologies; UML; Web application design; WWW},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-13144306135&partnerID=40&md5=19ae5520925b9ed516258fcf702044c5}
}

@CONFERENCE{Dias2009409,
  author = {Dias, A., Amaral, V., Araújo, J.},
  title = {Towards a domain specific language for a goal-oriented approach based
	on KAOS},
  year = {2009},
  pages = {409-420},
  note = {cited By (since 1996) 2},
  abstract = {Requirements Engineering (RE) is the branch of Software Engineering
	dealing with requirements for software systems. A software requirement
	is a property which must be exhibited by software developed or adapted
	to solve a particular problem. Within RE, there are several branches
	of methodologies for obtaining requirements, among which we have
	Goal-Oriented Requirements Engineering (GORE), that uses goals to
	treat requirements. The visual complexity of standard GORE diagrams,
	when dealing with real cases, can get very high due to the high number
	of goals to be refined and detailed in the models. This can make
	them unreadable and difficult to manage and, as a consequence, the
	models can became harder to validate or update. As this problem has
	never been tackled before by the current existent tools, this paper
	proposes an extension to the KAOS language in order to incorporate
	the notion of Compartment, an encapsulation technique to keep concepts
	and with collapsing ability at user's request, with the main purpose
	of improving scalability of models. For the making of the tool it
	was used the Eclipse framework (with GMF/EMF plugins). We have chosen
	a specific GORE methodology named KAOS and based on it we designed
	a new Domain-Specific Language (DSL) by creating its extended metamodel.
	© 2009 IEEE.},
  affiliation = {Departamento de Informática, Faculdade de Ciências e Tecnologia, Universidade
	Nova de Lisboa, Caparica, Portugal},
  art_number = {5089305},
  document_type = {Conference Paper},
  journal = {Proceedings of the 2009 3rd International Conference on Research
	Challenges in Information Science, RCIS 2009},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-70349450010&partnerID=40&md5=077c6d3ca5468bc895339f15a40ecc52}
}

@CONFERENCE{Dib2008,
  author = {Dib, A.A., Féraud, L., Ober, I., Percebois, C.},
  title = {Towards a rigorous framework for dealing with domain specific language
	families},
  year = {2008},
  note = {cited By (since 1996) 0},
  abstract = {In this paper we present our approach to rigorously handle variation
	within a family of languages. Our starting point is a case study
	that we developed with industrial partners, where a major difficulty
	arised from the need to work with a set of domain specific languages
	(DSLs). Our solution is based on using the Category Theory. We consider
	the category of algebraic specifications implementing the semantics
	of the DSLs and we calculate the unifying language of the family.},
  affiliation = {IRIT, Université de Toulouse, 118, route de Narbonne, 31062 Toulouse,
	France},
  art_number = {4530342},
  author_keywords = {Category theory; Domain specific language (DSL); Domain specific modeling
	(DSM); Domain specific modeling language (DSML); Formal semantics;
	Incremental verification},
  document_type = {Conference Paper},
  journal = {2008 3rd International Conference on Information and Communication
	Technologies: From Theory to Applications, ICTTA},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-49149094274&partnerID=40&md5=e5ebc37b1519caaf482b4532807f4aff}
}

@ARTICLE{Dietrich201181,
  author = {Dietrich, D., Schröder, L., Schulz, E.},
  title = {Formalizing and operationalizing industrial standards},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2011},
  volume = {6603 LNCS},
  pages = {81-95},
  note = {cited By (since 1996) 0},
  abstract = {Industrial standards establish technical criteria for various engineering
	artifacts, materials, or services, with a view to ensuring their
	functionality, safety, and reliability. We develop a methodology
	and tools to systematically formalize such standards, in particular
	their domain specific calculation methods, in order to support the
	automatic verification of functional properties for concrete physical
	artifacts. We approach this problem in the setting of the Bremen
	heterogeneous tool set Hets, which allows for the integrated use
	of a wide range of generic and custom-made logics. Specifically,
	we (i) design a domain specific language for the formalization of
	industrial standards; (ii) formulate a semantics of this language
	in terms of a translation into the higher-order specification language
	HasCasl, and (iii) integrate computer algebra systems (CAS) with
	the Hets framework via a generic CAS-Interface in order to execute
	explicit and implicit calculations specified in the standard. This
	enables a wide variety of added-value services based on formal reasoning,
	including verification of parameterized designs and simplification
	of standards for particular configurations. We illustrate our approach
	using the European standard EN 1591, which concerns calculation methods
	for gasketed flange connections that assure the impermeability and
	mechanical strength of the flange-bolt-gasket system. © 2011 Springer-Verlag.},
  affiliation = {DFKI Bremen, Germany},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-79953190073&partnerID=40&md5=df1cd1582023cb659e06b25227a9a2a9}
}

@ARTICLE{Dijkstra200630,
  author = {Dijkstra, A., Doaitse Swierstra, S.},
  title = {Ruler: Programming type rules},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2006},
  volume = {3945 LNCS},
  pages = {30-46},
  note = {cited By (since 1996) 5},
  abstract = {Some type systems are first described formally, to be sometimes followed
	by an implementation. Other type systems are first implemented as
	language extensions, to be sometimes retrofitted with a formal description.
	In neither case it is an easy task to keep both artefacts consistent.
	In this paper we introduce Ruler, a domain specific language for
	describing type rules. Type rules can be incrementally described,
	thus providing a means for building complex type systems on top of
	simpler ones. Besides checking well-formedness of Ruler programs
	we use them to generate (1) a visual LAT EX rendering, suitable for
	use in the presentation of formal aspects, and (2) an attribute grammar
	based implementation. Combining these two aspects in Ruler contributes
	to bridging the gap between theory and practice: mutually consistent
	representations can be generated for use in both theoretical and
	practical settings. © Springer-Verlag Berlin Heidelberg 2006.},
  affiliation = {Department of Information and Computing Sciences, Universiteit Utrecht,
	Padualaan 14, Utrecht, Netherlands},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-33745827697&partnerID=40&md5=cfc8f64af42ed260adb16e4bb34a968f}
}

@ARTICLE{Diniz2011322,
  author = {Diniz, P.C.a , Cardoso, J.M.P.b },
  title = {Code transformations for embedded reconfigurable computing architectures},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2011},
  volume = {6491 LNCS},
  pages = {322-344},
  note = {cited By (since 1996) 0},
  abstract = {Embedded Systems permeate all aspects of our daily life, from the
	ubiquitous mobile devices (e.g., PDAs and smart-phones) to play-stations,
	set-top boxes, household appliances, and in every electronic system,
	be it large or small (e.g., in cars, wrist-watches). Most embedded
	systems are characterized by stringent design constraints such as
	reduced memory and computing capacity, severe power and energy restrictions,
	weight and space limitations, most importantly, very short life spans
	and thus strict design cycles. Reconfiguration has emerged as a key
	technology for embedded systems as it offers the promise of increased
	system performance and component number reduction. Reconfigurable
	components can be customized or specialized (even dynamically) to
	the task at hand, thereby executing specific tasks more efficiently
	leading to possible reductions of the weight and power. In this article,
	we introduce and discuss compilation techniques for reconfigurable
	embedded systems. We present specific compiler techniques focusing
	on source-level code transformations highlighting their potential
	and the applicability of generative programming techniques to this
	compilation domain. © 2011 Springer-Verlag.},
  affiliation = {Departamento de Engenharia Informática, Instituto Superior Técnico/INESC-ID,
	Av. Prof. Dr. Cavaco Silva, 2780-990 Porto Salvo, Portugal; Departamento
	de Engenharia Informática, Faculdade de Engenharia, Universidade
	Do Porto, Rua Dr. Roberto Frias, s/n, 4200-465 Porto, Portugal},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-79251572339&partnerID=40&md5=20a118d5c649e389afcaa07cd5b11bc0}
}

@CONFERENCE{Dinkelaker2009825,
  author = {Dinkelaker, T.},
  title = {Versatile language semantics with reflective embedding},
  year = {2009},
  pages = {825-827},
  note = {cited By (since 1996) 0},
  abstract = {Often, for one programming language, various implementations exist
	that have subtle but important variations in their syntax and semantics.
	While current technology provides good support for syntax variability
	in form of syntax extensions, there is only limited support for semantic
	variability in language implementations. My thesis is about a novel
	approach for adaptable language implementations that uses a meta-object
	protocol to embed language abstractions into the host language and
	that uses reflective techniques to adapt the language implementation.
	The techniques developed in my thesis open up several possibilities
	for adaptation in language implementations not addressed by related
	work. Similarly to the role of a meta-object protocol in general-purpose
	languages for adapting object-oriented abstractions, the meta-object
	protocol allows to adapt language abstractions of advanced language
	features, such as the abstractions of aspect-oriented programming
	and domain abstractions in domain-specific languages.},
  affiliation = {Technische Universität Darmstadt, Hochschulstr. 10, 64289 Darmstadt,
	Germany},
  author_keywords = {Aspect-oriented programming; Embedded domain-specific languages; Meta-object
	protocols},
  document_type = {Conference Paper},
  journal = {Proceedings of the Conference on Object-Oriented Programming Systems,
	Languages, and Applications, OOPSLA},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-72249094418&partnerID=40&md5=489e3dd39a2bd88301683ae024b9e191}
}

@CONFERENCE{Dinkelaker20111309,
  author = {Dinkelaker, T., Eichberg, M., Mezini, M.},
  title = {Incremental concrete syntax for embedded languages},
  year = {2011},
  pages = {1309-1316},
  note = {cited By (since 1996) 0},
  abstract = {Embedded domain-specific languages (EDSLs) are known to improve the
	productivity of developers. However, for many domains no DSL implementation
	is available. Two important reasons are: First, the effort to implement
	embedded DSLs that provide the domain's established syntax (called
	concrete syntax) is very high. Second, the embedded DSL and its underlying
	general-purpose programming language (GPL) are typically tightly
	integrated which hampers reusability across different GPLs. In this
	paper, we present an approach that significantly reduces the necessary
	effort to implement embedded DSLs with concrete syntax. The idea
	is to use island grammars to specify the EDSL's concrete syntax.
	This enables the developer to implement the embedded DSL as a library
	and to incrementally specify the concrete syntax using meta-data.
	Only those parts of the EDSL's grammar need to be specified that
	deviate from the grammar of the GPL and which is required to enable
	the integration with the GPL. © 2011 ACM.},
  affiliation = {Technische Universität Darmstadt, Germany},
  author_keywords = {domain-specific languages; generic pre-processor; language design
	and implementation; language embeddings; program transformation},
  document_type = {Conference Paper},
  journal = {Proceedings of the ACM Symposium on Applied Computing},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-79959309799&partnerID=40&md5=6a7761623800a16376b4571df4a9a043}
}

@CONFERENCE{Dinkelaker201049,
  author = {Dinkelaker, T., Eichberg, M., Mezini, M.},
  title = {An architecture for composing embedded domain-specific languages},
  year = {2010},
  pages = {49-60},
  note = {cited By (since 1996) 2},
  abstract = {Embedded domain-specific languages (EDSLs) are said to be easier to
	compose than DSLs that are implemented by preprocessors. However,
	existing approaches focus on composition scenarios where the use
	of abstractions from one domain does not affect the interpretation
	of abstractions from another domain. This leads to programs that
	exhibit scattering and tangling symptoms if multiple EDSLs with crosscutting
	domain semantics are used. To address this issue, we propose an architecture
	for embedding DSLs that makes use of meta-object protocols and aspect-oriented
	concepts to support crosscutting composition of EDSLs. This enables
	to write modularized EDSL programs where each program addresses one
	concern. Copyright 2010 ACM.},
  affiliation = {Technische Universität Darmstadt, Darmstadt, Germany},
  author_keywords = {Aspect-oriented programming; Embedded domain-specific languages; Meta-object
	protocols},
  document_type = {Conference Paper},
  journal = {AOSD.10 - 9th International Conference on Aspect-Oriented Software
	Development},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-77952270484&partnerID=40&md5=6c212f9995bf65426968413d84963578}
}

@CONFERENCE{Dinkelaker2008,
  author = {Dinkelaker, T., Mezini, M.},
  title = {Dynamically linked domain-specific extensions for advice languages},
  year = {2008},
  note = {cited By (since 1996) 0},
  abstract = {Domain-specific aspect languages allow defining aspects for a certain
	problem domain faster and easier by providing specialized expressivity
	and by reducing the complexity of the language interface. However,
	providing domain-specific aspect languages is a rather complex task.
	With current approaches only specialists can build new domain specific
	aspect languages; in doing so they have to replicate large parts
	of the tool set. In this paper, we have extended a general-purpose
	aspect language to support embedded domain-specific syntax in the
	advice language. The approach has several advantages. First, it allows
	reusing a large part of existing tools and infrastructure. Second
	domain-specific extensions can be defined in separated modules, which
	can be dynamically linked into the advice language; these modules
	can be inherited from, they can be refined from existing implementations,
	and can be composed to support abstractions from different domains.
	© 2008 ACM.},
  affiliation = {Darmstadt University of Technology, Hochschulstr. 10, 64289, Darmstadt,
	Germany},
  art_number = {3},
  author_keywords = {Domain-specific aspect languages; Embedded domain-specific languages;
	Languages},
  document_type = {Conference Paper},
  journal = {DSAL'08: Proceedings of the 2008 AOSD Workshop on Domain-specific
	Aspect Languages},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-65249103298&partnerID=40&md5=11e13e28df0dff94637d840236517e43}
}

@CONFERENCE{Dinkelaker20091,
  author = {Dinkelaker, T., Monperrus, M., Mezini, M.},
  title = {Untangling crosscutting concerns in domain-specific languages with
	domain-specific join points},
  year = {2009},
  pages = {1-5},
  note = {cited By (since 1996) 1},
  abstract = {Like programs written in general-purpose languages, programs written
	in DSLs may also suffer from tangling and scattering in the presence
	of domain-specific crosscutting concerns. This paper presents an
	architecture that supports aspect-oriented features for domain-specific
	base languages. Both base programs and advices are written in different
	domain-specific languages. The framework relies on the concept of
	domain-specific join point. Copyright 2009 ACM.},
  affiliation = {Technische Universität Darmstadt, Germany},
  author_keywords = {aspect-oriented programming; domain-specific languages; separation
	of concerns},
  document_type = {Conference Paper},
  journal = {Proceedings of the 4th Workshop on Domain-Specific Aspect Languages,
	DSAL '09, Co-located with the 8th International Conference on Aspect-Oriented
	Software Development, AOSD.09},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-77954016908&partnerID=40&md5=4b8414736b63fc705489429bd3a135a3}
}

@ARTICLE{Djuric201038,
  author = {Djuric, D.a , Devedzic, V.b },
  title = {Magic potion: Incorporating new development paradigms through metaprogramming},
  journal = {IEEE Software},
  year = {2010},
  volume = {27},
  pages = {38-44},
  number = {5},
  note = {cited By (since 1996) 0},
  abstract = {Today's applications require mixing and matching languages, platforms,
	and paradigms, which increases a solution's complexity. The authors
	propose a lighter approach that borrows a desired paradigm and incorporates
	it as an integral part of a preferred development environment. They've
	applied metaprogramming to internalize the ontology-modeling paradigm
	into a programming environment that's based on the Java ecosystem.
	Their method is also lightweight and suitable for small teams. They
	implemented an embedded domain-specific metalanguage, called Magic
	Potion, in the Clojure development environment, where it blends ontology,
	functional, object-oriented, and concurrent paradigms. © 2010 IEEE.},
  affiliation = {University of Belgrade, Serbia; Department of Computer Science, University
	of Belgrade, Belgrade, Serbia},
  art_number = {5473201},
  author_keywords = {domain engineering; domain-specific languages; metaprogramming; multiparadigm
	languages; ontology languages; programming languages; programming
	paradigms; programming techniques},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-77956033168&partnerID=40&md5=c0605b8d4cecab6d649b2324c1f27aa0}
}

@CONFERENCE{Djuric201083,
  author = {Djuric, D.a , Jovanovic, J.a , Devedzic, V.a , Sendelj, R.b },
  title = {Modeling ontologies as executable domain specific languages},
  year = {2010},
  pages = {83-92},
  note = {cited By (since 1996) 0},
  abstract = {Ontologies, one of the cornerstone technologies of the Semantic Web
	are a very expressive and powerful means for domain modeling. To
	become really usable and ubiquitous, the implementations of ontology
	languages yet have to deliver satisfactory performance and before
	anything else have to be developer-friendly. We present an example
	of using Magic Potion, a description logics-based domain specific
	meta-language for building executable domain models. We are using
	LOCO ontology framework developed to support personalised learning
	contexts in learning applications to illustrate how ontologies in
	the form of executable domain-specific languages can blend the Semantic
	Web ideas into classical software engineering to improve expressiveness
	of domain models. Copyright 2010 ACM.},
  affiliation = {University of Belgrade, FON, Jove Ilica 154, Belgrade, Serbia; Mediterranean
	University, Vaka Djurovica bb, Podgorica, Montenegro},
  author_keywords = {Domain-specific languages; Functional programming; Learning; Model-driven
	engineering; Ontologies},
  document_type = {Conference Paper},
  journal = {ISEC'10 - Proceedings of the 2010 India Software Engineering Conference},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-77951446973&partnerID=40&md5=63256098654698ad64bc39b728deb5f4}
}

@ARTICLE{Dodero2010332,
  author = {Dodero, J.M.a , del Val, Á.M.a , Torres, J.b },
  title = {An extensible approach to visually editing adaptive learning activities
	and designs based on services},
  journal = {Journal of Visual Languages and Computing},
  year = {2010},
  volume = {21},
  pages = {332-346},
  number = {6},
  note = {cited By (since 1996) 1},
  abstract = {Learning management systems (LMS) provide an operational environment
	in which an online course can be created and later executed. Inter-operation
	between creators and their authoring facilities, and the LMS execution
	engine are based on defining standards and specifications, such as
	the IMS Learning Design (LD). Because an LMS better serves as a course
	player than as a course creator, a large number of approaches and
	environments for standards-compliant course authoring have been developed.
	These approaches and environments propose a number of issues that
	deal with how adaptations are edited and how to define the connection
	of learning activities with external learning applications and services.
	These questions have raised concern, mostly because of the excessive
	commitment of the creators' methods and tools used with an educational
	modeling language, as well as the isolation of the language used
	to describe the course from the host LMS. This work describes an
	abstract, extendible language used to specify the learning design
	of a course, which can be transformed into any LD language as required
	by the execution environment. The language is used from a generative
	authoring environment that offers the possibility of editing web
	services as an additional resource to assess learning activities.
	© 2010 Elsevier Ltd.},
  affiliation = {Computer Languages and Systems Department, Universidad de Cádiz, C/
	Chile 1, 11002 Cádiz, Spain; Computing Systems Department, Instituto
	Tecnológico y de Estudio Superiores de Monterrey, Av. Epigmenio González
	500, Fracc. San Pablo, 76130 Santiago de Querétaro, Qro., Mexico},
  author_keywords = {Domain-specific languages; Learning design; Learning management systems},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-78149499605&partnerID=40&md5=fc5a511f6cf894c6d4e2a362ea8a14bf}
}

@ARTICLE{Doh200191,
  author = {Doh, K.-G.a , Mosses, P.D.b },
  title = {Composing programming languages by combining action-semantics modules},
  journal = {Electronic Notes in Theoretical Computer Science},
  year = {2001},
  volume = {44},
  pages = {91-113},
  number = {2},
  note = {cited By (since 1996) 2},
  abstract = {This article demonstrates a method for composing a programming language
	by combining action-semantics modules. Each module is defined separately,
	and then a new module is defined by either extending or combining
	existing modules. This method enables the language designer to gradually
	develop a language by selecting, extending and combining suitable
	language modules. The resulting modular structure is substantially
	different from that previously employed in action-semantic descriptions.
	We also discuss how to resolve the conflicts that may arise when
	combining modules, and indicate some advantages that action semantics
	has over other approaches in this respect. ©2001 Published by Elsevier
	Science B.V.},
  affiliation = {Department of Computer Science and Engineering, Hanyang University,
	Ansan, South Korea; BRICS and Department of Computer Science, University
	of Aarhus, Denmark},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-18944401742&partnerID=40&md5=4b2c7f9898bac1ed94d620bdef0cdaa2}
}

@CONFERENCE{Doran2008121,
  author = {Doran, S.},
  title = {Anima: A Ada derived programming language for real-time embedded
	software development},
  year = {2008},
  pages = {121-132},
  note = {cited By (since 1996) 0},
  abstract = {Currently, embedded programs are written in a variety of programming
	languages. None were specifically designed for the real-time environment.
	The use of a general purpose language for embedded systems can lead
	to inefficient applications which are more likely to fail to meet
	timing and execution requirements, or experience run-time errors
	that prove catastrophic for safety-critical systems. A domain specific
	language, in which real-time constructs are part of the language
	proper rather than hosted in a library, is likely to lessen the risks
	of implementation of tasks with strict real-time requirements. This
	paper outlines a Ada derived programming language called Anima that
	directly addresses many of the challenging issues of real-time embedded
	software development. Copyright 2008 ACM.},
  affiliation = {Northrop Grumman - Space and ISR Systems, 1100 Hollyvale St, Azusa,
	CA},
  author_keywords = {Embedded; Real-time; Reliability},
  document_type = {Conference Paper},
  journal = {Proceedings of the ACM SIGAda Annual International Conference; SIGAda},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-63549100031&partnerID=40&md5=17c36c18cf39e2eae1f1af7fe33c27e9}
}

@CONFERENCE{DosReis20102131,
  author = {Dos Reis, G., Stroustrup, B.},
  title = {General constant expressions for system programming languages},
  year = {2010},
  pages = {2131-2136},
  note = {cited By (since 1996) 0},
  abstract = {Most mainstream system programming languages provide support for builtin
	types, and extension mechanisms through userdefined types. They also
	come with a notion of constant expressions whereby some expressions
	(such as array bounds) can be evaluated at compile time. However,
	they require constant expressions to be written in an impoverished
	language with minimal support from the type system; this is tedious
	and error-prone. This paper presents a framework for generalizing
	the notion of constant expressions in modern system programming languages.
	It extends compile time evaluation to functions and variables of
	user-defined types, thereby including formerly ad hoc notions of
	Read Only Memory (ROM) objects into a general and type safe framework.
	It allows a programmer to specify that an operation must be evaluated
	at compile time. Furthermore, it provides more direct support for
	key meta programming and generative programming techniques. The framework
	is formalized as an extension of underlying type system with a binding
	time analysis. It was designed to meet real-world requirements. In
	particular, key design decisions relate to balancing expressive power
	to implementability in industrial compilers and teachability. It
	has been implemented for C++ in the GNU Compiler Collection, and
	is part of the next ISO C++ standard. © 2010 ACM.},
  affiliation = {Texas A and M University, United States},
  author_keywords = {compile time evaluation; standardization},
  document_type = {Conference Paper},
  journal = {Proceedings of the ACM Symposium on Applied Computing},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-77954720101&partnerID=40&md5=ff3ba4195dab6d2d85301c32e1fa09c2}
}

@ARTICLE{Doty200925,
  author = {Doty, D., Patitz, M.J.},
  title = {A domain-specific language for programming in the tile assembly model},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2009},
  volume = {5877 LNCS},
  pages = {25-34},
  note = {cited By (since 1996) 0},
  abstract = {We introduce a domain-specific language (DSL) for creating sets of
	tile types for simulations of the abstract Tile Assembly Model. The
	language defines objects known as tile templates, which represent
	related groups of tiles, and a small number of basic operations on
	tile templates that help to eliminate the error-prone drudgery of
	enumerating such tile types manually or with low-level constructs
	of general-purpose programming languages. The language is implemented
	as a class library in Python (a so-called internal DSL), but is presented
	independently of Python or object-oriented programming, with emphasis
	on support for a visual editing tool for creating large sets of complex
	tile types. © 2009 Springer-Verlag.},
  affiliation = {Department of Computer Science, Iowa State University, Ames, IA 50011,
	United States},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-71449121430&partnerID=40&md5=c60cf6cdbbddf2c87da6137a33fb99d2}
}

@ARTICLE{Draheim200529,
  author = {Draheim, D.a , Lutteroth, C.b , Weber, G.b},
  title = {Generative programming for C},
  journal = {ACM SIGPLAN Notices},
  year = {2005},
  volume = {40},
  pages = {29-33},
  number = {8},
  note = {cited By (since 1996) 3},
  abstract = {This article describes how we extended the C# language by new constructs
	that provide means for generative programming. Those constructs make
	it possible to handle problems like the generation of user interfaces
	and certain crosscutting concerns in a less error prone and elegant
	way without affecting the overall language integrity.},
  affiliation = {Institute of Computer Science, Freie Universität Berlin, Takustr.
	9, 14195 Berlin, Germany; Department of Computer Science, University
	of Auckland, 38 Princes Street, Auckland 1020, New Zealand},
  author_keywords = {Generative programming; Genericity; Reflection},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-33646121649&partnerID=40&md5=e1154a79d0cea65063fb0a3e6618abec}
}

@ARTICLE{DuBois2009170,
  author = {Du Bois, A.R., Echevarria, M.},
  title = {A domain specific language for composable memory transactions in
	Java},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2009},
  volume = {5658 LNCS},
  pages = {170-186},
  note = {cited By (since 1996) 0},
  abstract = {In this paper we present CMTJava, a domain specific language for composable
	memory transactions [7] in Java. CMTJava provides the abstraction
	of transactional objects. Transactional objects have their fields
	accessed only by special get and set methods that are automatically
	generated by the compiler. These methods return transactional actions
	as a result. A transactional action is an action that, when executed,
	will produce the desired effect. Transactional actions can only be
	executed by the atomic method. Transactional actions are first class
	values in Java and they are composable: transactions can be combined
	to generate new transactions. The Java type system guarantees that
	the fields of transactional objects will never be accessed outside
	a transaction. CMTJava supports the retry and orElse constructs from
	STM Haskell. To validate our design we implemented a simple transactional
	system following the description of the original Haskell system.
	CMTJava is implemented as a state passing monad using BBGA closures,
	a Java extension that supports closures in Java. © IFIP International
	Federation for Information Processing 2009.},
  affiliation = {PPGInf - Programa de Pós-Graduação em Informática, Universidade Católica
	de Pelotas, Pelotas-RS, CEP: 96010-000, Brazil},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-69049117370&partnerID=40&md5=8c12e76fbef2a8ffef45c5210dcbc0a2}
}

@ARTICLE{Ducasse2006604,
  author = {Ducasse, S.a b , Gîrba, T.a },
  title = {Using Smalltalk as a reflective executable meta-language},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2006},
  volume = {4199 LNCS},
  pages = {604-618},
  note = {cited By (since 1996) 0},
  abstract = {Object-oriented meta-languages such as MOF or EMOF are often used
	to specify domain specific languages. However, these meta-languages
	lack the ability to describe behavior or operational semantics. Several
	approaches have used a subset of Java mixed with OCL as executable
	meta-languages. In this paper, we report our experience of using
	Smalltalk as an executable meta-language. We validated this approach
	in incrementally building over the last decade, Moose, a meta-described
	reengineering environment. The reflective capabilities of Smalltalk
	support a uniform way of letting the developer focus on his tasks
	while at the same time allowing him to meta-describe his domain model.
	The advantage of our approach is that the developer uses the same
	tools and environment he uses for his regular tasks. © Springer-Verlag
	Berlin Heidelberg 2006.},
  affiliation = {Software Composition Group, University of Bern; Language and Software
	Evolution, LISTIC, Université de Savoie},
  author_keywords = {Meta behavior description; Reflective language; Smalltalk},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-33750337633&partnerID=40&md5=52f22961de93ff08ce630b6629cd89f2}
}

@ARTICLE{Dui2003148,
  author = {Dui, D., Emmerich, W.},
  title = {Compatibility of XML language versions},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2003},
  volume = {2649},
  pages = {148-162},
  note = {cited By (since 1996) 0},
  abstract = {Individual organisations as well as industry consortia are currently
	defining application and domain-specific languages using the extended
	Markup Language (XML) standard of the World Wide Web Consortium (W3C).
	The paper shows that XML languages differ in significant aspects
	from generic software engineering artifacts and that they therefore
	require a specific approach to version and configuration management.
	When an XML language evolves, consistency between the language and
	its instance documents needs to be preserved in addition to the internal
	consistency of the language itself. We propose a definition for compatibility
	between versions of XML languages that takes this additional need
	into account. Compatibility between XML languages in general is undecidable.
	We argue that the problem can become tractable using heuristic methods
	if the two languages are related in a version history. We propose
	to evaluate the method by using different versions of the Financial
	products Markup Language (FpML), in the definition of which we participate.
	© Springer-Verlag Berlin Heidelberg 2003.},
  affiliation = {Department of Computer Science, University College London, Gower Street,
	London WC1E 6BT, United Kingdom},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-35248884346&partnerID=40&md5=c86b35c645284d0aab796d93a456a8f4}
}

@ARTICLE{Duke200931,
  author = {Duke, D.J.a , Borgo, R.a , Wallace, M.b , Runciman, C.b },
  title = {Huge data but small programs: Visualization design via multiple embedded
	DSLs},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2009},
  volume = {5418 LNCS},
  pages = {31-45},
  note = {cited By (since 1996) 0},
  abstract = {Although applications of functional programming are diverse, most
	examples deal with modest amounts of data - no more than a few megabytes.
	This paper describes how Haskell has been used to address a challenging
	astrophysics visualization problem, where the complete uncompressed
	dataset is nearly a terabyte. Our solution makes extensive use of
	three novel domain-specific languages: to specify data resources,
	to abstract over rendering operations, and most significantly, to
	design the desired visualization. The result is a powerful framework
	for time-varying multi-field visualization. This approach represents
	a significant departure from standard practices in the visualization
	field, and has application well beyond the original problem. That
	our solution consists of less than 4.5K lines of code is itself a
	notable result. This paper motivates and describes the overall architecture
	of our solution, and technical features of the DSLs that are used
	in place of the traditional visualization pipeline. © 2009 Springer
	Berlin Heidelberg.},
  affiliation = {School of Computing, Uni. of Leeds, United Kingdom; Dept. of Computer
	Science, Uni. of York, United Kingdom},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-70350656154&partnerID=40&md5=e8edba7d5f41d2fe260ff0da60aa58ed}
}

@CONFERENCE{Dunning2011371,
  author = {Dunning, S.a , Sawyer, D.b },
  title = {A little language for rapidly constructing automated performance
	tests},
  year = {2011},
  pages = {371-380},
  note = {cited By (since 1996) 0},
  abstract = {In order to effectively measure the performance of large scale data
	management solutions at NetApp, we use a fully automated infrastructure
	to execute end-to-end system performance tests. Both the software
	and user requirements of this infrastructure are complex: the system
	under test runs a multi-protocol, highly specialized operating system
	and the infrastructure serves a diverse audience of developers, analysts,
	and field engineers (including both sales and support). In this paper
	we describe our approach to rapidly constructing automated performance
	system tests by using a lightweight, little, or domain-specific language
	called SLSL in order to more effectively express test specifications.
	Using a real world example, we illustrate the efficacy of SLSL in
	terms of its expressiveness, flexibility, and ease of use by showing
	a complex test configuration expressed with just a few language constructs.
	We also demonstrate how SLSL can be used in conjunction with our
	performance measurement lab to quickly deploy performance tests that
	yield highly repeatable measurements.},
  affiliation = {NetApp, Inc., Kit Creek Road, Research Triangle Park, NC 27709, United
	States; NetApp, Inc., 475 East Java Drive, Sunnyvale, CA 94089, United
	States},
  author_keywords = {Domain-specific language; Little language; Performance; Test automation},
  document_type = {Conference Paper},
  journal = {ICPE'11 - Proceedings of the 2nd Joint WOSP/SIPEW International Conference
	on Performance Engineering},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-79953844980&partnerID=40&md5=f1ce91436b91f655805ed54a52ed0176}
}

@CONFERENCE{Dupuy-Chessa2010362,
  author = {Dupuy-Chessa, S., Rieu, D., Mandran, N.},
  title = {Towards a community for information system design validation},
  year = {2010},
  volume = {3 ISAS},
  pages = {362-367},
  note = {cited By (since 1996) 0},
  abstract = {Information systems become ubiquitous. This opens a large spectrum
	of possibilities for end-users, but the design complexity is increasing.
	So domain specific languages are proposed sometimes supported by
	appropriate processes. These proposals are interesting but they are
	under-validated. Even if validation is a difficult task, which requires
	specific knowledge, we argue that validation should be systematic.
	But many problems remain to be considered to achieve this goal: 1)
	computer scientists are often not trained to evaluation; 2) the domain
	of information systems design validation and evaluation is still
	under construction. To cope with the first problem, we propose to
	capitalize evaluation practices into patterns so that they can be
	reusable for non-specialists of validation practices. For the second
	issue, we propose an environment where evaluation specialists and
	engineering methods specialists can work together to define their
	common and reusable patterns.},
  affiliation = {LIG Laboratory, CNRS, University of Grenoble, 681 rue de la Passerelle,
	38402 St Martin d'Hères, France},
  author_keywords = {Community; Design; Evaluation; Patterns; Validation},
  document_type = {Conference Paper},
  journal = {ICEIS 2010 - Proceedings of the 12th International Conference on
	Enterprise Information Systems},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-78649918689&partnerID=40&md5=0bd557bdae91f52bd5a9d00badb2eb5a}
}

@ARTICLE{Díaz2011237,
  author = {Díaz, O., Puente, G.},
  title = {A DSL for corporate wiki initialization},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2011},
  volume = {6741 LNCS},
  pages = {237-251},
  note = {cited By (since 1996) 1},
  abstract = {Some wikis support virtual communities that are built around the wiki
	itself (e.g., Wikipedia). By contrast, corporate wikis are not created
	in a vacuum since the community already exists. Documentation, organigrams,
	etc are all there by the time the wiki is created. The wiki should
	then be tuned to the existing information ecosystem. That is, wiki
	concerns (e.g., categories, permissions) are to be influenced by
	the corporate settings. So far, "all wikis are created equal": empty.
	This paper advocates for corporate wikis to be initialized with a
	"wiki scaffolding": a wiki installation where some categories, permissions,
	etc, are initialized to mimic the corporate settings. Such scaffolding
	is specified in terms of a Domain Specific Language (DSL). The DSL
	engine is then able to turn the DSL expression into a Media Wiki
	installation which is ready to be populated but now, along the company
	settings. The DSL is provided as a FreeMind plugin, and DSL expressions
	are denoted as mindmaps. © 2011 Springer-Verlag.},
  affiliation = {Onekin Research Group, University of the Basque Country, Spain},
  author_keywords = {dsl; information system; MDE; wiki},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-79960311381&partnerID=40&md5=6a2ef77b7cfc910561abffa4b0c156a1}
}

@ARTICLE{Díaz20091440,
  author = {Díaz, P., Guerra, E., Zarraonandía, T., Aedo, I., Padrón, C.L.},
  title = {A meta-modeling based approach for the multi-disciplinary design
	of web educational systems},
  journal = {Journal of Universal Computer Science},
  year = {2009},
  volume = {15},
  pages = {1440-1454},
  number = {7},
  note = {cited By (since 1996) 0},
  abstract = {Multi-disciplinary teams might provide a multi-faceted perspective
	of web educational systems that integrates experience from different
	fields. Each expert has a view of the system and she uses domain
	specific languages in order to express solutions to the problems
	she is concerned with. In this way, the final system can be seen
	as a combination of a number of complementary views, each of which
	focuses on problems of a different nature. However, such views are
	expressed with different specification tools so that they have to
	be integrated to produce a common design that is complete and consistent.
	Creating a common language encompassing multi-disciplinary design
	views is a challenging endeavor but it might impose a cognitive overload
	to each member of the group who is exposed to unfamiliar concepts
	of other disciplines in her design view. Alternatively, this paper
	describes an approach called MODUWEB that consists of letting each
	designer use the tool she is proficient in for her design tasks and
	then complementary design perspectives are integrated using meta-modeling
	techniques. MODUWEB also includes a number of constraints and semantic
	rules that guarantee the completeness and consistency of the resulting
	model. © J.UCS.},
  affiliation = {Computer Science Department, Universidad Carlos III de Madrid, Spain},
  author_keywords = {Educational design; Model-driven development; Multi-disciplinary design;
	Web design},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-68649114322&partnerID=40&md5=d341f6f20ba048316b7a27235cfd0639}
}

@ARTICLE{Efendy2000713,
  author = {Efendy, L.},
  title = {A Reference model of cad system generation from various object model-based
	specification description languages specific to individual domains},
  journal = {IEICE Transactions on Information and Systems},
  year = {2000},
  volume = {E83-D},
  pages = {713-721},
  number = {4},
  note = {cited By (since 1996) 2},
  abstract = {This paper proposes a reference model of CAD system generation, and
	describes its prototype implementation. The problems encountered
	in using CAD systems in industry involve complicated data handling
	and unsatisfied demands for domain knowledge because of the lack
	of a way of extracting and adopting it in the system. In the example
	domain of architecture, the authors have already defined domain-specific
	BDL (Building Design Language) for architecture experts to describe
	modelers of architectural structure in CAD systems by themselves.
	Moreover, the authors have developed a CAD system generator based
	on BDL descriptions. However, the different domain-specific languages
	required for individual domains create difficulty in developing various
	CAD system generators. The proposed reference model solves this problem
	by applying a common intermediate language based on the object model.
	Moreover, the model allows the creation of an integrated CAD system
	which contains multiple domains required by a field of industry.
	Its prototype implementation demonstrates its feasibility.},
  affiliation = {Faculty of Computer Science and Systems Engineering, Kyushu Institute
	of Technology, lizuka-shi, 820-8502, Japan},
  author_keywords = {Cad systems; Domain-specific language; Object model; Reference model;
	System generation},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-0033702076&partnerID=40&md5=4e64b2cdda20639984ee5ce1859a6b0b}
}

@CONFERENCE{ElKharbili2011247,
  author = {El Kharbili, M.a , Ma, Q.a b , Kelsen, P.a b , Pulvermueller, E.c
	},
  title = {CoReL: Policy-based and model-driven regulatory compliance management},
  year = {2011},
  pages = {247-256},
  note = {cited By (since 1996) 0},
  abstract = {Regulatory compliance management is now widely recognized as one of
	the main challenges still to be efficiently dealt with in information
	systems. In the discipline of business process management in particular,
	compliance is considered as an important driver of the efficiency,
	reliability and market value of companies. It consists of ensuring
	that enterprise systems behave according to some guidance provided
	in the form of regulations. This paper gives a definition of the
	research problem of regulatory compliance. We show why we expect
	a formal policy-based and model-driven approach to provide significant
	advantages in allowing enterprises to flexibly manage decision-making
	related to regulatory compliance. For this purpose, we contribute
	CoReL, a domain-specific modeling language for representing compliance
	requirements that has a graphical concrete syntax. Informal semantics
	of CoReL are introduced and its use is illustrated on an example.
	CoReL allows to leverage business process compliance modeling and
	checking, enhancing it with regard to, among other dimensions, user-friendliness,
	genericity, and traceability. © 2011 IEEE.},
  affiliation = {Laboratory for Advanced Software Systems, University of Luxembourg,
	Luxembourg; Interdisciplinary Centre for Security Reliability and
	Trust, University of Luxembourg, Luxembourg; Department of Mathematics
	and Computer Science, Institute of Computer Science, University of
	Osnabrueck, Germany},
  art_number = {6037578},
  author_keywords = {Business processes; Domain specific language; Policy; Regulatory compliance},
  document_type = {Conference Paper},
  journal = {Proceedings - IEEE International Enterprise Distributed Object Computing
	Workshop, EDOC},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-80054915001&partnerID=40&md5=fbbcd30dcd83e376476479f315042570}
}

@ARTICLE{Elliott1999291,
  author = {Elliott, C.},
  title = {An embedded modeling language approach to interactive 3d and multimedia
	animation},
  journal = {IEEE Transactions on Software Engineering},
  year = {1999},
  volume = {25},
  pages = {291-308},
  number = {3},
  note = {cited By (since 1996) 18},
  abstract = {While interactive multimedia animation is a very compelling medium,
	few people are able to express themselves in it. There are too many
	low-level details that have to do not with the desired content-e.g.,
	shapes, appearance and behavior-but rather how to get a computer
	to present the content. For instance, behaviors like motion and growth
	are generally gradual, continuous phenomena. Moreover, many such
	behaviors go on simultaneously. Computers, on the other hand, cannot
	directly accommodate either of these basic properties, because they
	do their work in discrete steps rather than continuously, and they
	only do one thing at a time. Graphics programmers have to spend much
	of their effort bridging the gap between what an animation is and
	how to present it on a computer. We propose that this situation can
	be improved by a change of language, and present Fran, synthesized
	by complementing an existing declarative host language, Haskell,
	with an embedded domain-specific vocabulary for modeled animation.
	As demonstrated in a collection of examples, the resulting animation
	descriptions are not only relatively easy to write, but also highly
	composable. © 1999 IEEE.},
  affiliation = {Microsoft Research, One Microsoft Way, Redmond, WA 98052., United
	States},
  author_keywords = {Animation; Domain-specific languages; Embedded languages; Functional
	programming; Graphics; Haskell; Multimedia; Temporal modeling},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-0032594249&partnerID=40&md5=4d57f3c12441efb1ec4180a17a97f467}
}

@ARTICLE{Elsner2010181,
  author = {Elsner, C.a , Ulbrich, P.b , Lohmann, D.b , Schröder-Preikschat,
	W.b },
  title = {Consistent product line configuration across file type and product
	line boundaries},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2010},
  volume = {6287 LNCS},
  pages = {181-195},
  note = {cited By (since 1996) 0},
  abstract = {Creating a valid software configuration of a product line can require
	laborious customizations involving multiple configuration file types,
	such as feature models, domain-specific languages, or preprocessor
	defines in C header files. Using configurable off-the-shelf components
	causes additional complexity. Without checking of constraints across
	file types boundaries already at configuration time, intricate inconsistencies
	are likely to be introduced-resulting in product defects, which are
	costly to discover and resolve later on. Up to now, at best ad-hoc
	solutions have been applied. To tackle this problem in a general
	way, we have developed an approach and a corresponding plug-in infrastructure.
	It allows for convenient definition and checking of constraints across
	configuration file types and product line boundaries. Internally,
	all configuration files are converted to models, facilitating the
	use of model-based constraint languages (e.g., OCL). Converter plug-ins
	for arbitrary configuration file types may be integrated and hide
	a large amount of complexity usually associated with modeling. We
	have validated our approach using a quadrotor helicopter product
	line comprising three sub-product-lines and four different configuration
	file formats. The results give evidence that our approach is practically
	applicable, reduces time and effort for product derivation (by avoiding
	repeated compiling, testing, and reconfiguration cycles), and prevents
	faulty software deployment. © 2010 Springer-Verlag Berlin Heidelberg.},
  affiliation = {Siemens Corporate Research and Technologies, Erlangen, Germany; Friedrich-Alexander
	University Erlangen-Nuremberg, Germany},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-78049379202&partnerID=40&md5=24d74ec37db87a4025c16e8e335783e1}
}

@CONFERENCE{Endresen2008651,
  author = {Endresen, J.a , Carlson, E.a , Moen, T.a , Alme, K.J.a , Haugen,
	Oø.b , Olsen, G.K.b , Svendsen, A.b },
  title = {Train control language - Teaching computers interlocking},
  year = {2008},
  volume = {103},
  pages = {651-660},
  note = {cited By (since 1996) 0},
  abstract = {Computer specialists are rarely trained in the world of tracks and
	trains, while signaling experts are rarely computer specialists.
	This paper is about bridging the gap between trains and computers
	with a specially designed language that enables the signaling experts
	to create consistent train interlocking systems. The language is
	supported by tailored tools created with open source technology on
	the development platform Eclipse. From the formal definition of the
	language in the form of a metamodel, a graphical editor is generated.
	The systems created with that graphic editor are then transformed
	for several purposes that are internally consistent. The editor makes
	sure that the systems conform to the language, and the language makes
	sure that the systems conform to the way interlockings are designed.
	The transformations then produce interlocking tables and even actual
	code automatically from the graphically created model.},
  affiliation = {ABB, Bergensveien 12, 1375 Billingstad, Norway; SINTEF, Forskningsveien
	1, Oslo, Norway},
  author_keywords = {Code generation; Computer Based Interlocking (CBI); Domain Specific
	Language (DSL); Eclipse; Interlocking},
  document_type = {Conference Paper},
  journal = {WIT Transactions on the Built Environment},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-58849155008&partnerID=40&md5=edbd745afae603a8fc222f2992353518}
}

@CONFERENCE{Englmeier2009321,
  author = {Englmeier, K.a , Koinig, R.b },
  title = {Decoupling configuration and deployment procedures by aspect-oriented
	policies},
  year = {2009},
  volume = {1},
  pages = {321-324},
  note = {cited By (since 1996) 0},
  abstract = {Model-driven development (MDD) has the potential to increase the level
	of cooperation in software design and adaptation between stakeholders
	from IT and business domains. Clear and understandable models can
	raise transparency of business-relevant key characteristics of software.
	Our approach addresses a domain-specific configuration language (DSCL)
	for the dynamic composition and adaptation of applications through
	configuration information. We concentrate on model representations
	that reflect individually tailored compositions of generic application
	modules and their adaptations to individual business needs. Our approach
	fosters the collaboration in defining application models on two different
	levels of abstraction. High-level model concepts focus on the definition
	of process aspects across modules. Low-level concepts cover the complementary
	role of definition and adaptation of low-level processes that are
	abstracted away in the high-level concepts.},
  affiliation = {Schmalkalden University of Applied Science, Faculty of Computer Science,
	Am Schwimmbad, Schmalkalden, Germany; Bwin Entertainment AG, Vienna,
	Austria},
  author_keywords = {Aspect-oriented metamodels; Configuration and deployment management;
	Domain-specific languages; Model-driven-design},
  document_type = {Conference Paper},
  journal = {ICSOFT 2009 - 4th International Conference on Software and Data Technologies,
	Proceedings},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-74549175168&partnerID=40&md5=5d61004daa4a66a8060a55580c816f61}
}

@CONFERENCE{Englmeier2009490,
  author = {Englmeier, K.a , Koinig, R.b },
  title = {Domain-specific deployment and configuration language for composition
	and adaptation of coarse-grained services},
  year = {2009},
  pages = {490-493},
  note = {cited By (since 1996) 0},
  abstract = {Domain-specific languages promise an unprecedented integration of
	business and IT aspects in software development. This translates
	into a stronger focus on user requirements, higher adaptability,
	and shorter time-to-market. DSLs provide the opportunity to bring
	business actors and IT experts closer together by raising the mutual
	understanding of the models underpinning software development. A
	closer cooperation in modeling improves the understanding of systems
	and allows for experimentation. Business actors can identify their
	business processes and resources in the models and can experiment
	with them. This paper presents work-in-progress addressing a model
	layer for the dynamic composition and adaptation of coarse-grained
	web services through configuration information. Our domain-specific
	configuration language (DSCL) enables IT experts and business actors
	to concentrate on model representations that reflect individually
	tailored compositions of generic portal services. Our approach fosters
	modeling on two different levels of abstraction. Business actors
	define high-level models focusing on the definition of processes
	across coarse-grained services. Low-level concepts complete technical
	aspects that are abstracted away in high-level concepts. © 2009 IEEE.},
  affiliation = {Fachhochschule Schmalkalden; Bwin Entertainment AG},
  art_number = {5283916},
  document_type = {Conference Paper},
  journal = {SCC 2009 - 2009 IEEE International Conference on Services Computing},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-74049094362&partnerID=40&md5=a65a7dc8133e89fb542622fa503adab1}
}

@CONFERENCE{Erche20071037,
  author = {Erche, M.a , Wagner, M.a , Hein, C.b },
  title = {Mapping visual notations to MOF compliant models with QVT relations},
  year = {2007},
  pages = {1037-1038},
  note = {cited By (since 1996) 0},
  abstract = {Model-centric methodologies rely on the definition of domain-specific
	modeling languages for being able to create domain-specific models.
	With MOF the OMG adopted a standard which provides the essential
	constructs for the definition of semantic language constructs (abstract
	syntax). However, there are no specifications on how to define the
	notations (concrete syntax) for abstract syntax elements. Usually,
	the concrete syntax of MOF compliant languages is described informally.
	We propose to define MOF-based metamodels for abstract syntax and
	concrete syntax and to connect them by model transformations specified
	with QVT Relations in a flexible, declarative way. Using a QVT based
	transformation engine one can easily implement a Model View Controller
	architecture by integrating modeling tools and metadata repositories.
	Copyright 2007 ACM.},
  affiliation = {IKV++ Technologies AG, Bernburger Strasse 24-25, Berlin, Germany;
	Fraunhofer Fokus, Kaiserin-Augusta-Allee 31, Berlin, Germany},
  author_keywords = {Domain specific languages; Model transformation; OCL; QVT relations;
	Visual languages},
  document_type = {Article},
  journal = {Proceedings of the ACM Symposium on Applied Computing},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-35248839448&partnerID=40&md5=42752cfaf6eaa41cfaa2c2b651c1edd2}
}

@CONFERENCE{Erdweg2011391,
  author = {Erdweg, S., Rendel, T., Kästner, C., Ostermann, K.},
  title = {Sugarj: Library-based syntactic language extensibility},
  year = {2011},
  pages = {391-406},
  note = {cited By (since 1996) 3},
  abstract = {Existing approaches to extend a programming language with syntactic
	sugar often leave a bitter taste, because they cannot be used with
	the same ease as the main extension mechanism of the programming
	language-libraries. Sugar libraries are a novel approach for syntactically
	extending a programming language within the language. A sugar library
	is like an ordinary library, but can, in addition, export syntactic
	sugar for using the library. Sugar libraries maintain the composability
	and scoping properties of ordinary libraries and are hence particularly
	well-suited for embedding a multitude of domain-specific languages
	into a host language. They also inherit self-applicability from libraries,
	which means that sugar libraries can provide syntactic extensions
	for the definition of other sugar libraries. To demonstrate the expressiveness
	and applicability of sugar libraries, we have developed SugarJ, a
	language on top of Java, SDF and Stratego, which supports syntactic
	extensibility. SugarJ employs a novel incremental parsing technique,
	which allows changing the syntax within a source file. We demonstrate
	SugarJ by five language extensions, including embeddings of XML and
	closures in Java, all available as sugar libraries. We illustrate
	the utility of selfapplicability by embedding XML Schema, a metalanguage
	to define XML languages. Copyright is held by the author / owner(s).},
  affiliation = {University of Marburg, Germany},
  author_keywords = {DSL embedding; Language composition; Language extensibility; Libraries;
	Sugarj; Syntactic sugar},
  document_type = {Conference Paper},
  journal = {Proceedings of the Conference on Object-Oriented Programming Systems,
	Languages, and Applications, OOPSLA},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-81355144631&partnerID=40&md5=07e49fc80f600a6c90edefd0fc0fa432}
}

@CONFERENCE{Erdweg2011167,
  author = {Erdweg, S.a , Kats, L.C.L.b , Rendel, T.a , Kästner, C.a , Ostermann,
	K.a , Visser, E.b },
  title = {Growing a language environment with editor libraries},
  year = {2011},
  pages = {167-176},
  note = {cited By (since 1996) 0},
  abstract = {Large software projects consist of code written in a multitude of
	different (possibly domain-specific) languages, which are often deeply
	interspersed even in single files. While many proposals exist on
	how to integrate languages semantically and syntactically, the question
	of how to support this scenario in integrated development environments
	(IDEs) remains open: How can standard IDE services, such as syntax
	highlighting, outlining, or reference resolving, be provided in an
	extensible and compositional way, such that an open mix of languages
	is supported in a single file? Based on our library-based syntactic
	extension language for Java, SugarJ, we propose to make IDEs extensible
	by organizing editor services in editor libraries. Editor libraries
	are libraries written in the object language, SugarJ, and hence activated
	and composed through regular import statements on a file-by-file
	basis. We have implemented an IDE for editor libraries on top of
	SugarJ and the Eclipse-based Spoofax language workbench. We have
	validated editor libraries by evolving this IDE into a fully-fledged
	and schema-aware XML editor as well as an extensible LATEX editor,
	which we used for writing this paper. Copyright © 2011 ACM.},
  affiliation = {University of Marburg, Germany; Delft University of Technology, Netherlands},
  author_keywords = {Dsl embedding; Language extensibility; Language workbench; Library},
  document_type = {Conference Paper},
  journal = {GPCE'11 - Proceedings of the 10th International Conference on Generative
	Programming and Component Engineering},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-81455154931&partnerID=40&md5=c79818a9e1a9d00a63fcc105951d24ab}
}

@CONFERENCE{Erfurth2007278,
  author = {Erfurth, C.a , Rossak, W.a , Schachtzabe, C.a , Hornbostel, D.b ,
	Skatulla, S.b },
  title = {Concepts of model driven software development in practice-Generic
	model representation and DSL interpretation},
  year = {2007},
  volume = {ISAS},
  pages = {278-286},
  note = {cited By (since 1996) 0},
  abstract = {This paper discusses possibilities to realize constructs of a domain
	specific model (DSL) on the concrete development and runtime platform
	Ibykus AP. Here software engineering takes advantage of a combination
	of generative techniques and stable so-called DSL interpreters. These
	techniques to implement model driven software development (MDSD)
	concepts can improve the flexibility, the quality and the performance
	of the development of large application systems. Presenting the DSL
	interpreter approach underlying techniques of generic repository
	structures to hold the software model as well as runtime configuration
	information are discussed. The importance of an associated clear
	and well structured interface and tuning alternatives for the repository
	are pointed out. Finally the paper concludes with an outlook to future
	research work.},
  affiliation = {Department of Computer Science, Friedrich Schiller University Jena,
	Ernst Abbe Platz 2, Jena, Germany; IBYKUSAG for Information Technology,
	Erfurt, Germany},
  author_keywords = {Domain specific language (DSL); DSL-Interpreter; Model driven software
	development (MDSD)},
  document_type = {Conference Paper},
  journal = {ICEIS 2007 - 9th International Conference on Enterprise Information
	Systems, Proceedings},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-70349576695&partnerID=40&md5=a074b0485be55db01d4fb8de700f8150}
}

@CONFERENCE{Erkök2009,
  author = {Erkök, L., Matthews, J.},
  title = {High assurance programming in cryptol},
  year = {2009},
  note = {cited By (since 1996) 0},
  abstract = {Cryptol is a domain specific language tailored for cryptographic algorithms
	(www.cryptol.net). Explicit support for program verification is an
	indispensable part of the Cryptol toolset, due to the inherent high-assurance
	requirements of the application domain. To this end, Cryptol comes
	with a suite of formal-methods based tools, allowing users to perform
	various program verification tasks. In this extended abstract, we
	provide an overview of the Cryptol language and its verification
	environment. The challenges in this domain are multifaceted: from
	the engineering concerns of providing an easy-to-use system for non-experts,
	to open research problems in program verification. Copyright © 2009
	ACM.},
  affiliation = {Galois, Inc., 421 SW 6th Ave., Portland, OR 97204, United States},
  art_number = {60},
  document_type = {Conference Paper},
  journal = {ACM International Conference Proceeding Series},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-70350700693&partnerID=40&md5=4a4bef4bed293b9b90b1a289c89e12db}
}

@ARTICLE{Ermel2008265,
  author = {Ermel, C.a , Ehrig, K.b },
  title = {Visualization, simulation and analysis of reconfigurable systems},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2008},
  volume = {5088 LNCS},
  pages = {265-280},
  note = {cited By (since 1996) 0},
  abstract = {Meta-modeling is well known to define the basic concepts of domain-specific
	languages in an object-oriented way. Based on graph transformation,
	an abstract meta-model may be enhanced with information on concrete
	visualization of objects and relations, and the language syntax is
	defined by a graph grammar. Moreover, graph transformation can also
	formalize the semantic aspects of models, thus providing a basis
	for model validation by simulation. Apart from editing and simulating
	the behavior of a system, there may be necessary reconfiguration
	operations which change the underlying system structure at runtime.
	In this paper, we focus on the interrelation of simulation and reconfiguration
	operations using formal verification techniques based on graph transformation.
	Our approach is demonstrated by the definition of a domain-specific
	language for building, simulating and reconfiguring small railway
	systems, using the Tiger tool environment. For further verification,
	we define a model transformation from the railway domain to Petri
	nets. © 2008 Springer Berlin Heidelberg.},
  affiliation = {Institut für Softwaretechnik und Theoretische Informatik, Technische
	Universität Berlin, Germany; Department of Computer Science, University
	of Leicester, United Kingdom},
  author_keywords = {Analysis; Graph transformation; Model transformation; Reconfigurable
	system; Simulation; Visualization},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-56749154971&partnerID=40&md5=fd0e1a52c2fc253e8f9535784bd00e67}
}

@ARTICLE{Erwig2005134,
  author = {Erwig, M., Kollmansberger, S.},
  title = {Modeling genome evolution with a DSEL for probabilistic programming},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2005},
  volume = {3819 LNCS},
  pages = {134-149},
  note = {cited By (since 1996) 0},
  abstract = {Many scientific applications benefit from simulation. However, programming
	languages used in simulation, such as C++ or Matlab, approach problems
	from a deterministic procedural view, which seems to differ, in general,
	from many scientists' mental representation. We apply a domain-specific
	language for probabilistic programming to the biological field of
	gene modeling, showing how the mental-model gap may be bridged. Our
	system assisted biologists in developing a model for genome evolution
	by separating the concerns of model and simulation and providing
	implicit probabilistic non-determinism. © Springer-Verlag Berlin
	Heidelberg 2006.},
  affiliation = {School of EECS, Oregon State University},
  author_keywords = {Functional Programming; Genome Evolution; Haskell; Probabilistic Programming},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-33745443795&partnerID=40&md5=633a34e30d4e8524f78d5f087b598ed3}
}

@ARTICLE{Erwig2009335,
  author = {Erwig, M., Walkingshaw, E.},
  title = {A DSL for explaining probabilistic reasoning},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2009},
  volume = {5658 LNCS},
  pages = {335-359},
  note = {cited By (since 1996) 1},
  abstract = {We propose a new focus in language design where languages provide
	constructs that not only describe the computation of results, but
	also produce explanations of how and why those results were obtained.
	We posit that if users are to understand computations produced by
	a language, that language should provide explanations to the user.
	As an example of such an explanation-oriented language we present
	a domain-specific language for explaining probabilistic reasoning,
	a domain that is not well understood by non-experts. We show the
	design of the DSL in several steps. Based on a story-telling metaphor
	of explanations, we identify generic constructs for building stories
	out of events, and obtaining explanations by applying stories to
	specific examples. These generic constructs are then adapted to the
	particular explanation domain of probabilistic reasoning. Finally,
	we develop a visual notation for explaining probabilistic reasoning.
	© IFIP International Federation for Information Processing 2009.},
  affiliation = {School of EECS, Oregon State University},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-69049103174&partnerID=40&md5=ee7a3e294aa995fda7416c9c71c559b0}
}

@ARTICLE{Esfahani2009591,
  author = {Esfahani, N., Malek, S., Sousa, J.P., Gomaa, H., Menascé, D.A.},
  title = {A Modeling Language for Activity-Oriented Composition of Service-Oriented
	Software Systems},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2009},
  volume = {5795 LNCS},
  pages = {591-605},
  note = {cited By (since 1996) 1},
  abstract = {The proliferation of smart spaces and emergence of new standards,
	such as Web Services, have paved the way for a new breed of software
	systems. Often the complete functional and QoS requirements of such
	software systems are not known a priori at design-time, and even
	if they are, they may change at run-time. Unfortunately, the majority
	of existing software engineering techniques rely heavily on human
	reasoning and manual intervention, making them inapplicable for automatic
	composition of such software systems at run-time. Moreover, these
	approaches are primarily intended to be used by technically knowledgeable
	software engineers, as opposed to domain users. In this paper, we
	present Service Activity Schemas (SAS), an activity-oriented language
	for modeling software system's functional and QoS requirements. SAS
	targets service-oriented software systems, and relies on an ontology
	to provide domain experts with modeling constructs that are intuitively
	understood. SAS forms the centerpiece of a framework intended for
	user-driven composition and adaptation of service-oriented software
	systems in a pervasive setting. We provide a detailed description
	of SAS in the context of a case study and formally specify its structural
	and dynamic properties. © 2009 Springer Berlin Heidelberg.},
  affiliation = {Department of Computer Science, George Mason University, Denmark},
  author_keywords = {Autonomic Computing; Domain Specific Modeling Languages; Model Driven
	Development; Pervasive Systems; Requirements Modeling},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-77249177242&partnerID=40&md5=7846fe2b80c1709103f3010ce96730ae}
}

@ARTICLE{Espinazo-Pagán2008185,
  author = {Espinazo-Pagán, J., Menárguez, M., García-Molina, J.},
  title = {Metamodel syntactic sheets: An approach for defining textual concrete
	syntaxes},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2008},
  volume = {5095 LNCS},
  pages = {185-199},
  note = {cited By (since 1996) 0},
  abstract = {The development process of Domain Specific Languages (DSL) can be
	tackled from different technical spaces such as XML, Grammarware
	or Model Driven Engineering (MDE). In the case of using MDE, the
	definition of a concrete syntax for a textual DSL requires commonly
	building a bridge between this technical space and Grammarware. Several
	bridging approaches have been recently proposed in which the existing
	coupling between concrete and abstract syntaxes causes information
	duplication in the development process of DSLs. Moreover, reusability
	of concrete syntaxes has received no attention in these approaches.
	In this paper we present the MSS (Metamodel Syntactic Sheets) approach
	for defining textual concrete syntaxes. MSS is intended to promote
	the reuse of textual concrete syntaxes and to avoid information duplication.
	In MSS, metamodels are annotated with syntactic properties and a
	propagation mechanism reduces the number of annotations required
	as well as the coupling between concrete and abstract syntaxes. Textual
	concrete syntaxes can be reused by annotating syntactically the metamodeling
	language. This reuse makes possible to share syntactic idioms (textual
	conventions) among different DSLs. © 2008 Springer-Verlag Berlin
	Heidelberg.},
  affiliation = {University of Murcia, Spain},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-70349869468&partnerID=40&md5=43b8109c68e94fbe8c7d85de66abf035}
}

@ARTICLE{Estevez2007217,
  author = {Estevez, E., Janowski, T.},
  title = {Programmable messaging for electronic government - building a foundation},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2007},
  volume = {4700 LNCS},
  pages = {217-236},
  note = {cited By (since 1996) 1},
  abstract = {Electronic Government offers citizens and businesses a single interface
	to all public services, implemented through cross-agency processes
	and applications. This paper presents a fragment of a software infrastructure
	that enables agencies to collaborate in the delivery of public services,
	responsible for automated, process-driven exchange of messages between
	applications. In addition to basic message exchange, the infrastructure
	supports high-level messaging through dynamically-enabled horizontal
	(process independent) and vertical (process dependent) extensions.
	In particular, the paper presents a fragment of a semantic model
	to formalize the process of specifying and implementing messaging
	extensions, and demonstrates a prototype implementation of this model
	to underpin a reliable delivery of government services. © Springer-Verlag
	Berlin Heidelberg 2007.},
  affiliation = {Center for Electronic Governance, United Nations University, International
	Institute for Software Technology, P.O. Box 3058, Macau, Brazil},
  author_keywords = {Asynchronous messaging; Domain specific languages; Electronic government;
	Messaging middleware; Software specification},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-38149111864&partnerID=40&md5=773b945165b1e3c6c5ca326c5ccb0397}
}

@ARTICLE{Estublier2010431,
  author = {Estublier, J., Leveque, T., Vega, G.},
  title = {Evolution control in MDE projects: Controlling model and code co-evolution},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2010},
  volume = {5961 LNCS},
  pages = {431-438},
  note = {cited By (since 1996) 0},
  abstract = {The dream of Model Driven Engineering (MDE) is that Software Engineering
	activities should be performed only on models, but in practice a
	significant amount of programming is still being performed. There
	is a clear need to keep code and models strongly synchronized when
	they represent the same entities at different levels of abstraction.
	We observe that versioning is ill supported by MDE tools, and that
	no strong synchronization is ensured between code and model versions.
	This, among other things, explains why MDE is not widely adopted
	in industry. This paper presents the solution developed in the CADSE
	project for providing consistent support for model and code co-evolution.
	It is shown that it requires to (1) define, what evolution policy
	is to be applied, (2) closely synchronize both ways, the model entities
	and the computer artifacts, and (3) enforce consistency constraints
	and evolution policies during the commit and check-out of both model
	elements and their corresponding artifacts. © 2010 Springer.},
  affiliation = {LIG-IMAG, 220, rue de la Chimie, 38041 Grenoble Cedex 9, France},
  author_keywords = {Composition of DSL interpreters; Composition of models; Domain Specific
	Languages (DSL); Metamodel-based environments},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-77949497858&partnerID=40&md5=73ea231ad694b9c6d80d80ac89b7d029}
}

@ARTICLE{Estublier200569,
  author = {Estublier, J., Vega, G., Ionita, A.D.},
  title = {Composing domain-specific languages for wide-scope software engineering
	applications},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2005},
  volume = {3713 LNCS},
  pages = {69-83},
  note = {cited By (since 1996) 7},
  abstract = {Domain-Specific Languages (DSL) offer many advantages over general
	languages, but their narrow scope makes them really effective only
	in very focused domains, for example Product Lines. The recent Model
	Driven Engineering (MDE) approach seeks to provide a technology to
	compose and combine models coming from different metamodels. Adapted
	to DSL, it means that it should be possible to compose "programs"
	written in different DSLs, which will enable the use of the DSL approach
	to build applications spanning different domains. The paper presents
	the Mélusine environment, where such a composition technology has
	been developed and experimented. © Springer-Verlag Berlin Heidelberg
	2005.},
  affiliation = {LSR-IMAG, 220, rue de la Chimie, Grenoble Cedex 9, France},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-33646187115&partnerID=40&md5=7591e81113e9229f33cbead46cb595e4}
}

@ARTICLE{Evermann200521,
  author = {Evermann, J.a , Wand, Y.b },
  title = {Toward formalizing domain modeling semantics in language syntax},
  journal = {IEEE Transactions on Software Engineering},
  year = {2005},
  volume = {31},
  pages = {21-37},
  number = {1},
  note = {cited By (since 1996) 29},
  abstract = {Information Systems are situated in and are representations of some
	business or organizational domain. Hence, understanding the application
	domain is critical to the success of information systems development.
	To support domain understanding, the application domain is represented
	in conceptual models. The correctness of conceptual models can affect
	the development outcome and prevent costly rework during later development
	stages. This paper proposes a method to restrict the syntax of a
	modeling language to ensure that only possible configurations of
	a domain can be modeled, thus increasing the likelihood of creating
	correct domain models. The proposed method, based on domain ontologies,
	captures relationships among domain elements via constraints on the
	language metamodel, thus restricting the set of statements about
	the domain that can be generated with the language. In effect, this
	method creates domain specific modeling languages from more generic
	ones. The method is demonstrated using the Unified Modeling Language
	(UML). Specifically, it is applied to the subset of UML dealing with
	object behavior and its applicability is demonstrated on a specific
	modeling example. © 2005 IEEE.},
  affiliation = {School of Information Management, Victoria University of Wellington,
	Wellington, New Zealand; Sauder School of Business, University of
	British Columbia, 2053 Main Mall, Vancouver, BC V6T 1Z2, Canada},
  author_keywords = {Analysis; CASE; Design concepts; Methodologies; Object-oriented design
	methods; Ontology; Specification},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-17644403480&partnerID=40&md5=1ea4861deb59461bc2fb1ca35c775277}
}

@CONFERENCE{Eysholdt2010307,
  author = {Eysholdt, M., Behrens, H.},
  title = {Xtext - Implement your language faster than the quick and dirty way
	tutorial summary},
  year = {2010},
  pages = {307-309},
  note = {cited By (since 1996) 0},
  abstract = {Whether there is an (emerging or legacy) Domain-Specific Language
	to increase the expressiveness of your coworkers or whether you are
	about to invent a new General Purpose Prgramming Language: Tool support
	that goes beyond a parser/compiler is essential to make other people
	adopt your language and to be more productive. Xtext is an award-winning1
	framework to build such tooling. In this tutorial we explain how
	to define a language and a statically typed, EMF-based Abstract Syntax
	Tree using only a grammar. We then generate a parser, a serializer
	and a smart editor from it. The editor provides many features out-of-the-box,
	such as syntax highlighting, content-assist, folding, jump-to-declaration
	and reverse-reference lookup across multiple files. Then, it is shown
	how literally every aspects of the language and its complementary
	tool support can be customized using Dependency Injection, especially
	how this can be done for linking, formatting and validation. As an
	outlook, we will demonstrate how to integrate a custom language with
	Java, how Xtext maintains a workspace-wide index of named elements
	and how to implement incremental code generation or attach an interpreter.
	© 2010 ACM.},
  affiliation = {Itemis AG, Germany},
  author_keywords = {DSL; Eclipse; EMF; MDSD; Modeling; Xtext},
  document_type = {Conference Paper},
  journal = {Proceedings of the ACM International Conference Companion on Object
	Oriented Programming Systems Languages and Applications Companion,
	SPLASH '10},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-78650158701&partnerID=40&md5=c5c7c0f4c46bd6c204ed6b21a41c51af}
}

@ARTICLE{Fabiano1996145,
  author = {Fabiano, A.S.a c , Cerri, S.A.b },
  title = {Concurrent, asynchronous search for the availability of knowledge},
  journal = {Applied Artificial Intelligence},
  year = {1996},
  volume = {10},
  pages = {145-161},
  number = {2},
  note = {cited By (since 1996) 1},
  abstract = {We describe how a common conceptual model of the application domain
	can be used to support a cooperative and concurrent search among
	loosely coupled knowledge sources distributed over a network with
	unknown topology. The introduction of a conceptual level, shared
	among all the knowledge sources in the net, allows us to obtain independence
	from the logical data organization of each node, not only from the
	physical, as is the case in distributed database management systems
	(DDBMS). The navigation process is based on the conceptual model
	and has been designed and developed by means of a set of cooperative
	agents, with specific knowledge and abilities, that reason about
	the local data and exchange information to ensure both the communication
	through the net and the information processing at each net node.
	In order to ensure the comprehension of the architecture, we include
	a worked-out example in the domain of pharmacology, where such a
	model and its associated domain-specific language have been realized.
	Copyright © 1996 Taylor & Francis.},
  affiliation = {CISE S.p.A, Segrate, Italy; Dipartimento di Scienze dell'Informazione,
	Università di Milano, Milano, Italy; CISE S.p.A, Via Reggio E milia,
	39-20090 Segrate (MI), Italy},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-0030108935&partnerID=40&md5=f45e1bdc64cf91224ef6cca69af597c6}
}

@CONFERENCE{Fabry2005428,
  author = {Fabry, J., Cleenewerck, T.},
  title = {Aspect-Oriented Domain Specific Languages for advanced transaction
	management},
  year = {2005},
  pages = {428-432},
  note = {cited By (since 1996) 3},
  abstract = {Transaction management has some known drawbacks, which have been researched
	in the past, and many solutions in the form of advanced transaction
	models have been proposed. However, these models are too difficult
	to be used by the application programmer because of their complexity
	and their lack of separation of concerns. In this paper we address
	this by letting the application programmer specify advanced transactions
	at a much higher abstraction level. To achieve this, we use the software
	engineering techniques of Aspect Oriented Programming and Domain-Specific
	Languages. This allows the programmer to declare advanced transactions
	separately in a concise specification which is much more straightforward.},
  affiliation = {Vrije Universiteit Brussel, Pleinlaan 2, 1050 Brussel, Belgium},
  author_keywords = {Aspect-oriented programming; Domain-specific languages; Software engineering;
	Transaction support},
  document_type = {Conference Paper},
  journal = {ICEIS 2005 - Proceedings of the 7th International Conference on Enterprise
	Information Systems},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-34547763861&partnerID=40&md5=0ef40d9fab65b634a0c0fb770be37b87}
}

@CONFERENCE{Fabry20061615,
  author = {Fabry, J., D'Hondt, T.},
  title = {KALA: Kernel aspect language for advanced transactions},
  year = {2006},
  volume = {2},
  pages = {1615-1620},
  note = {cited By (since 1996) 5},
  abstract = {Transaction management is a known cross-cutting concern. Previous
	research has been conducted to express this concern as an aspect.
	However, this work uses general-purpose aspect languages which lack
	a formal foundation and are unable to express advanced models for
	transaction management. In contrast, we designed a domain-specific
	aspect language for advanced transaction management, called KALA,
	that is based on a formalism for advanced transactions. As a result,
	KALA covers the field of advanced transaction management while obtaining
	a much higher level of abstraction than is achieved with general-purpose
	aspect languages. In this paper we detail the creation process of
	KALA. Copyright 2006 ACM.},
  affiliation = {Vrije Universiteit Brussel, Programming Technology Lab., Pleinlaan
	2, 1050 Brussel, Belgium},
  author_keywords = {ACTA; Advanced transaction management; Domain-specific languages},
  document_type = {Conference Paper},
  journal = {Proceedings of the ACM Symposium on Applied Computing},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-33751022056&partnerID=40&md5=6769b72fd1a34ec9567d4cf3fc472d38}
}

@ARTICLE{Fabry2008165,
  author = {Fabry, J.a , Tanter, É.a , D'Hondt, T.b },
  title = {KALA: Kernel aspect language for advanced transactions},
  journal = {Science of Computer Programming},
  year = {2008},
  volume = {71},
  pages = {165-180},
  number = {3},
  note = {cited By (since 1996) 4},
  abstract = {Transaction management is a known crosscutting concern. Previous research
	has been conducted to express this concern as an aspect. However,
	such work has used general-purpose aspect languages which lack a
	formal foundation, and most importantly are unable to express advanced
	models of transaction management. In this paper, we propose a domain-specific
	aspect language for advanced transaction management, called KALA,
	that overcomes these limitations. First, KALA is based on a recognized
	formalism for the domain of advanced transaction management, called
	ACTA. Second, as a consequence of being based on the ACTA formalism,
	KALA covers a wide variety of models for transaction management.
	Finally, being a domain-specific aspect language, KALA allows programmers
	to express their needs at a higher level of abstraction than what
	is achieved with general-purpose aspect languages. This paper reports
	on the design of KALA and its implementation over Java, based on
	the Reflex AOP kernel for domain-specific aspect languages. © 2008
	Elsevier B.V. All rights reserved.},
  affiliation = {PLEIAD Lab, Computer Science Department (DCC), University of Chile,
	Blanco Encalada 2120, Santiago, Chile; Vrije Universiteit Brussel,
	Programming Technology Lab, Pleinlaan 2, 1050 Brussel, Belgium},
  author_keywords = {ACTA; Advanced transaction management; Domain-specific languages;
	Reflex},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-44249108549&partnerID=40&md5=0a17a8301b0e71136a1847ca3657ff41}
}

@ARTICLE{Falcon200958,
  author = {Falcon, J., Cook, W.R.},
  title = {Gel: A generic extensible language},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2009},
  volume = {5658 LNCS},
  pages = {58-77},
  note = {cited By (since 1996) 1},
  abstract = {Both XML and Lisp have demonstrated the utility of generic syntax
	for expressing tree-structured data. But generic languages do not
	provide the syntactic richness of custom languages. Generic Extensible
	Language (Gel) is a rich generic syntax that embodies many of the
	common syntactic conventions for operators, grouping and lists in
	widely-used languages. Prefix/infix operators are disambiguated by
	white-space, so that documents which violate common white-space conventions
	will not necessarily parse correctly with Gel. With some character
	replacements and adjusting for mismatch in operator precedence, Gel
	can extract meaningful structure from typical files in many languages,
	including Java, Cascading Style Sheets, Smalltalk, and ANTLR grammars.
	This evaluation shows the expressive power of Gel, not that Gel can
	be used as a parser for existing languages. Gel is intended to serve
	as a generic language for creating composable domain-specific languages.
	© IFIP International Federation for Information Processing 2009.},
  affiliation = {Department of Computer Science, University of Texas, Austin},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-69049086734&partnerID=40&md5=b581daf87ab697a6d11b070e72fa6176}
}

@ARTICLE{Falcou2008729,
  author = {Falcou, J.a , Sérot, J.b , Pech, L.c , Lapresté, J.-T.b },
  title = {Meta-programming applied to automatic SMP parallelization of linear
	algebra code},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2008},
  volume = {5168 LNCS},
  pages = {729-738},
  note = {cited By (since 1996) 1},
  abstract = {We describe a software solution to the problem of automatic parallelization
	of linear algebra code on multi-processor and multi-core architectures.
	This solution relies on the definition of a domain specific language
	for matrix computations, a performance model for multi-processor
	architectures and its implementation using C++ template meta-programming.
	Experimental results asses this model and its implementation on sample
	computation kernels. © 2008 Springer-Verlag Berlin Heidelberg.},
  affiliation = {IEF, Université Paris Sud, Orsay, France; LASMEA, Université Blaise
	Pascal, Clermont-Ferrand, France; Ecole Normale Supérieure, Paris,
	France},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-51849106962&partnerID=40&md5=14659f7797643ad7db62ed34355b6af7}
}

@ARTICLE{Farwick2010278,
  author = {Farwick, M.a , Agreiter, B.a , White, J.b , Forster, S.a , Lanzanasto,
	N.a , Breu, R.a },
  title = {A web-based collaborative metamodeling environment with secure remote
	model access},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2010},
  volume = {6189 LNCS},
  pages = {278-291},
  note = {cited By (since 1996) 0},
  abstract = {This contribution presents GEMSjax - a web-based metamodeling tool
	for the collaborative development of domain specific languages. By
	making use of modern Web 2.0 technologies like Ajax and REST services,
	the tool allows for simultaneous web browser-based creation/editing
	of metamodels and model instances, as well as secure remote model
	access via REST, which enables remote model modification over a simple
	HTTP-based interface. This paper describes the complex technical
	challenges we faced and solutions we produced to provide browser-based
	synchronous model editing. It further explains on the XACML-based
	access control mechanisms to provide secure remote access to models
	and model elements. Additionally, we highlight the usefulness of
	our approach by describing its application in a realistic usage scenario.
	© 2010 Springer-Verlag.},
  affiliation = {Institute of Computer Science, University of Innsbruck, Austria; Electrical
	Engineering and Computer Science, Vanderbilt University, Nashville,
	TN, United States},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-77955027607&partnerID=40&md5=5e85c9b1416828b25e5cd287b8109bbf}
}

@CONFERENCE{Felderer2009152,
  author = {Felderer, M.a , Breu, R.a , Chimiak-Opoka, J.a , Breu, M.b , Schupp,
	F.c },
  title = {Concxsepts for model-based requirements testing of service oriented
	systems},
  year = {2009},
  pages = {152-157},
  note = {cited By (since 1996) 0},
  abstract = {In this paper we present the core concepts of Telling Test-Stories,
	a model - driven framework for test - driven requirements testing
	of service oriented systems. Telling TestSto-ries provides a new
	way of eliciting and validating requirements through intertwined
	specification of requirements and executable test stories. We define
	a Domain Specific Language (DSL) to formalize the system requirements
	and the test model. The DSL allows test cases to be specified based
	on the concepts of the requirements specification (actors, objects,
	services) and test cases to be separated from test data. To ensure
	the quality of the designed artifacts we introduce consistency and
	coverage checks expressed in OCL. We provide a prototypic implementation
	of the concepts and started an industrial validation of its usability.},
  affiliation = {Institute of Computer Science, University of Innsbruck, Innsbruck,
	Austria; Arctis Software Technology GmbH, Inzing, Austria; Softmethod
	GmbH, Munich, Germany},
  author_keywords = {Domain specific languages; Model-based testing; Quality assurance;
	Requirements engineering; Service oriented systems},
  document_type = {Conference Paper},
  journal = {Proceedings of the IASTED International Conference on Software Engineering,
	SE 2009},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-74549160235&partnerID=40&md5=f3a757d806f7f7ea670834cbd5ca2e8c}
}

@ARTICLE{Felfernig2000449,
  author = {Felfernig, A., Friedrich, G.E., Jannach, D.},
  title = {UML as domain specific language for the construction of knowledge-based
	configuration systems},
  journal = {International Journal of Software Engineering and Knowledge Engineering},
  year = {2000},
  volume = {10},
  pages = {449-469},
  number = {4},
  note = {cited By (since 1996) 22},
  abstract = {In many domains, software development has to meet the challenges of
	developing highly adaptable software very rapidly. In order to accomplish
	this task, domain specific, formal description languages and knowledge-based
	systems are employed. From the viewpoint of the industrial software
	development process, it is important to integrate the construction
	and maintenance of these systems into standard software engineering
	processes. In addition, the descriptions should be comprehensible
	for the domain experts in order to facilitate the review process.
	For the realization of product configuration systems, we show how
	these requirements can be met by using a standard design language
	(UML-Unified Modeling Language) as notation in order to simplify
	the construction of a logic-based description of the domain knowledge.
	We show how classical description concepts for expressing configuration
	knowledge can be introduced into UML and be translated into logical
	sentences automatically. These sentences are exploited by a general
	inference engine solving the configuration task.},
  affiliation = {Inst. Wirtschaftsinformatik A., University of Klagenfurt, 9020 Klagenfurt,
	Austria},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-0034240808&partnerID=40&md5=688cc7cd76717278a93678ded0e68bde}
}

@CONFERENCE{Fernandes20101306,
  author = {Fernandes, D.D., Cardoso, F.R.M., Montini, D.Á., Supino, F.M., Tasinaffo,
	P.M., Dias, L.A.V.},
  title = {An algorithm model to mapping mealy machines for a software manufacture
	cell Petri net},
  year = {2010},
  pages = {1306-1308},
  note = {cited By (since 1996) 0},
  abstract = {This paper shows how to use the state machines and systematic approaches
	for modeling software to help improve the consistency of the model,
	verification and validation of an analysis area through a Domain
	Specific Language (Domain Specifical Language - DSL), in addition
	to the refinement of the business process (since the mapping of domain
	analysis and process of business development). The main objective
	of this approach is how to obtain systematically a DSL from a domain
	analysis that may be using the system code compliance to all Business
	Rules outlined, and no documents and settings very complex. Many
	problems of Systems Computer Software (Computer Software Systems-CSS)
	are derived from a specification with and without its behavior defined.
	To resolve these problems, business rules will be treated since its
	formalization to its construction and testing. In this context, Petri
	Nets provide a graphical description technique easy to understand
	and, closed to state-transition diagrams. Parallelism, concurrency
	and sincronization are easy to model in a Petri net. Add to this,
	many techniques and tools (in software) are available for the analysis
	of Petri nets. However, too much formalization can bring problems
	to software development and the time and cost grow. Furthermore it
	is suggested that formal methods have fewer errors than the heuristic
	methods. © 2010 IEEE.},
  affiliation = {Brazilian Aeronautics Institute of Tecnology - ITA, Brazil},
  art_number = {5501574},
  author_keywords = {And state machines; Domain analysis; DSL; Formal methods; Petri nets},
  document_type = {Conference Paper},
  journal = {ITNG2010 - 7th International Conference on Information Technology:
	New Generations},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-77955287608&partnerID=40&md5=236b54a16ebed4815b69d1271fe97fef}
}

@ARTICLE{Fernández2007133,
  author = {Fernández, M.a , Fisher, K.a , Nathan Foster, J.b , Greenberg, M.a
	b , Mandelbaum, Y.a },
  title = {A generic programming toolkit for PADS/ML: First-class upgrades for
	third-party developers},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2007},
  volume = {4902 LNCS},
  pages = {133-149},
  note = {cited By (since 1996) 1},
  abstract = {Domain-specific languages facilitate solving problems in a targeted
	domain by providing features particular to the domain. Declarative
	domain-specific languages have the additional benefit that users
	specify what something means rather than how to do something. As
	a result, the language compiler is free to choose the best implementation
	strategies and to generate multiple artifacts from a single description.
	PADS/ML is a declarative data description language designed to facilitate
	ad hoc data management. From a single description, the compiler generates
	a myriad of artifacts, including data structures for the in-memory
	representation of the data and parsers and printers. In this paper,
	we describe a new generic programming infrastructure for PADS/ML
	that allows third-party developers to define additional useful artifacts
	without modifying the compiler. We report on two case studies that
	use this infrastructure. In the first, we build a version of PADX
	for PADS/ML, allowing any data source with a PADS/ML description
	to be queried as if it were XML. In the second, we extend Harmony
	with the ability to synchronize any data with a PADS/ML description.
	© Springer-Verlag Berlin Heidelberg 2008.},
  affiliation = {AT and T Research; University of Pennsylvania},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-38549110838&partnerID=40&md5=c084574ea37abca36c05d4664309f7b9}
}

@CONFERENCE{Ferreira2009434,
  author = {Ferreira, J.C.A.},
  title = {MDAI: Model based design in automobile industry},
  year = {2009},
  pages = {434-439},
  note = {cited By (since 1996) 0},
  abstract = {It is proposed a new approach based on a methodology, assisted by
	a tool, to create new products in the automobile industry based on
	previous defined processes and experiences inspired on a set of best
	practices or principles: it is based on high-level models or specifications;
	it is componentbased architecture centric; it is based on generative
	programming techniques. This approach follows in essence the MDA
	(Model Driven Architecture) philosophy with some specific characteristics.
	We propose a repository that keeps related information, such as models,
	applications, design information, generated artifacts and even information
	concerning the development process itself (e.g., generation steps,
	tests and integration milestones). Generically, this methodology
	receives the users' requirements to a new product (e.g., functional,
	non-functional, product specification) as its main inputs and produces
	a set of artifacts (e.g., design parts, process validation output)
	as its main output, that will be integrated in the engineer design
	tool (e.g. CAD system) facilitating the work. © 2009 IEEE.},
  affiliation = {GuIAA-ISEL, Rua Conselheiro Emídio Navarro 1, 1900-049 Lisboa, Portugal},
  art_number = {5195843},
  document_type = {Conference Paper},
  journal = {IEEE International Conference on Industrial Informatics (INDIN)},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-71049171700&partnerID=40&md5=4adf876d56760bb12c4a38d6550deb63}
}

@CONFERENCE{Ferreira2007,
  author = {Ferreira, J.a , Silva, A.b , Delgado, J.c },
  title = {A methodology to design information retrieval systems (MDIRS)},
  year = {2007},
  note = {cited By (since 1996) 0},
  abstract = {MDIRS is methodology to define the actors and the steps to build efficiently
	information retrieval (IR) System. MDRIS main mission is to analyze,
	develop and evaluate mechanisms and tools to produce IR systems from
	a more abstract, high level, efficient and productive way than it
	is done currently. MDIRS project is influenced by MDA reference model,
	and is mainly based on three principles: namely, high-level models
	specification; generative programming techniques; and it is component-based
	architecture-centric. In this paper we detail the methodology generative
	programming techniques used to produce IR Systems and the work that
	will be handled in the near future.},
  affiliation = {ISEL, Lisbon, Portugal; Inesc-ID, IST, Lisbon, Portugal; IST, Lisbon,
	Portugal},
  art_number = {a63},
  document_type = {Conference Paper},
  journal = {Euro American Conference on Telematics and Information Systems -
	Proceedings of the 2007 Euro American Conference on Telematics and
	Information Systems, EATIS 2007},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-56749175509&partnerID=40&md5=b2b1d3c338221c25cb0eaa441fd06604}
}

@CONFERENCE{Ferreira2007171,
  author = {Ferreira, J.a , Silva, A.b , Delgado, J.c },
  title = {IR-case tool},
  year = {2007},
  pages = {171-176},
  note = {cited By (since 1996) 0},
  abstract = {We propose a new approach based on a methodology assisted by a IR-Case
	tool for the creation of IR (Information Retrieval) systems inspired
	on a set of best practices or principles: it is based on high-level
	models or specifications; it is component-based architecture centric;
	it is based on generative programming techniques. This approach follows
	in essence the MDA (Model Driven Architecture) philosophy with some
	specific characteristics. We propose a repository that keeps related
	information, such as models, applications, software architectures,
	generated artifacts and even information concerning the software
	process itself (e.g., generation steps, tests and integration milestones).
	Generically, this methodology receives system requirements (e.g.,
	functional, non-functional and development requirements) as its main
	input, and produces a set of artifacts (e.g., source code, configuration
	scripts or data scripts) as its main output, that will be linked
	in the IRCase tool proposed, generating the IR-System. These aspects
	are implemented in a tool (IR-Case tool), providing a roadmap where
	designers can follow as well as model-to-model transformation templates
	in order to accelerate their system development tasks. This step
	facilitates the construction and consequently will contribute for
	the personalized IR-Systems and also a test platform for IR-Algorithms
	and IR-Process.},
  affiliation = {ISEL; INESC-ID; IST},
  author_keywords = {Case tool; MDA; Retrieval information; UML},
  document_type = {Conference Paper},
  journal = {Proceedings of the IASTED International Conference on Software Engineering,
	SE 2007},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-56149090365&partnerID=40&md5=04a2b04366f1c8a6d81799e731ccdeb8}
}

@CONFERENCE{Figueroa2009745,
  author = {Figueroa, P.},
  title = {InTml: A case study on virtual reality development},
  year = {2009},
  pages = {745-746},
  note = {cited By (since 1996) 0},
  abstract = {We present the Interaction Techniques Markup Language (InTml), a case
	study of the use of Domain Specific Languages (DSLs), Model Driven
	Development (MDD), and Software Product Lines (SPL) in the field
	of Virtual Reality (VR) applications, a challenging domain due a
	wide variety of hardware platforms, computational limitations, and
	available solutions. We use existing technologies around the Eclipse
	Platform in order to create an IDE in which families of VR applications
	can be generated and played.},
  affiliation = {Universidad de Los Andes, Colombia},
  author_keywords = {InTml; Virtual reality development},
  document_type = {Conference Paper},
  journal = {Proceedings of the Conference on Object-Oriented Programming Systems,
	Languages, and Applications, OOPSLA},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-72249115427&partnerID=40&md5=3266cf2b077ecc660168860b0b9d5743}
}

@ARTICLE{Figueroa2007760,
  author = {Figueroa, P., Florez, C.},
  title = {Easying MR development with eclipse and InTml},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2007},
  volume = {4842 LNCS},
  pages = {760-769},
  number = {PART 2},
  note = {cited By (since 1996) 0},
  abstract = {This paper shows our work in progress towards an easy to use development
	environment for Mixed Reality (MR) Applications. We argue that development
	of MR applications is a collaboration between interaction designers
	who know about user requirements, and expert developers who know
	the intricacies of MR development. This collaboration should be supported
	by tools that aid both roles and ease their communication. We also
	argue that real MR development should allow easy migration from one
	hardware setup to another, since hardware greatly varies in these
	type of applications, and it is important to fit a solution to the
	particular user's requirements and context. We show the foundational
	concepts in our work and current Integrated Development Environment
	(IDE) implementation. This work is based on InTmI, a domain specific
	language for MR applications, and Eclipse, an open source, general
	purpose IDE. © Springer-Verlag Berlin Heidelberg 2007.},
  affiliation = {Universidad de Los Andes, Colombia},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-38149011492&partnerID=40&md5=724cfb8033046a2b41b41d8aef15e210}
}

@CONFERENCE{Fisher2006111,
  author = {Fisher, D.a , Shivers, O.b },
  title = {Static analysis for syntax objects},
  year = {2006},
  volume = {2006},
  pages = {111-121},
  note = {cited By (since 1996) 1},
  abstract = {We describe an s-expression based syntax-extension framework much
	like Scheme macros, with a key additional facility: the ability to
	define static semantics, such as type systems or program analysis,
	for the new, user-defined forms or embedded languages, thus allowing
	us to construct "towers" of language levels. In addition, the static
	semantics of the languages at two adjacent levels in the tower can
	be connected, allowing improved reasoning power at a higher (and
	perhaps more restricted) level to be reflected down to the static
	semantics of the language level below. We demonstrate our system
	by designing macros for an assembly language, together with some
	example static analyses (termination analysis, type inference and
	control-flow analysis).},
  affiliation = {Georgia Institute of Technology, United States; Northeastern University,
	United States},
  author_keywords = {Domain-specific languages; Extensible programming languages; Flow
	analysis; Language towers; Lazy delegation; Macros; Static analysis;
	Type inference},
  document_type = {Conference Paper},
  journal = {Proceedings of the ACM SIGPLAN International Conference on Functional
	Programming, ICFP},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-34247182110&partnerID=40&md5=ee45a46329f0d0ea74f2d197c76675b6}
}

@ARTICLE{Fisher200862,
  author = {Fisher, K.},
  title = {We need more than one : Why students need a sophisticated understanding
	of programming languages},
  journal = {ACM SIGPLAN Notices},
  year = {2008},
  volume = {43},
  pages = {62-65},
  number = {11},
  note = {cited By (since 1996) 0},
  abstract = {Over the course of their careers, students will need to master a number
	of diverse programming languages because different languages are
	best suited to different tasks and because the set of "popular" languages
	evolves over time. In addition, sometimes the best way to solve a
	problem is to invent a little language particular to the task. Students
	need to be able to evaluate which languages to use for which tasks
	and whether to design a domain-specific language. Consequently, it
	is critical that students develop a sophisticated understanding of
	programming languages during their undergraduate studies. © 2008
	ACM.},
  affiliation = {ATandT Labs Research},
  author_keywords = {Programming languages curriculum},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-67049171642&partnerID=40&md5=74cd63d63ad3398b2bd52e4c26069c01}
}

@CONFERENCE{Fisher200739,
  author = {Fisher, K.},
  title = {Typing ad hoc data},
  year = {2007},
  pages = {39-40},
  note = {cited By (since 1996) 0},
  abstract = {Traditionally, types describe the internal data manipulated by programs.
	To accommodate the variety of desired data structures, language designers
	and type theorists have developed a wide variety of types and type
	constructors. But not all useful data is in programs; in fact, enormous
	amounts of it sit on disks or stream by on wires in a dizzying array
	of encodings and formats. It turns out that many of the types developed
	for internal data can be used to describe external data: tuples,
	records, unions, options, and lists come to mind as obvious examples.
	Perhaps more surprisingly, recursive types, singletons, functions,
	parametric polymorphism, and dependent types are relevant as well.
	Using types to describe external data leads naturally to the insight
	that we can reuse the same type to define an internal data structure
	and to generate parsing and printing functions to map between the
	two representations. The PADS project [1] has exploited this idea,
	building data description languages based on the type structure of
	C (PADS/C) [3] and on ML (PADS/ML) [5] and exploring the theoretical
	basis for such languages with the Data Description Calculus (DDC)
	[4]. Other groups have also leveraged this insight, most closely
	the work on DataScript [2] and Packet-Types [6]. Continuing the analogy,
	it turns out that other concepts from the types world are also relevant
	to ad hoc data processing, including generic programming, type inference,
	type isomorphisms, and subtyping. In this talk, I will describe the
	domain of ad hoc data processing and explain how types enable precise
	descriptions of such data. I will then explore the question of type
	inference, describing quantitative techniques we are currently developing
	to construct a description of ad hoc data given example instances.
	© 2007 ACM.},
  affiliation = {AT and T Labs. Research},
  author_keywords = {Ad hoc data; Data description languages; Dependent types; Domain-specific
	languages},
  document_type = {Conference Paper},
  journal = {Proceedings of the TLDI 2007: 2007 ACM SIGPLAN International Workshop
	on Types in Languages Design and Implementation - Papers Presented
	at the Workshop},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-34548319656&partnerID=40&md5=4923f23632aadade218dd7490fadd281}
}

@CONFERENCE{Fisher2005295,
  author = {Fisher, K.a b , Gruber, R.a b },
  title = {PADS: A domain-specific language for processing Ad hoc data},
  year = {2005},
  pages = {295-304},
  note = {cited By (since 1996) 28},
  abstract = {PADS is a declarative data description language that allows data analysts
	to describe both the physical layout of ad hoc data sources and semantic
	properties of that data. From such descriptions, the PADS compiler
	generates libraries and tools for manipulating the data, including
	parsing routines, statistical profiling tools, translation programs
	to produce well-behaved formats such as XML or those required for
	loading relational databases, and tools for running XQueries over
	raw PADS data sources. The descriptions are concise enough to serve
	as "living" documentation while flexible enough to describe most
	of the ASCII, binary, and Cobol formats that we have seen in practice.
	The generated parsing library provides for robust, application-specific
	error handling. Copyright 2005 ACM.},
  affiliation = {AT and T Labs. Research, 180 Park Ave., E244, Florham Park, NJ; Google,
	1600 Amphitheatre Pkwy, Mountain View, CA},
  author_keywords = {Data description language; Domain-specific languages},
  document_type = {Conference Paper},
  journal = {Proceedings of the ACM SIGPLAN Conference on Programming Language
	Design and Implementation (PLDI)},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-31844436571&partnerID=40&md5=efacc5293b97864aeef002d412fa87d2}
}

@CONFERENCE{Fisher2011,
  author = {Fisher, K.a , Foster, N.b , Walker, D.c , Zhu, K.Q.d },
  title = {Forest: A language and toolkit for programming with filestores},
  year = {2011},
  pages = {292-306},
  note = {cited By (since 1996) 0},
  abstract = {A filestore is a structured collection of data files housed in a conventional
	hierarchical file system. Many applications use filestores as a poor-man's
	database, and the correct execution of these applications requires
	that the collection of files, directories, and symbolic links stored
	on disk satisfy a variety of precise invariants. Moreover, all of
	these structures must have acceptable ownership, permission, and
	timestamp attributes. Unfortunately, current programming languages
	do not provide support for documenting assumptions about filestores,
	detecting errors in them, or safely loading from and storing to them.
	This paper describes the design, implementation, and semantics of
	Forest, a new domain-specific language for describing filestores.
	The language uses a type-based metaphor to specify the expected structure,
	attributes, and invariants of filestores. Forest generates loading
	and storing functions that make it easy to connect data on disk to
	an isomorphic representation in memory that can be manipulated as
	if it were any other data structure. Forest also generates metadata
	that describes the degree to which the structures on the disk conform
	to the specification, making error detection easy. In a nutshell,
	Forest extends the rigorous discipline of typed programming languages
	to the untyped world of file systems. We have implemented Forest
	as an embedded domain-specific language in Haskell. In addition to
	generating infrastructure for reading, writing and checking file
	systems, our implementation generates type class instances that make
	it easy to build generic tools that operate over arbitrary filestores.We
	illustrate the utility of this infrastructure by building a file
	system visualizer, a file access checker, a generic query interface,
	description-directed variants of several standard UNIX shell tools
	and (circularly) a simple Forest description inference engine. Finally,
	we formalize a core fragment of Forest in a semantics inspired by
	classical tree logics and prove round-tripping laws showing that
	the loading and storing functions behave sensibly. Copyright © 2011
	ACM.},
  affiliation = {Tufts University, United States; Cornell University, United States;
	Princeton University, United States; Shanghai Jiao Tong University,
	China},
  author_keywords = {Ad hoc data; Bidirectional transformations; Data description languages;
	Domain-specific languages; File systems; Filestores; Generic programming;
	Haskell},
  document_type = {Conference Paper},
  journal = {Proceedings of the ACM SIGPLAN International Conference on Functional
	Programming, ICFP},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-80054062487&partnerID=40&md5=4c03a360876daf053cc9d0c194b9575a}
}

@ARTICLE{Fisher2011292,
  author = {Fisher, K.a , Foster, N.b , Walker, D.c , Zhu, K.Q.d },
  title = {Forest: A language and toolkit for programming with filestores},
  journal = {ACM SIGPLAN Notices},
  year = {2011},
  volume = {46},
  pages = {292-306},
  number = {9},
  note = {cited By (since 1996) 0},
  abstract = {A filestore is a structured collection of data files housed in a conventional
	hierarchical file system. Many applications use filestores as a poor-man's
	database, and the correct execution of these applications requires
	that the collection of files, directories, and symbolic links stored
	on disk satisfy a variety of precise invariants. Moreover, all of
	these structures must have acceptable ownership, permission, and
	timestamp attributes. Unfortunately, current programming languages
	do not provide support for documenting assumptions about filestores,
	detecting errors in them, or safely loading from and storing to them.
	This paper describes the design, implementation, and semantics of
	Forest, a new domain-specific language for describing filestores.
	The language uses a type-based metaphor to specify the expected structure,
	attributes, and invariants of filestores. Forest generates loading
	and storing functions that make it easy to connect data on disk to
	an isomorphic representation in memory that can be manipulated as
	if it were any other data structure. Forest also generates metadata
	that describes the degree to which the structures on the disk conform
	to the specification, making error detection easy. In a nutshell,
	Forest extends the rigorous discipline of typed programming languages
	to the untyped world of file systems. We have implemented Forest
	as an embedded domain-specific language in Haskell. In addition to
	generating infrastructure for reading, writing and checking file
	systems, our implementation generates type class instances that make
	it easy to build generic tools that operate over arbitrary filestores.We
	illustrate the utility of this infrastructure by building a file
	system visualizer, a file access checker, a generic query interface,
	description-directed variants of several standard UNIX shell tools
	and (circularly) a simple Forest description inference engine. Finally,
	we formalize a core fragment of Forest in a semantics inspired by
	classical tree logics and prove round-tripping laws showing that
	the loading and storing functions behave sensibly. Copyright © 2011
	ACM.},
  affiliation = {Tufts University, United States; Cornell University, United States;
	Princeton University, United States; Shanghai Jiao Tong University,
	China},
  author_keywords = {Ad hoc data; Bidirectional transformations; Data description languages;
	Domain-specific languages; File systems; Filestores; Generic programming;
	Haskell},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-80053362080&partnerID=40&md5=f71a6769a2fa50875148733f8e142c3b}
}

@ARTICLE{Fisher2005,
  author = {Fisher, K.a , Gruber, R.b },
  title = {PADS: A domain-specific language for processing ad hoc data},
  journal = {ACM SIGPLAN Notices},
  year = {2005},
  volume = {40},
  pages = {295-304},
  number = {6},
  note = {cited By (since 1996) 18},
  abstract = {PADS is a declarative data description language that allows data analysts
	to describe both the physical layout of ad hoc data sources and semantic
	properties of that data. From such descriptions, the PADS compiler
	generates libraries and tools for manipulating the data, including
	parsing routines, statistical profiling tools, translation programs
	to produce well-behaved formats such as XML or those required for
	loading relational databases, and tools for running XQueries over
	raw PADS data sources. The descriptions are concise enough to serve
	as "living" documentation while flexible enough to describe most
	of the ASCII, binary, and Cobol formats that we have seen in practice.
	The generated parsing library provides for robust, application-specific
	error handling. Copyright 2005 ACM.},
  affiliation = {AT and T Labs Research, 180 Park Ave., E244, Florham Park, NJ; Google,
	1600 Amphitheatre Pkwy, Mountain View, CA},
  author_keywords = {Data description language; Domain-specific languages},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-33745288758&partnerID=40&md5=28d9bee06b5805914bbd51874d03ee82}
}

@ARTICLE{Fisher2010,
  author = {Fisher, K.a , Mandelbaum, Y.a , Walker, D.b },
  title = {The next 700 data description languages},
  journal = {Journal of the ACM},
  year = {2010},
  volume = {57},
  number = {2},
  note = {cited By (since 1996) 6},
  abstract = {In the spirit of Landin, we present a calculus of dependent types
	to serve as the semantic foundation for a family of languages called
	data description languages. Such languages, which include pads, datascript,
	and packettypes, are designed to facilitate programming with ad hoc
	data, that is, data not in well-behaved relational or xml formats.
	In the calculus, each type describes the physical layout and semantic
	properties of a data source. In the semantics, we interpret types
	simultaneously as the in-memory representation of the data described
	and as parsers for the data source. The parsing functions are robust,
	automatically detecting and recording errors in the data stream without
	halting parsing. We show the parsers are type-correct, returning
	data whose type matches the simple-type interpretation of the specification.
	We also prove the parsers are error-correct, accurately reporting
	the number of physical and semantic errors that occur in the returned
	data. We use the calculus to describe the features of various data
	description languages, and we discuss how we have used the calculus
	to improve pads. © 2010 ACM.},
  affiliation = {AT and T Labs Research, Building 103, 180 Park Avenue, Florham Park,
	NJ 07932, United States; Princeton University, Princeton, NJ 08544,
	United States},
  art_number = {10},
  author_keywords = {Ad hoc data formats; Context-sensitive grammars; Data description
	languages; Data processing; Data-dependent grammars; Dependent types;
	Domain-specific languages; PADS; Parsing},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-76849092260&partnerID=40&md5=0baa9f9544daae92a8c7d040092996ff}
}

@CONFERENCE{Fisher2006,
  author = {Fisher, K.a , Mandelbaum, Y.b , Walker, D.b },
  title = {The next 700 data description languages},
  year = {2006},
  pages = {2-15},
  note = {cited By (since 1996) 9},
  abstract = {In the spirit of Landin, we present a calculus of dependent types
	to serve as the semantic foundation for a family of languages called
	data description languages. Such languages, which include PADS, DATASCRIPT,
	and PACKETTYPES, are designed to facilitate programming with ad hoc
	data, i.e., data not in well-behaved relational or XML formats. In
	the calculus, each type describes the physical layout and semantic
	properties of a data source. In the semantics, we interpret types
	simultaneously as the in-memory representation of the data described
	and as parsers for the data source. The parsing functions are robust,
	automatically detecting and recording errors in the data stream without
	halting parsing. We show the parsers are type-correct, returning
	data whose type matches the simple-type interpretation of the specification.
	We also prove the parsers are "error-correct," accurately reporting
	the number of physical and semantic errors that occur in the returned
	data. We use the calculus to describe the features of various data
	description languages, and we discuss how we have used the calculus
	to improve PADS. Copyright © 2006 ACM.},
  affiliation = {AT and T Labs. Research; Princeton University},
  author_keywords = {Data description language; Dependent types; Domain-specific languages},
  document_type = {Conference Paper},
  journal = {Conference Record of the Annual ACM Symposium on Principles of Programming
	Languages},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-33745830891&partnerID=40&md5=30e9e5f95471b37b9fe91a79641ae32f}
}

@ARTICLE{Fisher20062,
  author = {Fisher, K.a , Mandelbaum, Y.b , Walker, D.b },
  title = {The next 700 data description languages},
  journal = {ACM SIGPLAN Notices},
  year = {2006},
  volume = {41},
  pages = {2-15},
  number = {1},
  note = {cited By (since 1996) 9},
  abstract = {In the spirit of Landin, we present a calculus of dependent types
	to serve as the semantic foundation for a family of languages called
	data description languages. Such languages, which include PADS, DATASCRIPT,
	and PACKETTYPES, are designed to facilitate programming with ad hoc
	data, i.e., data not in well-behaved relational or XML formats. In
	the calculus, each type describes the physical layout and semantic
	properties of a data source. In the semantics, we interpret types
	simultaneously as the in-memory representation of the data described
	and as parsers for the data source. The parsing functions are robust,
	automatically detecting and recording errors in the data stream without
	halting parsing. We show the parsers are type-correct, returning
	data whose type matches the simple-type interpretation of the specification.
	We also prove the parsers are "error-correct," accurately reporting
	the number of physical and semantic errors that occur in the returned
	data. We use the calculus to describe the features of various data
	description languages, and we discuss how we have used the calculus
	to improve PADS. Copyright © 2006 ACM.},
  affiliation = {AT and T Labs. Research; Princeton University},
  author_keywords = {Data description language; Dependent types; Domain-specific languages},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-33745214242&partnerID=40&md5=ec6b4c7a6c1b84a7dea555b4b74cb82c}
}

@CONFERENCE{Fisher201111,
  author = {Fisher, K.a , Walker, D.b },
  title = {The PADS project: An overview},
  year = {2011},
  pages = {11-17},
  note = {cited By (since 1996) 0},
  abstract = {The goal of the PADS project, which started in 2001, is to make it
	easier for data analysts to extract useful information from ad hoc
	data files. This paper does not report new results, but rather gives
	an overview of the project and how it helps bridge the gap between
	the unmanaged world of ad hoc data and the managed world of typed
	programming languages and databases. In particular, the paper reviews
	the design of PADS data description languages, describes the generated
	parsing tools and discusses the importance of meta-data. It also
	sketches the formal semantics, discusses useful tools and how can
	they can be generated automatically from PADS descriptions, and describes
	an inferencing system that can learn useful PADS descriptions from
	positive examples of the data format. © 2011 ACM.},
  affiliation = {AT and T Labs Research, United States; Princeton University, United
	States},
  author_keywords = {Ad hoc data; Data description languages; Domain-specific languages},
  document_type = {Conference Paper},
  journal = {ACM International Conference Proceeding Series},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-79952323192&partnerID=40&md5=5ff7c520a61a1bb682287be7f89f2515}
}

@ARTICLE{Fisler200866,
  author = {Fisler, K.},
  title = {Implementing domain-specific languages as the foundation of an honors
	intro CS course},
  journal = {ACM SIGPLAN Notices},
  year = {2008},
  volume = {43},
  pages = {66-70},
  number = {11},
  note = {cited By (since 1996) 0},
  abstract = {This position paper describes an honors introductory Computer Science
	course focused on designing and implementing domain-specific programming
	languages. The course presents programming language design as a fundamental
	tool for software engineering. Students build languages for prototypes
	of several nontrivial products (such as PowerPoint and TurboTax).
	The course aims to convey fundamental ideas behind programming languages
	in a form that mainstream Computer Science students can appreciate
	early in their careers. The paper includes descriptions of and links
	to assignments and course materials. © 2008 ACM.},
  affiliation = {WPI Department of Computer Science, Worcester MA, USA},
  author_keywords = {Programming languages curriculum},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-67049134473&partnerID=40&md5=5dd268d75b2088478c8182f436256c6c}
}

@ARTICLE{FisterJr.2011151,
  author = {Fister Jr., I., Mernik, M., Brest, J.},
  title = {Design and implementation of domain-specific language easytime},
  journal = {Computer Languages, Systems and Structures},
  year = {2011},
  volume = {37},
  pages = {151-167},
  number = {4},
  note = {cited By (since 1996) 0},
  abstract = {Measuring time in mass sporting competitions is, typically, performed
	with a timing system that consists of a measuring technology and
	a computer system. The first is dedicated to tracking events that
	are triggered by competitors and registered by measuring devices
	(primarily based on RFID technology). The latter enables the processing
	of these events. In this paper, the processing of events is performed
	by an agent that is controlled by the domain-specific language, EasyTime.
	EasyTime improves the flexibility of the timing system because it
	supports the measuring of time in various sporting competitions,
	their quick adaptation to the demands of new sporting competitions
	and a reduction in the number of measuring devices. Essentially,
	we are focused on the development of a domain specific language.
	In practice, we made two case studies of using EasyTime by measuring
	time in two different sporting competitions. The use of EasyTime
	showed that it can be useful for sports clubs and competition organizers
	by aiding in the results of smaller sporting competitions, while
	in larger sporting competitions it could simplify the configuration
	of the timing system. © 2011 Elsevier Ltd. All rights reserved.},
  affiliation = {University of Maribor, Faculty of Electrical Engineering and Computer
	Science, Smetanova 17, 2000 Maribor, Slovenia},
  author_keywords = {Domain-specific language; RFID technology; Timing system},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-80053314288&partnerID=40&md5=c87501a705bcfd3ff8dcbfaf975fbb3b}
}

@ARTICLE{Fleischmann200731,
  author = {Fleischmann, T.},
  title = {Model based HMI specification in an automotive context},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2007},
  volume = {4557 LNCS},
  pages = {31-39},
  number = {PART 1},
  note = {cited By (since 1996) 0},
  abstract = {An overview of how a model based specification approach can be used
	in the domain of automotive human machine interface (HMI) development
	is presented. The common paper based specification approach is compared
	to a model based, tool supported process. Requirements from different
	stakeholders for such an approach are outlined. Intended audiences
	are all stakeholders involved in the creation of graphical user interfaces
	ranging from design, usability engineering, and prototyping to specification
	and final product realization. © Springer-Verlag Berlin Heidelberg
	2007.},
  affiliation = {Elektrobit, Frauenweiherstr. 14, 91058 Erlangen, Germany},
  author_keywords = {Code generation; Domain specific language; HMI specification; Model
	based},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-38149052898&partnerID=40&md5=3b21e669c3b92b920e892bea51ca122b}
}

@ARTICLE{Fleurey2009606,
  author = {Fleurey, F., Solberg, A.},
  title = {A domain specific modeling language supporting specification, simulation
	and execution of dynamic adaptive systems},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2009},
  volume = {5795 LNCS},
  pages = {606-621},
  note = {cited By (since 1996) 1},
  abstract = {Constructing and executing distributed systems that can automatically
	adapt to the dynamic changes of the environment are highly complex
	tasks. Non-trivial challenges include provisioning of efficient design
	time and run time representations, system validation to ensure safe
	adaptation of interdependent components, and scalable solutions to
	cope with the possible combinatorial explosions of adaptive system
	artifacts such as configurations, variant dependencies and adaptation
	rules. These are all challenges where current approaches offer only
	partial solutions. Furthermore, in current approaches the adaptation
	logic is typically specified at the code level, tightly coupled with
	the main system functionality, making it hard to control and maintain.
	This paper presents a domain specific modeling language (DSML) allowing
	specification of the adaptation logic at the model level, and separation
	of the adaptation logic from the main system functionality. It supports
	model-checking and design-time simulation for early validation of
	adaptation policies. The model level specifications are used to generate
	the adaptation logic. The DSML also provides indirection mechanisms
	to cope with combinatorial explosions of adaptive system artifacts.
	The proposed approach has been implemented and validated through
	case studies. © 2009 Springer Berlin Heidelberg.},
  affiliation = {SINTEF, Oslo, Norway},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-77249177857&partnerID=40&md5=5d3df04d651474a3e20c21ab2f45ca0e}
}

@CONFERENCE{Fogarty2007112,
  author = {Fogarty, S.a , Pasalic, E.a , Siek, J.b , Taha, W.a },
  title = {Concoqtion: Indexed types now!},
  year = {2007},
  pages = {112-121},
  note = {cited By (since 1996) 8},
  abstract = {Almost twenty years after the pioneering efforts of Cardelli, the
	programming languages community is vigorously pursuing ways to incorporate
	F-style indexed types into programming languages. This paper advocates
	Concoqtion, a practical approach to adding such highly expressive
	types to full-fledged programming languages. The approach is applied
	to MetaOCaml using the Coq proof checker to conservatively extend
	Hindley-Milner type inference. The implementation of MetaOCaml Concoqtion
	requires minimal modifications to the syntax, the type checker, and
	the compiler; and yields a language comparable in notation to the
	leading proposals. The resulting language provides unlimited expressiveness
	in the type system while maintaining decidability. Furthermore, programmers
	can take advantage of a wide range of libraries not only for the
	programming language but also for the indexed types. Programming
	in MetaOCaml Concoqtion is illustrated with small examples and a
	case study implementing a statically-typed domain-specific language.
	Copyright © 2007 ACM.},
  affiliation = {Rice University; University of Colorado},
  document_type = {Conference Paper},
  journal = {Proceedings of the ACM SIGPLAN Symposium on Partial Evaluation and
	Semantics-Based Program Manipulation},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-35348823663&partnerID=40&md5=5e356661e98ce3751185df0cf416bbdf}
}

@CONFERENCE{Foley2010483,
  author = {Foley, C., Power, G., Griffin, L., Chen, C., Donnelly, N., De Leastar,
	E.},
  title = {Service group management facilitated by DSL driven policies in embedded
	middleware},
  year = {2010},
  pages = {483-488},
  note = {cited By (since 1996) 0},
  abstract = {Middleware by its very nature is fundamental to the functioning of
	systems as it provides the communication between software components.
	It is very much an underlying technology and is rarely visible to
	end users. As systems develop, certain domain semantics, provided
	by the domain experts, need to be injected into the behaviour of
	the underlying middleware, but in a controlled manner. The methods
	used to achieve this are often static in nature, wholly dependent
	on how they are implemented, deployed and managed. An increasingly
	popular way to manage this behaviour injection is through the use
	of policies, a technique used to govern defined rules, triggered
	by associated events, resulting in specific actions when certain
	conditions are encountered. Strong efforts have been made throughout
	the evolution of software development methods and programming languages
	to solve the lack of dynamicity which can arise through poor practices.
	Successive language based attempts to attain a higher level of abstraction
	in the notations used and techniques deployed have resulted in the
	re-discovery of Domain Specific Languages (DSL). This paper looks
	at injecting the dynamicity required in the management of service
	groups through a policy based DSL. © 2010 IEEE.},
  affiliation = {Telecommunications Software and Systems Group, Waterford Institute
	of Technology, Waterford, Ireland},
  art_number = {5546775},
  author_keywords = {Domain Specific Language; Group communication; Middleware; Policy
	Engine; Services},
  document_type = {Conference Paper},
  journal = {Proceedings - IEEE Symposium on Computers and Communications},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-77956501327&partnerID=40&md5=92185e45a854ac75001ed709a1caa625}
}

@ARTICLE{Fondement2005190,
  author = {Fondement, F., Baar, T.},
  title = {Making metamodels aware of concrete syntax},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2005},
  volume = {3748 LNCS},
  pages = {190-204},
  note = {cited By (since 1996) 12},
  abstract = {Language-centric methodologies, triggered by the success of Domain
	Specific Languages, rely on precise specifications of modeling languages.
	While the definition of the abstract syntax is standardized by the
	4-layer metamodel architecture of the OMG, most language specifications
	are held informally for the description of the semantics and the
	(graphical) concrete syntax. This paper is tackling the problem of
	specifying the concrete syntax of a language in a formal and non-ambiguous
	way. We propose to define the concrete syntax by an extension of
	the already existing metamodel of the abstract syntax, which describes
	the concepts of the language, with a second layer describing the
	graphical representation of concepts by visual elements. In addition,
	an intermediate layer defines how elements of both layers are related
	to each other. Unlike similar approaches that became the basis of
	some CASE tools, the intermediate layer is not a pure mapping from
	abstract to concrete syntax but connects both layers in a flexible,
	declarative way. We illustrate our approach with a simplified form
	of statecharts. © Springer-Verlag Berlin Heidelberg 2005.},
  affiliation = {École Polytechnique Fédérale de Lausanne (EPFL), School of Computer
	and Communication Sciences, CH-1015 Lausanne, Switzerland},
  author_keywords = {Concrete Syntax Description; Metamodeling; MOF; OCL; UML; Visual Languages},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-33646495970&partnerID=40&md5=e769e9856679a3175289708b6b0d527b}
}

@CONFERENCE{Fontijne2006141,
  author = {Fontijne, D.},
  title = {Gaigen 2: A geometric algebra implementation generator},
  year = {2006},
  pages = {141-150},
  note = {cited By (since 1996) 1},
  abstract = {Geometric Algebra (GA) is an algebra that encodes geometry much better
	than standard techniques, which are mainly based on linear algebra
	with various extensions. Compared to standard techniques, GA has
	clearer semantics and a richer, more consistent language. This expresses
	itself, among others, in a much greater genericity of functions over
	the algebra. Exploiting this genericity efficiently is a problem
	that can be solved through generative programming.This paper describes
	our Geometric Algebra Implementation Generator Gaigen 2. Gaigen 2
	synthesizes highly efficient GA implementations from the specification
	of the algebra. Functions over such algebras can be defined in a
	high-level coordinate-free domain-specific language, and Gaigen 2
	transforms these functions into low-level coordinate-based code.
	This code can be emitted in any target language through a custom
	back-end. Benchmarks of our implementation show that the combination
	of GA and Gaigen 2 can rival the performance of standard geometry
	techniques, despite the greater abstraction and genericity of GA.To
	obtain this high performance, Gaigen 2 must adapt the generated code
	to the program that links to it. This is done via a profiling feedback
	loop. While running, the generated code makes a connection to the
	code generator. The generated code sends information about functions
	that should be optimized. The code generator registers this information
	and sends back new type information. After the program terminates,
	the code is regenerated according to the recorded profile. This profiling
	feedback technique may also be useful to implement other types of
	algebras. Copyright © 2006 ACM.},
  affiliation = {University of Amsterdam},
  author_keywords = {Conformal model; Geometric algebra; Object-oriented; Profiling program
	transformation; Synthesis from specification},
  document_type = {Conference Paper},
  journal = {Proceedings of the 5th International Conference on Generative Programming
	and Component Engineering, GPCE'06},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-34547417045&partnerID=40&md5=63057c8df7e28718f894ff72eb8423f4}
}

@ARTICLE{Fontoura2000109,
  author = {Fontoura, M.a b , Braga, C.a , Moura, L.a , Lucena, C.a },
  title = {Using domain specific languages to instantiate object-oriented frameworks},
  journal = {IEE Proceedings: Software},
  year = {2000},
  volume = {147},
  pages = {109-116},
  number = {4},
  note = {cited By (since 1996) 6},
  abstract = {Prior research has shown that high levels of software reuse can be
	achieved through the use of object-oriented frameworks. An object-oriented
	framework captures the common aspects of a family of applications,
	thus allowing the designers and implementers to reuse this experience
	at the design and code levels. In spite of being a powerful design
	solution, frameworks are not always easy to use. A technique is described
	that uses domain specific languages (DSL) to describe the framework
	variation points and therefore syntactically assure the creation
	of valid framework instances. This approach allows framework users
	to develop applications without the worry of framework implementation,
	so allowing them to remain focused on the problem domain. In addition,
	the use of DSLs allows for better error handling, when compared to
	the standard approach of adapting frameworks by directly adding subclasses.
	The DSL programs are translated to the framework instantiation code
	using a transformational system. The approach is illustrated through
	two real-world frameworks.},
  affiliation = {Department of Computer Science, Princeton University, 35 Olden Street,
	Princeton, NJ 08544, United States; Computer Science Department,
	Catholic University of Rio dc Janeiro, Rua Marques de Sao Viccnte
	225, Rio de Janeiro 22453-900, Brazil},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-0034240046&partnerID=40&md5=1a3704415474a16932873524ca98deb8}
}

@ARTICLE{Fontoura2000239,
  author = {Fontoura, M.a , Crespo, S.a , Lucena, C.J.a , Alencar, P.S.Cb , Cowan,
	D.D.b },
  title = {Using viewpoints to derive object-oriented frameworks: A case study
	in the Web-based education domain},
  journal = {Journal of Systems and Software},
  year = {2000},
  volume = {54},
  pages = {239-257},
  number = {3},
  note = {cited By (since 1996) 9},
  abstract = {This paper is an experience report that illustrates the applicability
	of a viewpoint-based design method for the Web-based education (WBE)
	domain. The method is a new approach for domain analysis that generates
	an object-oriented framework from a set of concrete applications.
	These applications are defined as viewpoints, since they provide
	different perspectives of the framework domain. Various existent
	WBE environments have been used as viewpoints in our case study.
	The design method has been successfully applied for these viewpoints
	generating the ALADIN framework. The analyzed WBE environments are
	presented through object-oriented diagrams. The implementation and
	use of ALADIN is discussed to validate the results of the case study.},
  affiliation = {Computer Science Department, Pontifical Catholic University (PUC-Rio),
	Rua Marquês de São Vicente 225, 22453-900 Rio de Janeiro, Brazil;
	Computer Systems Group, University of Waterloo, Waterloo, Ont. N2L3G1,
	Canada},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-0034315634&partnerID=40&md5=07459fd21ea518fe1fb4fa548878e118}
}

@CONFERENCE{Forget2007803,
  author = {Forget, A.a , Arnold, D.b , Chiasson, S.a },
  title = {CASE-FX: Feature modeling support in an OO CASE tool},
  year = {2007},
  pages = {803-804},
  note = {cited By (since 1996) 0},
  abstract = {Generative Programming advocates developing a family of systems rather
	than a set of single systems. Feature modeling can assist in supporting
	the development of such software product lines through software reuse.
	To our knowledge, CASE-FX is the first implementation of state-level
	feature modeling support within a CASE tool.},
  affiliation = {School of Computer Science, Human-Oriented Technology Lab., Carleton
	University; School of Computer Science, Carleton University},
  author_keywords = {CASE; Feature modeling; Rational Rose-RT},
  document_type = {Conference Paper},
  journal = {Proceedings of the Conference on Object-Oriented Programming Systems,
	Languages, and Applications, OOPSLA},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-42149169778&partnerID=40&md5=00457ea11d16fe5783b043eead70ff0b}
}

@ARTICLE{Foster201135,
  author = {Foster, H.a , Gönczy, L.b , Koch, N.c d , Mayer, P.c , Montangero,
	C.e , Varró, D.b },
  title = {UML extensions for service-oriented systems},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2011},
  volume = {6582},
  pages = {35-60},
  note = {cited By (since 1996) 0},
  abstract = {A trend in software engineering is towards model-driven development.
	Models are used to document requirements, design results, and analysis
	in early phases of the development process. However, the aim of modeling
	is very often more ambitious as models are used for automatic generation
	in so-called model-driven engineering approaches. The relevance of
	models leads to the need of both, high-level domain specific modeling
	languages (DSML), and metamodels which are the basis for the definition
	of model transformations and code generation. For the service-oriented
	computing domain we developed within the Sensoria project a DSML
	for building and transforming SOA models. This DSML is defined as
	a family of UML profiles, which complement the SoaML profile for
	the specification of SOAs structure. Our family of profiles focus
	on orchestration of services, service-level agreements, non-functional
	properties of services, implementation of service modes and service
	deployment. © 2011 Springer-Verlag Berlin Heidelberg.},
  affiliation = {Imperial College London, United Kingdom; Budapest University of Technology
	and Economics, Hungary; Ludwig-Maximilians-Universität, München,
	Germany; Cirquent GmbH, Germany; Universitá di Pisa, Italy},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-80455174429&partnerID=40&md5=ef1c330a7915561cc6c9eb4b60c35393}
}

@CONFERENCE{Foster2011,
  author = {Foster, N.a , Harrison, R.b , Freedman, M.J.b , Monsanto, C.b , Rexford,
	J.b , Story, A.a , Walker, D.b },
  title = {Frenetic: A network programming language},
  year = {2011},
  pages = {279-291},
  note = {cited By (since 1996) 0},
  abstract = {Modern networks provide a variety of interrelated services including
	routing, traffic monitoring, load balancing, and access control.
	Unfortunately, the languages used to program today's networks lack
	modern features-they are usually defined at the low level of abstraction
	supplied by the underlying hardware and they fail to provide even
	rudimentary support for modular programming. As a result, network
	programs tend to be complicated, error-prone, and difficult to maintain.
	This paper presents Frenetic, a high-level language for programming
	distributed collections of network switches. Frenetic provides a
	declarative query language for classifying and aggregating network
	traffic as well as a functional reactive combinator library for describing
	high-level packet-forwarding policies. Unlike prior work in this
	domain, these constructs are-by design-fully compositional, which
	facilitates modular reasoning and enables code reuse. This important
	property is enabled by Frenetic's novel runtime system which manages
	all of the details related to installing, uninstalling, and querying
	low-level packet-processing rules on physical switches. Overall,
	this paper makes three main contributions: (1) We analyze the state-of-the
	art in languages for programming networks and identify the key limitations;
	(2) We present a language design that addresses these limitations,
	using a series of examples to motivate and validate our choices;
	(3)We describe an implementation of the language and evaluate its
	performance on several benchmarks. Copyright © 2011 ACM.},
  affiliation = {Cornell University, United States; Princeton University, United States},
  author_keywords = {Domain-specific languages; Functional reactive programming; Network
	programming languages; OpenFlow},
  document_type = {Conference Paper},
  journal = {Proceedings of the ACM SIGPLAN International Conference on Functional
	Programming, ICFP},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-80054087519&partnerID=40&md5=1aa954dfc16557235a5254d979f11420}
}

@ARTICLE{Foster2011279,
  author = {Foster, N.a , Harrison, R.b , Freedman, M.J.b , Monsanto, C.b , Rexford,
	J.b , Story, A.a , Walker, D.b },
  title = {Frenetic: A network programming language},
  journal = {ACM SIGPLAN Notices},
  year = {2011},
  volume = {46},
  pages = {279-291},
  number = {9},
  note = {cited By (since 1996) 0},
  abstract = {Modern networks provide a variety of interrelated services including
	routing, traffic monitoring, load balancing, and access control.
	Unfortunately, the languages used to program today's networks lack
	modern features-they are usually defined at the low level of abstraction
	supplied by the underlying hardware and they fail to provide even
	rudimentary support for modular programming. As a result, network
	programs tend to be complicated, error-prone, and difficult to maintain.
	This paper presents Frenetic, a high-level language for programming
	distributed collections of network switches. Frenetic provides a
	declarative query language for classifying and aggregating network
	traffic as well as a functional reactive combinator library for describing
	high-level packet-forwarding policies. Unlike prior work in this
	domain, these constructs are-by design-fully compositional, which
	facilitates modular reasoning and enables code reuse. This important
	property is enabled by Frenetic's novel runtime system which manages
	all of the details related to installing, uninstalling, and querying
	low-level packet-processing rules on physical switches. Overall,
	this paper makes three main contributions: (1) We analyze the state-of-the
	art in languages for programming networks and identify the key limitations;
	(2) We present a language design that addresses these limitations,
	using a series of examples to motivate and validate our choices;
	(3)We describe an implementation of the language and evaluate its
	performance on several benchmarks. Copyright © 2011 ACM.},
  affiliation = {Cornell University, United States; Princeton University, United States},
  author_keywords = {Domain-specific languages; Functional reactive programming; Network
	programming languages; OpenFlow},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-80053341773&partnerID=40&md5=04692a7f1290a4298e4f9a2f7a9c5c9d}
}

@ARTICLE{Fowler200913,
  author = {Fowler, M.},
  title = {A pedagogical framework for domain-specific languages},
  journal = {IEEE Software},
  year = {2009},
  volume = {26},
  pages = {13-14},
  number = {4},
  note = {cited By (since 1996) 3},
  abstract = {A framework for thinking about domain-specific languages (DSLs) divides
	them into internal DSLs, external DSLs, and language workbenches.
	In all cases, it's important to have an explicit semantic model so
	that they form a veneer over an underlying library. DSLs are valuable
	for increasing programmer productivity and improving communication
	with domain experts. © 2009 IEEE.},
  affiliation = {ThoughtWorks},
  author_keywords = {Data mining; Domain-specific language; DSL; Language workbench; Libraries;
	Probability density function; Programming; Software; XML},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-67650445776&partnerID=40&md5=6a6d55830176b68608884abe4b82af08}
}

@ARTICLE{Franchetti2005,
  author = {Franchetti, F., Voronenko, Y., Püschel, M.},
  title = {Formal loop merging for signal transforms},
  journal = {ACM SIGPLAN Notices},
  year = {2005},
  volume = {40},
  pages = {315-326},
  number = {6},
  note = {cited By (since 1996) 2},
  abstract = {A critical optimization in the domain of linear signal transforms,
	such as the discrete Fourier transform (DFT), is loop merging, which
	increases data locality and reuse and thus performance. In particular,
	this includes the conversion of shuffle operations into array reindexings.
	To date, loop merging is well understood only for the DFT, and only
	for Cooley-Tukey FFT based algorithms, which excludes DFT sizes divisible
	by large primes. In this paper, we present a formal loop merging
	framework for general signal transforms and its implementation within
	the SPIRAL code generator. The framework consists of Σ-SPL, a mathematical
	language to express loops and index mappings; a rewriting system
	to merge loops in Σ-SPL; and a compiler that translates Σ-SPL into
	code. We apply the framework to DFT sizes that cannot be handled
	using only the Cooley-Tukey FFT and compare our method to FFTW 3.0.1
	and the vendor library Intel MKL 7.2.1. Compared to FFTW our generated
	code is a factor of 2-4 faster under equal implementation conditions
	(same algorithms, same unrolling threshold). For some sizes we show
	a speed-up of a factor of 9 using Bluestein's algorithm. Further,
	we give a detailed comparison against the Intel vendor library MKL;
	our generated code is between 2 times faster and 4.5 times slower.
	Copyright 2005 ACM.},
  affiliation = {Department of Electrical and Computer Engineering, Carnegie Mellon
	University},
  author_keywords = {Automatic performance tuning; DFT; Discrete Fourier transform; Domain-specific
	language; Linear signal transform; Loop optimization},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-33745236838&partnerID=40&md5=be26195379f5e1b6ca62e586fc805956}
}

@CONFERENCE{Franchetti2005315,
  author = {Franchetti, F., Voronenko, Y., Püschel, M.},
  title = {Formal loop merging for signal transforms},
  year = {2005},
  pages = {315-326},
  note = {cited By (since 1996) 13},
  abstract = {A critical optimization in the domain of linear signal transforms,
	such as the discrete Fourier transform (DFT), is loop merging, which
	increases data locality and reuse and thus performance. In particular,
	this includes the conversion of shuffle operations into array reindexings.
	To date, loop merging is well understood only for the DFT, and only
	for Cooley-Tukey FFT based algorithms, which excludes DFT sizes divisible
	by large primes. In this paper, we present a formal loop merging
	framework for general signal transforms and its implementation within
	the SPIRAL code generator. The framework consists of Σ-SPL, a mathematical
	language to express loops and index mappings; a rewriting system
	to merge loops in Σ-SPL; and a compiler that translates Σ-SPL into
	code. We apply the framework to DFT sizes that cannot be handled
	using only the Cooley-Tukey FFT and compare our method to FFTW 3.0.1
	and the vendor library Intel MKL 7.2.1. Compared to FFTW our generated
	code is a factor of 2-4 faster under equal implementation conditions
	(same algorithms, same unrolling threshold). For some sizes we show
	a speed-up of a factor of 9 using Bluestein's algorithm. Further,
	we give a detailed comparison against the Intel vendor library MKL;
	our generated code is between 2 times faster and 4.5 times slower.
	Copyright 2005 ACM.},
  affiliation = {Department of Electrical and Computer Engineering, Carnegie Mellon
	University},
  author_keywords = {Automatic performance tuning; DFT; Discrete Fourier transform; Domain-specific
	language; Linear signal transform; Loop optimization},
  document_type = {Conference Paper},
  journal = {Proceedings of the ACM SIGPLAN Conference on Programming Language
	Design and Implementation (PLDI)},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-31844432305&partnerID=40&md5=9968a0da99bcf821eef0b05508c1d6f7}
}

@ARTICLE{Frankau200927,
  author = {Frankau, S.a , Spinellis, D.b , Nassuphis, N.a , Burgard, C.a },
  title = {Commercial uses: Going functional on exotic trades},
  journal = {Journal of Functional Programming},
  year = {2009},
  volume = {19},
  pages = {27-45},
  number = {1},
  note = {cited By (since 1996) 0},
  abstract = {Abstract The Functional Payout Framework (fpf) is a Haskell application
	that uses an embedded domain-specific functional language to represent
	and process exotic financial derivatives. Whereas scripting languages
	for pricing exotic derivatives are common in banking, fpf uses multiple
	interpretations to not only price such trades, but also to analyse
	the scripts to provide lifecycle support and more. This paper discusses
	fpf in relation to the wider trading workflow and our experiences
	in using a functional language in such a system as both an implementation
	language and a domain-specific language. © 2008 Cambridge University
	Press.},
  affiliation = {Barclays Capital, 5 The North Colonnade, London E14 4BB, United Kingdom;
	Athens University of Economics and Business, Patision 76, GR 104
	34, Athens, Greece},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-57549111697&partnerID=40&md5=d2c261c7e1e24d3dcc166e6503cd883b}
}

@ARTICLE{Frantz2008257,
  author = {Frantz, R.Z.a b },
  title = {A DSL for enterprise application integration},
  journal = {International Journal of Computer Applications in Technology},
  year = {2008},
  volume = {33},
  pages = {257-263},
  number = {4},
  note = {cited By (since 1996) 0},
  abstract = {Enterprise Application Integration (EAI) is one of the big challenges
	for software engineering. According to a recent report published
	by IBM, for each US dollar spent on developing an application, companies
	usually spend from 5 up to 20 times more to integrate it. In this
	paper we propose a Domain Specific Language (DSL) for designing application
	integration solutions. Contrarily to Apache Camel, our DSL proposal
	allows to design an integration solution visually, by working with
	building blocks at a higher level of abstraction, to create a reusable,
	well documented and independent of technology/platform solutions.
	Copyright © 2008 Inderscience Enterprises Ltd.},
  affiliation = {Universidade Regional do Noroeste do Estado do Rio Grande do Sul,
	São Francisco, 501, Ijuí, RS 98700-000, Brazil; University of Seville,
	Spain},
  author_keywords = {Building blocks; Domain specific language; DSL; EAI; EIP; Enterprise
	application integration; Enterprise integration patterns},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-58149216015&partnerID=40&md5=89ce6c4527d2a38eb9137a1b2885621a}
}

@ARTICLE{Frantz2011143,
  author = {Frantz, R.Z.a , Reina Quintero, A.M.b , Corchuelo, R.b },
  title = {A domain-specific language to design enterprise application integration
	solutions},
  journal = {International Journal of Cooperative Information Systems},
  year = {2011},
  volume = {20},
  pages = {143-176},
  number = {2},
  note = {cited By (since 1996) 0},
  abstract = {Enterprise Application Integration (EAI) solutions cope with two kinds
	of problems within software ecosystems, namely: keeping a number
	of application's data in synchrony or creating new functionality
	on top of them. Enterprise Service Bus (ESB) provides the technology
	required to implement a variety of EAI solutions at sensible costs,
	but they are still far from negligible. It is not surprising then
	that many authors are working on proposals to endow them with domain-specific
	tools to help software engineers reduce integration costs. In this
	article, we introduce a proposal called Guaraná. Its key features
	are as follows: it provides explicit support to devise EAI solutions
	using enterprise integration patterns by means of a graphical model;
	its DSL enables software engineers to have not only the view of a
	process, but also a view of the whole set of processes of which an
	EAI solution is composed; both processes and tasks can have multiple
	inputs and multiple outputs; and, finally, its runtime system provides
	a task-based execution model that is usually more efficient than
	the process-based execution models in current use. We have also implemented
	a graphical editor for our DSL and a set of scripts to transform
	our models into Java code ready to be compiled and executed. To set
	up a solution from this code, a software engineer only needs to configure
	a number of adapters to communicate with the applications being integrated.
	© 2011 World Scientific Publishing Company.},
  affiliation = {Department of Technology, Unijuí University, Rua do Comércio, 3000,
	Ijuí 98700-000 RS, Brazil; ETSI Informática, University of Seville,
	Avda. Reina Mercedes, s/n, Sevilla 41012, Spain},
  author_keywords = {Domain-Specific Language; enterprise application integration},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-79955960231&partnerID=40&md5=4bcb05c38350e94e6a1a3f26dcf550ea}
}

@CONFERENCE{Freeman2006855,
  author = {Freeman, S.a , Pryce, N.b },
  title = {Evolving an embedded domain-specific language in Java},
  year = {2006},
  volume = {2006},
  pages = {855-865},
  note = {cited By (since 1996) 6},
  abstract = {This paper describes the experience of evolving a domain-specific
	language embedded in Java over several generations of a test framework.
	We describe how the framework changed from a library of classes to
	an embedded language. We describe the lessons we have learned from
	this experience for framework developers and language designers.},
  affiliation = {M3P, London, United Kingdom; B13 Services, London, United Kingdom},
  art_number = {1176735},
  author_keywords = {Embedded domain-specific language; Java; Mock objects},
  document_type = {Conference Paper},
  journal = {Proceedings of the Conference on Object-Oriented Programming Systems,
	Languages, and Applications, OOPSLA},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-34248366070&partnerID=40&md5=218245943ced5ba5657da759a7c8aefa}
}

@CONFERENCE{Freudenstei20081069,
  author = {Freudenstei, P.a , Nussbaumer, M.a , Allerding, F.b , Gaedke, M.c
	},
  title = {A domain-specific language for the model-driven construction of advanced
	web-based dialogs},
  year = {2008},
  pages = {1069-1070},
  note = {cited By (since 1996) 1},
  abstract = {Complex dialogs with comprehensive underlying data models are gaining
	increasing importance in today's Web applications. This in turn accelerates
	the need for highly dynamic dialogs offering guidance to the users
	and thus reducing cognitive overload. Beyond that, requirements from
	the fields of aesthetics, Web accessibility, platform-independence,
	and Web service integration arise. To this end, we present an evolutionary,
	extensible approach for the model-driven construction of advanced
	dialogs. It is based on a Domain-specific Language (DSL) focusing
	on simplicity and fostering collaboration with stakeholders.},
  affiliation = {University of Karlsruhe (TH), Institute of Telematics, D-76128 Karlsruhe,
	Germany; University of Karlsruhe (TH), Institute of Applied Informatics
	and Formal Description Methods, D-76128 Karlsruhe, Germany; Chemnitz
	University of Technology, Distributed and Self-organizing, Computer
	Systems Group, D-09107 Chemnitz, Germany},
  author_keywords = {DSL; Model-driven; User interaction; Web engineering},
  document_type = {Conference Paper},
  journal = {Proceeding of the 17th International Conference on World Wide Web
	2008, WWW'08},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-57349180395&partnerID=40&md5=d36ec300f87f610df59c3974bd0d7974}
}

@CONFERENCE{Freudenstein200838,
  author = {Freudenstein, P., Nussbaumer, M.},
  title = {Constructing advanced web-based dialog components with stakeholders
	- A DSL approach},
  year = {2008},
  pages = {38-44},
  note = {cited By (since 1996) 0},
  abstract = {Complex dialogs with comprehensive underlying data models are gaining
	increasing importance in today's Web applications. This in turn accelerates
	the need for highly dynamic dialogs offering guidance to the users
	and reducing cognitive overload. Beyond that, requirements from the
	fields of Web accessibility, platform-independence and Web service
	integration arise. Considering the resulting complexity, a systematic
	engineering approach becomes important. Besides addressing the specific
	characteristics of these dialogs, key success factors from a communication
	perspective like strong user involvement and clear business objectives
	must be taken into account. To this end, we present an evolutionary,
	extensible approach for the model-driven construction of advanced
	dialogs which is based on a Domain-specific Language (DSL). We introduce
	a modeling notation based on Petri net constructs and XForms as well
	as a supporting Web-based editor, both focusing on simplicity and
	fostering communications. The technical framework allows for quick
	prototyping and flexible changes. In conclusion, complex, device-independent
	dialogs with rich behavior and appearance can be constructed and
	evolved with intense stakeholder collaboration. © 2008 IEEE.},
  affiliation = {Karlsruhe Institute of Technology, University of Karlsruhe (TH), Department
	of Telematics, Engesserstr. 4, 76128 Karlsruhe, Germany},
  art_number = {4577867},
  document_type = {Conference Paper},
  journal = {Proceedings - 8th International Conference on Web Engineering, ICWE
	2008},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-51749120568&partnerID=40&md5=a2b94e1a4f4436e36065c698b6a3911f}
}

@CONFERENCE{Freudenthal2010,
  author = {Freudenthal, M.},
  title = {Using DSLs for developing enterprise systems},
  year = {2010},
  note = {cited By (since 1996) 0},
  abstract = {This paper investigates the suitability of contemporary DSL tools
	in the context of enterprise software development. The main focus
	is on integration issues between the DSL tool, the DSL implementation
	and the rest of the enterprise system. The paper examines different
	scenarios for integrating DSLs into the enterprise systems. A number
	of criteria for evaluating DSL tools are then extracted from these
	scenarios. These criteria are then used to evaluate five industry-strength
	DSL tools. © ACM 2010.},
  affiliation = {University of Tartu, Cybernetica AS, Aleksandri 8a, Tartu 51004, Estonia},
  art_number = {11},
  author_keywords = {Domain-specific languages},
  document_type = {Conference Paper},
  journal = {Proceedings of the 10th Workshop on Language Descriptions, Tools
	and Applications, LDTA 2010},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-78649764122&partnerID=40&md5=04e453dad6b96561e5d2b4867b3c20a9}
}

@ARTICLE{Freudenthal201065,
  author = {Freudenthal, M.},
  title = {Domain-specific languages in a customs information system},
  journal = {IEEE Software},
  year = {2010},
  volume = {27},
  pages = {65-71},
  number = {2},
  note = {cited By (since 1996) 0},
  abstract = {This article presents a case study for applying the domain-specific
	languages (DSL) approach to building a configurable customs information
	system. The use of DSLs let Customs Engine's developers follow a
	highly iterative and reuse-oriented design method. Analysts benefited
	from the ability to specify system behavior directly, instead of
	relaying this information to programmers via lengthy human-language
	documentation. However, the developers encountered problems when
	trying to enable nontechnical domain experts to write or modify DSL
	programs by themselves. © 2010 IEEE.},
  affiliation = {Department of Computer Science, University of Tartu, Estonia},
  art_number = {5420799},
  author_keywords = {Domain-specific languages; DSLs; Reusable software; Specialized application
	languages},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-77649269440&partnerID=40&md5=7036dbe2542a11311d0ad657e8efdafe}
}

@ARTICLE{Fritsch2005103,
  author = {Fritsch, C.a c , Renz, B.b },
  title = {Four mechanisms for adaptable systems: A meta-level approach to building
	a software product line},
  journal = {Software Process Improvement and Practice},
  year = {2005},
  volume = {10},
  pages = {103-124},
  number = {2},
  note = {cited By (since 1996) 1},
  abstract = {Meta-level architectures combined with domain-specific languages serve
	as a powerful tool to build and maintain a software product line:
	Meta-level architectures lead to adaptable software systems. Executable
	descriptions capture expert knowledge. We have developed a meta-level
	architecture for a software product line of legal expert systems.
	Four meta-level mechanisms support both variability and evolution
	of the product line. Domain analysis had shown that separation of
	expert knowledge from technical code was essential. Descriptions
	written in domain-specific languages reside in the meta level, and
	serve as specification, code, and documentation. Technical code finds
	its place in interpreting machines in the base level. We discuss
	how meta-level architectures influence the qualities of software
	product lines and how properties and patterns of the problem space
	can guide the design of domain-specific languages. Copyright © 2005
	John Wiley & Sons, Ltd.},
  affiliation = {Robert Bosch GmbH, P.O. Box 94 03 50, D-60461 Frankfurt, Germany;
	University of Applied Sciences Giessen-Friedberg, Department MNI,
	Wiesenstr. 14, D-35390 Giessen, Germany; Robert Bosch GmbH, Corporate
	Research and Development, P.O. Box 94 03 50, D-60461 Frankfurt, Germany},
  author_keywords = {Adaptable software; Domain-specific languages; Meta-level architectures;
	Software architecture; Software product lines},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-20744439085&partnerID=40&md5=e7c9107fd759543209012fcf390a8f6f}
}

@CONFERENCE{Fritsch2007,
  author = {Fritsch, S., Senart, A., Clarke, S.},
  title = {Addressing dynamic contextual adaptation with a domain-specific language},
  year = {2007},
  note = {cited By (since 1996) 0},
  abstract = {The increasing number of mobile devices and sensors equipped with
	wireless networking capabilities enable a new generation of pro-active
	applications. These applications make use of context to adapt their
	behaviour to better fit their current situation. To support unanticipated
	changes to application behaviour, mechanisms are needed to specify
	when and how to adapt an application during its runtime. Many dynamic
	platforms exist that achieve this to some extent, and that are built
	on general-purpose languages (GPLs). However, these approaches suffer
	from standard difficulties of GPLs relating to the lack of semantic
	expressiveness of their constructs. In this paper, we describe high-level
	declarative constructs that can be used to specify the adaptation
	of application behaviour to specific situations. The language is
	supported by a framework that enables the exchange and merge of behaviours
	on-the-fly. Our approach is evaluated against application scenarios
	in the domain of autonomous vehicles. © 2007 IEEE.},
  affiliation = {Distributed Systems Group, Trinity College Dublin, Ireland},
  art_number = {4273313},
  document_type = {Conference Paper},
  journal = {Proceedings - ICSE 2007 Workshops: First International Workshop on
	Software Engineering for Pervasive Computing Applications, Systems,
	and Environments, SEPCASE'07},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-38549173050&partnerID=40&md5=c7b5e4b6980e934576738c010e76be23}
}

@ARTICLE{Fritzsche2009134,
  author = {Fritzsche, M.a c , Johannes, J.b , Aßmann, U.b , Mitschke, S.a b
	, Gilani, W.a , Spence, I.c , Brown, J.c , Kilpatrick, P.c },
  title = {Systematic usage of embedded modelling languages in automated model
	transformation chains},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2009},
  volume = {5452},
  pages = {134-150},
  note = {cited By (since 1996) 2},
  abstract = {Annotation of programs using embedded Domain-Specific Languages (embedded
	DSLs), such as the program annotation facility for the Java programming
	language, is a well-known practice in computer science. In this paper
	we argue for and propose a specialized approach for the usage of
	embedded Domain-Specific Modelling Languages (embedded DSMLs) in
	Model-Driven Engineering (MDE) processes that in particular supports
	automated many-step model transformation chains. It can happen that
	information defined at some point, using an embedded DSML, is not
	required in the next immediate transformation step, but in a later
	one. We propose a new approach of model annotation enabling flexible
	many-step transformation chains. The approach utilizes a combination
	of embedded DSMLs, trace models and a megamodel. We demonstrate our
	approach based on an example MDE process and an industrial case study.},
  affiliation = {SAP Research CEC, Belfast Shore Road, BT370QB Newtownabbey, United
	Kingdom; Technische Universität, Dresden D-01062, Dresden, Germany;
	Queen's University Belfast, University Road, Belfast BT7 1NN United
	Kingdom},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-67649934202&partnerID=40&md5=ab3749ce08cccb36467ca08f46573bcc}
}

@ARTICLE{Fröhlich200263,
  author = {Fröhlich, P., Hu, Z., Schoelzke, M.},
  title = {Using UML for information modeling in industrial systems with multiple
	hierarchies},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2002},
  volume = {2460 LNCS},
  pages = {63-72},
  note = {cited By (since 1996) 3},
  abstract = {Traditionally, information models for industrial plants have been
	formulated based on domain-specific languages and tools satisfying
	the requirements of given standards like IEC 750, IEC 61346 or the
	Power Station Designation System (KKS). There is however a trend
	in the automation industry to use common IT standards like XML and
	UML. The current paper shows our experiences in applying UML for
	information modeling of industrial plant applications, which typically
	consist of multiple structural hierarchies. We introduce a meta-model,
	which describes, how the information models can be expressed in UML.
	Further, we discuss a simple case study, which applies this model
	in the context of ABB's Industrial IT platform. Finally, we describe
	our experiences with UML-based modeling in this domain and discuss
	the differences between a UML-based representation and the concepts
	of IEC 61346. © Springer-Verlag Berlin Heidelberg 2002.},
  affiliation = {ABB Forschungszentrum Wallstadter, Straße 59, 68526 Ladenburg, Germany},
  author_keywords = {Business modelling; Industrial experience; Metamodelling},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-3142672934&partnerID=40&md5=33c2bd87cbf7ad4aa596f05e2945ce75}
}

@CONFERENCE{Funke2011496,
  author = {Funke, H.},
  title = {Model based test specifications developing of test specifications
	in a semi automatic model based way},
  year = {2011},
  pages = {496-500},
  note = {cited By (since 1996) 0},
  abstract = {Developing and implementing conformity tests is a time-consuming and
	fault-prone task. To reduce these efforts a new route must be tackled.
	The current way of specifying tests and implementing them includes
	too many manual parts. Based on the experience of testing electronic
	smart cards in ID documents like passports or ID cards the author
	describes a new way of saving time to write new test specifications
	and to get test cases based on these specifications. With new technologies
	like model based testing (MBT) and domain specific languages (DSL)
	it is possible to improve the specification and implementation of
	tests significantly. The author describes his experience in using
	a DSL to define a new language for testing smart cards and to use
	this language to generate both documents and test cases that can
	be run in several test tools. © 2011 IEEE.},
  affiliation = {HJP Consulting GmbH, Paderborn, Germany},
  art_number = {5954454},
  author_keywords = {Based testing; DSL; Finite state machines; Generator; MBT; Model;
	Specification},
  document_type = {Conference Paper},
  journal = {Proceedings - 4th IEEE International Conference on Software Testing,
	Verification, and Validation Workshops, ICSTW 2011},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-80051646563&partnerID=40&md5=e7f9126958eddc20ee75ef17b5bf6a49}
}

@ARTICLE{Furtado2007280,
  author = {Furtado, A.W.B., Santos, A.L.M., Ramalho, G.L.},
  title = {Computer games software factory and edutainment platform for Microsoft.NET},
  journal = {IET Software},
  year = {2007},
  volume = {1},
  pages = {280-293},
  number = {6},
  note = {cited By (since 1996) 3},
  abstract = {An environment targeted at computer games development industrialisation
	in the.NET platform is presented. A computer game product line definition
	and its architecture are specified and implemented by means of software
	factory assets, such as a visual designer based on a domain-specific
	language, semantic validators and code generators. The proposed approach
	is then illustrated and empirically validated by the creation of
	real world case studies. Finally, it is investigated how the proposed
	factory can be used as an edutainment platform for Computer Science
	1 and 2 courses. The final intention is to empower game developers
	and designers to work more productively, with a higher level of abstraction
	and closer to their application domain. © The Institution of Engineering
	and Technology 2007.},
  affiliation = {Center of Informatics, Federal University of Pernambuco, Cidade Universitária,
	Av. Professor Luís Freire, s/n, CEP 50740-540, Recife/PE, Brazil},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-38649103479&partnerID=40&md5=e588c36e0dbac4e6741fc276c4d9b7f0}
}

@ARTICLE{Furtado201130,
  author = {Furtado, A.W.B., Santos, A.L.M., Ramalho, G.L., De Almeida, E.S.},
  title = {Improving digital game development with software product lines},
  journal = {IEEE Software},
  year = {2011},
  volume = {28},
  pages = {30-37},
  number = {5},
  note = {cited By (since 1996) 0},
  abstract = {Introducing reuse and software product line (SPL) concepts into digital
	game-development processes isn't a straightforward task. This work
	presents a systematic process for bridging SPLs to game development,
	culminating with domain-specific languages and generators streamlined
	for game subdomains. The authors present a game SPL for arcade games
	as a case study to illustrate and evaluate their proposed guidelines.
	This article is part of a special issue on games. © 2011 IEEE.},
  affiliation = {Center of Informatics, Federal University of Pernambuco, Brazil},
  art_number = {5984795},
  author_keywords = {digital games development; domain-specific languages; software; software
	engineering; software product lines},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-80051728643&partnerID=40&md5=b1ba04833c9426f16d7f4818444718e8}
}

@CONFERENCE{Fähndrich2006275,
  author = {Fähndrich, M.a , Carbin, M.b , Larus, J.R.a },
  title = {Reflective program generation with patterns},
  year = {2006},
  pages = {275-284},
  note = {cited By (since 1996) 14},
  abstract = {Runtime reflection facilities, as present in Java and .NET, are powerful
	mechanisms for inspecting existing code and metadata, as well as
	generating new code and metadata on the fly. Such power does come
	at a high price though. The runtime reflection support in Java and
	.NET imposes a cost on all programs, whether they use reflection
	or not, simply by the necessity of keeping all metadata around and
	the inability to optimize code because of future possible code changes.
	A second - -often overlooked - -cost is the difficulty of writing
	correct reflection code to inspect or emit new metadata and code
	and the risk that the emitted code is not well-formed.In this paper
	we examine a subclass of problems that can be addressed using a simpler
	mechanism than runtime reflection, which we call compile-time reflection.
	We argue for a high-level construct called a transform that allows
	programmers to write inspection and generation code in a pattern
	matching and template style, avoiding at the same time the complexities
	of reflection APIs and providing the benefits of staged compilation
	in that the generated code and metadata is known to be well-formed
	and type safe ahead of time. Copyright © 2006 ACM.},
  affiliation = {Microsoft Research; Stanford University},
  author_keywords = {Generative programming; Patterns; Reflection; Templates},
  document_type = {Conference Paper},
  journal = {Proceedings of the 5th International Conference on Generative Programming
	and Component Engineering, GPCE'06},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-34547421201&partnerID=40&md5=b3928ea16e67340af11202ed80945e47}
}

@CONFERENCE{Förster2006135,
  author = {Förster, A.a , Engels, G.a , Schattkowsky, T.a , Van Der Straeten,
	R.b },
  title = {A pattern-driven development process for quality standard-conforming
	business process models},
  year = {2006},
  pages = {135-142},
  note = {cited By (since 1996) 6},
  abstract = {Quality management is a hot issue in most organisations and must be
	considered in the business processes of the organisation. Existing
	approaches on business process modelling provide neither explicit
	strategies to model quality requirements on business processes nor
	do they provide explicit support for the construction of business
	processes satisfying such quality requirements. In this paper, we
	present a patterndriven development process for modelling business
	processes with respect to given quality constraints. We introduce
	a visual pattern specification language based on UML Activity Diagrams
	that enables the expression of quality constraints as patterns. These
	patterns can be used in a forward-engineering development process
	which supports the business process designer in constructing business
	processes by applying patterns. Thereby, quality constraints can
	be integrated into the design of business processes seamlessly. ©
	2006 IEEE.},
  affiliation = {University of Paderborn, Germany; Vrije Universiteit Brussel, Belgium},
  art_number = {1698775},
  author_keywords = {Business process modelling; Patternbased development; Visual domain
	specific language},
  document_type = {Conference Paper},
  journal = {Proceedings - IEEE Symposium on Visual Languages and Human-Centric
	Computing, VL/HCC 2006},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-34548856931&partnerID=40&md5=803fed8a25795331aed9682ead9b8bbb}
}

@CONFERENCE{Gallant20101501,
  author = {Gallant, S.a , Gaughan, C.b c },
  title = {Systems engineering for distributed live, virtual, and constructive
	(LVC) simulation},
  year = {2010},
  pages = {1501-1511},
  note = {cited By (since 1996) 0},
  abstract = {Designing a distributed simulation environment across multiple domains
	that typically have disparate middleware transport protocols, data
	exchange formats and applications increases the difficulty of capturing
	and linking system design decisions to the resultant implementation.
	Systems engineering efforts for distributed simulation environments
	are typically based on the middleware transport used, the applications
	available and the constraints placed on the technical team including
	network, computer and personnel limitations. To facilitate community
	re-use, systems engineering should focus on integrated operational
	function decomposition. This links data elements produced within
	the simulation to the functional capabilities required by the user.
	The system design should be captured at a functional level and subsequently
	linked to the technical design. Doing this within a data-driven systems
	engineering infrastructure allows generative programming techniques
	to assist accurate, flexible and rapid architecture development.
	This paper describes the MATREX program systems engineering process,
	infrastructure and path forward. ©2010 IEEE.},
  affiliation = {Effective Applications Corporation, 318 Osprey Lakes Circle, Chuluota,
	FL 32766, United States; U.S. Army Research, Dev. and Eng. Command,
	Simulation and Training Technology Center (STTC), 12423 Research
	Parkway, Orlando, FL 32826, United States; U.S. Army Research, Dev.
	and Eng. Command, Simulation and Training Technology Center (STTC),
	Orlando, FL 20052, United States},
  art_number = {5679044},
  document_type = {Conference Paper},
  journal = {Proceedings - Winter Simulation Conference},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-79951655016&partnerID=40&md5=a8b7478935b3ecc50bba0efd758af449}
}

@ARTICLE{Gamatié2008,
  author = {Gamatié, A.a , Rutten, É.b , Yu, H.a , Boulet, P.a , Dekeyser, J.-L.a
	},
  title = {Synchronous modeling and analysis of data intensive applications},
  journal = {Eurasip Journal on Embedded Systems},
  year = {2008},
  volume = {2008},
  number = {1},
  note = {cited By (since 1996) 0},
  abstract = {We present the modeling of data-intensive parallel applications following
	the synchronous approach. We consider the GASPARD environment, which
	is dedicated to high-performance system-on-chip (SoC) codesign. Our
	motivation is to bridge the gap between the GASPARD design approach
	and the formal validation techniques provided by the synchronous
	technology. First, we define a synchronous dataflow equational model
	of GASPARD models. The modeling formalism adopted in GASPARD consists
	of an extension of the domain-specific language Array-OL. Then, we
	address correctness issues (e.g., causality and synchronizability
	analyses) about GASPARD models via their corresponding synchronous
	descriptions in order to formally validate the original system descriptions.},
  affiliation = {LIFL, CNRS/INRIA, Bât A, 40 avenue Halley, 59650 Villeneuve d'Ascq
	Cedex, France; INRIA Rhône-Alpes, 655 avenue de l'Europe, Montbonnot,
	38334 Saint-Ismier Cedex, France},
  art_number = {561863},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-57349193555&partnerID=40&md5=1fd77ff25f53653946e3477678e0311c}
}

@ARTICLE{García200923,
  author = {García, F.a , Ruiz, F.a , Calero, C.a , Bertoa, M.F.b , Vallecillo,
	A.b , Mora, B.a , Piattini, M.a },
  title = {Effective use of ontologies in software measurement},
  journal = {Knowledge Engineering Review},
  year = {2009},
  volume = {24},
  pages = {23-40},
  number = {1},
  note = {cited By (since 1996) 7},
  abstract = {Ontologies are frequently used in the context of software and technology
	engineering. These can be grouped into two main categories, depending
	on whether they are used to describe the knowledge of a domain (domain
	ontologies) or whether they are used as software artifacts in software
	development processes. This paper presents some experiences and lessons
	learnt from the effective use of an ontology for Software Measurement,
	called software measurement ontology (SMO). The SMO was developed
	some years ago as a result of a thorough analysis of the software
	measurement domain. Its use as a domain ontology is presented first,
	a description of how the SMO can serve as a conceptual basis for
	comparing international standards related to software measurement.
	Second, the paper describes several examples of the applications
	of SMO as a software artifact. In particular, we show how the SMO
	can be instantiated to define a data quality model for Web portals,
	and also how it can be used to define a Domain-Specific Language
	(DSL) for measuring software entities. These examples show the significant
	role that ontologies can play as software artifacts in the realm
	of model-driven engineering and domain-specific modeling. © 2009
	Copyright Cambridge University Press.},
  affiliation = {Department of Information Technologies and Systems, Escuela Superior
	de Informtica, University of Castilla-La Mancha, Spain; Departamento
	de Lenguajes y Ciencias de la Computacin, Universidad de Mlaga, 29071
	Mlaga, Spain},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-68349140137&partnerID=40&md5=5ee4fec955ebf0fe464d0e3ed3f92b51}
}

@ARTICLE{García-Magariño20092043,
  author = {García-Magariño, I., Fuentes-Fernández, R.},
  title = {A technique for defining metamodel translations},
  journal = {IEICE Transactions on Information and Systems},
  year = {2009},
  volume = {E92-D},
  pages = {2043-2052},
  number = {10},
  note = {cited By (since 1996) 0},
  abstract = {Model-Driven Engineering and Domain-Specific Modeling Languages are
	encouraging an increased used of metamodels for the definition of
	languages and tools. Although the Meta Object Facility language is
	the standard for metamodeling, there are alternative metamodeling
	languages that are aimed at satisfying specific requirements. In
	this context, sharing information throughout different domains and
	tools requires not only being able to translate models between modeling
	languages de-fined with the same metamodeling language, but also
	between different metamodeling languages. This paper addresses this
	latter need describing a general technique to define transformations
	that perform this translation. In this work, two case studies illustrate
	the application of this process. Copyright © 2009 The Institute of
	Electronics, Information and Communication Engineers.},
  affiliation = {Dept. of Software Engineering and Artificial Intelligence, Facultad
	de Informática, Universidad Complutense de Madrid, Spain},
  author_keywords = {Metamodel Translation; Model Transformation; Model-Driven Engineering},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-77950235519&partnerID=40&md5=64389c6723f1c2c1be0516cbabd3f01c}
}

@CONFERENCE{Garrett20002425,
  author = {Garrett, J.T., Ledeczi, A., DeCaria, F.},
  title = {Towards a paradigm for activity modeling},
  year = {2000},
  volume = {4},
  pages = {2425-2430},
  note = {cited By (since 1996) 0},
  abstract = {Model Integrated Computing involves defining a domain-specific language
	that allows for someone to effectively program an environment at
	whatever level the modeling-environment-creator deems appropriate.
	We've taken several complex, heterogeneous systems that posed problems
	of needing integration and requiring frequent reconfiguration at
	very high levels. This paper discusses gathering the specifications
	for these systems, how the systems can be represented at these high
	levels in a paradigm also capturing the specifications, and then
	how reconfiguring this group can proceed. All of the activities constituting
	monitoring functionality and the resulting decision making exposed
	by the information system will be shown to have been solved through
	utilization of Model Integrated Computing techniques.},
  affiliation = {Vanderbilt Univ, Nashville, United States},
  document_type = {Conference Paper},
  journal = {Proceedings of the IEEE International Conference on Systems, Man
	and Cybernetics},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-0034514213&partnerID=40&md5=fc8ebb9cb70fbc30970001bbca45dfcf}
}

@CONFERENCE{Gartner201158,
  author = {Gartner, J.a , Musliu, N.b , Schafhauser, W.a , Slany, W.c },
  title = {TEMPLE - A domain specific language for modeling and solving staff
	scheduling problems},
  year = {2011},
  pages = {58-64},
  note = {cited By (since 1996) 0},
  abstract = {We present TEMPLE, a domain specific language for modeling and solving
	staff scheduling problems. TEMPLE provides a set of intuitive abstractions
	and notations allowing to formulate the constraints of a particular
	problem in a very compact and natural way. After modeling a staff
	scheduling problem in TEMPLE, three generic local search algorithms
	can immediately be applied to the corresponding optimization problem.
	We show how real-life staff scheduling problems can be both effectively
	modeled as well as efficiently solved using our approach. Finally,
	we report on a practical application of TEMPLE in a commercial staff
	scheduling software. © 2011 IEEE.},
  affiliation = {Ximes GmbH, Hollandstrae 12/12, A-1020 Vienna, Austria; Vienna University
	of Technology, Favoritenstrae 9-11, A-1040, Austria; Graz University
	of Technology, Inffeldgasse 16B/II, A-8010, Austria},
  art_number = {5976550},
  document_type = {Conference Paper},
  journal = {IEEE SSCI 2011 - Symposium Series on Computational Intelligence -
	CISched 2011: 2011 IEEE Symposium on Computational Intelligence in
	Scheduling},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-80052097115&partnerID=40&md5=32949a4c3747b65d631bd6a35097d45c}
}

@ARTICLE{Gatti2011217,
  author = {Gatti, S., Balland, E., Consel, C.},
  title = {A step-wise approach for integrating QoS throughout software development},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2011},
  volume = {6603 LNCS},
  pages = {217-231},
  note = {cited By (since 1996) 1},
  abstract = {When developing real-time systems such as avionics software, it is
	critical to ensure the performance of these systems. In general,
	deterministic Quality of Service (QoS) is guaranteed by the execution
	platform, independently of a particular application. For example,
	in the avionics domain, the ARINC 664 standard defines a data network
	that provides deterministic QoS guarantees. However, this strategy
	falls short of addressing how the QoS requirements of an application
	get transformed through all development phases and artifacts. Existing
	approaches provide support for QoS concerns that only cover part
	of the development process, preventing traceability. In this paper,
	we propose a declarative approach for specifying QoS requirements
	that covers the complete software development process, from the requirements
	analysis to the deployment. This step-wise approach is dedicated
	to control-loop systems such as avionics software. The domain-specific
	trait of this approach enables the stakeholders to be guided and
	ensures QoS requirements traceability via a tool-based methodology.
	© 2011 Springer-Verlag.},
  affiliation = {Thales Airborne Systems, University of Bordeaux, INRIA, France},
  author_keywords = {Domain-Specific Design Language; Generative Programming; Quality of
	Service; Tool-Based Development Methodology},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-79953181317&partnerID=40&md5=b820dcf545a16c9f6f8166db37721d34}
}

@ARTICLE{Gauffre200865,
  author = {Gauffre, G., Dubois, E., Bastide, R.},
  title = {Domain-specific methods and tools for the design of advanced interactive
	techniques},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2008},
  volume = {5002 LNCS},
  pages = {65-76},
  note = {cited By (since 1996) 2},
  abstract = {Novel interactive systems such as Augmented Reality are promising
	tools considering the possibilities they offer, but no real development
	methods exist at the moment to help designers in their work. We present
	in this paper a design method for tightly coupling early interaction
	design choices and software design solutions. Based on an existing
	model used for abstract UI design, our work introduces a second model
	dedicated to the software UI specification and the model-based process
	used to derive one from the other. To achieve this, we present here
	a framework based on domain-specific models and transformations to
	link them and thus support the development process. © 2008 Springer-Verlag
	Berlin Heidelberg.},
  affiliation = {IRIT, University of Toulouse, 118, route de Narbonne, Toulouse Cedex
	9 31062, France},
  author_keywords = {Design process; Domain-specific languages; Metamodeling; Mixed interactive
	systems; Model transformations; Model-driven engineering},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-47749095994&partnerID=40&md5=c420fc0c9803a34061e052db162ea0f8}
}

@ARTICLE{Geiß2006383,
  author = {Geiß, R., Batz, G.V., Grund, D., Hack, S., Szalkowski, A.},
  title = {GrCen: A fast SPO-based graph rewriting tool},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2006},
  volume = {4178 LNCS},
  pages = {383-397},
  note = {cited By (since 1996) 13},
  abstract = {Graph rewriting is a powerful technique that requires graph pattern
	matching, which is an NP-complete problem. We present GRGEN, a generative
	programming system for graph rewriting, which applies heuristic optimizations.
	According to Varró's benchmark it is at least one order of magnitude
	faster than any other tool known to us. Our graph rewriting tool
	implements the well-founded single-pushout approach. We define the
	notion of search plans to represent different matching strategies
	and equip these search plans with a cost model, taking the present
	host graph into account. The task of selecting a good search plan
	is then viewed as an optimization problem. For the ease of use, GRGEN
	features an expressive specification language and generates program
	code with a convenient interface. © Springer-Verlag Berlin Heidelberg
	2006.},
  affiliation = {Universität Karlsruhe (TH), 76131 Karlsruhe, Germany},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-33750271573&partnerID=40&md5=e150c64d365f8eb377b61d54938a67ec}
}

@CONFERENCE{Genevès2010305,
  author = {Genevès, P.a , Layaïda, N.b },
  title = {Eliminating dead-code from XQuery programs},
  year = {2010},
  volume = {2},
  pages = {305-306},
  note = {cited By (since 1996) 0},
  abstract = {One of the challenges in web software development is to help achieving
	a good level of quality in terms of code size and runtime performance,
	for increasingly popular domain specific languages such as XQuery.
	We present an IDE equipped with static analysis features for assisting
	the programmer. These features are capable of identifying and eliminating
	dead code automatically. The tool is based on newly developed formal
	programming language verification techniques [4, 3], which are now
	mature enough to be introduced in the process of software development.
	Copyright 2010 ACM.},
  affiliation = {CNRS, France; INRIA, France},
  document_type = {Conference Paper},
  journal = {Proceedings - International Conference on Software Engineering},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-77954722631&partnerID=40&md5=106fcd1c1ebcb400146754b9d7e5afc7}
}

@ARTICLE{Ghindici200832,
  author = {Ghindici, D., Simplot-Ryl, I.},
  title = {On practical information flow policies for java-enabled multiapplication
	smart cards},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2008},
  volume = {5189 LNCS},
  pages = {32-47},
  note = {cited By (since 1996) 1},
  abstract = {In the multiapplicative context of smart cards, a strict control of
	underlying information flow between applications is highly desired.
	In this paper we propose a model to improve information flow usability
	in such systems by limiting the overhead for adding information flow
	security to a Java Virtual Machine. We define a domain specific language
	for defining security policies describing the allowed information
	flow inside the card. The applications are certified at loading time
	with respect to information flow security policies. We illustrate
	our approach on the LoyaltyCard, a multiapplicative smart card involving
	four loyalty applications sharing fidelity points. © IFIP International
	Federation for Information Processing 2008.},
  affiliation = {IRCICA/LIFL, CNRS UMR 8022, Univ. Lille 1, Nord Europe, France},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-52949147438&partnerID=40&md5=3231a276572162182614524962f30ddf}
}

@ARTICLE{Ghosh201110,
  author = {Ghosh, D.},
  title = {Domain-specific languages bridge the semantic gap in programming},
  journal = {Queue},
  year = {2011},
  volume = {9},
  pages = {10-21},
  number = {6},
  note = {cited By (since 1996) 0},
  abstract = {One of the main reasons why software projects fail is the lack of
	communication between the business users, who actually know the problem
	domain, and the developers who design and implement the software
	model. Business users understand the domain terminology, and they
	speak a vocabulary that may be quite alien to the software people;
	it's no wonder that the communication model can break down right
	at the beginning of the project life cycle. A DSL (domain-specific
	language)1,3 bridges the semantic gap between business users and
	developers by encouraging better collaboration through shared vocabulary.
	The domain model that the developers build uses the same terminologies
	as the business. The abstractions that the DSL offers match the syntax
	and semantics of the problem domain. As a result, users can get involved
	in verifying business rules throughout the life cycle of the project.
	This article describes the role that a DSL plays in modeling expressive
	business rules. It starts with the basics of domain modeling and
	then introduces DSLs, which are classified according to implementation
	techniques. The article then explains in detail the design and implementation
	of an embedded DSL from the domain of securities trading operations.
	© 2011 ACM.},
  affiliation = {Anshinsoft, India},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-79960116605&partnerID=40&md5=a5043d7ed41114b2957f7d7bf5aac5d9}
}

@ARTICLE{Ghosh201144,
  author = {Ghosh, D.H.},
  title = {DSL for the uninitiated},
  journal = {Communications of the ACM},
  year = {2011},
  volume = {54},
  pages = {44-50},
  number = {7},
  note = {cited By (since 1996) 0},
  abstract = {Domain-specific languages bridge the semantic gap in programming.
	© 2011 ACM.},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-79959952297&partnerID=40&md5=ed9f6e04663e9c8f6b0f252185386a6b}
}

@ARTICLE{Giachetti20102353,
  author = {Giachetti, G., Albert, M., Marín, B., Pastor, O.},
  title = {Linking UML and MDD through UML profiles: A practical approach based
	on the UML association},
  journal = {Journal of Universal Computer Science},
  year = {2010},
  volume = {16},
  pages = {2353-2373},
  number = {17},
  note = {cited By (since 1996) 0},
  abstract = {In a model-driven development context, the definition (or selection)
	of an appropriate modeling language is a crucial task. OMG, in the
	model-driven architecture specification, recommends the use of UML
	for model-driven developments. However, the lack of semantic precision
	in UML has led to different model-driven approaches proposing their
	own domain-specific modeling languages in order to introduce their
	modeling needs. This paper focuses on customizing the UML association
	in order to facilitate its application in model-driven development
	environments. To do this, a well-defined process is defined to integrate
	the abstract syntax of a domain-specific modeling language that supports
	a precise semantics for the association construct in UML by means
	of the automatic generation of a UML profile. Finally, a brief example
	shows how the results obtained by the application of the proposed
	process can generate software products through a real model compilation
	tool. © J.UCS.},
  affiliation = {Centro de Investigación en Métodos de Producción de Software, Universidad
	Politécnica de Valencia, Camino de Vera s/n, 46022 Valencia, Spain},
  author_keywords = {Association; DSML; MDA; MDD; Profile; UML},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-78650255710&partnerID=40&md5=053f1cab4451b0efe86223b90e8711ac}
}

@ARTICLE{Giachetti2009110,
  author = {Giachetti, G., Marín, B., Pastor, O.},
  title = {Using UML as a domain-specific modeling language: A proposal for
	automatic generation of UML profiles},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2009},
  volume = {5565 LNCS},
  pages = {110-124},
  note = {cited By (since 1996) 3},
  abstract = {Nowadays, there are several MDD approaches that have defined Domain-Specific
	Modeling Languages (DSML) that are oriented to representing their
	particular semantics. However, since UML is the standard language
	for software modeling, many of these MDD approaches are trying to
	integrate their semantics into UML in order to use UML as DSML. The
	use of UML profiles is a recommended strategy to perform this integration
	allowing, among other benefits, the use of the existent UML modeling
	tools. However, in the literature related to UML profile construction;
	it is not possible to find a standardized UML profile generation
	process. Therefore, a process that integrates a DSML into UML through
	the automatic generation of a UML profile is presented in this paper.
	This process facilitates the correct use of UML in a MDD context
	and provides a solution to take advantage of the benefits of UML
	and DSMLs. © 2009 Springer Berlin Heidelberg.},
  affiliation = {Centro de Investigación en Métodos de Producción de Software, Universidad
	Politécnica de Valencia, Camino de Vera s/n, Valencia 46022, Spain},
  author_keywords = {DSML; MDD; UML; UML Profile},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-69849114835&partnerID=40&md5=695fe8da814370dfc6886df7160ca92d}
}

@CONFERENCE{Giachetti2009385,
  author = {Giachetti, G., Marín, B., Pastor, O.},
  title = {Using UML profiles to interchange DSML and UML models: A proposal
	for MDD approaches},
  year = {2009},
  pages = {385-394},
  note = {cited By (since 1996) 1},
  abstract = {A key requirement for MDD solutions is to have a modeling language
	that allows the correct representation of conceptual models. Nowadays,
	there are two options that are the most widely used for the definition
	of these modeling languages: 1) the specification of a domain-specific
	modeling language (DSML) or 2) the customization of UML. In practice,
	these two modeling alternatives are viewed as opposite solutions.
	However, since both alternatives provide benefits for the application
	of MDD solutions, in this paper, we present a proposal that uses
	UML profile extension mechanisms to interchange modeling information
	between DSML-based models and UML models. This proposal shows how
	these two modeling alternatives can be integrated in a unique MDD
	solution. © 2009 IEEE.},
  affiliation = {Centro de Investigación en Métodos de Producción de Software, Universidad
	Politécnica de Valencia, Camino de Vera s/n, 46022 Valencia, Spain},
  art_number = {5089302},
  author_keywords = {DSML; MDD; UML; UML profile},
  document_type = {Conference Paper},
  journal = {Proceedings of the 2009 3rd International Conference on Research
	Challenges in Information Science, RCIS 2009},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-70349466923&partnerID=40&md5=543da6d70248ca93966641f235f2b415}
}

@ARTICLE{Giachetti2008113,
  author = {Giachetti, G., Valverde, F., Pastor, O.},
  title = {Improving automatic UML2 profile generation for MDA industrial development},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2008},
  volume = {5232 LNCS},
  pages = {113-122},
  note = {cited By (since 1996) 2},
  abstract = {In the context of MDA-oriented solutions, a modeling language with
	a precise semantics is a mandatory requirement. Even though MDA encourages
	the use of UML, there are several MDA approaches that define their
	own Domain Specific Modeling Languages (DSML) in order to obtain
	the needed semantic precision. However, the high acceptance of UML
	in the software industry has led different MDA-approaches to integrate
	their DSMLs semantics into UML by means of UML profiles. Certain
	approaches provide alternatives to elaborate a UML profile from the
	DSML metamodel, but generally speaking, the resultant profile does
	not include all the semantic expressiveness of the original DSML.
	This paper provides a solution that is focused on the MDA industrial
	development. This solution is based on a systematic approach to generate
	a DSML metamodel that is used to automatically obtain a UML profile
	that has all the expressiveness of the original DSML. © 2008 Springer
	Berlin Heidelberg.},
  affiliation = {Departamento de Sistemas Informáticos y Computación, Universidad Politécnica
	de Valencia, Camino de Vera s/n, 46022 Valencia, Spain},
  author_keywords = {DSML; MDA; MDD; Metamodeling; Model-driven Engineering; UML Profile;
	UML2},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-69849098525&partnerID=40&md5=49f39685d1c7ee1f400f64c8a5f53550}
}

@ARTICLE{Giachetti2009145,
  author = {Giachetti, G.a , Marín, B.b , Pastor, O.c },
  title = {Integration of domain-specific modeling languages and uml through
	uml profile extension mechanism},
  journal = {International Journal of Computer Science and Applications},
  year = {2009},
  volume = {6},
  pages = {145-174},
  number = {5},
  note = {cited By (since 1996) 2},
  abstract = {A key requirement for MDD solutions is to have a modeling language
	that allows the correct representation of conceptual models. Nowadays,
	there are two options that are the most widely used for the definition
	of these modeling languages: 1) the specification of a domain-specific
	modeling language (DSML) or 2) the customization of UML. In practice,
	these two modeling alternatives are viewed as opposite solutions.
	However, since both alternatives provide benefits for the application
	of MDD solutions, in this article, we present a proposal that uses
	UML profile extension mechanisms to interchange modeling information
	between DSML-based models and UML models. This proposal shows how
	these two modeling alternatives can be integrated in a unique MDD
	solution. © Technomathematics Research Foundation.},
  affiliation = {Centro de Investigación en Métodos de Producción de Software, Universidad
	Politécnica de Valencia, Camino de Vera s/n 46022 Valencia, Spain;
	Centro de Investigación en Métodos de Producción de Software, Universidad
	Politécnica de Valencia, Camino de Vera s/n 46022 Valencia, Spain;
	Centro de Investigación en Métodos de Producción de Software, Universidad
	Politécnica de Valencia, Camino de Vera s/n 46022 Valencia, Spain},
  author_keywords = {DSML; MDD; UML; UML profile},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-77953506281&partnerID=40&md5=6fa2b9b5c110520b588f0d1072ca55c5}
}

@CONFERENCE{Gianni2008118,
  author = {Gianni, D.a , D'Ambrogio, A.b },
  title = {A domain specific language for the definition of extended queueing
	network models},
  year = {2008},
  pages = {118-124},
  note = {cited By (since 1996) 1},
  abstract = {The use of design patterns and modular decomposition for the development
	of component-based software products brings significant improvements
	in terms of several quality attributes (e.g., reusability, reliability,
	maintainability). In addition, the modular design of interacting
	software components allows the foundation of a flexible Domain Specific
	Language (DSL) that acts as a model description language rather than
	a coding language, bringing significant savings in terms of development
	effort. This is particularly true in the field of simulation, in
	which the use of a common language both to represent and to simulate
	a given simulation model practically eliminates the need and the
	effort to fill the gap between the model specification and the simulator
	implementation. This paper introduces the design features of jEQN,
	a language for the specification and implementation of simulation
	models based on extended queueing networks. Details concerning the
	application of design patterns, modular decomposition and generic
	type parameters are also presented.},
  affiliation = {Department of Electrical and Electronic Engineering, Imperial College,
	Exhibition Road, SW7 2AZ, London, United Kingdom; Department of Computer
	Science Systems and Production, University of Rome TorVergata, Via
	del Politecnico, 1, I-00133, Rome, Italy},
  author_keywords = {DSL; EQN; Java; Model-driven design; Simulation},
  document_type = {Conference Paper},
  journal = {Proceedings of the IASTED International Conference on Software Engineering,
	SE 2008},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-58049139201&partnerID=40&md5=d6bc8e87e810f351c7629f44f4d10aef}
}

@CONFERENCE{Giavitto2010,
  author = {Giavitto, J.-L.},
  title = {A domain specific language for complex natural and artificial systems
	simulations},
  year = {2010},
  note = {cited By (since 1996) 0},
  abstract = {A DSL for Systems Biology. Domain specific languages are often designed
	to incorporate domain-specific knowledge in order to enhance expressiveness
	(for the programmer) and quality, flexibility, maintenability, ...,
	of the produced soft-wares. In this talk I introduce a language initially
	developed to ease the modeling and the simulation of developmental
	processes in biology. In this application domain, one must face:
	• dynamical processes that are located and move in space, • processes
	that interact locally with their (spatial) neighbors, • a spatial
	neighborhood that is build (computed) and adjusted as a result of
	the process activities, • various style of processes (numerical simulation
	of ODE and PDE, stochastic processes and discrete deterministic or
	non-deterministic transition systems). © ACM 2010.},
  affiliation = {Université d'Evry, CNRS - IBISC, Genopole, 523 place des Terrasses
	de l'Agora, 91000 Evry, France},
  art_number = {1},
  document_type = {Conference Paper},
  journal = {Proceedings of the 10th Workshop on Language Descriptions, Tools
	and Applications, LDTA 2010},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-78649795440&partnerID=40&md5=dbbe965327f2b4da5b84123111faa19d}
}

@CONFERENCE{Giegerich20061603,
  author = {Giegerich, R., Steffen, P.},
  title = {Challenges in the compilation of a domain specific languages for
	dynamic programming},
  year = {2006},
  volume = {2},
  pages = {1603-1609},
  note = {cited By (since 1996) 4},
  abstract = {Many combinatorial optimization problems in biosequence analysis are
	solved via dynamic programming. To increase programming productivity
	and program reliability, a domain specific language embedded in Haskell
	has been suggested. We point out several shortcomings of this approach,
	and report on some challenges in the (ongoing) project of migrating
	this domain specific language from its host language to a directly
	compiled implementation. Most of these challenges are domain specific
	optimizations, which not only improve significant constant factors
	of runtime and space requirements, but also affect asymptotic efficiency.
	We report on our solutions to some of these problems, and point out
	others that are still open. Copyright 2006 ACM.},
  affiliation = {Faculty of Technology, Bielefeld University, Postfach 10 01 31, 33501
	Bielefeld, Germany},
  author_keywords = {Biosequence analysis; Domain specific languages; Dynamic programming},
  document_type = {Conference Paper},
  journal = {Proceedings of the ACM Symposium on Applied Computing},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-33751009251&partnerID=40&md5=704fbd0ea4dc0b65a649344589907761}
}

@ARTICLE{Gil2010573,
  author = {Gil, J.(Y.), Lenz, K.},
  title = {Simple and safe SQL queries with C++ templates},
  journal = {Science of Computer Programming},
  year = {2010},
  volume = {75},
  pages = {573-595},
  number = {7},
  note = {cited By (since 1996) 2},
  abstract = {Most large software applications rely on an external relational database
	for storing and managing persistent data. Typically, such applications
	interact with the database by first constructing strings that represent
	SQL statements, and then submitting these for execution by the database
	engine. The fact that these statements are only checked for correctness
	at runtime is a source for many potential defects, including type
	and syntax errors and vulnerability to injection attacks. The AraRat
	system presented here offers a method for dealing with these difficulties
	by coercing the host C++ compiler to do the necessary checks of the
	generated strings. A library of templates and preprocessor directives
	is used to embed in C++ a little language representing an augmented
	relational algebra formalism. Type checking of this embedded language,
	carried out by our template library, assures, at compile-time, the
	correctness and safety of the generated SQL strings. All SQL statements
	constructed by AraRat are guaranteed to be syntactically correct,
	and type safe with respect to the database schema. Moreover, AraRat
	statically ensures that the generated statements are immune to all
	injection attacks. The standard techniques of "expression templates"
	and "compile-time symbolic derivation" for compile-time representation
	of symbolic structures, are enhanced in our system. We demonstrate
	the support of a type system and a symbol table lookup of the symbolic
	structure. A key observation of this work is that type equivalence
	of instantiated nominally typed generics in C++ (as well as other
	languages, e.g., Java) is structural rather than nominal. This makes
	it possible to embed the structural type system, characteristic to
	persistent data management, in the nominal type system of C++. For
	some of its advanced features, AraRat relies on two small extensions
	to the standard C++ language: the typeof pseudo operator and the
	__COUNTER__ preprocessor macro. © 2010 Elsevier B.V. All rights reserved.},
  affiliation = {Department of Computer Science, Technion-Israel Institute, Technology
	Technion City, Haifa, 32000, Israel},
  author_keywords = {C++; Databases; Domain specific languages; Embedded languages; Relational
	algebra; Structural type equivalence; Template programming},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-77950860276&partnerID=40&md5=dc9d5fcc0eef135bbf76c6fc187ae0ee}
}

@CONFERENCE{Gil200713,
  author = {Gil, J., Lenz, K.},
  title = {Simple and safe SQL queries with c++ templates},
  year = {2007},
  pages = {13-24},
  note = {cited By (since 1996) 7},
  abstract = {Most software applications use a relational database for data management
	and storage. Interaction with such a database is often done by letting
	the program construct strings with valid SQL statements, which are
	then sent for execution to the database engine. The fact that these
	statements are only checked for correctness at runtime is a source
	for many potential problems such as type and syntax errors and vulnerability
	to injection attacks. The ARARAT system presented here offers a method
	for dealing with these predicaments, by coercing the host C++ compiler
	to do the necessary checks of the generated strings. A library of
	templates and preprocessor directives effectively extends C++ with
	a little language representing an augmented relational algebra formalism.
	Type checking of this language extension, carried out by our template
	library, assures, at compile-time, the correctness and safety of
	the generated SQL strings. That is to say that all SQL statements
	constructed by the system are syntactically correct, legal with respect
	to the database schema, and immune to injection attacks. Standard
	techniques (e.g., "expression templates") for compile time representation
	of symbolic structures, are enhanced in our system to support a type
	system (featuring structural equivalence) and a symbol table lookup
	of the symbolic structure. Our work may also open the way for embedding
	other domain specific languages in C++. The system provides also
	initial support for the task of defining C++ data structures required
	for storing the results returned by database queries. An optional
	pre-processor can be used to define the database scheme to the C++
	program. Copyright © 2007 ACM.},
  affiliation = {Department of Computer Science, Technion-Israel Institute of Technology,
	Technion City, Haifa 32000, Israel},
  author_keywords = {C++; Databases; Domain specific languages; Embedded languages; Relational
	algebra; Structural type equivalence; Template programming},
  document_type = {Conference Paper},
  journal = {GPCE'07 - Proceedings of the Sixth International Conference on Generative
	Programming and Component Engineering},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-38849190566&partnerID=40&md5=88202c7e665f99f98eeaaca0fe6612d7}
}

@CONFERENCE{Gill2009117,
  author = {Gill, A.},
  title = {Type-safe observable sharing in Haskell},
  year = {2009},
  pages = {117-128},
  note = {cited By (since 1996) 2},
  abstract = {Haskell is a great language for writing and supporting embedded Domain
	Specific Languages (DSLs). Some form of observable sharing is often
	a critical capability for allowing so-called deep DSLs to be compiled
	and processed. In this paper, we describe and explore uses of an
	IO function for reification which allows direct observation of sharing.
	Copyright© 2009 ACM.},
  affiliation = {Information Technology and Telecommunication Center, Department of
	Electrical Engineering and Computer Science, University of Kansas,
	2335 Irving Hill Road, Lawrence KS 66045, United States},
  author_keywords = {DSL compilation; Observable sharing},
  document_type = {Conference Paper},
  journal = {Haskell'09 - Proceedings of the 2009 ACM SIGPLAN Haskell Symposium},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-72949096879&partnerID=40&md5=e583cf58153abc2b35050ccdf8e74ebc}
}

@ARTICLE{Gill2009285,
  author = {Gill, A.},
  title = {A haskell hosted dsl for writing transformation systems},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2009},
  volume = {5658 LNCS},
  pages = {285-309},
  note = {cited By (since 1996) 0},
  abstract = {KURE is a Haskell hosted Domain Specific Language (DSL) for writing
	transformation systems based on rewrite strategies. When writing
	transformation systems, a significant amount of engineering effort
	goes into setting up plumbing to make sure that specific rewrite
	rules can fire. Systems like Stratego and Strafunski provide most
	of this plumbing as infrastructure, allowing the DSL user to focus
	on the rewrite rules. KURE is a strongly typed strategy control language
	in the tradition of Stratego and Strafunski. It is intended for writing
	reasonably efficient rewrite systems, makes use of type families
	to provide a delimited generic mechanism for tree rewriting, and
	provides support for efficient identity rewrite detection. © IFIP
	International Federation for Information Processing 2009.},
  affiliation = {Department of Electrical Engineering and Computer Science, Information
	Technology and Telecommunication Center, University of Kansas, 2335
	Irving Hill Road, Lawrence, KS 66045},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-69049101228&partnerID=40&md5=a497a1cdb7419887a687fcd4b83437cd}
}

@ARTICLE{Gill201018,
  author = {Gill, A., Bull, T., Kimmell, G., Perrins, E., Komp, E., Werling,
	B.},
  title = {Introducing Kansas Lava},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2010},
  volume = {6041 LNCS},
  pages = {18-35},
  note = {cited By (since 1996) 2},
  abstract = {Kansas Lava is a domain specific language for hardware description.
	Though there have been a number of previous implementations of Lava,
	we have found the design space rich, with unexplored choices. We
	use a direct (Chalmers style) specification of circuits, and make
	significant use of Haskell overloading of standard classes, leading
	to concise circuit descriptions. Kansas Lava supports both simulation
	(inside GHCi), and execution via VHDL, by having a dual shallow and
	deep embedding inside our Signal type. We also have a lightweight
	sized-type mechanism, allowing for MATLAB style matrix based specifications
	to be directly expressed in Kansas Lava. © 2010 Springer-Verlag.},
  affiliation = {Information Technology and Telecommunication Center, Department of
	Electrical Engineering and Computer Science, University of Kansas,
	2335 Irving Hill Road, Lawrence, KS 66045, United States},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-78649952901&partnerID=40&md5=4070e5b4c0f9f71ad0200987ee4605c8}
}

@CONFERENCE{Gilles201050,
  author = {Gilles, O.a , Hugues, J.b },
  title = {A MDE-based optimisation process for Real-Time systems},
  year = {2010},
  volume = {1},
  pages = {50-57},
  note = {cited By (since 1996) 1},
  abstract = {The design and implementation of Real-Time Embedded Systems is now
	heavily relying on Model-Driven Engineering (MDE) as a central place
	to define and then analyze or implement a system. MDE toolchains
	are taking a key role as to gather most of functional and not functional
	properties in a central framework, and then exploit this information.
	Such toolchain is based on both 1) a modeling notation, and 2) companion
	tools to transform or analyse models. In this paper, we present a
	MDE-based process for system optimisation based on an architectural
	description. We first define a generic evaluation pipeline, define
	a library of elementary transformations and then shows how to use
	it through Domain-Specific Language to evaluate and then transform
	models. We illustrate this process on an AADL case study modeling
	a Generic Avionics Platform. © 2010 IEEE.},
  affiliation = {GET-Télécom Paris, LTCI-UMR 5141 CNRS, 46, Rue Barrault, F-75634 Paris
	Cedex 13, France; Université de Toulouse, ISAE, 10, Avenue E. Belin,
	31055 Toulouse Cedex 4, France},
  art_number = {5479575},
  document_type = {Conference Paper},
  journal = {ISORC 2010 - 2010 13th IEEE International Symposium on Object/Component/Service-Oriented
	Real-Time Distributed Computing},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-77954767476&partnerID=40&md5=8fc901dd25a46a3f122e02aef1166c6b}
}

@ARTICLE{Giorgidze2011138,
  author = {Giorgidze, G., Nilsson, H.},
  title = {Embedding a functional hybrid modelling language in Haskell},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2011},
  volume = {5836 LNCS},
  pages = {138-155},
  note = {cited By (since 1996) 0},
  abstract = {In this paper we present the first investigation into the implementation
	of a Functional Hybrid Modelling language for non-causal modelling
	and simulation of physical systems. In particular, we present a simple
	way to handle connect constructs: a facility for composing model
	fragments present in some form in most non-causal modelling languages.
	Our implementation is realised as a domain-specific language embedded
	in Haskell. The method of embedding employs quasiquoting, thus demonstrating
	the effectiveness of this approach for languages that are not suitable
	for embedding in more traditional ways. Our implementation is available
	on-line, and thus the first publicly available prototype implementation
	of a Functional Hybrid Modelling language. © 2011 Springer-Verlag.},
  affiliation = {Functional Programming Laboratory, School of Computer Science, University
	of Nottingham, United Kingdom},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-80053939777&partnerID=40&md5=ac6afc09e4b496661854abb85514b8db}
}

@ARTICLE{Giorgidze201148,
  author = {Giorgidze, G., Nilsson, H.},
  title = {Mixed-level embedding and JIT compilation for an iteratively staged
	DSL},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2011},
  volume = {6559 LNCS},
  pages = {48-65},
  note = {cited By (since 1996) 1},
  abstract = {This paper explores how to implement an iteratively staged domain-specific
	language (DSL) by embedding into a functional language. The domain
	is modelling and simulation of physical systems where models are
	expressed in terms of non-causal differential-algebraic equations;
	i.e., sets of constraints solved through numerical simulation. What
	distinguishes our language is that the equational constraints are
	first class entities allowing for an evolving model structure characterised
	by repeated generation of updated constraints. Hence iteratively
	staged. Our DSL can thus be seen as a combined functional and constraint
	programming language, albeit a two-level one, with the functional
	language chiefly serving as a meta language. However, the two levels
	do interact throughout the simulation. The embedding strategy we
	pursue is a mixture of deep and shallow, with the deep embedding
	enabling just-in-time (JIT) compilation of the constraints as they
	are generated for efficiency, while the shallow embedding is used
	for the remainder for maximum leverage of the host language. The
	paper is organised around a specific DSL, but our implementation
	strategy should be applicable for iteratively staged languages in
	general. Our DSL itself is further a novel variation of a declarative
	constraint programming language. © 2011 Springer-Verlag.},
  affiliation = {Functional Programming Laboratory, School of Computer Science, University
	of Nottingham, United Kingdom},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-79957621846&partnerID=40&md5=24d01c8efa60e4bf7215fce9d23f58fb}
}

@ARTICLE{Glass200321,
  author = {Glass, R.L.},
  title = {One giant step backward},
  journal = {Communications of the ACM},
  year = {2003},
  volume = {46},
  pages = {21-23},
  number = {5},
  note = {cited By (since 1996) 4},
  abstract = {To date, a number of things have come along to help software developers.
	However, a close look at the current scenario reveals that not much
	have been attained. Taking programming languages as a case in point,
	it is shown that the programming language community has taken several
	steps backward. For the most part, today's programming languages
	are significant improvements over those of yester-decade and yester-millenium.
	Nonetheless, there is one important way in which programming languages
	have fallen backward - that way is application domain focus.},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-0038103732&partnerID=40&md5=da6d8dafc8a4766bde5ea9cb0a914654}
}

@CONFERENCE{Glombitza20102,
  author = {Glombitza, N., Pfisterer, D., Fischer, S.},
  title = {Using state machines for a model driven development of web service-based
	sensor network applications},
  year = {2010},
  pages = {2-7},
  note = {cited By (since 1996) 2},
  abstract = {In the Internet of Things, all kinds of devices will extend the Internet
	to the physical world. In that vision, even extremely resource constrained
	sensor nodes can be triggered by as well as trigger business processes
	and are not limited to sense-and-send anymore. Despite the large
	potential, due to the time consuming, inflexible, and error prone
	development of sensor network applications, sensor networks are rarely
	integrated into today's enterprise IT. In this paper, we present
	an approach using state machines for a Model Driven Development of
	Web Service-based sensor network applications. We show how Web Services
	can be realized on sensor nodes and present a domain-specific language
	called State Machine for Resource Constrained Devices (SM4RCD) to
	orchestrate these services. © 2010 ACM.},
  affiliation = {Institute of Telematics, University of Lübeck, Germany},
  author_keywords = {internet of things; model driven software development; sensor network;
	service oriented architecture; state machine for resource constrained
	devices; web service},
  document_type = {Conference Paper},
  journal = {Proceedings - International Conference on Software Engineering},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-77955827775&partnerID=40&md5=0daabf0f5cc09dfc1bcca6e95a31dc32}
}

@CONFERENCE{Gluck200951,
  author = {Gluck, R.},
  title = {Is there a fourth futamura projection?},
  year = {2009},
  pages = {51-60},
  note = {cited By (since 1996) 1},
  abstract = {The three classic Futamura projections stand as a cornerstone in the
	development of partial evaluation. The observation by Futamura [1983],
	that compiler generators produced by his third projection are self-generating,
	and the insight by Klimov and Romanenko [1987], that Futamura's abstraction
	scheme can be continued beyond the three projections, are systematically
	investigated, and several new applications for compiler generators
	are proposed. Possible applications include the generation of quasi-online
	compiler generators and of compiler generators for domain-specific
	languages, and the bootstrapping of compiler generators from program
	specializers. From a theoretical viewpoint, there is equality between
	the class of self-generating compiler generators and the class of
	compiler generators produced by the third Futamura projection. This
	exposition may lead to new practical applications of compiler generators,
	as well as deepen our theoretical understanding of program specialization.
	©2009 ACM.},
  affiliation = {DIKU, Department of Computer Science, University of Copenhagen, Universitetsparken
	1, DK-2100 Copenhagen, Denmark},
  author_keywords = {Bootstrapping; Cogen approach; Compiler generators; Domain-specific
	languages; Futamura projections; Generator selfgeneration; Program
	specialization; Self-application},
  document_type = {Conference Paper},
  journal = {Proceedings of the 2009 ACM SIGPLAN Symposium on Partial Evaluation
	and Program Manipulation, PEPM'09},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-67650673243&partnerID=40&md5=c4272b7c8e87bac59d0fc4dec07228bc}
}

@ARTICLE{Gokhale2007359,
  author = {Gokhale, A.a , Kaul, D.a , Kogekar, A.a , Gray, J.b , Gokhale, S.c
	},
  title = {POSAML: A visual modeling language for middleware provisioning},
  journal = {Journal of Visual Languages and Computing},
  year = {2007},
  volume = {18},
  pages = {359-377},
  number = {4},
  note = {cited By (since 1996) 1},
  abstract = {Next generation distributed applications are often hosted on heterogeneous
	platforms including different kinds of middleware. Due to the applications'
	growing functional complexity and their multiple quality of service
	(QoS) requirements, system developers are increasingly facing a substantial
	number of middleware provisioning challenges, which include configuring,
	optimizing and validating the middleware platforms for QoS properties.
	Traditional techniques for middleware provisioning tend to use non-intuitive,
	low-level and technology-specific approaches, which are tedious,
	error prone, and non-reusable across different technologies. Quite
	often the middleware provisioning activities are carried out by different
	actors without much interaction among them, which results in an iterative
	trial-and-error process to provisioning. Higher level abstractions,
	particularly those that use visual models, are effective in addressing
	these challenges. This paper describes the design of a visual modeling
	language called POSAML (pattern-oriented software architecture modeling
	language) and associated tools that provide an intuitive, higher
	level and unified framework for provisioning middleware platforms.
	POSAML provides visual modeling capabilities for middleware-independent
	configurations and optimizations while enabling automated middleware-specific
	validation of system QoS properties. © 2007 Elsevier Ltd. All rights
	reserved.},
  affiliation = {Department of Electrical Engineering and Computer Science, Vanderbilt
	University, Nashville, TN 37235, United States; Department of CIS,
	University of Alabama at Birmingham, Birmingham, AL 35294, United
	States; Department of CSE, University of Connecticut, Storrs, CT
	06269, United States},
  author_keywords = {Generative tools; Model-driven engineering; Visual domain-specific
	modeling languages},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-34548654619&partnerID=40&md5=1740a9813c9802a7abc8166a4ce3c952}
}

@CONFERENCE{Goldman199920,
  author = {Goldman, Neil M., Balzer, Robert M.},
  title = {ISI visual design editor generator},
  year = {1999},
  pages = {20-27},
  note = {cited By (since 1996) 5},
  abstract = {The benefits of `domain specific' languages and development environments
	are widely recognized. Constructing an environment for a new domain,
	however, remains a costly activity, requiring expertise in several
	areas of software development as well as in the targeted domain.
	The ISI design editor generator and design environment comprises
	a novel infrastructure that simplifies this task, producing visual
	domain-specific design environments. This paper presents the runtime
	architecture of these environments, a visual `specify-by-example'
	capability that deals with a major portion of editor generation,
	and an implementation that uses a COTS product (Microsoft PowerPoint)
	as both graphic middleware and end-user GUI.},
  affiliation = {USC/Information Sciences Inst},
  document_type = {Article},
  journal = {IEEE Symposium on Visual Languages, Proceedings},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-0032642158&partnerID=40&md5=5e218a3e2ec78c3fdedae2e8f9884d82}
}

@CONFERENCE{Golra2011924,
  author = {Golra, F.R., Dagnat, F.},
  title = {The lazy initialization multilayered modeling framework (NIER track)},
  year = {2011},
  pages = {924-927},
  note = {cited By (since 1996) 0},
  abstract = {Lazy Initialization Multilayer Modeling (LIMM) is an object oriented
	modeling language targeted to the declarative definition of Domain
	Specific Languages (DSLs) for Model Driven Engineering. It focuses
	on the precise definition of modeling frameworks spanning over multiple
	layers. In particular, it follows a two dimensional architecture
	instead of the linear architecture followed by many other modeling
	frameworks. The novelty of our approach is to use lazy initialization
	for the definition of mapping between different modeling abstractions,
	within and across multiple layers, hence providing the basis for
	exploiting the potential of metamodeling. © 2011 ACM.},
  affiliation = {Université Européenne de Bretagne, Institut Télécom/Télécom Bretagne,
	Bretagne, France},
  author_keywords = {instantiation; limm; metamodeling; strict metamodeling},
  document_type = {Conference Paper},
  journal = {Proceedings - International Conference on Software Engineering},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-79959912897&partnerID=40&md5=263e86ceb6cfc74fe71f09b2f1b4233e}
}

@CONFERENCE{GonzalezBoix2008,
  author = {Gonzalez Boix, E., Cleenewerk, T., Dedecker, J., De Meuter, W.},
  title = {Towards a domain-specific aspect language for leasing in mobile ad
	hoc networks},
  year = {2008},
  note = {cited By (since 1996) 0},
  abstract = {Leasing provides a robust mechanism to manage reclamation of remote
	objects in mobile ad hoc networks. However, applying the leasing
	semantics on each remote object reference places a considerable burden
	on developers. Low-level leasing management details can be abstracted
	away as much as possible by means of dedicated language support.
	This paper focusses on the software engineering issues that arise
	using language support for leasing. We observe that the concerns
	dealing with leasing are inherently cross-cutting and argue in favour
	of a modularization of such concerns in an aspect. We propose a domain-specific
	aspect language (DSAL) for leasing which provides dedicated means
	to express the leasing concerns separately from the base functionality.
	© 2008 ACM.},
  affiliation = {Programming Technology Lab., Vrije Universiteit Brussel, Pleinlaan
	2, 1050 Brussels, Belgium},
  art_number = {6},
  author_keywords = {Aspect-oriented programming; Domain-specific languages; Leasing; Mobile
	ad hoc networks},
  document_type = {Conference Paper},
  journal = {DSAL'08: Proceedings of the 2008 AOSD Workshop on Domain-specific
	Aspect Languages},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-65249097703&partnerID=40&md5=a01f06aaeda594f1642e6750d116d905}
}

@CONFERENCE{González2009585,
  author = {González, O.a , Casallas, R.a , Deridder, D.b },
  title = {Automating the implementation of analysis concerns in workflow applications},
  year = {2009},
  pages = {585-589},
  note = {cited By (since 1996) 0},
  abstract = {In workflow management systems, analysis concerns related to monitoring,
	measurement, and control aim at identifying potential improvements
	of workflow applications. However, the specification of analysis
	concerns is done using a specific workflow language and engine, producing
	entangled code which is detrimental to their maintainability. The
	purpose of this paper is twofold. First, it presents briefly a domain-specific
	language to specify analysis concerns, independently of any workflow
	technology and in a modularized way. Second, it shows a strategy
	to assist developers to enhance a given workflow technology to support
	the automated implementation of analysis concerns into its workflow
	applications. Thus, given a workflow application and its analysis
	concerns, they are automatically integrated producing an enhanced
	executable workflow application. © 2009 IEEE.},
  affiliation = {TICSw Research Group, Universidad de Los Andes Bogotá, Colombia; Software
	Languages Lab., Vrije Universiteit Brussel, Brussels, Belgium},
  art_number = {5431728},
  author_keywords = {Analysis concerns; Code generation; Languages; Measurement; Monitors;
	Workflow management},
  document_type = {Conference Paper},
  journal = {ASE2009 - 24th IEEE/ACM International Conference on Automated Software
	Engineering},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-77952162808&partnerID=40&md5=4d4a802c29874a4c13f9f0df5f86643c}
}

@ARTICLE{Gopal2008144,
  author = {Gopal, S., Tansey, W., Kannan, G.C., Tilevich, E.},
  title = {DeXteR - An extensible framework for declarative parameter passing
	in distributed object systems},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2008},
  volume = {5346 LNCS},
  pages = {144-163},
  note = {cited By (since 1996) 0},
  abstract = {In modern distributed object systems, reference parameters are passed
	to a remote method based on their runtime type. We argue that such
	type-based parameter passing is limiting with respect to expressiveness,
	readability, and maintainability, and that parameter passing semantics
	should be decoupled from parameter types. We present declarative
	parameter passing, an approach that fully decouples parameter passing
	semantics from parameter types in distributed object systems. In
	addition, we describe DeXteR, an extensible framework for transforming
	a type-based remote parameter passing model to a declaration-based
	model transparently. Our framework leverages aspect-oriented and
	generative programming techniques to enable adding new remote parameter
	passing semantics, without requiring detailed understanding of the
	underlying middleware implementation. Our approach is applicable
	to both application and library code and incurs negligible performance
	overhead. We validate the expressive power of our framework by adding
	several non-trivial remote parameter passing semantics (i.e., copy-restore,
	lazy, streaming) to Java RMI. © 2008 Springer Berlin Heidelberg.},
  affiliation = {Department of Computer Science, Virginia Tech., Blacksburg, VA 24061,
	United States},
  author_keywords = {Aspect oriented programming; Declarative programming; Extensible middleware;
	Metadata; Parameter passing},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-58149097660&partnerID=40&md5=15799f58055b486ed3408a67327b7937}
}

@CONFERENCE{Gopinath2011276,
  author = {Gopinath, V.S., Sprinkle, J., Lysecky, R.},
  title = {Modeling of data adaptable reconfigurable embedded systems},
  year = {2011},
  pages = {276-283},
  note = {cited By (since 1996) 0},
  abstract = {Many applications require high flexibility, high configurability and
	high processing speeds. The physical constraints of a highly flexible
	system's hardware implementation preclude a hardware solution that
	satisfies all configuration options. Similarly for pure software
	implementations, even if configurability is satisfied, process efficiency
	will be sacrificed. Thus for applications of any significant size,
	there can be no single hardware or software configuration that can
	efficiently support all the configurability options of the applications.
	The Data-Adaptable Reconfigurable Embedded System (DARES) approach
	tackles this problem through combination of the hardware-software
	co-design and reconfigurable computing methodologies. Data-adaptability
	means that as data streams change, the system is reconfigured along
	the baselines defined within the system's specifications. In this
	project we use the concepts of Model-Integrated Computing to implement
	a domain-specific modeling language for the DARES approach. The language
	captures all the configurability options of the application task(s),
	performs design-space exploration, and provides a template for source
	code generation. © 2011 IEEE.},
  affiliation = {Department of Electrical and Computer Engineering, University of Arizona,
	Tucson, AZ, United States},
  art_number = {5934785},
  author_keywords = {DARES; Data adaptability; GME; Model integrated computing; Model-based
	design},
  document_type = {Conference Paper},
  journal = {Proceedings - 18th IEEE International Conference and Workshops on
	Engineering of Computer-Based Systems, ECBS 2011},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-80051997890&partnerID=40&md5=0bda499a42361583af543d87d692ca5a}
}

@CONFERENCE{Governatori200546,
  author = {Governatori, G.a , Milosevic, Z.b },
  title = {Dealing with contract violations: Formalism and domain specific language},
  year = {2005},
  pages = {46-57},
  note = {cited By (since 1996) 10},
  abstract = {This paper presents a formal system for reasoning about violations
	of obligations in contracts. The system is based on the formalism
	for the representation of contrary-to-duty obligations. These are
	the obligations that take place when other obligations are violated
	as typically applied to penalties in contracts. The paper shows how
	this formalism can be mapped onto the key policy concepts of a contract
	specification language. This language, called Business Contract Language
	(BCL) was previously developed to express contract conditions of
	relevance for run time contract monitoring. The aim of this mapping
	is to establish a formal underpinning for this key subset of BCL.
	© 2005 IEEE.},
  affiliation = {School of Information Technology and Electrical Engineering, University
	of Queensland, Brisbane, QLD 4072, Australia; CRC for Enterprise
	Distributed Systems Technology, Brisbane, QLD 4072, Australia},
  art_number = {1540667},
  document_type = {Conference Paper},
  journal = {Proceedings - IEEE International Enterprise Distributed Object Computing
	Workshop, EDOC},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-33749380253&partnerID=40&md5=fddca8b43bb6ebb8a07c36b8fa30deca}
}

@CONFERENCE{Grabmüeller200794,
  author = {Grabmüeller, M., Kleeblatt, D.},
  title = {Harpy: Run-time code generation in haskell},
  year = {2007},
  pages = {94},
  note = {cited By (since 1996) 1},
  abstract = {We present Harpy, a Haskell library for run-time code generation of
	x86 machine code. Harpy provides efficient generation of machine
	code, a convenient domain specific language for generating code and
	a collection of code generation combinators.},
  affiliation = {Technische Universität Berlin},
  author_keywords = {Dynamic code generation; Haskell},
  document_type = {Conference Paper},
  journal = {Haskell'07: Proceedings of the ACM SIGPLAN 2007 Haskell Workshop},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-38849152111&partnerID=40&md5=60f9088b84996961d669094fa6c46066}
}

@CONFERENCE{Grammel200944,
  author = {Grammel, B.},
  title = {Towards a generic traceability framework for model-driven software
	engineering},
  year = {2009},
  pages = {44-47},
  note = {cited By (since 1996) 0},
  abstract = {With the inception of Model-Driven Software Engineering (MDSD) the
	need for traceability is raised to understand the complexity of model
	transformations and overall to improve the quality of MDSD. Using
	the advantage of generating traceability information automatically
	in MDSD, eases the problem of creating and maintaining trace links,
	which is a labor intensive task, when done manually. Yet, there is
	still a wide range of open challenges in existing traceability solutions
	and a need to consolidate traceability domain knowledge. This paper
	proposes a generic framework for augmenting arbitrary model transformation
	approaches with a traceability mechanism. Essentially, this augmentation
	is based on a domain-specific language for traceability providing
	the formalization on integration conditions needed for implementing
	traceability. The paper is of positional nature and outlines work
	currently in progress.},
  affiliation = {SAP Research CEC Dresden, Chemnitzer Str. 48, 01187 Dresden, Germany},
  document_type = {Conference Paper},
  journal = {Future Trends of Model-Driven Development - Proceedings of the 1st
	International Workshop on Future Trends of Model-Driven Development
	- FTMDD 2009 In Conjunction with ICEIS 2009},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-74549211836&partnerID=40&md5=bfb638250423cb61c8ee17f9dec4fceb}
}

@CONFERENCE{Grammel20107,
  author = {Grammel, B., Kastenholz, S.},
  title = {A generic traceability framework for facet-based traceability data
	extraction in Model-Driven Software development},
  year = {2010},
  pages = {7-14},
  note = {cited By (since 1996) 0},
  abstract = {Traceability of artefacts induces the means of understanding the complexity
	of logical relations existing among artefacts, that are created during
	software development. In turn, this provides the necessary knowledge
	for reasoning about the quality of software. With the inception of
	Model-Driven Software Engineering, the advantage of generating traceability
	information automatically, eases the problem of creating and maintaining
	trace links, which is a labor intensive task, when done manually.
	Yet, there is still a wide range of open challenges in existing traceability
	solutions and a need to consolidate traceability domain knowledge.
	This paper proposes a generic traceability framework for augmenting
	arbitrary model transformation approaches with a traceability mechanism.
	Essentially, this augmentation is based on a domain-specific language
	for traceability, accounting for facet-based data extraction. Copyright
	© 2010 ACM.},
  affiliation = {SAP Research CEC Dresden, Chemnitzer Str. 48, 01187 Dresden, Germany},
  document_type = {Conference Paper},
  journal = {ACM International Conference Proceeding Series},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-77954982916&partnerID=40&md5=bfe1c9e138428d7b7e257a1305c34f56}
}

@CONFERENCE{Grant2008221,
  author = {Grant, E.S., Reza, H.},
  title = {Towards model driven testing for mission critical software systems},
  year = {2008},
  pages = {221-224},
  note = {cited By (since 1996) 0},
  abstract = {A fundamental problem faced in developing and maintaining safety critical
	software, is that of verification of the system that has just been
	completed or modified. This problem is most evident in large integrated
	systems, in which one component has been modified, and it is not
	known what impact the modification has on the entire system. This
	work presents an approach to checking the input/output relation of
	software systems that uses domain-specific modeling languages to
	model the expected inputs and outputs, and constraints between them.
	The technique provides a partial solution to the verification problem
	and is most applicable during the maintenance phase of the system.
	This approach is applied a program synthesizer for mathematical state
	estimation problems.},
  affiliation = {Department of Computer Science, University of North Dakota, Grand
	Forks, ND, United States},
  author_keywords = {Domain modeling language; Verification},
  document_type = {Conference Paper},
  journal = {Proceedings of the 2008 International Conference on Software Engineering
	Research and Practice, SERP 2008},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-62749178063&partnerID=40&md5=ff5db47ec7047e0ee1b12fce27d6b275}
}

@CONFERENCE{Grant2007102,
  author = {Grant, E.S., Reza, H.},
  title = {Towards the development of a rigorous model-driven domain-specific
	software engineering environment},
  year = {2007},
  pages = {102-107},
  note = {cited By (since 1996) 0},
  abstract = {Over the past decades, the software development community has increasingly
	embraced the principles of a model-driven approach, resulting in
	the definition of many such methodologies. It is now an appropriate
	time to consolidate the many software model-driven approaches into
	a set of well-defined and related techniques, and processes. This
	set of techniques and processes, would be the building block for
	subsequent model-driven development methodologies. Such an accomplishment
	would provide a framework from which rigorously defined domain-specific
	methodologies are crafted. It would also provide a platform from
	which the next significant advancement in software development may
	be launched. The objective of this research is the definition and
	implementation of a platform independent environment for model-driven
	software development that incorporates formal specification techniques
	with informal graphical modeling notations. The methodologies of
	the environment will amalgamate some of the best practices in model-driven
	development from academia and industry. The success and viability
	of this defined environment will be manifested in its adaptation
	by industrial partners.},
  affiliation = {University of North Dakota, Department of Computer Science, Grand
	Forks, ND, United States},
  author_keywords = {Architectural description language; Domain-specific modeling language
	1},
  document_type = {Conference Paper},
  journal = {Proceedings of the 3rd IASTED International Conference on Advances
	in Computer Science and Technology, ACST 2007},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-56149111635&partnerID=40&md5=e7d5069a57e9f8f46da3a8a70a00f85e}
}

@ARTICLE{Graunke2008187,
  author = {Graunke, P.},
  title = {Verified Safety and Information Flow of a Block Device},
  journal = {Electronic Notes in Theoretical Computer Science},
  year = {2008},
  volume = {217},
  pages = {187-202},
  number = {C},
  note = {cited By (since 1996) 0},
  abstract = {This work reports on the author's experience designing, implementing,
	and formally verifying a low-level piece of system software. The
	timing model and the adaptation of an existing information flow policy
	to a monadic framework are reasonably novel. Interactive compilation
	through equational rewriting worked well in practice. Finally, the
	project uncovered some potential areas for improving interactive
	theorem provers. © 2008 Elsevier B.V. All rights reserved.},
  affiliation = {Galois, Inc., OR, United States},
  author_keywords = {domain-specific language; higher-order logic; monads; multi-level
	security},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-47049095499&partnerID=40&md5=e6268ebc1891316f8a23ff3a147ca04d}
}

@CONFERENCE{Gray2010,
  author = {Gray, J.a , White, J.b , Gokhale, A.b },
  title = {Model-driven engineering: Raising the abstraction level through domain-specific
	modeling},
  year = {2010},
  note = {cited By (since 1996) 0},
  abstract = {Model-Driven Engineering (MDE) has emerged as a promising paradigm
	in software engineering by emphasizing the use of models not just
	for documentation and communication purposes, but as first-class
	artifacts to be transformed into other work products (e.g., other
	models, source code, and test scripts). MDE supports full-scale round-trip
	engineering, from idea inception to operationalization. Historically,
	models have been developed using general-purpose modeling languages,
	such as the Unified Modeling Language (UML). A more recent trend
	is to use domain-specific modeling languages (DSMLs), which assist
	domain experts in working within their own problem space without
	being concerned about technical details of the solution space (e.g.,
	programming languages and middleware). DSMLs also provide an accessible
	way to communicate with stakeholders who are not familiar with the
	fast changing technologies. This introductory tutorial will present
	a summary of the areas represented by MDE and offer some insight
	into the benefits of using DSMLs in both research and teaching. Copyright
	© 2010 ACM.},
  affiliation = {University of Alabama, Department of Computer Science, Tuscaloosa,
	AL 35487, United States; Vanderbilt University, Institute for Software
	Integrated Systems, Nashville, TN 37235, United States},
  art_number = {1},
  document_type = {Conference Paper},
  journal = {Proceedings of the Annual Southeast Conference},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-79951843738&partnerID=40&md5=e0822ae27f198ad80870f6124d2905b3}
}

@CONFERENCE{Greenfield200316,
  author = {Greenfield, J., Short, K.},
  title = {Software factories: Assembling applications with patterns, models,
	frameworks and tools},
  year = {2003},
  pages = {16-27},
  note = {cited By (since 1996) 13},
  abstract = {The confluence of component based development, model driven development
	and software product lines forms an approach to application development
	based on the concept of software factories. This approach promises
	greater gains in productivity and predictability than those produced
	by incremental improvements to the current paradigm of object orientation,
	which have not kept pace with innovation in platform technology.
	Software factories promise to make application assembly more cost
	effective through systematic reuse, enabling the formation of supply
	chains and opening the door to mass customization.},
  affiliation = {Visual Studio Enterprise Frameworks and Tools, Microsoft Corporation,
	One Microsoft Way, Redmond, WA 98053, United States},
  author_keywords = {Design Patterns; Domain-Specific Languages; Model-Driven Development;
	Software Factories; Software Product Lines},
  document_type = {Conference Paper},
  journal = {Proceedings of the Conference on Object-Oriented Programming Systems,
	Languages, and Applications, OOPSLA},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-33646513737&partnerID=40&md5=cff57491754ead3e11300434ce8bfb04}
}

@ARTICLE{Gregg20061465,
  author = {Gregg, D.a , Ertl, M.A.b },
  title = {Optimizing code-copying JIT compilers for virtual stack machines},
  journal = {Concurrency Computation Practice and Experience},
  year = {2006},
  volume = {18},
  pages = {1465-1484},
  number = {11},
  note = {cited By (since 1996) 0},
  abstract = {Just-in-time (JIT) compilers are widely used to implement stack-based
	virtual machines, such as the Java and .NET virtual machines. One
	disadvantage of most JIT compilers is that they are importable; much
	of the back-end is specific to the target machine. An alternative
	to machine-specific code generation methods is to define a routine
	in a high-level language for each virtual machine instruction. These
	can be compiled to native code using a normal C compiler. The native
	code for these routines can then be strung together, allowing very
	simple, unoptimized code to be produced just in time. In this paper
	we present such a system based on an existing implementation of the
	Forth language. We present a novel system of optimizations for the
	system based on exploiting common sequences of virtual machine instructions.
	We use a small domain specific language and tool to generate stack-optimized
	code for sequences of virtual machine instructions, and for choosing
	the most useful sequences for a code-copying compiler. By measuring
	the length of the resulting executable code, we allow machine-specific
	sequences to be chosen without any machine-dependent code in our
	system. Experimental results show that best (average) speedups of
	47.2% (15.75%) are possible on a Pentium 4 machine, and even higher
	an a PowerPC based machine. Furthermore, our optimizations allow
	the size of the generated code to be reduced by an average of 17.9%
	on the Pentium 4, and 20.5% on the PowerPC over a wide range of programs.
	Copyright © 2006 John Wiley & Sons, Ltd.},
  affiliation = {Department of Computer Science, University of Dublin, Trinity College,
	Dublin 2, Ireland; Institut für Computersprachen, Technische Universität
	Wien, Argentinierstrasse 8, 1220 Wien, Austria},
  author_keywords = {Compiler; Interpreter; Virtual machine},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-33748456522&partnerID=40&md5=ff57d2f5123a5f2e7564dd905b5d9df8}
}

@ARTICLE{Grelck2007410,
  author = {Grelck, C.a b , Penczek, F.a b , Trojahner, K.b },
  title = {CAOS: A domain-specific language for the parallel simulation of cellular
	automata},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2007},
  volume = {4671 LNCS},
  pages = {410-417},
  note = {cited By (since 1996) 0},
  abstract = {We present the design and implementation of CAOS, a domain-specific
	high-level programming language for the parallel simulation of extended
	cellular automata. CAOS allows scientists to specify complex simulations
	with limited programming skills and effort. Yet the CAOS compiler
	generates efficiently executable code that automatically harnesses
	the potential of contemporary multi-core processors, shared memory
	multiprocessors, workstation clusters and supercomputers. © Springer-Verlag
	Berlin Heidelberg 2007.},
  affiliation = {University of Hertfordshire, Department of Computer Science; University
	of Lübeck, Institute of Software Technology and Programming Languages},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-38149134484&partnerID=40&md5=03f1c28a898a39c05796dd35e322789f}
}

@ARTICLE{Grigorenko2010251,
  author = {Grigorenko, P., Tyugu, E.},
  title = {Higher-order attribute semantics of flat declarative languages},
  journal = {Computing and Informatics},
  year = {2010},
  volume = {29},
  pages = {251-280},
  number = {2},
  note = {cited By (since 1996) 0},
  abstract = {A technique is described that provides a convenient instrument for
	implementation of semantics of simple declarative languages called
	flat languages. Semantics of a specification is defined in the paper
	as a set of programs derivable for solvable goals. We introduce higher-order
	attribute models that include more control information than conventional
	attribute models and explain the algorithm for dynamic evaluation
	of attributes on these models. A visual tool CoCoViLa is briefly
	described as an instrument for implementing attribute semantics of
	flat languages.},
  affiliation = {Institute of Cybernetics, Tallinn University of Technology, Akadeemia
	tee 21, 12618 Tallinn, Estonia},
  author_keywords = {Attribute semantics of declarative languages; Domain specific languages;
	Flat languages; Higher-order attribute models; Synthesis of programs},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-77954780528&partnerID=40&md5=465fc5a03837bcbb8fb1e30e0730350c}
}

@ARTICLE{Griss1995213,
  author = {Griss, M.L., Wentzel, K.D.},
  title = {Hybrid domain-specific kits},
  journal = {The Journal of Systems and Software},
  year = {1995},
  volume = {30},
  pages = {213-230},
  number = {3},
  note = {cited By (since 1996) 5},
  abstract = {As part of Hewlett-Packard Laboratories research into systematic,
	domain-specific reuse, we are exploring the notion of domain-specific
	kits. Kits are comprised of compatible, domain-specific components,
	frameworks, and languages, supported by a variety of well-integrated
	technologies and tools, such as domain-specific languages, builders,
	generators, and domain-tailored environments. We are particularly
	interested in hybrid kits, which make visible the combination of
	both generative and compositional reuse. We have prototyped several
	sample kits and have designed a framework for analyzing and comparing
	kits. © 1995.},
  affiliation = {Hewlett-Packard Laboratories, Palo Alto, CA, United States},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-0029379011&partnerID=40&md5=3484cd0f981214887557e5e3c26a4c52}
}

@ARTICLE{Grobelny2010132,
  author = {Grobelny, P.},
  title = {A method for reasoning about complex services within geographic information
	systems},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2010},
  volume = {6070 LNAI},
  pages = {132-141},
  number = {PART 1},
  note = {cited By (since 1996) 0},
  abstract = {This paper addresses the problem of intelligent discovery and matchmaking
	of services within geographic information systems (GIS) domain. Expert
	system could advise the domain engineer in adaptively building of
	new functionalities with the help of deductive database and domain
	knowledge. The Services Oriented Architecture (SOA) allows one to
	fulfill these requirements. The objective of this document is to
	provide a method for arranging complex services with use of object-oriented
	expert system, domain specific language and domain ontology in the
	area of Internet GIS. © 2010 Springer-Verlag.},
  affiliation = {University of Zielona Gora, Faculty of Electrical Engineering, Computer
	Science and Telecommunications, Podgorna 50, Zielona Gora 65-246,
	Poland},
  author_keywords = {Domain Specific Language; Expert System; Geographic Information Systems;
	Semantic Web Services},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-77954593355&partnerID=40&md5=838941f584c3fb819962efbd501643aa}
}

@CONFERENCE{Grobelny2008119,
  author = {Grobelny, P.},
  title = {The expert system approach in development of loosely coupled software
	with use of domain specific language},
  year = {2008},
  volume = {3},
  pages = {119-123},
  note = {cited By (since 1996) 1},
  abstract = {This paper addresses the problem of supporting the software development
	process through the artificial intelligence. The expert systems could
	advise the domain engineer in programming without the detailed experience
	in programming languages. He will use and integrate, with the help
	of deductive database and domain knowledge, the previously developed
	software components to new complex functionalities. The Service Oriented
	Architecture (SOA) and loosely coupled software allow to fulfill
	these requirements. The objective of this document is to provide
	the knowledge representation of atomic Web Services which will be
	registered as the facts in the deductive database as well as the
	inferring techniques. Also, the use of Domain Specific Language (DSL)
	for modeling domain engineer's requests to the expert system will
	be considered within this document. © 2008 IEEE.},
  affiliation = {University of Zielona Gora, Faculty of Electrical Engineering, Computer
	Science and Telecommunication, Podgorna 50, 65-246 Zielona Gora,
	Poland},
  art_number = {4747227},
  document_type = {Conference Paper},
  journal = {Proceedings of the International Multiconference on Computer Science
	and Information Technology, IMCSIT 2008},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-70349334197&partnerID=40&md5=28a44f9a5b6857f6ee7f8085708a30a2}
}

@CONFERENCE{Groce2010129,
  author = {Groce, A.a , Havelund, K.b , Smith, M.c },
  title = {From scripts to specifications: The evolution of a flight software
	testing effort},
  year = {2010},
  volume = {2},
  pages = {129-138},
  note = {cited By (since 1996) 2},
  abstract = {This paper describes the evolution of a software testing effort during
	a critical period for the flagship Mars Science Laboratory rover
	project at the Jet Propulsion Laboratory. Formal specification for
	post-run analysis of log files, using a domain-specific language,
	LogScope, replaced scripted real-time analysis. Log analysis addresses
	the key problems of on-the-fly approaches and cleanly separates specification
	and execution. Mining the test repository suggested the inadequacy
	of the scripted approach, and encouraged a partly engineer-driven
	development. LogScope development should hold insights for others
	facing the tight deadlines and reactionary nature of testing for
	critical projects. LogScope received a JPL Mariner Award for "improving
	productivity and quality of the MSL Flight Software" and has been
	discussed as an approach for other flight missions. We note LogScope
	features that most contributed to ease of adoption and effectiveness.
	LogScope is general and can be applied to any software producing
	logs. © 2010 ACM.},
  affiliation = {School of Electrical Engineering and Computer Science, Oregon State
	University, Corvallis, OR, United States; Laboratory for Reliable
	Software, Jet Propulsion Laboratory, California Institute of Technology,
	Pasadena, CA, United States; Software System Engineering, Jet Propulsion
	Laboratory, California Institute of Technology, Pasadena, CA, United
	States},
  author_keywords = {development practices; logs; Python; runtime verification; space flight
	software; temporal logic; test infrastructure; testing},
  document_type = {Conference Paper},
  journal = {Proceedings - International Conference on Software Engineering},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-77954690759&partnerID=40&md5=ceed668bca49e90fb88ca359ad2f0023}
}

@ARTICLE{Groenewegen201031,
  author = {Groenewegen, D., Hemel, Z., Visser, E.},
  title = {Separation of concerns and linguistic integration in webDSL},
  journal = {IEEE Software},
  year = {2010},
  volume = {27},
  pages = {31-37},
  number = {5},
  note = {cited By (since 1996) 0},
  abstract = {Web application development is a complex task, in which developers
	must address many concerns, such as user interface, data model, access
	control, data validation, and search. Current technology typically
	requires multiple languages and programming paradigms to cover these
	aspects. Using such domain-specific languages improves developer
	expressivity and lets them separate concerns. However, coupling these
	technologies is often less than optimal. It results in little or
	no consistency checking between concerns as well as wildly different
	language styles and paradigmsfrom XML-style transformation languages
	like Extensible Style Sheet Language Transformation, to aspect languages
	like cascading style sheets, to object-oriented languages like Java
	and Java Script. WebDSL is a domain-specific language for constructing
	Web information systems. The language comprises sublanguages that
	address Web application concerns, maintaining separation of concerns,
	but integrating linguistically to provide consistency checking and
	reuse of common language concepts consistency checking and reuse
	of common language concepts between concerns. In this paper we describe
	the problems in web application development and discuss the WebDSL
	solution. © 2006 IEEE.},
  affiliation = {Software Engineering Research Group, Delft University of Technology,
	Netherlands},
  art_number = {5473205},
  author_keywords = {domain-specific languages; separation of concerns; static verification;
	web applications; WebDSL},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-77956033888&partnerID=40&md5=224aec8173c3722b9f9e51f73d73d951}
}

@CONFERENCE{Groenewegen2008175,
  author = {Groenewegen, D., Visser, E.},
  title = {Declarative access control for webDSL: Combining language integration
	and separation of concerns},
  year = {2008},
  pages = {175-188},
  note = {cited By (since 1996) 6},
  abstract = {In this paper, we present the extension of WebDSL, a domain-specific
	language for web application development, with abstractions for declarative
	definition of access control. The extension supports the definition
	of a wide range of access control policies concisely and transparently
	as a separate concern. In addition to regulating the access to pages
	and actions, access control rules are used to infer navigation options
	not accessible to the current user, preventing the presentation of
	inaccessible links. The extension is an illustration of a general
	approach to the design of domain-specific languages for different
	technical domains to support separation of concerns in application
	development, while preserving linguistic integration. This approach
	is realized by means of a transformational semantics that weaves
	separately defined aspects into an integrated implementation. © 2008
	IEEE.},
  affiliation = {Software Engineering Research Group, Delft University of Technology,
	Netherlands},
  art_number = {4577881},
  document_type = {Conference Paper},
  journal = {Proceedings - 8th International Conference on Web Engineering, ICWE
	2008},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-51749099604&partnerID=40&md5=ab1e2260febfc866b8cb319ffdc2c472}
}

@CONFERENCE{Groenewegen2008779,
  author = {Groenewegen, D.M., Hemel, Z., Kats, L.C.L., Visser, E.},
  title = {WebDSL : A domain-specific language for dynamic web applications},
  year = {2008},
  pages = {779-780},
  note = {cited By (since 1996) 4},
  abstract = {WebDSL is a domain-specific language for the implementation of dynamic
	web applications with a rich data model. It consists of a core language
	with constructs to define entities, pages and business logic. Higher-level
	abstractions, modeling access control and workflow, are defined in
	a modular fashion as extensions of the core language.},
  affiliation = {Delft University of Technology, Netherlands},
  author_keywords = {Design; Languages},
  document_type = {Conference Paper},
  journal = {Proceedings of the Conference on Object-Oriented Programming Systems,
	Languages, and Applications, OOPSLA},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-63349109706&partnerID=40&md5=aef3f8b27622de93c2057252268c8abb}
}

@ARTICLE{Groenewegen2010164,
  author = {Groenewegen, D.M., Visser, E.},
  title = {Integration of data validation and user interface concerns in a DSL
	for web applications},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2010},
  volume = {5969 LNCS},
  pages = {164-173},
  note = {cited By (since 1996) 0},
  abstract = {Data validation rules constitute the constraints that data input and
	processing must adhere to in addition to the structural constraints
	imposed by a data model. Web modeling tools do not address data validation
	concerns explicitly, hampering full code generation and model expressivity.
	Web application frameworks do not offer a consistent interface for
	data validation. In this paper, we present a solution for the integration
	of declarative data validation rules with user interface models in
	the domain of web applications, unifying syntax, mechanisms for error
	handling, and semantics of validation checks, and covering value
	well-formedness, data invariants, input assertions, and action assertions.
	We have implemented the approach in WebDSL, a domain-specific language
	for the definition of web applications. © 2010 Springer-Verlag.},
  affiliation = {Software Engineering Research Group, Delft University of Technology,
	Netherlands},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-77951592919&partnerID=40&md5=709482f7c9391c60e8c3040235376f55}
}

@CONFERENCE{Groenewegen2009797,
  author = {Groenewegen, D.M., Visser, E.},
  title = {Weaving web applications with WebDSL (demonstration)},
  year = {2009},
  pages = {797-798},
  note = {cited By (since 1996) 0},
  abstract = {WebDSL is a domain-specific language for the development of web applications
	that integrates data-models, user-interface models, actions, validation,
	access control, and workflow. The compiler verifies the consistency
	of applications and generates complete implementations in Java or
	Python. We illustrate the key concepts of the language with a small
	web application.},
  affiliation = {Software Engineering Research Group, Delft University of Technology,
	Netherlands},
  author_keywords = {Access control; Data binding; Data model; Domain-specific languages;
	Web application model},
  document_type = {Conference Paper},
  journal = {Proceedings of the Conference on Object-Oriented Programming Systems,
	Languages, and Applications, OOPSLA},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-72249107813&partnerID=40&md5=2477efa449dad7ca0ad78d0b0e968264}
}

@CONFERENCE{Grund2009136,
  author = {Grund, M., Krueger, J., Schaffner, J., Schapranow, M., Bog, A.},
  title = {Operational reporting using navigational SQL},
  year = {2009},
  pages = {136-140},
  note = {cited By (since 1996) 0},
  abstract = {Ad-hoc analytics on top of OLTP data provides direct business value
	in that business users can directly interact with the system to gather
	information for decision-making. From a business user perspective,
	SQL requires - for a schema that is never changed - deep schema knowledge
	in order to express navigation along join paths even for simple queries.
	In this paper we introduce Navigational SQL, a language that provides
	constructs specifically tailored for data retrieval in the context
	of operational reporting, such as a navigation operator that has
	explicit knowledge about join paths in a particular schema and gives
	the user an "application level view" of the tables. We motivate NSQL
	using examples from operational reporting and outline its benefits
	over materialized views and domain specific languages, which could
	also be used to address the issues with SQL described above fully
	or in part. © 2008 IEEE.},
  affiliation = {Hasso-Plattner-Institut, University of Potsdam, August-Bebel-Str 88,
	14482 Potsdam, Germany},
  art_number = {4721477},
  document_type = {Conference Paper},
  journal = {2008 IEEE Symposium on Advanced Management of Information for Globalized
	Enterprises, AMIGE 2008 - Proceedings},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-61649113793&partnerID=40&md5=b71b50a3e9b9e2fa2064c8f9db2a2dd9}
}

@CONFERENCE{Grönniger2008925,
  author = {Grönniger, H., Krahn, H., Rumpe, B., Schindler, M., Völkel, S.},
  title = {Monti core: A framework for the development of textual domain specific
	languages},
  year = {2008},
  pages = {925-926},
  note = {cited By (since 1996) 6},
  abstract = {In this paper we demonstrate a framework for the efficient development
	of textual domain specific languages and supporting tools. We use
	a redundance-free and compact definition of a readable concrete syntax
	and a comprehensible abstract syntax as both representations significantly
	overlap in their structure. To further improve the usability of the
	abstract syntax, this definition format integrates additional concepts
	like associations and inheritance into the well-understood grammar-based
	approach. Modularity concepts like language inheritance and embedding
	are used to simplify the development of languages based on already
	existing ones. In addition, the generation of editors and a template
	approach for code generation is explained.},
  affiliation = {Software Systems Engineering, TU Braunschweig, United Kingdom},
  author_keywords = {Domain Specific Languages; Extensibility; Modularity},
  document_type = {Conference Paper},
  journal = {Proceedings - International Conference on Software Engineering},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-57349126795&partnerID=40&md5=064b1b89b6d28b2d133bdd9f56198780}
}

@ARTICLE{Guerra2007269,
  author = {Guerra, E., Sanz, D., Díaz, P., Aedo, I.},
  title = {A transformation-driven approach to the verification of security
	policies in web designs},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2007},
  volume = {4607 LNCS},
  pages = {269-284},
  note = {cited By (since 1996) 1},
  abstract = {In this paper, we present a verification framework for security policies
	of Web designs. The framework is based on the transformation of the
	models that conform the system design into a formalism where further
	analysis can be performed. The transformation is specified as a triple
	graph transformation system, which in addition creates mappings between
	the elements in the source and target models. This allows the back-annotation
	of the analysis results to the original model by means of triple
	graphical patterns. The verification mechanisms are provided by the
	designer of the Web design language, together with the language specification.
	However, the complexities of the formalisms are hidden to the developer
	who uses the language. As case study, we apply these ideas to Labyrinth,
	a domain specific language oriented to the design of Web applications.
	The analysis is done by a transformation into the Petri nets formalism,
	and then performing model checking on the coverability graph. The
	framework is supported by the meta-modelling tool AToM3. © Springer-Verlag
	Berlin Heidelberg 2007.},
  affiliation = {Computer Science Department, Universidad Carlos III de Madrid, Spain},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-38149022761&partnerID=40&md5=1a262b053c4421296386beb4d842b244}
}

@CONFERENCE{Gulotta20093,
  author = {Gulotta, J., Chu, D., Yu, X., Al-Helal, H., Patki, T., Hansen, J.,
	Hudson, M., Sprinkle, J.},
  title = {Using integrative models in an advanced heterogeneous system simulation},
  year = {2009},
  pages = {3-10},
  note = {cited By (since 1996) 0},
  abstract = {This paper is an academic experience report describing the use by
	researchers at the University of Arizona of a domain-specific language
	developed by the Institute for Software Integrated Systems (at Vanderbilt
	University). The domain in question is heterogeneous, distributed
	simulation of quad-rotor unmanned aerial vehicles (UAVs) as they
	respond to command and control requests from a human operator. We
	describe in detail how our individual designs of the controller and
	guidance laws for the UAV, its rendering and position updates, on-board
	sensors, and the various commands to delegate mission-critical behaviors,
	all interact using the ISIS-developed modeling language. We then
	discuss the outlook for this domain (heterogeneous system simulation
	and integration) for domain-specific languages and models, specifically
	for unmanned vehicle control and interaction. © 2009 IEEE.},
  affiliation = {Department of Electrical and Computer Engineering, University of Arizona,
	Tucson, AZ 85721-0104, United States},
  art_number = {4839226},
  document_type = {Conference Paper},
  journal = {Proceedings of the International Symposium and Workshop on Engineering
	of Computer Based Systems},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-67650236592&partnerID=40&md5=c180b27ec8ae4857a395e9f23d20e761}
}

@ARTICLE{Gulwani2001191,
  author = {Gulwani, S.a , Tarachandani, A.a , Gupta, D.a , Sanghi, D.a , Barreto,
	L.P.b , Muller, G.b , Consel, C.b , Compose Groupb },
  title = {WebCaL - a domain specific language for web caching},
  journal = {Computer Communications},
  year = {2001},
  volume = {24},
  pages = {191-201},
  number = {2},
  note = {cited By (since 1996) 1},
  abstract = {Web caching aims to improve the performance of the Internet in three
	ways - by improving client latency, alleviating network traffic and
	reducing server load. A web cache is basically a limited store of
	information which helps in presenting a faster web-access environment
	to the clients. The performance of a cache depends on proper management
	of this information and effective inter-cache communication. The
	existing web caches have simple and hard-coded policies which are
	not best suited for all environments. They offer limited flexibility
	just in the form of changing some simple parameters such as cache
	size, peer caches, etc. This drawback motivates the need for a framework
	for building new web caches tailored to specific environments. In
	this paper, we describe a domain specific language based on an event-action
	model using which new local web cache policies and inter-cache protocols
	can be easily specified. This should make it possible to write a
	new policy or protocol quickly, evaluate its performance and test
	it thoroughly using the complete program-execute-debug cycle.},
  affiliation = {Dept. of Comp. Sci. and Engineering, Indian Institute of Technology,
	Kanpur, India; IRISA/INRIA, Rennes, France},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-9144274582&partnerID=40&md5=445d05b4ac17bea34d41f4d74c2e3c2e}
}

@CONFERENCE{Guta2009255,
  author = {Guta, G.a , Schreiner, W.a , Draheim, D.b },
  title = {A lightweight MDSD process applied in small projects},
  year = {2009},
  pages = {255-258},
  note = {cited By (since 1996) 0},
  abstract = {Model driven software development, domain specific languages and other
	generative programming approaches have gained much attention. There
	is a large number of tools available, starting from simple code generators
	to full-blown tool suites. There are several success stories and
	process frameworks about applying full scale MDSD approaches, but
	there is no or little help for small-size projects. To fill this
	gap, we designed a new development process which targets small and
	middle size projects with limited resources. According to our experience
	the process is working efficiently in small projects even if they
	cannot afford bigger initial resource investment. In this experince
	report we document an industrial project in which the process was
	used. We present this process in the form which is applied in the
	first project and also discuss our experience and the limitations
	of the process. © 2009 IEEE.},
  affiliation = {Research Institute for Symbolic Computation (RISC), Johannes Kepler
	University, Linz, Austria; Central Information Technology Services,
	University of Innsbruck, Austria},
  art_number = {5349852},
  author_keywords = {Agile development; MDSD; Software process},
  document_type = {Conference Paper},
  journal = {Conference Proceedings of the EUROMICRO},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-74549193948&partnerID=40&md5=89067a74886feff446cddec9cb80bf93}
}

@ARTICLE{Guyer200039,
  author = {Guyer, S.Z., Lin, C.},
  title = {An annotation language for optimizing software libraries},
  journal = {SIGPLAN Notices (ACM Special Interest Group on Programming Languages)},
  year = {2000},
  volume = {35},
  pages = {39-51},
  number = {1},
  note = {cited By (since 1996) 3},
  abstract = {This paper introduces an annotation language and a compiler that together
	can customize a library implementation for specific application needs.
	Our approach is distinguished by its ability to exploit high level,
	domain-specific information in the customization process. In particular,
	the annotations provide semantic information that enables our compiler
	to analyze and optimize library operations as if they were primitives
	of a domain-specific language. Thus, our approach yields many of
	the performance benefits of domain-specific languages, without the
	effort of developing a new compiler for each domain. This paper presents
	the annotation language, describes its role in optimization, and
	illustrates the benefits of the overall approach. Using a partially
	implemented compiler, we show how our system can significantly improve
	the performance of two applications written using the PLAPACK parallel
	linear algebra library.},
  affiliation = {University of Texas, Austin, TX, United States},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-17644426739&partnerID=40&md5=2f8eb04b4d3d10688fbe58e07362ff8e}
}

@ARTICLE{Gérard2010361,
  author = {Gérard, S.a , Dumoulin, C.b , Tessier, P.a , Selic, B.c },
  title = {Papyrus: A UML2 tool for domain-specific language modeling},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2010},
  volume = {6100 LNCS},
  pages = {361-368},
  note = {cited By (since 1996) 0},
  abstract = {This chapter outlines Papyrus, a tool for graphical modeling of UML2
	applications. It is an open-source project, designed as an Eclipse
	component, and based on the existing EMF-based realization of the
	UML2 meta-model. The goal of this open-source project is twofold.
	First, it is a complete, efficient, robust, and methodologically
	agnostic implementation of a UML2 tool to both industry and academia.
	Second, it is an open and flexible facility for defining and utilizing
	domain-specific modeling languages using a very advanced implementation
	of the UML profile concept. © 2010 Springer-Verlag.},
  affiliation = {CEA LIST, Laboratory of Model Driven Engineering for Embedded Systems
	(LISE), Boîte courrier 65, Gif sur Yvette Cedex, F-91191, France;
	LIFL, INRIA-Lille Nord Europe, University of Lille, France; Malina
	Software Corp., Nepean, ON, Canada},
  author_keywords = {DSL; MDD; MDE; Modeling and Eclipse; UML profile; UML2},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-78449236588&partnerID=40&md5=66171b69073c35b81674e908806befae}
}

@ARTICLE{Gérard2010129,
  author = {Gérard, S.a , Espinoza, H.b , Terrier, F.a , Selic, B.b },
  title = {Modeling languages for real-time and embedded systems: Requirements
	and standards-based solutions},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2010},
  volume = {6100 LNCS},
  pages = {129-154},
  note = {cited By (since 1996) 0},
  abstract = {Development of increasingly more sophisticated dependable real-time
	and embedded systems requires new paradigms since contemporary code-centric
	approaches are reaching their limits. Experience has shown that model-based
	engineering using domain-specific modeling languages is an approach
	that can overcome many of these limitations. This chapter first identifies
	the requirements for a modeling language to be used in the real-time
	and embedded systems domain. Second, it describes how the MARTE profile
	of the industry-standard UML language meets these requirements. MARTE
	enables precise modeling of phenomena such as time, concurrency,
	software and hardware platforms, as well as their quantitative characteristics.
	© 2010 Springer-Verlag.},
  affiliation = {CEA LIST, Laboratory of Model Driven Engineering for Embedded Systems
	(LISE), Boîte courrier 65, Gif sur Yvette Cedex, F-91191, France;
	Malina Software Corp., Nepean, ON, Canada},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-78449261764&partnerID=40&md5=6b9257c5ca7bda63ecaf36de7100c226}
}

@ARTICLE{Günes2010465,
  author = {Günes, M., Juraschek, F., Blywis, B.},
  title = {An experiment description language for wireless network research},
  journal = {Journal of Internet Technology},
  year = {2010},
  volume = {11},
  pages = {465-472},
  number = {4},
  note = {cited By (since 1996) 0},
  abstract = {This article introduces a network experiment description language
	that is designed as a general approach for testbed networks and simulation
	environments. The approach is based on a domain specific language
	simplifying the execution of experiments by using an easily comprehensible
	and straight-forward design scheme. By laying out a clear logical
	structure, experiment descriptions provide the user with the possibility
	to only focus on the crucial matter of experiments. An experiment
	description file serves as the input for a software tool that executes
	the experiment automatically, thus being able to use a reliable timing
	for all specified actions. We developed this approach as DES-Cript
	for the DES-Testbed at the Freie Universität Berlin, but it is not
	limited to this particular testbed.},
  affiliation = {Distributed Embedded Systems, Freie Universität Berlin, Germany},
  author_keywords = {Experiment description language; Networking experiments; Wireless
	testbed},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-77956517474&partnerID=40&md5=097d77722234b33ebb9a02992e0cd0dc}
}

@ARTICLE{Günther201025,
  author = {Günther, S.},
  title = {Multi-DSL applications with Ruby},
  journal = {IEEE Software},
  year = {2010},
  volume = {27},
  pages = {25-30},
  number = {5},
  note = {cited By (since 1996) 3},
  abstract = {Domain-specific languages (DSLs) are becoming a mature application
	development tool that developers use to express concerns. Multi-DSL
	applications comprise DSLs and host language code. Exploiting the
	Ruby programming language's built-in support for the imperative,
	functional, and object-oriented paradigm, extended with feature-oriented
	programming, the author uses integrated and interwoven multiparadigm
	expressions of several DSLs to express all application layers, concerns,
	and artifacts. In addition to the case study, the author discusses
	how this approach impacts analysis, design, implementation, and testing
	of applications. © 2010 IEEE.},
  art_number = {5473204},
  author_keywords = {Internet applications; multiparadigm languages; programming languages;
	software engineering; specialized application languages},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-77956033657&partnerID=40&md5=e935daa7a4ee1f4e0de1c6e49557757e}
}

@CONFERENCE{Günther2010162,
  author = {Günther, S., Haupt, M., Splieth, M.},
  title = {Agile engineering of internal Domain-Specific Languages with dynamic
	programming languages},
  year = {2010},
  pages = {162-168},
  note = {cited By (since 1996) 0},
  abstract = {Domain-Specific Languages (DSL) abstract from the domain entities
	and operations to represent domain knowledge in the form of an executable
	language. While they solve many of the current software development
	challenges, related literature claims that DSLs usually have a flaw:
	The high effort required to implement and use them. However, internal
	DSLs are developed with less effort because they are built on top
	of an existing programming language and can use the whole language
	infrastructure consisting of interpreter, compiler, or editors. This
	article presents an engineering process for internal DSLs. An agile
	process leads from analysis to design and implementation. Expressions
	and language capabilities are implemented using tests and a set of
	patterns, which provide reusable knowledge how to properly structure
	and design the DSL implementation. As a case study, we show how to
	implement a software product line configuration DSL using Ruby and
	Python as host languages. In summary, the proposed process and patterns
	facilitate the successful planning and developing of internal DSLs
	using dynamic programming languages as the host. © 2010 IEEE.},
  affiliation = {School of Computer Science, University of Magdeburg, Germany},
  art_number = {5615143},
  author_keywords = {Domain-Specific Languages},
  document_type = {Conference Paper},
  journal = {Proceedings - 5th International Conference on Software Engineering
	Advances, ICSEA 2010},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-78649848098&partnerID=40&md5=ea627d56f49363a94e4ba4af0f516029}
}

@CONFERENCE{Günther201080,
  author = {Günther, S., Sunkle, S.},
  title = {Dynamically adaptable software product lines using Ruby metaprogramming},
  year = {2010},
  pages = {80-87},
  note = {cited By (since 1996) 1},
  abstract = {Software product lines (SPL) is a paradigm to structure software development
	assets in a common and reusable form. Out of this common asset base
	- which includes the application's source code, documentation, and
	configuration - concrete product variants can be created. The variants
	are differing in terms of the features, which are basically an increment
	in functionality important for a stakeholder. Feature-oriented programming
	(FOP) provides the capability to compose those different variants.
	In earlier work we presented rbFeatures, a FOP implementation in
	Ruby. With rbFeatures, features become are first-class entities of
	the language that facilitate runtime changes of the program. This
	paper presents an extension to rbFeatures that implements product
	lines and their variants as first-class entities too. The entities
	allow powerful runtime-adaptation and configuration, like to add
	new features or constraints to the product line and the instantiation
	of several variants with different feature configurations. The particular
	contributions are to show how Ruby's metaprogramming capabilities
	are used to design first-class entities and an explanation of the
	usage of our approach with a common case study. © 2010 ACM.},
  affiliation = {School of Computer Science, University of Magdeburg, Germany},
  art_number = {1868700},
  author_keywords = {domain-specific languages; feature-oriented programming; metaprogramming;
	runtime adaptation; software product lines},
  document_type = {Conference Paper},
  journal = {Proceedings of the 2nd International Workshop on Feature-Oriented
	Software Development, FOSD'10},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-78751682728&partnerID=40&md5=ac3e5a61c1174d69c3549a11ab84e9f7}
}

@CONFERENCE{Günther200911,
  author = {Günther, S., Sunkle, S.},
  title = {Feature-oriented programming with Ruby},
  year = {2009},
  pages = {11-18},
  note = {cited By (since 1996) 0},
  abstract = {Features identify core characteristics of software in order to produce
	families of programs. Through configuration, different variants of
	a program can be composed. Our approach is to design features as
	first-class entities of a language. With this approach, features
	can be constructed and returned by methods, stored in variables and
	used in many expressions of the language. This paper introduces rbFeatures,
	an implementation of first-class features in the dynamic programming
	language Ruby. Our goal is to show how such a language extension
	works with respect to its dynamic host language and the applicability
	of our results. In particular, we present a step-by-step walkthrough
	how to use rbFeatures in order to implement known case-studies like
	the Graph Product Line or the Expression Product Line. Since we created
	a pure Ruby language extension, rbFeatures can be used with any existing
	programs and in any virtual machine implementing Ruby. Copyright
	2009 ACM.},
  affiliation = {Faculty of Computer Science, University of Magdeburg},
  art_number = {1629721},
  author_keywords = {Domain-specific languages; Dynamic programming languages; Feature-oriented
	programming},
  document_type = {Conference Paper},
  journal = {ACM International Conference Proceeding Series},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-70350686395&partnerID=40&md5=8591b13adee5bedf0138227be527fbf3}
}

@CONFERENCE{Haber2011,
  author = {Haber, A.a , Kutz, T.a , Rendel, H.a , Rumpe, B.a , Schaefer, I.b
	},
  title = {Delta-oriented architectural variability using MontiCore},
  year = {2011},
  note = {cited By (since 1996) 0},
  abstract = {Modeling of software architectures is a fundamental part of software
	development processes. Reuse of software components and early analysis
	of software topologies allow the reduction of development costs and
	increases software quality. Integrating variability modeling concepts
	into architecture description languages (ADLs) is essential for the
	development of diverse software systems with high demands on software
	quality. In this paper, we present the integration of delta modeling
	into the existing ADL MontiArc. Delta modeling is a language-independent
	variability modeling approach supporting proactive, reactive and
	extractive product line development. We show how δ-MontiArc, a language
	for explicit modeling of architectural variability based on delta
	modeling, is implemented as domain-specific language (DSL) using
	the DSL development framework MontiCore. We also demonstrate how
	MontiCore's language reuse mechanisms provide effcient means to derive
	an implementation of δ-MontiArc tool implementation. We evaluate
	δ-Monti- Arc by comparing it with annotative variability modeling.
	Copyright © 2011 ACM.},
  affiliation = {Software Engineering, RWTH Aachen University, Germany; Institute for
	Software Systems Engineering, TU Braunschweig, Germany},
  art_number = {6},
  author_keywords = {Delta modeling; DSL development; DSL reuse; Software architectures},
  document_type = {Conference Paper},
  journal = {ACM International Conference Proceeding Series},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-80053916791&partnerID=40&md5=6610e3ae9f28d199e99eac9c29841ab8}
}

@ARTICLE{Hafner2006275,
  author = {Hafner, M., Alam, M., Breu, R.},
  title = {Towards a MOF/QVT-based domain architecture for model driven security},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2006},
  volume = {4199 LNCS},
  pages = {275-290},
  note = {cited By (since 1996) 4},
  abstract = {The SECTET-framework realizes an extensible domain architecture for
	the collaborative development and management of security-critical,
	inter-organizational workflows. Models integrate security requirements
	at the abstract level and are rendered in a visual language based
	on UML 2.0. The models form the input for a chain of integrated tools
	that transform them into artefacts configuring security components
	of a Web services-based architecture. Based on findings of various
	projects, this contribution has three objectives. First, we detail
	the MOF based metamodels defining a domain specific language for
	the design of inter-organizational workflows. The language supports
	various categories of security patterns. We then specify model-to-model
	transformations based on the MDA standard MOF-QVT. The mappings translate
	platform independent models into platform specific artefacts targeting
	the reference architecture. Third, we exemplarily show how model-to-code
	transformation could be implemented with an MDA-framework like OPEN
	ARCHITECTUREWARE. © Springer-Verlag Berlin Heidelberg 2006.},
  affiliation = {Universität Innsbruck, Institut für Informatik, Techniker Straße 21a,
	A - 6020 Innsbruck},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-33750315310&partnerID=40&md5=51566ec7b562e94a432c08dc22077452}
}

@ARTICLE{Hafner2008132,
  author = {Hafner, M., Memon, M., Alam, M.},
  title = {Modeling and enforcing advanced access control policies in healthcare
	systems with SECTET},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2008},
  volume = {5002 LNCS},
  pages = {132-144},
  note = {cited By (since 1996) 1},
  abstract = {This contribution gives an overview of various access control strategies
	in use in healthcare scenarios and shows how a variety of policies
	can be modeled based on a single security policy model for usage
	control, UCON. The core of this contribution consists of the specialization
	of the Sectet-Framework for Model Driven Security for complex healthcare
	scenarios based on UCON. The resulting Domain Architecture comprises
	a Domain Specific Language for the modeling of policies with advanced
	security requirements, a target architecture for the enforcement
	of these policies and model-to-code transformations. © 2008 Springer-Verlag
	Berlin Heidelberg.},
  affiliation = {University of Innsbruck, Austria},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-47749117634&partnerID=40&md5=dcd6ea3c0c9d297669a0c9223926fd28}
}

@ARTICLE{Hahn200916,
  author = {Hahn, C., Fischer, K.},
  title = {The formal semantics of the domain specific modeling language for
	multiagent systems},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2009},
  volume = {5386},
  pages = {16-30},
  note = {cited By (since 1996) 0},
  abstract = {Recently, associated with the increasing acceptance of agentbased
	computing as a novel computing paradigm a lot of research has been
	addressed to develop mechanisms and methods to support the agent-based
	development of complex software systems. Especially the idea to define
	agent-oriented languages on a more abstract level through metamodels
	is recently often applied. However, the metamodel's opportunity to
	express the language's semantics are restricted as only concepts
	and their relationships to each other can be defined within the metamodel.
	This paper discusses an approach to formalize the semantics of Dsml4mas-a
	modeling language for multiagent systems-to support the system designer
	in validating and verifying the generated design.},
  affiliation = {German Research Institute for Artificial Intelligence (DFKI), Stuhlsatzenhasuweg
	3, 66123 Saarbrücken},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-67649998168&partnerID=40&md5=a840229cc1fb16df32505ff2c84c0df1}
}

@CONFERENCE{Haleplidis2010366,
  author = {Haleplidis, E., Tranoris, C., Denazis, S., Koufopavlou, O.},
  title = {Adopting software engineering practices to network processor devices:
	Introducing the domain specific modeling paradigm to the ForCES framework},
  year = {2010},
  pages = {366-369},
  note = {cited By (since 1996) 0},
  abstract = {IETF's new Forwarding and Control Element Separation (ForCES) architecture
	specifies the ForCES model providing an accurate description of the
	Forwarding Plane in an Object-Oriented fashion. However, the model
	is described totally in an XML Schema Definition (XSD): it is well-defined
	but purely machine oriented, being readable and usable, thus not
	human-friendly and difficult extending itself in the future. We argue
	that the ForCES model is actually a meta-model that is used to model
	ForCES components, e.g. Logical Function Blocks (LFBs), that later
	are used in ForCES applications. This paper presents a methodology
	based on a case study on how to automate the process of configuring
	the forwarding plane of network devices using state-of-the-art model-driven
	techniques in a tangible way while specifying a tool supported by
	a Domain Specific Language (DSL) for ForCES. We first consider describing
	the ForCES XSD based meta-model to a more manageable Ecore (MOF)
	based meta-model and then we create a DSL based on this Ecore meta-model.
	Then we target to transform automatically a Platform Independent
	ForCES model specified in the DSL to an executable target source
	code (Platform Specific: XML-ForCES compliant, C++, Java) able to
	communicate with the ForCES protocol. © 2010 IEEE.},
  affiliation = {Electrical and Computer Engineering Department, University of Patras,
	Rio, Greece},
  art_number = {5691237},
  author_keywords = {Domain specific languages; Ecore; ForCES model; Meta-modelling},
  document_type = {Conference Paper},
  journal = {Proceedings of the 2010 International Conference on Network and Service
	Management, CNSM 2010},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-79951624253&partnerID=40&md5=3640d33aed7714cc7aedae71d2f31c92}
}

@CONFERENCE{Hales200169,
  author = {Hales, T.C.},
  title = {Invited talk sphere packings and generative programming},
  year = {2001},
  pages = {69},
  note = {cited By (since 1996) 0},
  document_type = {Conference Paper},
  journal = {Proceedings of the Annual Symposium on Computational Geometry},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-0034832689&partnerID=40&md5=73fd467d92a8b2fc69518d16e5b77155}
}

@CONFERENCE{Hamdi2009150,
  author = {Hamdi, H., Mosbah, M.},
  title = {A DSL framework for policy-based security of distributed systems},
  year = {2009},
  pages = {150-158},
  note = {cited By (since 1996) 0},
  abstract = {Securing distributed systems remains a significant challenge for several
	reasons. First, the security features required in an application
	may depend on the environment in which the application is operating,
	the type of data exchanged, and the capability of the end-points
	of communication. Second, the security mechanisms deployed could
	apply to both communication and application layers in the system,
	making it difficult to understand and manage overall system security.
	This paper presents a policy-based approach to meeting these needs.
	We propose a framework based on a Domain-Specific Language for the
	specification, verification and implementation of security policies
	for distributed systems. Based on a set of abstractions, this framework
	allows to develop modular security policies and independent of the
	underlying system. Thus, security policies can be developed by a
	developer who is not necessarily computer security expert. © 2009
	IEEE.},
  affiliation = {Université de Bordeaux, LaBRI, 351, cours de la Libération, F-33405
	Talence Cedex, France},
  art_number = {5325382},
  author_keywords = {Compilation; DSL; Implementation; Security policy; Specification;
	Verification},
  document_type = {Conference Paper},
  journal = {SSIRI 2009 - 3rd IEEE International Conference on Secure Software
	Integration Reliability Improvement},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-72849113856&partnerID=40&md5=da15b379e2ae1dba1c723342eb9f55d7}
}

@CONFERENCE{Hamdi2007,
  author = {Hamdi, H.a , Mosbah, M.a , Bouhoula, A.b },
  title = {A domain specific language for securing distributed systems},
  year = {2007},
  note = {cited By (since 1996) 0},
  abstract = {Distributed applications are becoming increasingly common. However,
	incorporating security in them remains a major challenge. There are
	currently few choices to express and enforce security in distributed
	systems. We can either use a special-purpose language which may be
	too limited to express security requirements, or use a general purpose
	language that provides the ability to make complicated security policy
	but makes us reimplement infrastructure code for authorization, interdiction,
	obligation and so on with each new security policy. In this paper,
	we introduce a domain-specific language approach that takes the middle
	road, giving a way to reuse security infrastructure for new policies
	while also allowing the expression of complicated security policy
	easily. We present our DSL approach and and apply it to a real-world
	scenario: specification and implementation of security policy.1 ©
	2007 IEEE.},
  affiliation = {Université de Bordeaux, LaBRI, 351, cours de la Libération, F-33405
	Talence cedex, France; Sup'COM Tunis, Rte de Raoued Km 3, 5 2083,
	Ariana, Tunisia},
  art_number = {4300048},
  document_type = {Conference Paper},
  journal = {Second International Conference on Systems and Networks Communications,
	ICSNC 2007},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-47949108453&partnerID=40&md5=0e33fcda7ad224d7c9df9e2fd3c3df74}
}

@CONFERENCE{Hamey2007533,
  author = {Hamey, L.G.C.},
  title = {Efficient image processing with the apply language},
  year = {2007},
  pages = {533-540},
  note = {cited By (since 1996) 0},
  abstract = {Apply is a Domain-Specific Language for image processing and low-level
	computer vision. Apply allows programmers to write kernel operations
	that focus on the computation for a single pixel location. The compiler
	generates code to perform the kernel computation over entire images.
	The original Apply implementation was developed 20 years ago for
	efficient processing on parallel architectures. The current-generation
	Apply compiler targets efficient code generation for general-purpose
	computers, typically outperforming handwritten code, while maintaining
	the simplicity of the original language. The use of modem compiler
	writing tools, specifically Stratego/XT, has facilitated improvements
	in the language design and made it easy to target the compiler to
	different environments. A large number of computer vision and image
	processing operations can be expressed in Apply. However, some algorithms
	require additional features. To motivate future language development,
	we analyse the requirements of the algorithms provided in a commercial
	machine vision library. © 2007 IEEE.},
  affiliation = {Macquarie University, Sydney, Australia},
  art_number = {4426843},
  document_type = {Conference Paper},
  journal = {Proceedings - Digital Image Computing Techniques and Applications:
	9th Biennial Conference of the Australian Pattern Recognition Society,
	DICTA 2007},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-44949114442&partnerID=40&md5=bb2e9763f9760f95777439ea2f38e4ad}
}

@ARTICLE{Hamey200837,
  author = {Hamey, L.G.C.a , Goldrei, S.N.b },
  title = {Implementing a Domain-Specific Language Using Stratego/XT: An Experience
	Paper},
  journal = {Electronic Notes in Theoretical Computer Science},
  year = {2008},
  volume = {203},
  pages = {37-51},
  number = {2},
  note = {cited By (since 1996) 0},
  abstract = {We describe the experience of implementing a Domain-Specific Language
	using transformation to a General Purpose Language. The domain of
	application is image processing and low-level computer vision. The
	transformation is accomplished using the Stratego/XT language transformation
	toolset. The implementation presented here is contrasted with the
	original implementation carried out many years ago using standard
	compiler implementation tools of the day. We highlight some of the
	unexpected advantages afforded to us, as language designers and implementers,
	by the source-to-source transformation technique. We also present
	some of the practical challenges faced in the implementation and
	show how these issues were addressed. © 2008 Elsevier B.V. All rights
	reserved.},
  affiliation = {Computing Department, Macquarie University, Sydney, Australia; Computing
	Department, Macquarie University, Sydney, Australia},
  author_keywords = {compiler implementation; computer vision; Domain-specific language;
	language definition; transformation},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-41349100475&partnerID=40&md5=4991b04264f085f08ca94b934b3f01a6}
}

@ARTICLE{Hammond200337,
  author = {Hammond, K.a , Michaelson, G.b },
  title = {Hume: A domain-specific language for real-time embedded systems},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2003},
  volume = {2830},
  pages = {37-56},
  note = {cited By (since 1996) 11},
  abstract = {This paper describes Hume: A novel domain-specific language whose
	purpose is to explore the expressibility/costability spectrum in
	resource-constrained systems, such as real-time embedded or control
	systems. Hume provides a number of high level features including
	higher-order functions, polymorphic types, arbitrary but sized user-defined
	data structures, asynchronous processes, lightweight exception handling,
	automatic memory management and domain-specific metaprogramming features,
	whilst seeking to guarantee strong space/time behaviour and maintaining
	overall determinacy. © Springer-Verlag Berlin Heidelberg 2003.},
  affiliation = {School of Computer Science, University of St. Andrews, St Andrews,
	United Kingdom; Dept. of Mathematics and Computer Science, Heriot-Watt
	University, Edinburgh, United Kingdom},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-35248821142&partnerID=40&md5=0882d5e87a556011d1321a3ac805b5b9}
}

@CONFERENCE{Han20081235,
  author = {Han, Y., Liu, S., Wang, X., Li, B.},
  title = {Design of a metamodel-based telecoms modelling language},
  year = {2008},
  pages = {1235-1238},
  note = {cited By (since 1996) 0},
  abstract = {Along with the evolution of computer technology, language oriented
	programming came out as a revolutionary progress which beyond the
	object-oriented programming. In current object-oriented programming,
	the general modeling language UML lacks of rich syntax and semantics
	in the specific domain. Developing and using domain specific language
	model in the progress of language oriented programming can solve
	this problem well. By constructing a executable model based on the
	MOF, defining an abstract syntax model and an concrete syntax model
	and extending semantics, this paper designs a telecommunication topology
	modelling language TML which based on the MOF metamodel. TML contains
	rich syntax, semantics and constraints which are telecommunication
	domain specific, and has the executable feature, thus it greatly
	simplifies the complexity of system modelling in domain and enhances
	the efficiency of software production. © 2008 IEEE.},
  affiliation = {Collage of Computer Science and Technology, Jilin University, 130012
	Changchun},
  art_number = {4730787},
  author_keywords = {Domain modelling; Meta object facility; Modelling language design},
  document_type = {Conference Paper},
  journal = {9th International Conference on Computer-Aided Industrial Design
	and Conceptual Design: Multicultural Creation and Design - CAIDCD
	2008},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-62449147173&partnerID=40&md5=1dd8884ea5c489c2e16db6f5503ff481}
}

@CONFERENCE{Handurukande201051,
  author = {Handurukande, S.a , Wallin, S.b , Jonsson, A.b },
  title = {IPTV service modeling in magneto networks},
  year = {2010},
  pages = {51-54},
  note = {cited By (since 1996) 1},
  abstract = {One of the main steps of service assurance is service monitoring using
	Key Performance Indicators (KPIs) and Service Level Agreements (SLAs).
	We show an approach for service modeling, first starting with an
	abstract service model that depends on the network. And then, we
	show how a corresponding model can be realized using a domain specific
	language. This solution is able to condense various sources of service
	model requirements into a condense formal and executable model including
	service decomposition and KPI aggregation. We have described this
	solution in the context of Magneto project and uses IPTV as a service
	in our description. © 2010 IEEE.},
  affiliation = {Network Management Lab., LM Ericsson, Athlone, Ireland; Data Ductus
	Nord AB, SE-931 31 Skellefteå, Sweden},
  art_number = {5486602},
  document_type = {Conference Paper},
  journal = {2010 IEEE/IFIP Network Operations and Management Symposium Workshops,
	NOMS 2010},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-77957896736&partnerID=40&md5=0762d533f815555afb43697b7af62e96}
}

@ARTICLE{Hanson1999849,
  author = {Hanson, D.R.},
  title = {Machine-independent debugger - revisited},
  journal = {Software - Practice and Experience},
  year = {1999},
  volume = {29},
  pages = {849-862},
  number = {10},
  note = {cited By (since 1996) 2},
  abstract = {Most debuggers are notoriously machine-dependent, but some recent
	research prototypes achieve varying degrees of machine-independence
	with novel designs. Cdb, a simple source-level debugger for C, is
	completely independent of its target architecture. This independence
	is achieved by embedding symbol tables and debugging code in the
	target program, which costs both time and space. This paper describes
	a revised design and implementation of cdb that reduces the space
	cost by nearly one-half and the time cost by 13 per cent by storing
	symbol tables in external files. A symbol table is defined by a 31-line
	grammar in the Abstract Syntax Description Language (ASDL). ASDL
	is a domain-specific language for specifying tree data structures.
	The ASDL tools accept an ASDL grammar and generate code to construct,
	read, and write these data structures. Using ASDL automates implementing
	parts of the debugger, and the grammar documents the symbol table
	concisely. Using ASDL also suggested simplifications to the interface
	between the debugger and the target program. Perhaps most important,
	ASDL emphasizes that symbol tables are data structures, not file
	formats. Many of the pitfalls of working with low-level file formats
	can be avoided by focusing instead on high-level data structures
	and automating the implementation details.},
  affiliation = {Microsoft Research, 1 Microsoft Way, Redmond, WA 98052, United States},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-0032640215&partnerID=40&md5=196d87a51425cebfbca1755534881a86}
}

@ARTICLE{Hanus200339,
  author = {Hanus, M., Höppner, K., Huch, F.},
  title = {Towards translating embedded Curry to C},
  journal = {Electronic Notes in Theoretical Computer Science},
  year = {2003},
  volume = {86},
  pages = {39-55},
  number = {3},
  note = {cited By (since 1996) 1},
  abstract = {This paper deals with a framework to program autonomous robots in
	the declarative multi-paradigm language Curry. Our goal is to apply
	a high-level declarative programming language for the programming
	of embedded systems. For this purpose, we use a specialization of
	Curry called Embedded Curry. We show the basic ideas of our framework
	and an implementation that translates Embedded Curry programs into
	C. © 2003 Published by Elsevier Science B.V.},
  affiliation = {Institut für Informatik, CAU Kiel, D-24098 Kiel, Germany},
  author_keywords = {Domain-specific languages; Embedded systems; Functional logic programming;
	Process-oriented programming},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-18944391447&partnerID=40&md5=f22625cd49d76b27ef0e3cf8b4a06692}
}

@ARTICLE{Harcourt200913,
  author = {Harcourt, E.},
  title = {Policies of System Level Pipeline Modeling},
  journal = {Electronic Notes in Theoretical Computer Science},
  year = {2009},
  volume = {238},
  pages = {13-23},
  number = {2},
  note = {cited By (since 1996) 0},
  abstract = {Pipelining is a well understood and often used implementation technique
	for increasing the performance of a hardware system. We develop several
	SystemC/C++ modeling techniques that allow us to quickly model, simulate,
	and evaluate pipelines. We employ a small domain specific language
	(DSL) based on resource usage patterns that automates the drudgery
	of boilerplate code needed to configure connectivity in simulation
	models. The DSL is embedded directly in the host modeling language
	SystemC/C++. Additionally we develop several techniques for parameterizing
	a pipeline's behavior based on policies of function, communication,
	and timing (performance modeling). © 2009 Elsevier B.V. All rights
	reserved.},
  affiliation = {Department of Mathematics, Computer Science, and Statistics, St. Lawrence
	University, Canton, NY, United States},
  author_keywords = {discrete-event simulation; generic programming; hardware modeling;
	pipeline; policies; system level design; SystemC},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-67649395610&partnerID=40&md5=febbf7c1c492645067fa65fb52118a94}
}

@ARTICLE{Harmanci20101053,
  author = {Harmanci, D.a , Gramoli, V.a b , Felber, P.a , Fetzer, C.c },
  title = {Extensible transactional memory testbed},
  journal = {Journal of Parallel and Distributed Computing},
  year = {2010},
  volume = {70},
  pages = {1053-1067},
  number = {10},
  note = {cited By (since 1996) 1},
  abstract = {Transactional Memory (TM) is a promising abstraction as it hides all
	synchronization complexities from the programmers of concurrent applications.
	More particularly, the TM paradigm operated a complexity shift from
	the application programming to the TM programming. Therefore, expert
	programmers have now started to look for the ideal TM that will bring,
	once-for-all, performance to all concurrent applications. Researchers
	have recently identified numerous issues TMs may suffer from. Surprisingly,
	no TMs have ever been tested in these scenarios. In this paper, we
	present the first to date TM testbed. We propose a framework, TMunit,
	that provides a domain specific language to write rapidly TM workloads
	so that our test-suite is easily extensible. Our reproducible semantic
	tests indicate through reproducible counter-examples that existing
	TMs do not satisfy recent consistency criteria. Our performance tests
	identify workloads where well-known TMs perform differently. Finally,
	additional tests indicate some workloads preventing contention managers
	from progressing. © 2010 Elsevier Inc. All rights reserved.},
  affiliation = {University of Neuchtel, Rue Emile-Argand 11, CH-2009 Neuchtel, Switzerland;
	EPFL, Station 14, CH-1015 Lausanne, Switzerland; Dresden University
	of Technology, D-01062 Dresden, Germany},
  author_keywords = {Performance; Semantics; Transactional memory},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-77956061666&partnerID=40&md5=1fa4ba96dd67a6a7f126a57676e3847e}
}

@ARTICLE{Harper20093,
  author = {Harper, R., Licata, D.R., Zeilberger, N.},
  title = {A pronominal approach to binding and computation},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2009},
  volume = {5608 LNCS},
  pages = {3-4},
  note = {cited By (since 1996) 0},
  abstract = {There has been a great deal of research on programming languages for
	computing with binding and scope (bound variables, α-equivalence,
	capture-avoiding substitution). These languages are useful for a
	variety of tasks, such as implementing domain-specific languages
	and formalizing the metatheory of programming languages. Functional
	programming with binding and scope involves two different notions
	of function: functions-as-data and functions-as-computation. Functions-as-data,
	used to represent abstract syntax with variable binding, have an
	intensional, syntactic, character, in the sense that they can be
	inspected in ways other than function application. For example, many
	algorithms that process abstract syntax recur under binders, treating
	variables symbolically. On the other hand, functions-as-computation,
	the usual functions of functional programming, have an extensional
	character-a function from A to B is a black box that, when given
	an A, delivers a B. © 2009 Springer Berlin Heidelberg.},
  affiliation = {Carnegie Mellon University},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-70350327555&partnerID=40&md5=856f918da8a1bd97581389c99962b346}
}

@ARTICLE{Harrison200920,
  author = {Harrison, W.L.a , Procter, A.M.a , Agron, J.b , Kimmell, G.c , Allwein,
	G.d },
  title = {Model-driven engineering from modular monadic semantics: Implementation
	techniques targeting hardware and software},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2009},
  volume = {5658 LNCS},
  pages = {20-44},
  note = {cited By (since 1996) 0},
  abstract = {Recent research has shown how the formal modeling of concurrent systems
	can benefit from monadic structuring. With this approach, a formal
	system model is really a program in a domain specific language defined
	by a monad for shared-state concurrency. Can these models be compiled
	into efficient implementations? This paper addresses this question
	and presents an overview of techniques for compiling monadic concurrency
	models directly into reasonably efficient software and hardware implementations.
	The implementation techniques described in this article form the
	basis of a semantics-directed approach to model-driven engineering.
	© IFIP International Federation for Information Processing 2009.},
  affiliation = {Department of CS, University of Missouri, Missouri, United States;
	Department of CS and CE, University of Arkansas, Fayetteville, AR,
	United States; Department of EECS, University of Kansas, Lawrence,
	KS, United States; US Naval Research Laboratory, Code 5543, Washington,
	DC, United States},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-69049097160&partnerID=40&md5=4c44a50cbd69529e95a6f81536b60bc8}
}

@CONFERENCE{Hartmann200982,
  author = {Hartmann, T.},
  title = {Model based testing of end-to-end chains using domain specific languages},
  year = {2009},
  pages = {82-91},
  note = {cited By (since 1996) 0},
  abstract = {In this paper, the author explains a new approach of model based end-to-end
	chain testing using scenarios with original and simulated equipment.
	The first goal is to automatically derive test data and test cases
	from the model, which is defined by a domain specific language. Several
	solvers can be attached to the conversion to quickly create a wide
	variety of stimuli for the system(s) under test. Furthermore, the
	system under test can be stimulated by either original equipment
	- which is connected to the test bench - or the test bench can simulate
	equipment and create inputs for the tested systems. Any mixture of
	simulated and original equipment is possible and can be changed on
	the fly. In the end, the results from the system under test are collected.
	These results can then be displayed back in the model. This method
	is currently used and improved in the project "E-Cab" in which the
	author is involved. Passengers travelling by plane are in the focus
	of this project. Complete services and service chains - from the
	booking at home up to leaving the destination airport - are created
	and used by many systems communicating with each other. The author
	expects advantages from testing these end-to-end chains with this
	approach. © 2009 IEEE.},
  affiliation = {TZI, University of Bremen, Research Group Operating Systems and Distributed
	Systems, Bremen, Germany},
  art_number = {5381641},
  author_keywords = {Automatic test case generation; Automatic test data generation; End-to-end
	chain; Model based; Testing},
  document_type = {Conference Paper},
  journal = {TAIC PART 2009 - Testing: Academic and Industrial Conference - Practice
	and Research Techniques},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-77949800260&partnerID=40&md5=d776f41eb5a2ee24172e4d6f16634e68}
}

@CONFERENCE{Haschemi2009470,
  author = {Haschemi, S., Wider, A.},
  title = {An extensible language for service dependency management},
  year = {2009},
  pages = {470-473},
  note = {cited By (since 1996) 0},
  abstract = {Service dependency management in service-oriented component platforms
	is described with languages, which cannot be easily adapted to domain-specific
	requirements. This prevents the development of language concepts,
	which are more suitable for the cognitive space and intuition of
	domain experts than general-purpose languages. We use a model-driven
	approach to create an extensible language supporting the creation
	of new language concepts. With this approach, languages for service
	dependency management can be extended to have the desired concepts
	and expressiveness. © 2009 IEEE.},
  affiliation = {Institut für Informatik, Humboldt-Universität zu Berlin, Unter den
	Linden 6, 10099 Berlin, Germany},
  art_number = {5350025},
  author_keywords = {Domain-specific languages; Metamodeling; Service dependency management},
  document_type = {Conference Paper},
  journal = {Conference Proceedings of the EUROMICRO},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-74549203275&partnerID=40&md5=9845188a87ff8460b77e7de292bd49e1}
}

@CONFERENCE{Hatori2007105,
  author = {Hatori, K.a , Hiraki, K.b },
  title = {A network programming language based on concurrent processes and
	regular expressions},
  year = {2007},
  pages = {105-110},
  note = {cited By (since 1996) 0},
  abstract = {We propose a new programming language Preccs for networking and implementing
	communication protocols. Preccs is based on ideas of concurrent processes
	and regular expressions. We designed the language for simple and
	intuitive description of communication protocols. Then, we have developed
	a Preccs compiler that generates C code from a Preccs source program.
	The generation of C code with the Preccs compiler will make it possible
	for reliable communication programs development in a short period.
	In order to evaluate the effectiveness of our approach, we have implemented
	a simple HTTP server and a simple VoIP application in Preccs. Both
	of them are implemented in a few lines of code.},
  affiliation = {Systems Development Division, Research Institute of Systems Planning,
	Inc., ISP, Tokyo, Japan; Graduate School of Information Science and
	Technology, University of Tokyo, Tokyo, Japan},
  author_keywords = {Concurrent processes; Domain specific languages; Network programming;
	Regular expressions},
  document_type = {Conference Paper},
  journal = {Proceedings of the IASTED International Conference on Software Engineering,
	SE 2007},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-56149111056&partnerID=40&md5=6f797cb45b4b62f9c2efb1206d26eee6}
}

@CONFERENCE{Hatzisymeon2005194,
  author = {Hatzisymeon, G.a , Houssos, N.b , Andreadis, D.c , Samoladas, V.a
	},
  title = {An architecture for implementing application interoperation with
	heterogeneous systems},
  year = {2005},
  volume = {3543},
  pages = {194-205},
  note = {cited By (since 1996) 0},
  abstract = {We are concerned with the issues faced by software developers with
	a certain family of distributed applications; those that connect
	to and interoperate with a heterogeneous infrastructure, i.e., a
	large heterogeneous collection of external systems (databases, embedded
	devices, network equipment, internet servers etc.) using different
	communication protocols. This product family includes applications
	such as e-commerce systems, network management applications and Grid-based
	collaborations. For such applications, implementing the interoperation
	logic is both challenging and expensive. We discuss the major concerns
	that contribute to the problem, such as transaction support, security
	and management, as well as integration with workflow or component
	frameworks. We propose an architecture and related development methodology,
	based on generative programming, to reduce implementation complexity,
	allow for rapid application development, ease deployment and manageability.
	© IFIP International Federation for Information Processing 2005.},
  affiliation = {Tech. U. of Crete; Communication Networks Laboratory, University of
	Athens; JBoss Europe},
  document_type = {Conference Paper},
  journal = {Lecture Notes in Computer Science},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-26444573150&partnerID=40&md5=0af45886a470e4615cf71e351cb8a5a3}
}

@ARTICLE{Haubold200939,
  author = {Haubold, T., Beier, G., Golubski, W., Herbig, N., Beine, G., Arnold,
	O.},
  title = {The technical foundation of the GeneSEZ MDSD approach},
  journal = {Frontiers in Artificial Intelligence and Applications},
  year = {2009},
  volume = {199},
  pages = {39-60},
  number = {1},
  note = {cited By (since 1996) 1},
  abstract = {Model-Driven Software Development (MDSD) is highly regarded and already
	used in industry. Several approaches exist which use UML (Unified
	Modeling Language), DSLs (Domain Specific Languages) or other meta
	models. One weakness of these approaches is the use or complexity
	of the meta model used to model the application within the whole
	MDSD process. This restricts the reusability of model transformations
	in case of another meta model. The GeneSEZ approach targets this
	problem by introducing a separate meta model for the MDSD process.
	Decoupling the meta models used during modeling and within model
	transformations leads to a fixed back-end of the MDSD process consisting
	of reusable model transformations for code generation resulting in
	a higher benefit of model driven approaches. Models created by different
	modeling tools with different meta models can reuse the same model
	transformations increasing the return of invest of these model transformations.
	The GeneSEZ approach is a pragmatic model driven approach and evolved
	through the experience gained by applying it to several industry
	projects. © 2009 IOS Press. All rights reserved.},
  affiliation = {Zwickau University of Applied Sciences Informatics, Zwickau, Germany},
  author_keywords = {DSL; MDA; MDSD; Model driven development approach; UML},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-72949093958&partnerID=40&md5=1a59971e8b9c5e772b6cfe7220bb037e}
}

@CONFERENCE{Hauch2005793,
  author = {Hauch, R., Miller, A., Cardwell, R.},
  title = {Information intelligence: Metadata for information discovery, access,
	and integration},
  year = {2005},
  pages = {793-798},
  note = {cited By (since 1996) 17},
  abstract = {Integrating enterprise information requires an accurate, precise and
	complete understanding of the disparate data sources, the needs of
	the information consumers, and how these map to the semantic business
	concepts of the enterprise. We describe how MetaMatrix captures and
	manages this metadata through the use of the OMG's MOF architecture
	and multiple domain-specific modeling languages, and how this semantic
	and syntactic metadata is then used for a variety of purposes, including
	accessing data in real-time from the underlying enterprise systems,
	integrating it, and returning it as information expected by consumers.
	Copyright 2005 ACM.},
  affiliation = {MetaMatrix, St. Louis, MO 63017},
  document_type = {Conference Paper},
  journal = {Proceedings of the ACM SIGMOD International Conference on Management
	of Data},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-29844456689&partnerID=40&md5=0af58f632c7e314d06c65067a1bf638d}
}

@CONFERENCE{Haugen2008139,
  author = {Haugen, O.a , Møoller-Pedersen, B.b , Oldevik, J.a , Olsen, G.K.c
	, Svendsen, A.c },
  title = {Adding standardized variability to domain specific languages},
  year = {2008},
  pages = {139-148},
  note = {cited By (since 1996) 16},
  abstract = {We show how a common language of variability can be used to enhance
	the expressiveness of a Domain Specific Language (DSL). DSLs have
	been proposed as a mechanism for expressing variability. Variability
	between models in a given domain or of a family of systems is captured
	by language constructs, implying that all possible models in this
	language are the allowed variations. We explore the possibility of
	expressing variability in a language independently of the base modeling
	language. We explore how this works for small DSLs as well as for
	general purpose languages like UML. Implications of this approach
	are that the variability language can be standardized, and that DSLs
	do not have to include variability mechanisms. © 2008 IEEE.},
  affiliation = {SINTEF, Univ. of Oslo; University of Oslo; SINTEF},
  art_number = {4626848},
  document_type = {Conference Paper},
  journal = {Proceedings - 12th International Software Product Line Conference,
	SPLC 2008},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-55049098614&partnerID=40&md5=46b044ba8f00e5ef637ba132f4b2dfbf}
}

@ARTICLE{Havelund2001749,
  author = {Havelund, K.a c , Lowry, M.a d , Penix, J.b d d },
  title = {Formal analysis of a space-craft controller using SPIN},
  journal = {IEEE Transactions on Software Engineering},
  year = {2001},
  volume = {27},
  pages = {749-765},
  number = {8},
  note = {cited By (since 1996) 35},
  abstract = {This paper documents an application of the finite state model checker
	SPIN to formally analyze a multithreaded plan execution module. The
	plan execution module is one component of NASA's New Millennium Remote
	Agent, an artificial intelligence-based space-craft control system
	architecture which launched in October of 1998 as part of the DEEP
	SPACE 1 mission. The bottom layer of the plan execution module architecture
	is a domain specific language, named ESL (Executive Support Language),
	implemented as an extension to multithreaded COMMON LISP. ESL supports
	the construction of reactive control mechanisms for autonomous robots
	and space-craft. For this case study, we translated the ESL services
	for managing interacting parallel goal-and-event driven processes
	into the PROMELA input language of SPIN. A total of five previously
	undiscovered concurrency errors were identified within the implementation
	of ESL. According to the Remote Agent programming team, the effort
	has had a major impact, locating errors that would not have been
	located otherwise and, in one case, identifying a major design flaw.
	In fact, in a different part of the system, a concurrency bug identical
	to one discovered by this study escaped testing and caused a deadlock
	during an in-flight experiment 96 million kilometers from earth.
	The work additionally motivated the introduction of procedural abstraction
	in terms of inline procedures into SPIN.},
  affiliation = {IEEE Computer Society; IEEE; Kestrel Technology, NASA Ames Research
	Center, Moffett Field, CA 94035, United States; NASA Ames Research
	Center, Moffett Field, CA 94035, United States},
  author_keywords = {Concurrent programs; Model checking; Model extraction; Program abstraction;
	Program verification; Space-craft software; Temporal logic},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-0035417837&partnerID=40&md5=40d17e74a0f341f8fae1d78ca452ce69}
}

@ARTICLE{Haveraaen2001261,
  author = {Haveraaen, M.},
  title = {Case study on algebraic software methodologies for scientific computing},
  journal = {Scientific Programming},
  year = {2001},
  volume = {8},
  pages = {261-273},
  number = {4},
  note = {cited By (since 1996) 7},
  abstract = {The use of domain specific languages and appropriate software architectures
	are currently seen as the way to enhance reusability and improve
	software productivity. Here we outline a use of algebraic software
	methodologies and advanced program constructors to improve the abstraction
	level of software for scientific computing. This leads us to the
	language of coordinate free numerics as an alternative to the traditional
	coordinate dependent array notation. This provides the backdrop for
	the three accompanying papers: Coordinate Free Programming of Computational
	Fluid Dynamics Problems, centered around an example of using coordinate
	free numerics, Machine and Collection Abstractions for User-Implemented
	Data-Parallel Programming, exploiting the higher abstraction level
	when parallelising code, and An Algebraic Programming Style for Numerical
	Software and its Optimization, looking at high-level transformations
	enabled by the domain specific programming style.},
  affiliation = {Department of Informatics, University of Bergen, P.O. Box 7800, N-502O
	Bergen, Norway},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-0035158821&partnerID=40&md5=c8cd1bcfbb9dd723a46b9d2349e9d41d}
}

@ARTICLE{Haxthausen2011176,
  author = {Haxthausen, A.E.},
  title = {Towards a framework for modelling and verification of relay interlocking
	systems},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2011},
  volume = {6662 LNCS},
  pages = {176-192},
  note = {cited By (since 1996) 1},
  abstract = {This paper describes a framework currently under development for modelling,
	simulation, and verification of relay interlocking systems as used
	by the Danish railways. The framework is centred around a domain-specific
	language (DSL) for describing such systems, and provides (1) a graphical
	editor for creating DSL descriptions, (2) a data validator for checking
	that DSL descriptions follow the structural rules of the domain,
	(3) a graphical simulator for simulating the dynamic behaviour of
	relay interlocking systems, and (4) verification support for deriving
	and verifying safety properties of relay interlocking systems. ©
	2011 Springer-Verlag.},
  affiliation = {DTU Informatics, Technical University of Denmark, DK-2800 Lyngby,
	Denmark},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-79960019298&partnerID=40&md5=a9daec10da7932d883f5113db8288b50}
}

@ARTICLE{Haxthausen2007320,
  author = {Haxthausen, A.E.a , Peleska, J.b },
  title = {A domain-oriented, model-based approach for construction and verification
	of railway control systems},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2007},
  volume = {4700 LNCS},
  pages = {320-348},
  note = {cited By (since 1996) 1},
  abstract = {This paper describes a complete model-based development and verification
	approach for railway control systems. For each control system to
	be generated, the user makes a description of the application-specific
	parameters in a domain-specific language. This description is automatically
	transformed into an executable control system model expressed in
	SystemC. This model is then compiled into object code. Verification
	is performed using four main methods applied to different levels:
	(0) The domain-specific description is validated wrt. internal consistency
	by static analysis. (1) The crucial safety properties are verified
	for the SystemC model by means of bounded model checking. (2) The
	object code is verified to be I/O behavioural equivalent to the SystemC
	model from which it was compiled. (3) The correctness of the hardware/software
	integration is checked by automated testing. © Springer-Verlag Berlin
	Heidelberg 2007.},
  affiliation = {Informatics and Mathematical Modelling, Technical University of Denmark,
	Lyngby, Denmark; TZI, Universität Bremen, Germany},
  author_keywords = {Code generation; Domain engineering; Domain-specific languages; Formal
	methods; Railway control systems; Verification},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-38149023375&partnerID=40&md5=93acc7a9a571747f19c485e7e2c5441c}
}

@ARTICLE{Haxthausen2011191,
  author = {Haxthausen, A.E.a , Peleska, J.b , Kinder, S.b },
  title = {A formal approach for the construction and verification of railway
	control systems},
  journal = {Formal Aspects of Computing},
  year = {2011},
  volume = {23},
  pages = {191-219},
  number = {2},
  note = {cited By (since 1996) 2},
  abstract = {This paper describes a complete model-based development and verification
	approach for railway control systems. For each control system to
	be generated, the user makes a description of the application-specific
	parameters in a domain-specific language. This description is automatically
	transformed into an executable control system model expressed in
	SystemC. This model is then compiled into object code. Verification
	is performed using threemainmethods applied to different levels.
	(0) The domain-specific description is validated wrt. internal consistency
	by static analysis. (1) The crucial safety properties are verified
	for the SystemC model by means of bounded model checking. (2) The
	object code is verified to be I/O behaviourally equivalent to the
	SystemC model from which it was compiled. BCS © 2009.},
  affiliation = {Department of Informatics and Mathematical Modelling, Technical University
	of Denmark, bld. 321, 2800 Lyngby, Denmark; Department of Mathematics
	and Computer Science, Universität Bremen, Bremen, Germany},
  author_keywords = {Code generation; Domain engineering; Domain-specific languages; Formal
	methods; Railway control systems; Verification},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-79955901791&partnerID=40&md5=b0e50dee5fbee520bc06be6cde629375}
}

@CONFERENCE{He2002161,
  author = {He, D., Muller, G., Lawall, J.L.},
  title = {Distributing MPEG movies over the Internet using programmable networks},
  year = {2002},
  pages = {161-170},
  note = {cited By (since 1996) 3},
  abstract = {Distributing video over the Internet is an increasingly important
	application. Nevertheless, the real-time and high bandwidth requirements
	of video make video distribution over today's Internet a challenge.
	Adaptive approaches can be used to respond to changes in bandwidth
	availability while limiting the effect of such changes on perceptual
	quality and resource consumption. Nevertheless, most existing adaptation
	mechanisms have limited scalability and do not effectively exploit
	the heterogeneity of the Internet. In this paper, we describe the
	design and implementation of a MPEG video broadcasting service based
	on active networks. In an active network, routers can be programmed
	to make routing decisions based on local conditions. Because decisions
	are made locally, adaptation reacts rapidly to changing conditions
	and is unaffected by conditions elsewhere in the network. Programmability
	allows the adaptation policy to be tuned to the structure of the
	transmitted data, and to the properties of local clients. We use
	the PLAN-P domain-specific language for programming active routers;
	this language provides high-level abstractions and safety guarantees
	that allow complex protocols to be developed rapidly and reliably.
	Our experiments show that our approach to video distribution permits
	the decoding of up to 9 times as many frames in a heavily loaded
	network as distribution using standard routers.},
  affiliation = {COMPOSE Group, INRIA, LaBRI, 33402 Talence Cedex, France},
  document_type = {Conference Paper},
  journal = {Proceedings - International Conference on Distributed Computing Systems},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-0036372780&partnerID=40&md5=28ed770393187b90bb98f4e0f06791be}
}

@ARTICLE{He2011216,
  author = {He, R.a , Lacoste, M.a , Pulou, J.a , Leneutre, J.b },
  title = {A DSL for specifying autonomic security management strategies},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2011},
  volume = {6514 LNCS},
  pages = {216-230},
  note = {cited By (since 1996) 0},
  abstract = {Existing self-protection frameworks so far hardly addressed the specification
	of autonomic security adaptation strategies which guide risk-aware
	selection or reconfiguration of security mechanisms. Domain-Specific
	Languages (DSL) present many benefits to achieve this goal in terms
	of simplicity, automated strategy verification, and run-time integration.
	This paper presents a DSL to describe security adaptation policies.
	The DSL is based on the condition-action approach and on a taxonomy
	of threats and applicable reactions. The DSL also allows to capture
	trade-offs between security and other concerns such as energy efficiency
	during the decision making phase. A translation mechanism to refine
	the DSL into a run-time representation, and integrate adaptation
	policies within legacy self-protection frameworks is also presented.
	© 2011 Springer-Verlag.},
  affiliation = {Orange Labs., France; Telecom ParisTech., France},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-79952253206&partnerID=40&md5=dc567d68091b9c4e78dfd9068a035ec1}
}

@CONFERENCE{Headrick2011240,
  author = {Headrick, W.J.a , Bodkin, M.A.a , Fox, R.R.b , Davis, T.W.c , Dusch,
	K.d , Wolfe, D.c },
  title = {Signal Based Domain Specific Language (SBDSL) a proposal for a next
	generation test},
  year = {2011},
  pages = {240-244},
  note = {cited By (since 1996) 0},
  abstract = {Signal Based Domain Specific Language (SBDSL) is a domain specific
	language which combines the use of ATLAS Signal statements with high-level
	programming language constructs. The goals of this new language are:
	facilitate the writing of concurrent test programs, provide a language
	that is easy to extend with new constructs, maintain backwards compatibility
	with ATLAS Family of languages, enable interoperability between test
	stations, and enable engineers' fresh out of college to quickly become
	productive with a test programming language. This paper will cover
	how the design of the SBDSL language, SBDSL Integrated Development
	Environment (IDE) and runtime executable will accomplish these goals
	and present results from the technology demonstration developed.
	© 2011 IEEE.},
  affiliation = {Lockheed Martin Global Training and Logistics (GTL), 100 Global Innovation
	Circle, Orlando, FL 32825-5002, United States; NAVAIR, Code 4.8.3.1,
	6206 Aviation Av., Jacksonville, FL 32221, United States; NAVAIR,
	Code 4.8.4.4, 6206 Aviation Av., Jacksonville, FL 32221, United States;
	NAVAIR, Building 2272, 47123 Buse Road, Patuxent River, MD 20620,
	United States},
  art_number = {6058739},
  document_type = {Conference Paper},
  journal = {AUTOTESTCON (Proceedings)},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-81055137659&partnerID=40&md5=fee594757139284907a42f175dd56012}
}

@CONFERENCE{Hedegaard200947,
  author = {Hedegaard, S., Houen, S., Simonsen, J.G.},
  title = {LAIR: A language for automated semantics-aware text sanitization
	based on frame semantics},
  year = {2009},
  pages = {47-52},
  note = {cited By (since 1996) 0},
  abstract = {We present LAIR: A domain-specific language that enables users to
	specify actions to be taken upon meeting specific semantic frames
	in a text, in particular to rephrase and redact the textual content.
	While LAIR presupposes superficial knowledge of frames and frame
	semantics, it requires only limited prior programming experience.
	It neither contain scripting or I/O primitives, nor does it contain
	general loop constructions and is not Turing-complete. We have implemented
	a LAIR compiler and integrated it in a pipeline for automated redaction
	of web pages. We detail our experience with automated redaction of
	web pages for subjectively undesirable content; initial experiments
	suggest that using a small language based on semantic recognition
	of undesirable terms can be highly useful as a supplement to traditional
	methods of text sanitization. © 2009 IEEE.},
  affiliation = {Department of Computer Science, University of Copenhagen (DIKU), Universitetsparken
	1, DK-2100 Copenhagen Ø, Denmark},
  art_number = {5298551},
  author_keywords = {Domainspecific languages; Frame semantics; Redaction; Sanitization},
  document_type = {Conference Paper},
  journal = {ICSC 2009 - 2009 IEEE International Conference on Semantic Computing},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-73449097460&partnerID=40&md5=8bad44b69594d5b2290ec743659ff7d5}
}

@ARTICLE{Hedin201168,
  author = {Hedin, G.a , Åkesson, J.a , Ekman, T.b },
  title = {Extending languages by leveraging compilers: From modelica to optimica},
  journal = {IEEE Software},
  year = {2011},
  volume = {28},
  pages = {68-74},
  number = {3},
  note = {cited By (since 1996) 0},
  abstract = {Combining attribute grammars with object-oriented programming supports
	a new kind of declarative programming, letting developers build compilers
	in a highly extensible manner. By leveraging a base compiler, extended
	languages can be supported at a relatively low cost. Recent work
	shows the applicability of the technique to general-purpose programming
	languages such as Java. In this article, the authors illustrate the
	approach using a case study for domain-specific languages. They built
	an extensible compiler for the physical systems modeling language
	Modelica and leveraged it to support a new extended language, Optimica.
	© 2011 IEEE.},
  affiliation = {Lund University, Sweden; Semmle, United Kingdom},
  art_number = {5440161},
  author_keywords = {design techniques; design tools; formal definitions; formal theory;
	processors; reusable software},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-79955567099&partnerID=40&md5=a48b7a2ac7a1128195d6d3368ece2e22}
}

@ARTICLE{Heer20101149,
  author = {Heer, J., Bostock, M.},
  title = {Declarative language design for interactive visualization},
  journal = {IEEE Transactions on Visualization and Computer Graphics},
  year = {2010},
  volume = {16},
  pages = {1149-1156},
  number = {6},
  note = {cited By (since 1996) 2},
  abstract = {We investigate the design of declarative, domain-specific languages
	for constructing interactive visualizations. By separatingspecification
	from execution, declarative languages can simplify development, enable
	unobtrusive optimization, and supportretargeting across platforms.
	We describe the design of the Protovis specification language and
	its implementation within anobject-oriented, statically-typed programming
	language (Java). We demonstrate how to support rich visualizations
	without requiring atoolkit-specific data model and extend Protovis
	to enable declarative specification of animated transitions. To support
	cross-platformdeployment, we introduce rendering and event-handling
	infrastructures decoupled from the runtime platform, letting designers
	retargetvisualization specifications (e.g., from desktop to mobile
	phone) with reduced effort. We also explore optimizations such as
	runtimecompilation of visualization specifications, parallelized
	execution, and hardware-accelerated rendering. We present benchmark
	studiesmeasuring the performance gains provided by these optimizations
	and compare performance to existing Java-based visualizationtools,
	demonstrating scalability improvements exceeding an order of magnitude.
	© 2006 IEEE.},
  affiliation = {Computer Science Department, Stanford University, Stanford, CA 94305,
	United States},
  art_number = {5613453},
  author_keywords = {declarative languages; domain specific languages; information visualization;
	optimization; toolkits; user interfaces},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-78149268393&partnerID=40&md5=09f9ccd5cb331749b8497d5a64925e07}
}

@CONFERENCE{Heering20081,
  author = {Heering, J.a , Mernik, M.b },
  title = {Domain-specific Languages as key tools for ULSSIS Engineering},
  year = {2008},
  pages = {1-2},
  note = {cited By (since 1996) 1},
  abstract = {We briefly discuss the potential of domain-specific languages and
	domain-specific modeling languages for ULSSIS engineering, some of
	the scaling challenges involved, and the possibilities for raising
	expressiveness beyond current levels. Copyright 2008 ACM.},
  affiliation = {CWI, Kruislaan 413, 1098 SJ Amsterdam, Netherlands; University of
	Maribor, Smetanova 17, 2000 Maribor, Slovenia},
  author_keywords = {Domain-specific languages; Ultra-large-scale systems},
  document_type = {Conference Paper},
  journal = {International Conference on Software Engineering - Proceedings of
	the 2nd International Workshop on Ultra-Large-Scale Software-Intensive
	Systems, ULSSIS'08},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-57349192799&partnerID=40&md5=383f9f41cacaa01bf34055e9df0ec068}
}

@ARTICLE{Heidenreich201099,
  author = {Heidenreich, F., Johannes, J., Seifert, M., Wende, C., Böhme, M.},
  title = {Generating safe template languages},
  journal = {ACM SIGPLAN Notices},
  year = {2010},
  volume = {45},
  pages = {99-108},
  number = {2},
  note = {cited By (since 1996) 0},
  abstract = {Template languages are widely used within generative programming,
	because they provide intuitive means to generate software artefacts
	expressed in a specific object language. However, most template languages
	perform template instantiation on the level of string literals, which
	allows neither syntax checks nor semantics analysis. To make sure
	that generated artefacts always conform to the object language, we
	propose to perform static analysis at template design time. In addition,
	the increasing popularity of domainspecific languages (DSLs) demands
	an approach that allows to reuse both the concepts of template languages
	and the corresponding tools. In this paper we address the issues
	mentioned above by presenting how existing languages can be automatically
	extended with generic template concepts (e.g., placeholders, loops,
	conditions) to obtain safe template languages. These languages provide
	means for syntax checking and static semantic analysis w.r.t. the
	object language at template design time.We discuss the prerequisites
	for this extension, analyse the types of correctness properties that
	can be assured at template design time, and exemplify the key benefits
	of this approach on a textual DSL and Java. Copyright © 2009 ACM.},
  affiliation = {Lehrstuhl Softwaretechnologie, Fakultät Informatik, Technische Universität
	Dresden, Germany},
  author_keywords = {Generative programming; Language extension; Safe authoring; Template
	language},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-77957567670&partnerID=40&md5=1b8752ebf185d4255f1b034573de48ff}
}

@CONFERENCE{Heidenreich200999,
  author = {Heidenreich, F., Johannes, J., Seifert, M., Wende, C., Böhme, M.},
  title = {Generating safe template languages},
  year = {2009},
  pages = {99-108},
  note = {cited By (since 1996) 0},
  abstract = {Template languages are widely used within generative programming,
	because they provide intuitive means to generate software artefacts
	expressed in a specific object language. However, most template languages
	perform template instantiation on the level of string literals, which
	allows neither syntax checks nor semantics analysis. To make sure
	that generated artefacts always conform to the object language, we
	propose to perform static analysis at template design time. In addition,
	the increasing popularity of domain-specific languages (DSLs) demands
	an approach that allows to reuse both the concepts of template languages
	and the corresponding tools. In this paper we address the issues
	mentioned above by presenting how existing languages can be automatically
	extended with generic template concepts (e.g., placeholders, loops,
	conditions) to obtain safe template languages. These languages provide
	means for syntax checking and static semantic analysis w.r.t. the
	object language at template design time. We discuss the prerequisites
	for this extension, analyse the types of correctness properties that
	can be assured at template design time, and exemplify the key benefits
	of this approach on a textual DSL and Java. Copyright © 2009 ACM.},
  affiliation = {Lehrstuhl Softwaretechnologie, Fakultät Informatik, Technische Universitat,
	Dresden, Germany},
  author_keywords = {Generative programming; Language extension; Safe authoring; Template
	language},
  document_type = {Conference Paper},
  journal = {GPCE'09 - Proceedings of the 8th International ACM SIGPLAN Conference
	on Generative Programming and Component Engineering},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-70450191779&partnerID=40&md5=da49890dc89f975b753df0b285c14557}
}

@CONFERENCE{Heijstek2010333,
  author = {Heijstek, W., Chaudron, M.R.V.},
  title = {The impact of model driven development on the software architecture
	process},
  year = {2010},
  pages = {333-341},
  note = {cited By (since 1996) 1},
  abstract = {While Model-Driven Development (MDD) is an increasingly popular software
	development approach, its impact on the development process in large-scale,
	industrial practice is not yet clear. For this study the application
	of MDD in a large-scale industrial software development project is
	analyzed over a period of two years. Applying a grounded theory approach
	we identified 14 factors which impact the architectural process.
	We found that scope creep is more likely to occur, late changes can
	imply more extensive rework and that business engineers need to be
	more aware of the technical impact of their decisions. In addition,
	the introduced Domain-Specific Language (DSL) provides a new common
	idiom that can be used by more team members and will ease communication
	among team members and with clients. Also, modelers need to be much
	more explicit and complete in their descriptions. Parallel development
	of a code generator and defining a proper meta-model require additional
	time investments. Lastly, the more central role of software architecture
	design documentation requires more structured, detailed and complete
	architectural information and consequently, more frequent reviews.
	© 2010 IEEE.},
  affiliation = {Leiden Institute of Advanced Computer Science, Leiden University,
	Niels Bohrweg 1, 2333 CA Leiden, Netherlands},
  art_number = {5598116},
  document_type = {Conference Paper},
  journal = {Proceedings - 36th EUROMICRO Conference on Software Engineering and
	Advanced Applications, SEAA 2010},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-78449296688&partnerID=40&md5=91a9f749038f50704ef12685a0b0c239}
}

@CONFERENCE{Helene200915,
  author = {Helene, A., Valentin, B., Haveraaen, D.M.},
  title = {The axioms strike back: Testing with concepts and axioms in C++},
  year = {2009},
  pages = {15-24},
  note = {cited By (since 1996) 0},
  abstract = {Modern development practises encourage extensive testing of code while
	it is still under development, using unit tests to check individual
	code units in isolation. Such tests are typically case-based, checking
	a likely error scenario or an error that has previously been identified
	and fixed. Coming up with good test cases is challenging, and focusing
	on individual tests can distract from creating tests that cover the
	full functionality. Axioms, known from program specification, allow
	for an alternative way of generating test cases, where the intended
	functionality is described as rules or equations that can be checked
	automatically. Axioms are proposed as part of the concept feature
	of the upcoming C++0x standard. In this paper, we describe how tests
	may be generated automatically from axioms in C++ concepts, and supplied
	with appropriate test data to form effective automated unit tests.
	Copyright © 2009 ACM.},
  affiliation = {University of Bergen},
  author_keywords = {Algebraic specification; Axiom-based testing axioms; C++; C++0x concepts;
	Generative programming; Mould-able programming; Program transformation;
	Test generation; Unit testing},
  document_type = {Conference Paper},
  journal = {GPCE'09 - Proceedings of the 8th International ACM SIGPLAN Conference
	on Generative Programming and Component Engineering},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-70450206936&partnerID=40&md5=d105176f12e277f424118088ac9588be}
}

@ARTICLE{Hemel2010375,
  author = {Hemel, Z., Kats, L.C.L., Groenewegen, D.M., Visser, E.},
  title = {Code generation by model transformation: A case study in transformation
	modularity},
  journal = {Software and Systems Modeling},
  year = {2010},
  volume = {9},
  pages = {375-402},
  number = {3},
  note = {cited By (since 1996) 0},
  abstract = {The realization of model-driven software development requires effective
	techniques for implementing code generators for domain-specific languages.
	This paper identifies techniques for improving separation of concerns
	in the implementation of generators. The core technique is code generation
	by model transformation, that is, the generation of a structured
	representation (model) of the target program instead of plain text.
	This approach enables the transformation of code after generation,
	which in turn enables the extension of the target language with features
	that allow better modularity in code generation rules. The technique
	can also be applied to 'internal code generation' for the translation
	of high-level extensions of a DSL to lower-level constructs within
	the same DSL using model-to-model transformations. This paper refines
	our earlier description of code generation by model transformation
	with an improved architecture for the composition of model-to-model
	normalization rules, solving the problem of combining type analysis
	and transformation. Instead of coarse-grained stages that alternate
	between normalization and type analysis, we have developed a new
	style of type analysis that can be integrated with normalizing transformations
	in a fine-grained manner. The normalization strategy has a simple
	extension interface and integrates non-local, context-sensitive transformation
	rules. We have applied the techniques in a realistic case study of
	domain-specific language engineering, i. e. the code generator for
	WebDSL, using Stratego, a high-level transformation language that
	integrates model-to-model, model-to-code, and code-to-code transformations.
	© 2009 The Author(s).},
  affiliation = {Software Engineering Research Group, Delft University of Technology,
	Delft, Netherlands},
  author_keywords = {Combination of analysis and transformation; Term rewriting; Transformation;
	Transformation engineering; Webapplication DSL},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-77953541085&partnerID=40&md5=4c368baa45b543bf23102b2b43dc8c61}
}

@ARTICLE{Hemel2008183,
  author = {Hemel, Z., Kats, L.C.L., Visser, E.},
  title = {Code generation by model transformation a case study in transformation
	modularity},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2008},
  volume = {5063 LNCS},
  pages = {183-198},
  note = {cited By (since 1996) 8},
  abstract = {The realization of model-driven software development requires effective
	techniques for implementing code generators. In this paper, we present
	a case study of code generation by model transformation with Stratego,
	a high-level transformation language based on the paradigm of rewrite
	rules with programmable strategies that integrates model-to-model,
	model-to-code, and code-to-code transformations. The use of concrete
	object syntax guarantees syntactic correctness of code patterns,
	and enables the subsequent transformation of generated code. The
	composability of strategies supports two dimensions of transformation
	modularity. Vertical modularity is achieved by designing a generator
	as a pipeline of model-to-model transformations that gradually transforms
	a high-level input model to an implementation. Horizontal modularity
	is achieved by supporting the definition of plugins which implement
	all aspects of a language feature. We discuss the application of
	these techniques in the implementation of WebDSL, a domain-specific
	language for dynamic web applications with a rich data model. © Springer-Verlag
	Berlin Heidelberg 2008.},
  affiliation = {Software Engineering Research Group, Delft University of Technology,
	Netherlands},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-54249132538&partnerID=40&md5=dc9283535b42e70169be2126ec0da38a}
}

@ARTICLE{Hemel2010224,
  author = {Hemel, Z., Visser, E.},
  title = {PIL: A platform independent language for retargetable DSLs},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2010},
  volume = {5969 LNCS},
  pages = {224-243},
  note = {cited By (since 1996) 0},
  abstract = {Intermediate languages are used in compiler construction to simplify
	retargeting compilers to multiple machine architectures. In the implementation
	of domain-specific languages (DSLs), compilers typically generate
	high-level source code, rather than low-level machine instructions.
	DSL compilers target a software platform, i.e. a programming language
	with a set of libraries, deployable on one or more operating systems.
	DSLs enable targeting multiple software platforms if its abstractions
	are platform independent. While transformations from DSL to each
	targeted platform are often conceptually very similar, there is little
	reuse between transformations due to syntactic and API differences
	of the target platforms, making supporting multiple platforms expensive.
	In this paper, we discuss the design and implementation of PIL, a
	Platform Independent Language, an intermediate language providing
	a layer of abstraction between DSL and target platform code, abstracting
	from syntactic and API differences between platforms, thereby removing
	the need for platform-specific transformations. We discuss the use
	of PIL in an implemementation of WebDSL, a DSL for building web applications.
	© 2010 Springer-Verlag.},
  affiliation = {Software Engineering Research Group, Delft University of Technology,
	Netherlands},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-77951581593&partnerID=40&md5=3c039b7985e98ccf8cdc2a11711f181b}
}

@ARTICLE{Hemel2008113,
  author = {Hemel, Z., Verhaaf, R., Visser, E.},
  title = {WebWorkFlow: An object-oriented workflow modeling language for Web
	applications},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2008},
  volume = {5301 LNCS},
  pages = {113-127},
  note = {cited By (since 1996) 4},
  abstract = {Workflow languages are designed for the high-level description of
	processes and are typically not suitable for the generation of complete
	applications. In this paper, we present WebWorkFlow, an object-oriented
	workflow modeling language for the high-level description of workflows
	in web applications. Workflow descriptions define procedures operating
	on domain objects. Procedures are composed using sequential and concurrent
	process combinators. WebWorkFlow is an embedded language, extending
	WebDSL, a domain-specific language for web application development,
	with workflow abstractions. The extension is implemented by means
	of model-to-model transformations. Rather than providing an exclusive
	workflow language, WebWorkFlow supports interaction with the underlying
	WebDSL language. WebWorkFlow supports most of the basic workflow
	control patterns. © 2008 Springer-Verlag Berlin Heidelberg.},
  affiliation = {Software Engineering Research Group, Delft University of Technology,
	Netherlands},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-56649098887&partnerID=40&md5=e01f1060063252635ad04ec4d246e27c}
}

@CONFERENCE{Hemingway2007287,
  author = {Hemingway, G.a , Su, H.a , Chen, K.b , John Koo, T.c },
  title = {A semantic anchoring infrastructure for the design of embedded systems},
  year = {2007},
  volume = {1},
  pages = {287-294},
  note = {cited By (since 1996) 1},
  abstract = {Embedded systems are a key enabling technology for the recent vast
	increase in functionality of a huge list of critical infrastructures.
	Hybrid automata can be used to model system-level behaviors for the
	large category of systems that exhibit strong couplings between discrete
	and continuous dynamics. Many software tools have been developed
	for hybrid automata to enable model-based design of embedded systems
	and these software tools are constructed by using their own modeling
	languages. Model-based design frameworks, such as Model-Integrated
	Computing (MIC), Model Driven Architecture (MDA), and Model Driven
	Design (MDD), have been advocated to raise the level of abstraction
	in software tool design by placing stronger emphasis on the use of
	software models in the software tool design process. In particular,
	MIC places strong emphasis on the use of Domain Specific Modeling
	Languages (DSMLs) and model transformations in design flows. Practical
	and effective development of formal specifications for DSML semantics
	within model-based tools can be challenging, but could positively
	impact adoption and reuse of these tools. The semantic anchoring
	methodology was developed to address this challenge by formally tying
	DSMLs to a "semantic unit", which is a formal specification that
	captures the operational semantics of a specific model of computation.
	Leveraging our prior work with semantic units, we develop a semantic
	unit for hybrid automata. In this paper, we explicitly specify the
	operational semantics of hybrid automata, and develop the corresponding
	semantic unit and model transformation rules. We demonstrate the
	effectiveness of the infrastructure in a practical case study involving
	the hybrid automata DSMLs, Hy Visual and ReachLab. © 2007 IEEE.},
  affiliation = {Department of EECS, Vanderbilt University, Nashville, TN, United States;
	Motorola Labs., Motorola Inc., Schaumburg, IL, United States; College
	of Engineering, Shantou University, Shantou, Guangdong, China},
  art_number = {4291016},
  document_type = {Conference Paper},
  journal = {Proceedings - International Computer Software and Applications Conference},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-37349020578&partnerID=40&md5=e03caaf7b8eadb7623f061cfd23bf740}
}

@ARTICLE{Hen-Tov200939,
  author = {Hen-Tov, A.a , Lorenz, D.H.b , Pinhasi, A.a , Schachter, L.a },
  title = {Model talk: When everything is a domain-specific language},
  journal = {IEEE Software},
  year = {2009},
  volume = {26},
  pages = {39-46},
  number = {4},
  note = {cited By (since 1996) 3},
  abstract = {Many see a great future for domain-specific software development.
	Yet, the path to fulfilling the potential of domain-specific languages
	on a large scale remains largely uncharted. This article presents
	ModelTalk, a model-driven framework for DSL-based development. ModelTalk
	can be used to produce a product line of commercial business support
	systems for the telecommunications industry. © 2009 IEEE.},
  affiliation = {Pontis; Department of Mathematics and Computer Science, Open University
	of Israel, Ra'anana, Israel},
  author_keywords = {Business; Data mining; Domain-specific languages; DSL; Engines; Java;
	Model talk; Model-driven development; Probability density function;
	Software; Software product lines},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-67650504192&partnerID=40&md5=6c870c663d9af857531d669b3097e059}
}

@CONFERENCE{Hen-Tov2009751,
  author = {Hen-Tov, A.a , Lorenz, D.H.b , Schachter, L.a },
  title = {An interpretive domain specific language workbench},
  year = {2009},
  pages = {751-752},
  note = {cited By (since 1996) 0},
  abstract = {Domain-specific language (DSL) utilization comes in three sorts: internal,
	external, and language workbench. An internal DSL is confined to
	the hosting language. An external DSL is freed from confinement in
	the hosting language, but surrenders all native tool support in return.
	A language workbench incorporates external DSLs into the development
	environment, thus bridging the tool-support gap that exists between
	external and internal DSLs. DSL workbenches hold the most promise
	for DSL based development. Yet they are also the least utilized.
	In this work, we present a concrete example of a language workbench.
	Our language workbench facilitates DSL based development in Java,
	where the DSLs are external to Java and yet enjoy Java-like automatic
	tool support.},
  affiliation = {Pontis, Glil Yam 46905, Israel; Open University of Israel, Raanana
	43107, Israel},
  author_keywords = {Domain specific language; Language workbench; Modeltalk},
  document_type = {Conference Paper},
  journal = {Proceedings of the Conference on Object-Oriented Programming Systems,
	Languages, and Applications, OOPSLA},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-72249095473&partnerID=40&md5=edb814994382e07dae8ef9584eee62f6}
}

@CONFERENCE{Hen-Tov2009799,
  author = {Hen-Tov, A.a , Lorenz, D.H.b , Schachter, L.a },
  title = {ModelTalk: A DSL workbench in action},
  year = {2009},
  pages = {799},
  note = {cited By (since 1996) 0},
  abstract = {ModelTalk's language workbench is an IDE for DSL based development
	with Java. ModelTalk provides programmers and language designers
	with a DSL programming experience that has a Java-like look-and-feel
	and a short edit-execute cycle. The workbench exhibits a seamless
	integration of the DSLs with Java and with each other.},
  affiliation = {Pontis, Glil Yam 46905, Israel; Open University of Israel, Raanana
	43107, Israel},
  author_keywords = {Domain specific languages; Language workbench},
  document_type = {Conference Paper},
  journal = {Proceedings of the Conference on Object-Oriented Programming Systems,
	Languages, and Applications, OOPSLA},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-72249087021&partnerID=40&md5=e4b6ef96e63d3b28c7a523f968701afa}
}

@CONFERENCE{Henecka2010451,
  author = {Henecka, W., Kögl, S., Sadeghi, A.-R., Schneider, T., Wehrenberg,
	I.},
  title = {TASTY: Tool for automating secure two-party computations},
  year = {2010},
  pages = {451-462},
  note = {cited By (since 1996) 6},
  abstract = {Secure two-party computation allows two untrusting parties to jointly
	compute an arbitrary function on their respective private inputs
	while revealing no information beyond the outcome. Existing cryptographic
	compilers can automatically generate secure computation protocols
	from high-level specifications, but are often limited in their use
	and efficiency of generated protocols as they are based on either
	garbled circuits or (additively) homomorphic encryption only. In
	this paper we present TASTY, a novel tool for automating, i.e., describing,
	generating, executing, benchmarking, and comparing, efficient secure
	two-party computation protocols. TASTY is a new compiler that can
	generate protocols based on homomorphic encryption and efficient
	garbled circuits as well as combinations of both, which often yields
	the most efficient protocols available today. The user provides a
	high-level description of the computations to be performed on encrypted
	data in a domain-specific language. This is automatically transformed
	into a protocol. TASTY provides most recent techniques and optimizations
	for practical secure two-party computation with low online latency.
	Moreover, it allows to efficiently evaluate circuits generated by
	the well-known Fairplay compiler. We use TASTY to compare protocols
	for secure multiplication based on homomorphic encryption with those
	based on garbled circuits and highly efficient Karatsuba multiplication.
	Further, we show how TASTY improves the online latency for securely
	evaluating the AES functionality by an order of magnitude compared
	to previous software implementations. TASTY allows to automatically
	generate efficient secure protocols for many privacy-preserving applications
	where we consider the use cases for private set intersection and
	face recognition protocols. Copyright 2010 ACM.},
  affiliation = {System Security Lab., Ruhr-University, Bochum, Germany},
  author_keywords = {Compiler; Cryptography; Garbled circuits; Homomorphic encryption;
	Secure function evaluation},
  document_type = {Conference Paper},
  journal = {Proceedings of the ACM Conference on Computer and Communications
	Security},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-78649992236&partnerID=40&md5=379ea74c23133ef9e4b4d6c02f5dbf6c}
}

@CONFERENCE{Hennig2011634,
  author = {Hennig, S., Braune, A.},
  title = {Sustainable visualization solutions in industrial automation with
	Movisa A case study},
  year = {2011},
  pages = {634-639},
  note = {cited By (since 1996) 0},
  abstract = {Current visualization systems in industrial automation mostly rely
	on dedicated runtime environments making the migration of visualization
	solutions from one platform to another almost impossible. On the
	other hand, an increasing number of different platforms has to be
	used also in industrial automation, to monitor or to operate the
	technical process. We propose with Movisa a model-driven approach
	to the development of sustainable visualization solutions in industrial
	automation. Movisa is a Domain Specific Language designed to capture
	only functional contents of visualization solutions. This paper presents
	Movisa by introducing its main concepts in a case study. It will
	also point out the potential of model-driven approaches concerning
	the sustainability of visualization solution in industrial automation.
	© 2011 IEEE.},
  affiliation = {Institute of Automation, Technische Universität Dresden, Germany},
  art_number = {6034952},
  document_type = {Conference Paper},
  journal = {IEEE International Conference on Industrial Informatics (INDIN)},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-80055035114&partnerID=40&md5=1a38533153cfee6bf6bec87850b74a6b}
}

@CONFERENCE{Hennig2010,
  author = {Hennig, S., Braune, A., Koycheva, E.},
  title = {Towards a model driven approach for development of visualization
	applications in industrial automation},
  year = {2010},
  note = {cited By (since 1996) 0},
  abstract = {The eXtensible Visualization Components Markup Language (XVCML) was
	developed in order to ensure the sustainability of visualization
	solutions. Therefore, XVCML follows the Model-Driven Software Development
	(MDSD) approach: It enables technology independent modeling of visualization
	solutions whereas those models are compliant to a formal metamodel.
	XVCML was enhanced by a mean to express arbitrary routines using
	Executable UML. Since we realized the latter aspect only as a first
	proof of concept, this part of XVCML lacks a formal metamodel - a
	requirement for MDSD. This paper seizes on this topic so much that
	a Domain Specific Language, which enables the creation of Executable
	UML models, will be worked out in the context of MDSD. Therefore,
	this paper explains the required foundations for the subject matter
	at hand before it presents the way of proceeding towards a model-driven
	approach with XVCML. ©2010 IEEE.},
  affiliation = {Institute of Automation, Technische Universität Dresden, Germany},
  art_number = {5641320},
  document_type = {Conference Paper},
  journal = {Proceedings of the 15th IEEE International Conference on Emerging
	Technologies and Factory Automation, ETFA 2010},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-78650584430&partnerID=40&md5=e547125d3fc95723a2420ac3c4e4ce13}
}

@ARTICLE{Henriksson2008165,
  author = {Henriksson, J., Heidenreich, F., Johannes, J., Zschaler, S., Aßmann,
	U.},
  title = {Extending grammars and metamodels for reuse: The Reuseware approach},
  journal = {IET Software},
  year = {2008},
  volume = {2},
  pages = {165-184},
  number = {3},
  note = {cited By (since 1996) 5},
  abstract = {The trend towards domain-specific languages leads to an ever-growing
	plethora of highly specialised languages. Developers of such languages
	focus on their specific domains rather than on the technical challenges
	of language design. The generic features of languages are rarely
	included in special-purpose languages. One very important feature
	is the ability to formulate partial programs in separate encapsulated
	entities, which can be composed into complete programs in a well-defined
	manner. A language-independent approach is presented that adds useful
	constructs for defining components. The authors discuss the underlying
	concepts and describe a composition environment and tool supporting
	these ideas-the Reuseware Composition Framework. To evaluate this
	approach, the authors enrich the (Semantic) Web query language Xcerpt
	with an additional useful reuse concept - modules. © 2008 The Institution
	of Engineering and Technology.},
  affiliation = {Technische Universität Dresden, Fakultät Informatik, Dresden D-01062,
	Germany},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-45849138167&partnerID=40&md5=e0fa6348ce5ddc281ef9863b26ea566c}
}

@ARTICLE{Henriques200554,
  author = {Henriques, P.R.a , Pereira, M.J.V.b , Mernik, M.c , Lenič, M.c ,
	Gray, J.d , Wu, H.d },
  title = {Automatic generation of language-based tools using the LISA system},
  journal = {IEE Proceedings: Software},
  year = {2005},
  volume = {152},
  pages = {54-69},
  number = {2},
  note = {cited By (since 1996) 17},
  abstract = {Many tools have been constructed using different formal methods to
	process various parts of a language specification (e.g. scanner generators,
	parser generators and compiler generators). The automatic generation
	of a complete compiler was the primary goal of such systems, but
	researchers recognised the possibility that many other language-based
	tools could be generated from formal language specifications. Such
	tools can be generated automatically whenever they can be described
	by a generic fixed part that traverses the appropriate data structures
	generated by a specific variable part, which can be systematically
	derivable from the language specifications. The paper identifies
	generic and specific parts for various language-based tools. Several
	language-based tools are presented in the paper, which are automatically
	generated using an attribute grammar-based compiler generator called
	LISA. The generated tools that are described in the paper include
	editors, inspectors, debuggers and visualisers/animators. Because
	of their complexity of construction, special emphasis is given to
	visualisers/animators, and the unique contribution of our approach
	toward generating such tools. © IEE, 2005.},
  affiliation = {University of Minho, Department of Informatics, Portugal; Polytechnic
	Institute of Bragança, Campus de Sta Apolonia, 5301-857 Braganca,
	Portugal; Faculty of Electrical Engineering and Computer Science,
	University of Maribor, Smetanova ul.17, 2000 Maribor, Slovenia; Department
	of Computer and Information Sciences, University of Alabama at Birmingham,
	1300 University Blvd., Birmingham, AL 35294, United States},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-18444394961&partnerID=40&md5=5a0895dd156e8beeb2ba42a553ca0c92}
}

@ARTICLE{Henrlksson2007127,
  author = {Henrlksson, J., Johannes, J., Zschaler, S., Aßmann, U.},
  title = {Reuseware - Adding modularity to your language of choice},
  journal = {Journal of Object Technology},
  year = {2007},
  volume = {6},
  pages = {127-146},
  number = {9},
  note = {cited By (since 1996) 0},
  abstract = {The trend towards domain-specific languages leads to an ever-growing
	plethora of highly specialized languages. Developers of such languages
	focus on their specific domains rather than on technical challenges
	of language design. Generic features of languages are rarely Included
	In special-purpose languages. One very Important feature Is modularization,
	the ability to formulate partial programs In separate entitles, composable
	Into a complete program In a defined manner. This paper presents
	a generic approach for adding modularity to arbitrary languages,
	discussing the underlying concepts and presenting the Reuseware Composition
	Framework. We walk through an example based on Xcerpt, a Semantic
	Web query language.},
  affiliation = {Fakultät für Informatik, Technische Universität, Dresden},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-36049037352&partnerID=40&md5=39c5d11a068235ee11293a94ce6ccaea}
}

@ARTICLE{Heradio200925,
  author = {Heradio, R., Cerrada, J.A., Lopez, J.C., Coz, J.R.},
  title = {Code Generation with the Exemplar Flexibilization Language},
  journal = {Electronic Notes in Theoretical Computer Science},
  year = {2009},
  volume = {238},
  pages = {25-34},
  number = {2},
  note = {cited By (since 1996) 0},
  abstract = {Code Generation is an increasing popular technique for implementing
	Software Product Lines that produces code from abstract specifications
	written in Domain Specific Languages (DSLs). This paper proposes
	to take advantage of the similitude among the products in a domain
	to generate them by analogy. That is, instead of synthesizing the
	final code from scratch or transforming the DSL specifications, the
	final products are obtained by adapting a previously developed domain
	product. The paper also discusses the capabilities and limitations
	of several currently available tools and languages to implement this
	kind of generators and introduce a new language to overcome the limitations.
	© 2009 Elsevier B.V. All rights reserved.},
  affiliation = {Departamento de Ingenieria de Software y Sistemas Informaticos, Universidad
	Nacional de Educacion a Distancia, Juan del Rosal 16, E-28040 Madrid,
	Spain},
  author_keywords = {Code Generation; Domain Specific Language; Software Product Line},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-67649388082&partnerID=40&md5=570f4640d7f8b9ca326d4e117e7cb29a}
}

@ARTICLE{Hermans2009423,
  author = {Hermans, F., Pinzger, M., Van Deursen, A.},
  title = {Domain-specific languages in practice: A user study on the success
	factors},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2009},
  volume = {5795 LNCS},
  pages = {423-437},
  note = {cited By (since 1996) 2},
  abstract = {In this paper we present an empirical study on the use of a domain-specific
	language(DSL) in industry. This DSL encapsulates the details of services
	that communicate using Windows Communication Foundation (WCF). From
	definitions of the data contracts between clients and servers, WCF/C#
	code for service plumbing is generated. We conducted a survey amongst
	developers that use this DSL while developing applications for customers.
	The DSL has been used in about 30 projects all around the world.
	We describe the known success factors of the use of DSLs, such as
	improved maintainability and ease of re-use, and assert how well
	this DSL scores on all of them. The analysis of the results of this
	case study also shows which conditions should be fulfilled in order
	to increase the chances of success in using a DSL in a real life
	case. © 2009 Springer Berlin Heidelberg.},
  affiliation = {Delft University of Technology, Netherlands},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-77249142214&partnerID=40&md5=ad69fe7a6c0119d6bfe89700f71ea439}
}

@ARTICLE{Herrmann200647,
  author = {Herrmann, C.A.a , Langhammer, T.b },
  title = {Combining partial evaluation and staged interpretation in the implementation
	of domain-specific languages},
  journal = {Science of Computer Programming},
  year = {2006},
  volume = {62},
  pages = {47-65},
  number = {1},
  note = {cited By (since 1996) 1},
  abstract = {We propose a combination of partial evaluation and staged interpretation
	with MetaOCaml for rapid prototyping of domain-specific languages.
	Interpretation is an easy way to implement such languages. MetaOCaml
	can eliminate the overhead of interpretation at run-time, if the
	interpreter is written in a staged form, i.e., takes the source program
	separate from the input data in a first stage. Partial evaluation
	of the source program with values known at compile time can further
	improve the target code performance. Additional aggressive optimizations
	are possible due to the absence of general recursion. Algebraic simplifications
	can even achieve binding-time improvements during the online partial
	evaluation. Our approach both saves the application programmer completely
	from binding-time considerations and exploits staged interpretation
	with MetaOCaml for target code generation. The example domain presented
	in this paper is image processing, in which the domain-specific language
	permits the specification of convolution matrices, summations, case
	distinctions and non-local pixel accesses. All expressions known
	at compile time are simplified and all remaining expressions are
	turned into MetaOCaml code parts, which are combined to form the
	compiled application program. The example specifications deal with
	filtering by convolution and iterations in a series of images for
	wave effects and temperature distribution. The experimental results
	show significant speed-ups if online partial evaluation with algebraic
	simplifications is used for the elimination of interpretation overhead
	and optimization of code expressions. © 2006 Elsevier B.V. All rights
	reserved.},
  affiliation = {University of Passau, Innstr. 33, Room 128, 94032 Passau, Germany;
	Konrad-Zuse-Zentrum für Informationstechnik Berlin (ZIB), Department
	Computer Science Research, Takustr. 7, Room 3154, 14195 Berlin-Dahlem,
	Germany},
  author_keywords = {Binding-time improvement; Compilation; Domain-specific languages;
	Meta-programming; Partial evaluation; Staged interpretation},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-33745648357&partnerID=40&md5=cfcddf8e781c71145c3d5769a7bee674}
}

@CONFERENCE{Herrmann2000,
  author = {Herrmann, S., Mezini, M.},
  title = {PIROL: A case study for multidimensional separation of concerns in
	software engineering environments},
  year = {2000},
  volume = {35},
  number = {10},
  pages = {188-207},
  note = {cited By (since 1996) 2},
  abstract = {In this paper, we present our experience with applying multidimensional
	separation of concerns to a software engineering environment. By
	comparing two different designs of our system, we show the importance
	of separating integration issues from the implementation of the individual
	concerns. We present a model in which integration issues are encapsulated
	into first-class connector objects and indicate how this facilitates
	the understandability, maintenance and evolution of the system. We
	identify issues of binding time, binding granularity and binding
	cardinality as important criteria in selecting an appropriate model
	for separation of concerns. We finally show how a good choice following
	these criteria and considering the requirements of software engineering
	environments leads to a system with dynamic configurability, high-level
	component integration and support for multiple instantiable views.},
  affiliation = {Technical University Berlin, D-10587 Berlin, Germany},
  author_keywords = {Component integration; Domain-specific language; Separation of concerns;
	Software engineering environment},
  document_type = {Conference Paper},
  journal = {Proceedings of the Conference on Object-Oriented Programming Systems,
	Languages, and Applications, OOPSLA},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-0034448182&partnerID=40&md5=4fc3227115c427bc527dc45ba2e4f122}
}

@ARTICLE{Herrmann2000188,
  author = {Herrmann, S.a , Mezini, M.b },
  title = {PIROL: A case study for multidimensional separation of concerns in
	software engineering environments},
  journal = {SIGPLAN Notices (ACM Special Interest Group on Programming Languages)},
  year = {2000},
  volume = {35},
  pages = {188-207},
  number = {10},
  note = {cited By (since 1996) 2},
  abstract = {In this paper, we present our experience with applying multidimensional
	separation of concerns to a software engineering environment. By
	comparing two different designs of our system, we show the importance
	of separating integration issues from the implementation of the individual
	concerns. We present a model in which integration issues are encapsulated
	into first-class connector objects and indicate how this facilitates
	the understandability, maintenance and evolution of the system. We
	identify issues of binding time, binding granularity and binding
	cardinality as important criteria in selecting an appropriate model
	for separation of concerns. We finally show how a good choice following
	these criteria and considering the requirements of software engineering
	environments leads to a system with dynamic configurability, high-level
	component integration and support for multiple instantiable views.
	© 2000 ACM.},
  affiliation = {Technical University Berlin, D-10587 Berlin, Germany; Darmstadt University
	of Technology, D-64283 Darmstadt, Germany},
  author_keywords = {Component integration; Domain-specific language; Separation of concerns;
	Software engineering environment},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-0042621382&partnerID=40&md5=5f08f653677cd013c1e0b3a8dac3aac0}
}

@ARTICLE{Herrmannsdörfer2010121,
  author = {Herrmannsdörfer, M., Hummel, B.},
  title = {Library concepts for model reuse},
  journal = {Electronic Notes in Theoretical Computer Science},
  year = {2010},
  volume = {253},
  pages = {121-134},
  number = {7},
  note = {cited By (since 1996) 0},
  abstract = {Reuse and the composition of libraries of partial system descriptions
	is a fundamental and well-understood practice in software engineering,
	as long as we talk about source code. For models and modeling languages,
	the concepts of reuse often are limited to copy & paste, especially
	when it comes to domain-specific modeling languages (DSLs). This
	paper attempts to give an overview of techniques for including support
	for reuse and library concepts both in the meta-model and the modeling
	tool, and presents a novel generative approach for this task. The
	technical consequences for each of the approaches presented are discussed
	and compared to each other. © 2010 Elsevier B.V. All rights reserved.},
  affiliation = {Fakultät für Informatik, Technische Universität München, Garching
	bei München, Germany},
  author_keywords = {model library; model-based development; reuse},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-77956419955&partnerID=40&md5=453adbbf0642b1e1829ff37b73d85d71}
}

@CONFERENCE{Hessellund2007945,
  author = {Hessellund, A.},
  title = {SmartEMF guidance in modeling tools},
  year = {2007},
  pages = {945-946},
  note = {cited By (since 1996) 0},
  abstract = {The advent of domain-specific modeling in enterprise systems development
	has given rise to new tool requirements. Existing tools do not offer
	sufficient modeling guidance or inconsistency management for the
	multitude of new metamodels and models. Specifically, there is a
	need to offer guidance on 1) valid editing operations, 2) ensuring
	consistency among models, 3) bridging the gap between models and
	custom code, and 4) managing the evolution of domain-specific languages.
	Based on two empirical case studies, we propose a new unirepresentational
	modeling tool - SmartEMF - which provides guidance and inconsistency
	management when developing enterprise systems with multiple domain-specific
	languages.},
  affiliation = {IT University of Copenhagen, Denmark},
  author_keywords = {Modeling guidance; Multiple DSLs},
  document_type = {Conference Paper},
  journal = {Proceedings of the Conference on Object-Oriented Programming Systems,
	Languages, and Applications, OOPSLA},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-42149134918&partnerID=40&md5=12dbbc808c48940d34c86332e10461dc}
}

@ARTICLE{Hessellund200746,
  author = {Hessellund, A.a , Czarnecki, K.b , Wa̧sowski, A.a },
  title = {Guided development with multiple domain-specific languages},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2007},
  volume = {4735 LNCS},
  pages = {46-60},
  note = {cited By (since 1996) 13},
  abstract = {We study the Apache Open for Business (OFBiz), an industrial-strength
	platform for enterprise applications. OFBiz is an example of a substantial
	project using model-driven development with multiple domain-specific
	languages (DSLs). We identify consistency management as one of its
	key challenges. To address this challenge, we present SmartEMF, which
	is an extension of the Eclipse Modeling Framework that provides support
	for representing, checking, and maintaining constraints in the context
	of multiple loosely-coupled DSLs. SmartEMF provides a simple form
	of user guidance by computing the valid set of editing operations
	that are available in a given context. We evaluate the prototype
	by applying it to the OFBiz project. © Springer-Verlag Berlin Heidelberg
	2007.},
  affiliation = {IT University of Copenhagen, Denmark; University of Waterloo, Canada},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-38049033323&partnerID=40&md5=d5f023310ac8c73ec94b7cbc735514c9}
}

@CONFERENCE{Hill2011120,
  author = {Hill, J.H.},
  title = {Measuring and reducing modeling effort in domain-specific modeling
	languages with examples},
  year = {2011},
  pages = {120-129},
  note = {cited By (since 1996) 0},
  abstract = {Domain-specific modeling languages (DSMLs) facilitate rapid and "correct-by-construction"
	realization of concepts for the target domain. Although DSMLs provide
	such benefits, there is implied (or hidden) modeling effort - in
	terms of user actions - associated with using a DSML that can negatively
	impact its effectiveness. It is therefore critical that DSML developers
	understand the meaning of modeling effort and how to reduce it so
	their DSML is of high quality. This paper provides two contributions
	to research on developing DSMLs. First, the paper defines a metric
	for measuring model effort. Secondly, this paper discusses several
	techniques, with examples, reducing (or improving) modeling effort.
	The techniques discussed in the paper have been applied to an open-source
	DSML called the Platform Independent Component Modeling Language
	(PICML), which is currently used in both academic and industry settings
	for designing and implementing large-scale distributed systems. Finally,
	results show that it is possible to reduce modeling effort without
	requiring user studies to analyze such concerns. © 2011 IEEE.},
  affiliation = {Indiana University-Purdue University Indianapolis, Indianapolis, IN,
	United States},
  art_number = {5934812},
  document_type = {Conference Paper},
  journal = {Proceedings - 18th IEEE International Conference and Workshops on
	Engineering of Computer-Based Systems, ECBS 2011},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-80052010877&partnerID=40&md5=a91ac1ebdec6f9a1dc2205b30a9ff863}
}

@CONFERENCE{Hill201175,
  author = {Hill, J.H.},
  title = {Modeling Interface Definition Language Extensions (IDL3+) using domain-specific
	modeling languages},
  year = {2011},
  pages = {75-82},
  note = {cited By (since 1996) 0},
  abstract = {Model-driven engineering (MDE) of distributed real-time and embedded
	(DRE) systems built using distributed middleware technologies typically
	rely on interface definition language (IDL) to define interfaces
	and attributes of the system under development. Recent needs for
	using IDL to design and implement systems composed of heterogeneous
	communication architectures, however, has realized the limitations
	of IDL. To address these limitations, vendors have proposed several
	non-trivial extensions to IDL also known as IDL3+. In order to leverage
	such extensions in the modeling domain, it is necessary to update
	existing tools, e.g., domain-specific modeling languages) to support
	such extensions. This paper provides two contributions to MDE of
	DRE systems using domain-specific modeling languages (DSMLs). First,
	this paper highlights the technical challenges associated with modeling
	IDL3+. Secondly, this paper discusses how to overcome such challenges
	in the context of a representative DSML for modeling DRE systems
	designed and implemented using IDL3+. Experience gained from using
	DSMLs to model IDL3+ shows that DSML environments as is do not suffice
	and need improved application frameworks to support complex DSMLs,
	such as IDL3+. © 2011 IEEE.},
  affiliation = {Indiana University-Purdue University Indianapolis, Dept. of Computer
	and Information Science, Indianapolis, IN, United States},
  art_number = {5753594},
  author_keywords = {domain-specific modleing languages; DRE systems; heterogenous systems;
	IDL3+},
  document_type = {Conference Paper},
  journal = {Proceedings - 2011 14th IEEE International Symposium on Object/Component/Service-Oriented
	Real-Time Distributed Computing, ISORC 2011},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-79957982394&partnerID=40&md5=4a5380d774098c592762421b097f56a0}
}

@ARTICLE{Hill201065,
  author = {Hill, J.a , Schmidt, D.b , Edmondson, J.b , Gokhale, A.b },
  title = {Tools for continuously evaluating distributed system qualities},
  journal = {IEEE Software},
  year = {2010},
  volume = {27},
  pages = {65-71},
  number = {4},
  note = {cited By (since 1996) 0},
  abstract = {The end-to-end evaluation of distributed systems' quality-of-service
	(QoS) properties such as performance, reliability, and security has
	historically occurred late in the software life cycle. As a result,
	many design flaws that affect QoS aren't found and fixed in a timely
	and cost-effective manner. Model-driven engineeringparticularly,
	domain-specific modeling languages (DSMLs) coupled with system execution
	modeling toolscan enable agile development of distributed systems
	and facilitate continuous system integration testing to improve quality
	assurance of QoS properties throughout the software life cycle. For
	example, the authors have realized such agile techniques in an open-source
	DSML-based system execution modeling tool called CUTS (Component
	Workload Emulator [Coworker] Utilization Test Suite). They've used
	CUTS as a case study to qualitatively and quantitatively evaluate
	how DSML-based system execution modeling tools can support lightweight
	and adaptable software development and QoS assurance processes. ©
	2006 IEEE.},
  affiliation = {Indiana University, Purdue University at Indianapolis, Indianapolis,
	United States; Vanderbilt University, Nashville, United States},
  art_number = {5306061},
  author_keywords = {Agile techniques; Continuous system integration; Distributed systems;
	Domain-specific modeling languages; Model-driven engineering; System
	execution modeling tools},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-77953717116&partnerID=40&md5=7a65444d9a1ba21fedbf46a0432eddf3}
}

@CONFERENCE{Hill2008,
  author = {Hill, J.H., Gokhale, A.},
  title = {Model-driven specification of component-based distributed real-time
	and embedded systems for verification of systemic QoS properties},
  year = {2008},
  note = {cited By (since 1996) 0},
  abstract = {The adage "the whole is not equal to the sum of its parts" is very
	appropriate in the context of verifying a range of systemic properties,
	such as deadlocks, correctness, and conformance to quality of service
	(QoS) requirements, for component-based distributed real-time and
	embedded (DRE) systems. For example, end-to-end worst case response
	time (WCRT) in component-based DRE systems is not as simple as accumulating
	WCRT for each individual component in the system because of inherent
	complexities introduced by the large solution space of possible deployment
	and configurations. This paper describes a novel process and tool-based
	artifacts that simplify the formal specification of component-based
	DRE systems for verification of systemic QoS properties. Our approach
	is based on the mathematical formalism of Timed Input/Output Automata
	and uses generative programming techniques for automating the verification
	of systemic QoS properties for component-based DRE systems. ©2008
	IEEE.},
  affiliation = {Vanderbilt University, Nashville, TN, United States},
  art_number = {4536573},
  author_keywords = {Component-based distributed real-time and embedded systems; Formal
	specification; Generative programming; Model-driven engineering;
	System verification; Timed I/O automata},
  document_type = {Conference Paper},
  journal = {IPDPS Miami 2008 - Proceedings of the 22nd IEEE International Parallel
	and Distributed Processing Symposium, Program and CD-ROM},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-51049110957&partnerID=40&md5=4eaf1a4b7bb44a4007f0fe235c7a6d3f}
}

@CONFERENCE{Hill2007307,
  author = {Hill, J.H., Tambe, S., Gokhale, A.},
  title = {Model-driven engineering for development-time QoS validation of Component-based
	software systems},
  year = {2007},
  pages = {307-316},
  note = {cited By (since 1996) 2},
  abstract = {Model-driven engineering (MDE) techniques are increasingly being used
	to address many of the development and operational lifecycle concerns
	of large-scale component-based systems. One such concern lacking
	significant research deals with the validation of quality-of-service
	(QoS) properties of component-based systems throughout their development
	lifecycle instead of waiting until system integration time, which
	is very late and can be detrimental to project schedules and costs.
	This paper describes our novel MDE-based solution to address this
	challenge. At the core of our solution approach are (1) a set of
	domain-specific modeling languages that allow us to mimic component
	"business logic," and (2) a generative programming framework that
	synthesizes empirical benchmarking code for system emulation and
	continuous QoS evaluation. © 2007 IEEE.},
  affiliation = {Vanderbilt University, Nashville, TN, United States},
  art_number = {4148946},
  author_keywords = {Code generation; Continuous QoS validation; Model-driven system engineering},
  document_type = {Conference Paper},
  journal = {Proceedings of the International Symposium and Workshop on Engineering
	of Computer Based Systems},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-34250166538&partnerID=40&md5=8ae621c2b9798ded204e01b0c9c34453}
}

@ARTICLE{Hinze2006208,
  author = {Hinze, R.a , Jeuring, J.b , Löh, A.a },
  title = {Typed contracts for functional programming},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2006},
  volume = {3945 LNCS},
  pages = {208-225},
  note = {cited By (since 1996) 9},
  abstract = {A robust software component fulfills a contract: it expects data satisfying
	a certain property and promises to return data satisfying another
	property. The object-oriented community uses the design-by-contract
	approach extensively. Proposals for language extensions that add
	contracts to higher-order functional programming have appeared recently.
	In this paper we propose an embedded domain-specific language for
	typed, higher-order and first-class contracts, which is both more
	expressive than previous proposals, and allows for a more informative
	blame assignment. We take some first steps towards an algebra of
	contracts, and we show how to define a generic contract combinator
	for arbitrary algebraic data types. The contract language is implemented
	as a library in Haskell using the concept of generalised algebraic
	data types. © Springer-Verlag Berlin Heidelberg 2006.},
  affiliation = {Institut für Informatik III, Universität Bonn, Römerstraße 164, 53117
	Bonn, Germany; Institute of Information and Computing Sciences, Utrecht
	University, P.O. Box 80.089, 3508 TB Utrecht, Netherlands},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-33745822726&partnerID=40&md5=91134f6475aa612cad61e3c6052bd029}
}

@CONFERENCE{Hlaoui2011243,
  author = {Hlaoui, Y.B., Benayed, L.J.},
  title = {A model transformation approach based on homomorphic mappings between
	UML activity diagrams and BPEL4WS specifications of grid service
	workflows},
  year = {2011},
  pages = {243-248},
  note = {cited By (since 1996) 0},
  abstract = {We use a Domain Specific Language (DSL) based on UML activity diagrams
	to specify and compose systematically workflow models from Grid services.
	To be executed, workflow activity diagram models should be translated
	into BPEL4WS models which will be executed by the BPEL4WS engine.
	To reach this objective, we propose a meta-model based transformation
	from UML activity diagrams to BPEL4WS language. To ensure the correctness
	and the completion of the transformation, we propose a graph homomorphic
	mapping between the activity diagram and BPEL4WS language elements.
	© 2011 IEEE.},
  affiliation = {Research Unit in Technologies of Information and Communication (UTIC),
	Institute of Sciences and Techniques of Tunis, Tunis, Tunisia},
  art_number = {6032245},
  author_keywords = {BPEL4WS; Grid service workflow; Homomorphic mapping; Meta-model transformation;
	UML activity diagrams},
  document_type = {Conference Paper},
  journal = {Proceedings - International Computer Software and Applications Conference},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-80054972562&partnerID=40&md5=f15959a8a775b05b02e4ad98a3b40c59}
}

@CONFERENCE{Hoefler2009574,
  author = {Hoefler, T.a , Siebert, C.b , Lumsdaine, A.a },
  title = {Group operation assembly language - A flexible way to express collective
	communication},
  year = {2009},
  pages = {574-581},
  note = {cited By (since 1996) 0},
  abstract = {The implementation and optimization collective communication operations
	is an important field of active research. Such operations directly
	influence application performance and need to map the communication
	requirements in an optimal way to steadily changing network architectures.
	In this work, we define an abstract domain-specific language to express
	arbitrary group communication operations. We show the universality
	of this language and how all existing collective operations can be
	implemented with it. By design, it readily lends itself to blocking
	and nonblocking execution, as well as to off-loaded execution of
	complex group communication operations. We also define several offline
	and online optimizations (compiler transformations and scheduling
	decisions, respectively) to improve the overall performance of the
	operation. Performance results show that the overhead to express
	current collective operations is negligible in comparison to the
	potential gains in a highly optimized implementation. © 2009 IEEE.},
  affiliation = {Open Systems Lab., Indiana University, Bloomington IN 47405, United
	States; NEC Laboratories Europe, NEC Europe Ltd., Rathausallee 10,
	53757 Sankt Augustin, Germany},
  art_number = {5362477},
  document_type = {Conference Paper},
  journal = {Proceedings of the International Conference on Parallel Processing},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-77951446376&partnerID=40&md5=e07b6a6664a4e51be971b68819d3c6a3}
}

@ARTICLE{Hofer201183,
  author = {Hofer, C.a , Ostermann, K.b },
  title = {Modular domain-specific language components in scala},
  journal = {ACM SIGPLAN Notices},
  year = {2011},
  volume = {46},
  pages = {83-92},
  number = {2},
  note = {cited By (since 1996) 0},
  abstract = {Programs in domain-specific embedded languages (DSELs) can be represented
	in the host language in different ways, for instance implicitly as
	libraries, or explicitly in the form of abstract syntax trees. Each
	of these representations has its own strengths and weaknesses. The
	implicit approach has good composability properties, whereas the
	explicit approach allows more freedom in making syntactic program
	transformations. Traditional designs for DSELs fix the form of representation,
	which means that it is not possible to choose the best representation
	for a particular interpretation or transformation. We propose a new
	design for implementing DSELs in Scala which makes it easy to use
	different program representations at the same time. It enables the
	DSL implementor to define modular language components and to compose
	transformations and interpretations for them. Copyright © 2010 ACM.},
  affiliation = {Aarhus University, Denmark; University of Marburg, Germany},
  author_keywords = {Domain-Specific Languages; Embedded Languages; Scala; Term Representation;
	Visitor Pattern},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-79951758014&partnerID=40&md5=2c039ba0cdbfb3d3b78c3b3b88ad0edb}
}

@CONFERENCE{Hofer201083,
  author = {Hofer, C.a , Ostermann, K.b },
  title = {Modular domain-specific language components in Scala},
  year = {2010},
  pages = {83-92},
  note = {cited By (since 1996) 0},
  abstract = {Programs in domain-specific embedded languages (DSELs) can be represented
	in the host language in different ways, for instance implicitly as
	libraries, or explicitly in the form of abstract syntax trees. Each
	of these representations has its own strengths and weaknesses. The
	implicit approach has good composability properties, whereas the
	explicit approach allows more freedom in making syntactic program
	transformations. Traditional designs for DSELs fix the form of representation,
	which means that it is not possible to choose the best representation
	for a particular interpretation or transformation. We propose a new
	design for implementing DSELs in Scala which makes it easy to use
	different program representations at the same time. It enables the
	DSL implementor to define modular language components and to compose
	transformations and interpretations for them. © 2010 ACM.},
  affiliation = {Aarhus University, Denmark; University of Marburg, Germany},
  author_keywords = {Domain-specific languages; Embedded language; Scala; Term representation;
	Visitor pattern},
  document_type = {Conference Paper},
  journal = {GPCE'10 - Proceedings of the 2010 Conference on Generative Programming
	and Component Engineering},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-78650163562&partnerID=40&md5=0539fde2e1900b19764a8d823a8e88fe}
}

@CONFERENCE{Hofer2008137,
  author = {Hofer, C.a , Ostermann, K.a , Rendel, T.a , Moors, A.b },
  title = {Polymorphic embedding of DSLs},
  year = {2008},
  pages = {137-147},
  note = {cited By (since 1996) 12},
  abstract = {The influential pure embedding methodology of embedding domainspecific
	languages (DSLs) as libraries into a general-purpose host language
	forces the DSL designer to commit to a single semantics. This precludes
	the subsequent addition of compilation, optimization or domain-specific
	analyses. We propose polymorphic embedding of DSLs, where many different
	interpretations of a DSL can be provided as reusable components,
	and show how polymorphic embedding can be realized in the programming
	language Scala. With polymorphic embedding, the static type-safety,
	modularity, composability and rapid prototyping of pure embedding
	are reconciled with the flexibility attainable by external toolchains.
	© 2008 ACM.},
  affiliation = {University of Aarhus, Denmark; KU Leuven, Belgium},
  author_keywords = {Algebraic semantics; Compositionality; Domain-specific languages;
	Extensibility; Pure embedding; Scala},
  document_type = {Conference Paper},
  journal = {GPCE'08: Proceedings of the ACM SIGPLAN 7th International Conference
	on Generative Programming and Component Engineering},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-63449137141&partnerID=40&md5=0aa15ffd20d723104d1417c2036e3962}
}

@ARTICLE{Hoffert2008515,
  author = {Hoffert, J., Schmidt, D., Gokhale, A.},
  title = {DQML: A modeling language for configuring distributed publish/subscribe
	quality of service policies},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2008},
  volume = {5331 LNCS},
  pages = {515-534},
  number = {PART 1},
  note = {cited By (since 1996) 0},
  abstract = {Many publish/subscribe (pub/sub) middleware platforms provide flexibility
	in configuring policies that affect end-to-end quality of service
	(QoS). While the functionality and tunability of pub/sub middleware
	has increased, so has the complexity of creating semantically compatible
	QoS policy configurations. This paper makes two contributions to
	addressing these challenges. First, it describes how a domain-specific
	modeling language (DSML) can automate the analysis and synthesis
	of semantically compatible QoS policy configurations. Second, it
	empirically evaluates how this DSML increases productivity when generating
	valid QoS policy configurations. Our experimental results show a
	54% reduction in development effort using DQML over manual methods.
	© 2008 Springer Berlin Heidelberg.},
  affiliation = {Institute for Software Integrated Systems, Dept. of EECS, Vanderbilt
	University, Nashville, TN 37203, United States},
  author_keywords = {Configuration Modeling Tools; Data Distribution Service; Domain-Specific
	Modeling Languages; Modeling Metrics; Pub/Sub Middleware},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-58149103986&partnerID=40&md5=16a7ba238b9cc8362d470f14c6ebc359}
}

@CONFERENCE{Hoffert2007140,
  author = {Hoffert, J., Schmidt, D., Gokhale, A.},
  title = {A QoS policy configuration modeling language for publish/subscribe
	middleware platforms},
  year = {2007},
  volume = {233},
  pages = {140-145},
  note = {cited By (since 1996) 1},
  abstract = {Publish/subscribe (pub/sub) middleware platforms for event-based distributed
	systems often provide many configurable policies that affect end-to-end
	quality of service (QoS). Although the flexibility and functionality
	of pub/sub middleware platforms has matured, configuring their QoS
	policies in semantically compatible ways has become more complex.
	This paper makes two contributions to reducing the complexity of
	configuring QoS policies for event-based distributed systems. First,
	it evaluates various approaches for managing complex QoS policy configurations
	in pub/sub middleware platforms. Second, it describes a domain-specific
	modeling language (DSML) that automates the analysis and synthesis
	of semantically compatible QoS policy configurations. © 2007 ACM.},
  affiliation = {Institute for Software Integrated Systems, Dept of EECS, Vanderbilt
	University, Nashville, TN 37203, United States},
  author_keywords = {Data distribution service; Dom-ain-specific modeling languages; Event-based
	distributed systems; Pub/subMiddleware},
  document_type = {Conference Paper},
  journal = {ACM International Conference Proceeding Series},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-34548049538&partnerID=40&md5=75cbe47cdc6d722bc605c5cdf273ff2c}
}

@ARTICLE{Hofmann2011371,
  author = {Hofmann, M.a , Pierce, B.b , Wagner, D.b },
  title = {Symmetric lenses},
  journal = {ACM SIGPLAN Notices},
  year = {2011},
  volume = {46},
  pages = {371-384},
  number = {1},
  note = {cited By (since 1996) 0},
  abstract = {structures-have been extensively studied and are beginning to find
	their way into industrial practice. However, some aspects of their
	foundations remain poorly understood. In particular, most previous
	work has focused on the special case of asymmetric lenses, where
	one of the structures is taken as primary and the other is thought
	of as a projection, or view. A few studies have considered symmetric
	variants, where each structure contains information not present in
	the other, but these all lack the basic operation of composition.
	Moreover, while many domain-specific languages based on lenses have
	been designed, lenses have not been thoroughly explored from an algebraic
	perspective. We offer two contributions to the theory of lenses.
	First, we present a new symmetric formulation, based on complements,
	an old idea from the database literature. This formulation generalizes
	the familiar structure of asymmetric lenses, and it admits a good
	notion of composition. Second, we explore the algebraic structure
	of the space of symmetric lenses. We present generalizations of a
	number of known constructions on asymmetric lenses and settle some
	longstanding questions about their properties-in particular, we prove
	the existence of (symmetric monoidal) tensor products and sums and
	the non-existence of full categorical products or sums in the category
	of symmetric lenses. We then show how the methods of universal algebra
	can be applied to build iterator lenses for structured data such
	as lists and trees, yielding lenses for operations like mapping,
	filtering, and concatenation from first principles. Finally, we investigate
	an even more general technique for constructing mapping combinators,
	based on the theory of containers. Copyright © 2011 ACM.},
  affiliation = {Ludwig-Maximilians-Universität München, Germany; University of Pennsylvania,
	PA, United States},
  author_keywords = {Algebra; Category theory; Lens; View-update},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-79251553793&partnerID=40&md5=4925925b3cb3392aef48c3fa79205ff2}
}

@CONFERENCE{Hofmann2010371,
  author = {Hofmann, M.a , Pierce, B.b , Wagner, D.b },
  title = {Symmetric lenses},
  year = {2010},
  pages = {371-384},
  note = {cited By (since 1996) 0},
  abstract = {Lenses-bidirectional transformations between pairs of connected structures-have
	been extensively studied and are beginning to find their way into
	industrial practice. However, some aspects of their foundations remain
	poorly understood. In particular, most previous work has focused
	on the special case of asymmetric lenses, where one of the structures
	is taken as primary and the other is thought of as a projection,
	or view. A few studies have considered symmetric variants, where
	each structure contains information not present in the other, but
	these all lack the basic operation of composition. Moreover, while
	many domain-specific languages based on lenses have been designed,
	lenses have not been thoroughly explored from an algebraic perspective.
	We offer two contributions to the theory of lenses. First, we present
	a new symmetric formulation, based on complements, an old idea from
	the database literature. This formulation generalizes the familiar
	structure of asymmetric lenses, and it admits a good notion of composition.
	Second, we explore the algebraic structure of the space of symmetric
	lenses. We present generalizations of a number of known constructions
	on asymmetric lenses and settle some longstanding questions about
	their properties-in particular, we prove the existence of (symmetric
	monoidal) tensor products and sums and the non-existence of full
	categorical products or sums in the category of symmetric lenses.
	We then show how the methods of universal algebra can be applied
	to build iterator lenses for structured data such as lists and trees,
	yielding lenses for operations like mapping, filtering, and concatenation
	from first principles. Finally, we investigate an even more general
	technique for constructing mapping combinators, based on the theory
	of containers. Copyright © 2011 ACM.},
  affiliation = {Ludwig-Maximilians-Universität, München, Germany; University of Pennsylvania,
	PA, United States},
  author_keywords = {Algebra; Category theory; Lens; View-update},
  document_type = {Conference Paper},
  journal = {Conference Record of the Annual ACM Symposium on Principles of Programming
	Languages},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-79952034160&partnerID=40&md5=2f7996e7e542ecfb4c9f9597aee4996e}
}

@ARTICLE{Hohn2004797,
  author = {Hohn, M.H.},
  title = {A little language for modularizing numerical PDE solvers},
  journal = {Software - Practice and Experience},
  year = {2004},
  volume = {34},
  pages = {797-813},
  number = {9},
  note = {cited By (since 1996) 1},
  abstract = {This paper describes a concise specification language for linear partial
	differential equations (PDEs) on a union of rectangles, along with
	three tools: a pretty-printer, TEX generator, and a code generator.
	The pretty-printer and TEX generator help users by allowing equations
	to be specified (and read) in their natural form, while the code
	generator allows implementors to separate their numerical solver
	from the input equations, and greatly simplifies testing. Copyright
	© 2004 John Wiley &amp; Sons, Ltd.},
  affiliation = {Department of Mathematics, University of Utah, Salt Lake City, UT
	84112, United States},
  author_keywords = {Code generation; Domain-specific language; Partial differential equations;
	Pretty-printing},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-3142585454&partnerID=40&md5=7f88e4265dd86252424d482d73b41281}
}

@CONFERENCE{Holland2004224,
  author = {Holland, S.},
  title = {Reflective composition: The declarative composition of roles to unify
	objects, roles, and aspects},
  year = {2004},
  pages = {224-225},
  note = {cited By (since 1996) 0},
  abstract = {As bases for object-orientation, both class-based and prototype-based
	organization have limitations. We argue that roles have significant
	benefits as a foundation for organizing objects. We further argue
	that these benefits can be realised most flexibly using logic meta-programming.
	Additional benefits from this approach are to reduce redundancy and
	subsume aspects.},
  affiliation = {Department of Computing, Open University, Milton Keynes MK7 6AA, United
	Kingdom},
  author_keywords = {Aspects; Composition; Generative programming; Logic meta programming;
	Role models; Roles},
  document_type = {Conference Paper},
  journal = {Proceedings of the Conference on Object-Oriented Programming Systems,
	Languages, and Applications, OOPSLA},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-79951756531&partnerID=40&md5=4159e2d57941471069013110718f95a8}
}

@CONFERENCE{Horie201097,
  author = {Horie, M., Chiba, S.},
  title = {Tool support for crosscutting concerns of API documentation},
  year = {2010},
  pages = {97-108},
  note = {cited By (since 1996) 2},
  abstract = {Writing detailed API (Application Programming Interface) documentation
	is a significant task for developing a good class library or framework.
	However, existing documentation tools such as Javadoc provide only
	limited support and thus the description written by programmers for
	API documentation often contains scattering text. Occasionally, it
	also contains tangling text. This paper presents that this problem
	is due to crosscutting concerns of API documentation. Then it proposes
	our new tool named Comment-Weaver, which provides several mechanisms
	for modularly describing API documentation of class libraries or
	frameworks written in Java or AspectJ. It is an extended Javadoc
	tool and it provides several new tags for controlling how the text
	manually written by the programmers is scattering and appended to
	other entries or how it is moved from the original entry to another
	entry to be tangling. Finally this paper evaluates CommentWeaver
	by using three class libraries and frameworks: Javassist, the Java
	standard library, and Eclipse. It showed that CommentWeaver resolves
	the problems of scattering or tangling text and it adequately reduces
	the amount of description written by programmers for API documentation.
	Copyright 2010 ACM.},
  affiliation = {Tokyo Institute of Technology, 2-12-1 Ohkayama, Meguro-ku, Tokyo 152-8552,
	Japan},
  author_keywords = {API documentation; Aspect-oriented programming; Domain-specific language},
  document_type = {Conference Paper},
  journal = {AOSD.10 - 9th International Conference on Aspect-Oriented Software
	Development},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-77952247526&partnerID=40&md5=ac8d86bde52445cf1920724eaeb188f4}
}

@ARTICLE{Horn2011183,
  author = {Horn, T., Ebert, J.},
  title = {The GReTL transformation language},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2011},
  volume = {6707 LNCS},
  pages = {183-197},
  note = {cited By (since 1996) 0},
  abstract = {This paper introduces the graph-based transformation language GReTL.
	GReTL is an operational transformation language whose operations
	are either specified in plain Java using the GReTL API or in a simple
	domain-specific language. GReTL follows the conception of incrementally
	constructing the target metamodel together with the target graph.
	When creating a new metamodel element, a set-based semantic expression
	is specified that describes the set of instances that have to be
	created in the target graph. This expression is described by a query
	on the source graph. After a description of the foundations of GReTL,
	its most important elements are introduced along with a simple example.
	© 2011 Springer-Verlag.},
  affiliation = {Institute for Software Technology, University Koblenz-Landau, Germany},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-79960282648&partnerID=40&md5=b735ad7a467219f9e3987a88303ef8c6}
}

@ARTICLE{Hoyos201141,
  author = {Hoyos, J.R.a , Preuveneers, D.b , García-Molina, J.J.a , Berbers,
	Y.b },
  title = {A DSL for context quality modeling in context-aware applications},
  journal = {Advances in Intelligent and Soft Computing},
  year = {2011},
  volume = {92},
  pages = {41-49},
  note = {cited By (since 1996) 0},
  abstract = {Developing reliable context-aware applications remains a big challenge,
	even after a decade of research in this area. Usually a lot of code
	is required to handle an application's correct behavior in a variety
	of different situations. Along with a growing amount of code, also
	increases the risk of programming errors that may lead to an undesired
	behavior in particular situations. In this paper we present a domain
	specific language (DSL) for developing context-aware applications.
	It allows creating context quality models which are transformed into
	software artifacts of the final application. This code generation
	saves time and effort, and helps to ensure an appropriate autonomic
	behavior at runtime in inherently uncertain situations. © 2011 Springer-Verlag
	Berlin Heidelberg.},
  affiliation = {Departamento de Informática y Sistemas, Universidad de Murcia, 30100
	Murcia, Spain; Department of Computer Science, Katholieke Universiteit
	Leuven, Celestijnenlaan 200A, B-3001 Heverlee, Belgium},
  author_keywords = {Context Quality; Context-Aware; Domain Specific Language; MDD; Quality},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-80053038718&partnerID=40&md5=3bba995fb850a1f39c62818433d0b07e}
}

@CONFERENCE{Hrnčič2011919,
  author = {Hrnčič, D., Mernik, M.},
  title = {Memetic grammatical inference approach for DSL embedding},
  year = {2011},
  pages = {919-924},
  note = {cited By (since 1996) 0},
  abstract = {Domain-specific languages (DSLs) are often designed by domain experts
	who have no knowledge about the syntax and semantics of programming
	languages. However, they are able to write sample programs to accomplish
	their goals and illustrate the features of their language. Grammatical
	inference is a technique for inferring a context-free grammar (CFG)
	from a set of positive (and negative) samples. This paper presents
	an improved memetic algorithm for grammatical inference that may
	assist domain experts and software language engineers in developing
	DSLs by automatically producing a grammar which describes a set of
	sample DSL programs. Our approach uses local search technique with
	improved generalization step and mutation operator. Negative samples
	are also introduced to overcome overgeneralization problem. The algorithm
	was tested on several DSLs and a case study of embedding a DSL is
	presented. © 2011 MIPRO.},
  affiliation = {University of Maribor, Faculty of Electrical Engineering and Computer
	Science, Maribor, Slovenia},
  art_number = {5967187},
  document_type = {Conference Paper},
  journal = {MIPRO 2011 - 34th International Convention on Information and Communication
	Technology, Electronics and Microelectronics - Proceedings},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-80052285504&partnerID=40&md5=7545dd64c4371597354ce13b764fca34}
}

@CONFERENCE{Hu2010383,
  author = {Hu, C., Zhang, R.S., Wei, T.M., Wei, R.P., Li, S.P., Cheng, Y.},
  title = {Implementing the compiler of UDLC},
  year = {2010},
  pages = {383-387},
  note = {cited By (since 1996) 0},
  abstract = {The increasing complexity of chemical problems often requiring multiple
	chemical software work together to complete. Most chemical software
	uses different script languages to describe jobs, chemists have to
	consume lots of time to learn them before work. Unified Job-Description
	Language on Chemical Grid (UDLC) is designed to solve the problem.
	It is a domain specific-language (DSL), aims at reducing the cost
	of chemical research substantially by providing a general-purpose
	chemical job description language standard on grid. Using UDLC to
	describe a job is simple and can be translate to other chemical software
	script automatically by computer. Many heterogeneous chemical resources
	integrated in the grid can be directly invoked using UDLC. In this
	article, we focus on the three main parts in implementing the compiler
	of UDLC. Firstly, use ANTLR to build Abstract Syntax tree (AST) for
	UDLC. The AST is an intermediate form not only records the content
	of the UDLC input, but also records the structure of it. With the
	help of AST, we can get the chemical information out conveniently.
	Secondly, traverse the AST for Semantic processing. The major task
	of this part is to map the AST into chemical markup language (CML)
	file and produce jobs written by specified chemical script languages.
	Lastly, generate the target code. In this part, we insert the jobs
	into flow control sentences to make the target JAVA code which will
	be executed in the dynamic runtime we built. © 2010 IEEE.},
  affiliation = {School of Information Science and Engineering, Engineering Research
	Center of Open Source Software and Real-Time Systems, Lanzhou University,
	Lanzhou, 730000, China},
  art_number = {5662719},
  author_keywords = {ANTLR; AST; Chemical Grid; DSL; UDLC},
  document_type = {Conference Paper},
  journal = {Proceedings - 9th International Conference on Grid and Cloud Computing,
	GCC 2010},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-79960416980&partnerID=40&md5=6cfa2789e1bfa08b8afec237d92092f8}
}

@CONFERENCE{Hu2010,
  author = {Hu, H., Yan, G.},
  title = {Research on DSL-based composition language in service-oriented architecture},
  year = {2010},
  volume = {14},
  pages = {V14357-V14360},
  note = {cited By (since 1996) 0},
  abstract = {Enterprise Service Bus is the request and convergence point of all
	the services for the large-scale distributed applications. How to
	compose the service in the dynamic and open network environment is
	a difficult problem. This paper proposes a service-oriented DSL composition
	language, which provides Web service semantic description of the
	composition process. The language uses top-down composition approach
	and considers the matching of heterogeneous messages. It can be properly
	resolved the composition process granularity control and heterogeneous
	messages matching. It has some application value for loosely coupled,
	cross-platform, heterogeneous environments composition and integration
	of Web service such as e-commerce, e-government, and workflow based
	on Web services and so on. © 2010 IEEE.},
  affiliation = {Department of Computer Science, North China Electric Power University,
	Beijing, China},
  art_number = {5622272},
  author_keywords = {Composition engine; Domain-specific language; Enterprise service bus;
	Service-oriented architecture},
  document_type = {Conference Paper},
  journal = {ICCASM 2010 - 2010 International Conference on Computer Application
	and System Modeling, Proceedings},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-78649537466&partnerID=40&md5=89ed1c831ea1492f0992f28cba9a8e45}
}

@CONFERENCE{Huang2005165,
  author = {Huang, M.-J., Katayama, T.},
  title = {Steering model-driven development of enterprise information system
	through responsibilities},
  year = {2005},
  pages = {165-170},
  note = {cited By (since 1996) 0},
  abstract = {OMG proposes the MDA that promotes the ideas of modeling in UML and
	transforming UML models to code. But UML is not universal for every
	domain and the direct translation approach of the MDA is not adequate.
	In this paper, we introduce REST, an idea of using responsibilities
	as contextual information to instruct machines to generate software
	systems. First, we give an overview of RESTDA - a software development
	architecture for business based on the concept of REST. Then we describe
	a domain-specific language Business Models. It helps developers to
	describe a business from a documentprocessing perspective. We also
	introduce a rule-based validation of consistency within Business
	Models. Finally, we describe the transformation mechanism of RESTDA.
	Our approach provides machines higher intelligence to generate source
	code for different contexts.},
  affiliation = {School of Information Science, Japan Advanced Institute of Science
	and Technology, 1-1 Asahidai, Nomi-shi, Ishikawa, Japan},
  document_type = {Conference Paper},
  journal = {Proceedings of the Joint Workshop on Web Services and Model-Driven
	Enterprise Information Services, WSMDEIS 2005, in Conjunction with
	ICEIS 2005},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-78651292631&partnerID=40&md5=db8080d3013c872f8a16aad33714ac13}
}

@CONFERENCE{Huang2006865,
  author = {Huang, S.S., Smaragdakis, Y.},
  title = {Easy language extension with meta-AspectJ},
  year = {2006},
  volume = {2006},
  pages = {865-868},
  note = {cited By (since 1996) 6},
  abstract = {Domain-specific languages hold the potential of automating the software
	development process. Nevertheless, the adoption of a domain-specific
	language is hindered by the difficulty of transitioning to different
	language syntax and employing a separate translator in the software
	build process. We present a methodology that simplifies the development
	and deployment of small language extensions, in the context of Java.
	The main language design principle is that of language extension
	through unobtrusive annotations. The main language implementation
	idea is to express the language as a generator of customized AspectJ
	aspects, using our Meta-Aspect J tool. The advantages of the approach
	are twofold. First, the tool integrates into an existing software
	application much as a regular API or library, instead of as a language
	extension. This means that the programmer can remove the language
	extension at any point and choose to implement the required functionality
	by hand without needing to rewrite the client code. Second, a mature
	language implementation is easy to achieve with little effort since
	AspectJ takes care of the low-level issues of interfacing with the
	base Java language*.},
  affiliation = {College of Computing, Georgia Institute of Technology, Atlanta, GA
	30332, United States},
  author_keywords = {Domain-specific languages; Language extensions},
  document_type = {Conference Paper},
  journal = {Proceedings - International Conference on Software Engineering},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-34247139799&partnerID=40&md5=90e360406e4ce9825c847ceae771f515}
}

@ARTICLE{Huang2008,
  author = {Huang, S.S.a c , Zook, D.a c , Smaragdakis, Y.b d },
  title = {Domain-specific languages and program generation with meta-AspectJ},
  journal = {ACM Transactions on Software Engineering and Methodology},
  year = {2008},
  volume = {18},
  number = {2},
  note = {cited By (since 1996) 2},
  abstract = {Meta-AspectJ (MAJ) is a language for generating AspectJ programs using
	code templates. MAJ itself is an extension of Java, so users can
	interleave arbitrary Java code with AspectJ code templates. MAJ is
	a structured metaprogramming tool: a well-typed generator implies
	a syntactically correct generated program. MAJ promotes a methodology
	that combines aspect-oriented and generative programming. A valuable
	application is in implementing small domain-specific language extensions
	as generators using unobtrusive annotations for syntax extension
	and AspectJ as a back-end. The advantages of this approach are twofold.
	First, the generator integrates into an existing software application
	much as a regular API or library, instead of as a language extension.
	Second, a mature language implementation is easy to achieve with
	little effort since AspectJ takes care of the low-level issues of
	interfacing with the base Java language. In addition to its practical
	value, MAJ offers valuable insights to metaprogramming tool designers.
	It is a mature metaprogramming tool for AspectJ (and, by extension,
	Java): a lot of emphasis has been placed on context-sensitive parsing
	and error reporting. As a result, MAJ minimizes the number of metaprogramming
	(quote/unquote) operators and uses type inference to reduce the need
	to remember type names for syntactic entities. © 2008 ACM.},
  affiliation = {Georgia Institute of Technology, Atlanta, United States; University
	of Oregon; College of Computing, Georgia Institute of Technology,
	Atlanta, GA, United States; Department of Computer Science, University
	of Massachusetts, Amherst, 140 Governors Drive, Amherst, MA 01003,
	United States},
  art_number = {6},
  author_keywords = {Domain-specific languages; Language extensions; Metaprogramming; Program
	synthesis; Program transformation; Program verification},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-56149111605&partnerID=40&md5=8a8b09c85d50d447c5e141d09cb64d2d}
}

@ARTICLE{Huang2011376,
  author = {Huang, S.S.a , Zook, D.a , Smaragdakis, Y.b },
  title = {Statically safe program generation with SafeGen},
  journal = {Science of Computer Programming},
  year = {2011},
  volume = {76},
  pages = {376-391},
  number = {5},
  note = {cited By (since 1996) 0},
  abstract = {SafeGen is a meta-programming language for writing statically safe
	generators of Java programs. If a program generator written in SafeGen
	passes the checks of the SafeGen compiler, then the generator will
	only generate well-formed Java programs, for any generator input.
	In other words, statically checking the generator guarantees the
	correctness of any generated program, with respect to static checks
	commonly performed by a conventional compiler (including type safety,
	existence of a superclass, etc.). To achieve this guarantee, SafeGen
	supports only language primitives for reflection over an existing
	well-formed Java program, primitives for creating program fragments,
	and a restricted set of constructs for iteration, conditional actions,
	and name generation. SafeGen's static checking algorithm is a combination
	of traditional type checking for Java, and a series of calls to a
	theorem prover to check the validity of first-order logical sentences,
	constructed to represent well-formedness properties of the generated
	program under all inputs. The approach has worked quite well in our
	tests, providing proofs for correct generators or pointing out interesting
	bugs. © 2008 Elsevier B.V. All rights reserved.},
  affiliation = {College of Computing, Georgia Institute of Technology, Atlanta, GA,
	30332, United States; Department of Computer Science, University
	of Massachusetts, Amherst, MA 01003, United States},
  author_keywords = {Domain-specific languages; Language extensions; Meta-programming},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-79952616922&partnerID=40&md5=f387e8240cfc29f4e1ab8561d297f898}
}

@CONFERENCE{Hudak1998134,
  author = {Hudak, Paul},
  title = {Modular domain specific languages and tools},
  year = {1998},
  pages = {134-142},
  note = {cited By (since 1996) 67},
  abstract = {A domain specific language (DSL) allows one to develop software for
	a particular application domain quickly and effectively, yielding
	programs that are easy to understand, reason about, and maintain.
	On the other hand, there may be a significant overhead in creating
	the infrastructure needed to support a DSL. To solve this problem,
	a methodology is described for building domain specific embedded
	languages (DSELs), in which a DSL is designed within an existing,
	higher-order and typed, programming language such as Haskell or ML.
	In addition, techniques are described for building modular interpreters
	and tools for DSELs. The resulting methodology facilitates reuse
	of syntax, semantics, implementation code, software tools, as well
	as look-and-feel.},
  affiliation = {Yale Univ, New Haven, United States},
  document_type = {Conference Paper},
  journal = {International Conference on Software Reuse},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-0031676175&partnerID=40&md5=5308399fa618391c4cab25d79aa640a4}
}

@ARTICLE{Hudak2004159,
  author = {Hudak, P., Courtney, A., Nilsson, H., Peterson, J.},
  title = {Arrows, robots, and functional reactive programming},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2004},
  volume = {2638},
  pages = {159-187},
  note = {cited By (since 1996) 0},
  abstract = {Functional reactive programming, or FRP, is a paradigm for programming
	hybrid systems - i.e., systems containing a combination of both continuous
	and discrete components - in a high-level, declarative way. The key
	ideas in FRP are its notions of continuous, time-varying values,
	and time-ordered sequences of discrete events. Yampa is an instantiation
	of FRP as a domain-specific language embedded in Haskell. This paper
	describes Yampa in detail, and shows how it can be used to program
	a particular kind of hybrid system: a mobile robot. Because performance
	is critical in robotic programming, Yampa uses arrows (a generalization
	of monads) to create a disciplined style of programming with time-varying
	values that helps ensure that common kinds of time- and space-leaks
	do not occur. No previous experience with robots is expected of the
	reader, although a basic understanding of physics and calculus is
	assumed. No knowledge of arrows is required either, although we assume
	a good working knowledge of Haskell. © Springer-Verlag Berlin Heidelberg
	2003.},
  affiliation = {Department of Computer Science, Yale University},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-35248816084&partnerID=40&md5=ec87c98ddae4ccc4db7f854343795ac1}
}

@CONFERENCE{Hudson2011260,
  author = {Hudson, M., Sprinkle, J.},
  title = {Simplification of semantically-rich model transformations through
	generated transformation blocks},
  year = {2011},
  pages = {260-268},
  note = {cited By (since 1996) 0},
  abstract = {This paper demonstrates a novel concept for the simplification of
	model transformations in which composite or complex objects are inserted
	into an existing model through a well-defined interface. The technique
	utilizes a model transformation from the domain of the modeling language
	into the domain of model transformation languages. The user specifies
	these semantically rich blocks using the original domain-specific
	modeling language. Then, a transformation generates the necessary
	model transformation graph to create an instance of the semantically
	rich, user-defined pattern. Users insert these generated patterns
	into their customized transformations. The approach is helpful for
	endogenous transformations in which existing objects may be refactored.
	It will also serve as a teaching tool for users who are unfamiliar
	with model transformations: specifically how to represent a newly-created
	model in the transformation domain. Finally, the approach is designed
	to reduce specification errors of model transformations in which
	new (semantically rich) blocks are inserted at key points, as the
	correctness of the semantically rich blocks is guaranteed, based
	on their construction in the original domain. © 2011 IEEE.},
  affiliation = {Electrical and Computer Engineering, University of Arizona, Tucson,
	AZ, United States},
  art_number = {5934827},
  author_keywords = {Domain-specific modeling; Generative transformations; Model transformation;
	Transformation simplification},
  document_type = {Conference Paper},
  journal = {Proceedings - 18th IEEE International Conference and Workshops on
	Engineering of Computer-Based Systems, ECBS 2011},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-80052011896&partnerID=40&md5=14dfe1a56c960c09c52d5995b9309b22}
}

@CONFERENCE{Huh2009111,
  author = {Huh, J.a , Grundy, J.a b , Hosking, J.a , Liu, K.a , Amor, R.a },
  title = {Integrated data mapping for a software meta-tool},
  year = {2009},
  pages = {111-120},
  note = {cited By (since 1996) 0},
  abstract = {Complex data mapping tasks often arise in software engineering, particularly
	in code generation and model transformation. We describe Marama Torua,
	a tool supporting high-level specification and implementation of
	complex data mappings. Marama Torua is embedded in, and provides
	model transformation support for, our Eclipse-based Marama domain-specific
	language meta-tool. Developers can quickly develop stand alone data
	mappers and model translation and code import-export components for
	their tools. Complex data schema and mapping relationships are represented
	in multiple, high-level notational forms and users are provided semiautomated
	mapping assistance for large models. MaramaTorua is a set of Eclipse
	plug-ins allowing close integration with other tools such as schema
	browsers, and with the Marama meta-tool itself. © 2009 IEEE.},
  affiliation = {Department of Computer Science; Department of Electrical and Computer
	Engineering, University of Auckland, Private Bag 92019, Auckland
	1142, New Zealand},
  art_number = {5076633},
  document_type = {Conference Paper},
  journal = {Proceedings of the Australian Software Engineering Conference, ASWEC},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-70349483761&partnerID=40&md5=f3ffceac94c76b4cf917fe6ff6734f0b}
}

@CONFERENCE{Humm2010279,
  author = {Humm, B.G.a , Engelschall, R.S.b },
  title = {Language-Oriented Programming VIA DSL stacking},
  year = {2010},
  volume = {2},
  pages = {279-287},
  note = {cited By (since 1996) 0},
  abstract = {According to the paradigm of Language-Oriented Programming, an application
	for a problem should be implemented in the most appropriate domain-specific
	language (DSL). This paper introduces DSL stacking, an efficient
	method for implementing Language-Oriented Programming where DSLs
	and general-purpose languages are incrementally developed on top
	of a base language. This is demonstrated with components of a business
	information system that are implemented in different DSLs for Semantic
	Web technology in Lisp.},
  affiliation = {Darmstadt University of Applied Sciences, Department of Computer Science,
	Darmstadt, Germany; Capgemini Sd and M Research, Munich, Germany},
  author_keywords = {Business information systems; Domain-specific languages; Extensible
	programming languages; Language-oriented programming; Lisp; Meta
	programming; Semantic web},
  document_type = {Conference Paper},
  journal = {ICSOFT 2010 - Proceedings of the 5th International Conference on
	Software and Data Technologies},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-78751471523&partnerID=40&md5=905c29f15a03fd821d7ffad035b5c399}
}

@ARTICLE{Hummer2011277,
  author = {Hummer, W., Leitner, P., Dustdar, S.},
  title = {SEPL - A domain-specific language and execution environment for protocols
	of stateful Web services},
  journal = {Distributed and Parallel Databases},
  year = {2011},
  volume = {29},
  pages = {277-307},
  number = {4},
  note = {cited By (since 1996) 0},
  abstract = {In order to interact with stateful Web services, clients need to obtain
	information about the intra-service protocol, which contains valid
	operation sequences and the expected input-output transformation
	across invocations. While the community has widely agreed on WSDL
	as the standard for functional service description (the "static"
	service interface), there is still an evident lack of languages to
	describe the dynamic, behavioral interface of services. In this paper
	we introduce SEPL (SErvice Protocol Language), a domain-specific
	language (DSL) for defining executable intraservice protocols. Notable
	features of the DSL include support for WS-Addressing and simple
	creation of new Web service instances, synchronous and asynchronous
	service invocation facilities and easy access to WSRF-style service
	resource properties. Service providers use SEPL to define the procedure
	that clients must adhere to in order to achieve a certain higher-level
	functionality. Clients use the combined information of the SEPL document
	and the WSDL definitions to execute an intra-service protocol. We
	provide a graphical representation of SEPL the form of UML Activity
	Diagrams, and tools to generate executable code from these models.
	We further present a solution to host and execute SEPL protocols
	in a server application based on Web services technology. © Springer
	Science+Business Media, LLC 2011.},
  affiliation = {Distributed Systems Group, Vienna University of Technology, Argentinierstrasse
	8/184-1, 1040 Vienna, Austria},
  author_keywords = {Domain-specific language; Intra-service protocol; SEPL; SErvice Protocol
	Language; Stateful Web services; Web services},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-80052970245&partnerID=40&md5=56b365855dde192304fd2a86ba79672e}
}

@CONFERENCE{Hummer201121,
  author = {Hummer, W.a , Gaubatz, P.b , Strembeck, M.c , Zdun, U.b , Dustdar,
	S.a },
  title = {An integrated approach for identity and access management in a SOA
	context},
  year = {2011},
  pages = {21-30},
  note = {cited By (since 1996) 0},
  abstract = {In this paper, we present an approach for identity and access management
	(IAM) in the context of (cross-organizational) serviceoriented architectures
	(SOA). In particular, we defined a domainspecific language (DSL)
	for role-based access control (RBAC) that allows for the definition
	of IAM policies for SOAs. For the application in a SOA context, our
	DSL environment automatically produces WS-BPEL (Business Process
	Execution Language for Web services) specifications from the RBAC
	models defined in our DSL. We use the WS-BPEL extension mechanism
	to annotate parts of the process definition with directives concerning
	the IAM policies. At deployment time, the WS-BPEL process is instrumented
	with special activities which are executed at runtime to ensure its
	compliance to the IAM policies. The algorithm that produces extended
	WS-BPEL specifications from DSL models is described in detail. Thereby,
	policies defined via our DSL are automatically mapped to the implementation
	level of a SOA-based business process. This way, the DSL decouples
	domain experts' concerns from the technical details of IAM policy
	specification and enforcement. Our approach thus enables (non-technical)
	domain experts, such as physicians or hospital clerks, to participate
	in defining and maintaining IAM policies in a SOA context. Based
	on a prototype implementation we also discuss several performance
	aspects of our approach. © 2011 ACM.},
  affiliation = {Distributed Systems Group, Information Systems Institute, Vienna University
	of Technology, Austria; Software Architecture Group, Faculty of Computer
	Science, University of Vienna, Austria; Information Systems Institute,
	Vienna University of Economics and Business, Austria},
  author_keywords = {Identity and access management; SAML; SOAP; WS-BPEL; WSSecurity},
  document_type = {Conference Paper},
  journal = {Proceedings of ACM Symposium on Access Control Models and Technologies,
	SACMAT},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-79960160217&partnerID=40&md5=5ad888e0ed474470d896ca79b1c81d49}
}

@CONFERENCE{Hunt2009,
  author = {Hunt, J.M.},
  title = {A practical state machine project},
  year = {2009},
  note = {cited By (since 1996) 0},
  abstract = {A widely noted problem in teaching undergraduate theory courses is
	a lack of student interest related to the perception of theory as
	being irrelevant and impractical. To counter this we added a programming
	project that produces working code for a vending machine, an obviously
	practical problem. The project is based on state machine automata
	implemented with the SEI's PACC starter kit, which directly maps
	state machine models, represented in a domain specific language,
	into executable code. This allows the student to see a direct and
	obvious mapping between a state machine based design and a functioning
	product. ©2009 ACM.},
  affiliation = {Covenant College, 14049 Scenic Highway, Lookout Mountain, GA, United
	States},
  art_number = {1566500},
  author_keywords = {Automata; Curriculum; Education; Pedagogy; State machine},
  document_type = {Conference Paper},
  journal = {Proceedings of the 47th Annual Southeast Regional Conference, ACM-SE
	47},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-70449707908&partnerID=40&md5=760a2a5a05d10be90ea9aea225edb9fc}
}

@CONFERENCE{HuqKhandkar2010269,
  author = {Huq Khandkar, S., Maurer, F.},
  title = {A language to define multi-touch interactions},
  year = {2010},
  pages = {269-270},
  note = {cited By (since 1996) 0},
  abstract = {Touch has become a common interface for human computer interaction.
	From portable hand held devices like smart phones to tabletops, large
	displays and even devices that project on arbitrary surfaces support
	touch interface. However, at the end, it is the applications that
	bring meaning for these technologies to people. Incorporating a touch
	interface in application requires translating meaningful touches
	into system recognizable events. This process often involves complex
	implementations that are sometimes hard to fine tune. Due to the
	lack of higher-level frameworks, developers often end up writing
	code from scratch to implement touch interactions in their application.
	To address this, we present a domain-specific language to define
	multi-touch interaction that hides the low level implementation complexities
	from application developers. This allows them to focus on designing
	touch interactions that are natural and meaningful to the application
	context without worrying about implementation complexities. © 2010
	ACM.},
  affiliation = {Department of Computer Science, University of Calgary, Canada},
  author_keywords = {Domain-specific language; Gesture},
  document_type = {Conference Paper},
  journal = {ACM International Conference on Interactive Tabletops and Surfaces,
	ITS 2010},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-79952402160&partnerID=40&md5=48a8130a280304ee52f7c3f77efef3e7}
}

@CONFERENCE{Hurnaus20102544,
  author = {Hurnaus, D.a , Prähofer, H.b },
  title = {Programming assistance based on contracts and modular verification
	in the automation domain},
  year = {2010},
  pages = {2544-2551},
  note = {cited By (since 1996) 1},
  abstract = {In industrial automation, control software often has to get changed
	and adapted by domain experts and end users who have no or only limited
	software development expertise. This results in high demands on programming
	environments with respect to supporting, guiding, and supervising
	the programming tasks. In this paper we present an approach based
	on model checking and artificial intelligence techniques to guide
	domain experts in building control software which is guaranteed to
	obey specified contracts and constraints. The work is based on Monaco
	which is a domain-specific language for programming automation solutions.
	As Monaco employs a hierarchical component approach, the verification
	is done hierarchically where an upper component is verified against
	the contracts of its subcomponents. The verification approach is
	leveraged in different programming support systems which give immediate
	feedback about valid and invalid programs in an integrated development
	environment. © 2010 ACM.},
  affiliation = {Christian Doppler Laboratory for Automated Software Engineering, Johannes
	Kepler University, 4040 Linz, Austria; Institute for System Software,
	Johannes Kepler University, 4040 Linz, Austria},
  author_keywords = {automation software; component-based systems; domain-specific language;
	end-user programming},
  document_type = {Conference Paper},
  journal = {Proceedings of the ACM Symposium on Applied Computing},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-77954696796&partnerID=40&md5=00c779f6bbb67d61cfbbf81b1bb36afd}
}

@ARTICLE{Hutchesson2010389,
  author = {Hutchesson, S., McDermid, J.},
  title = {Development of high-integrity software product lines using model
	transformation},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2010},
  volume = {6351 LNCS},
  pages = {389-401},
  note = {cited By (since 1996) 0},
  abstract = {Academic and commercial approaches to software product line development
	have concentrated on the rapid instantiation of source code assets
	to minimise product time to market. Generative programming and model-based
	software engineering approaches have been suggested as effective
	ways of achieving this. However, for high-integrity software systems
	the instantiated product source code has to be accompanied by development
	process assets that demonstrate and support the product assurance
	arguments. This paper describes an approach to the model-based development
	of software product lines that is specifically designed to address
	the needs of high-integrity software systems. The approach consists
	of a reference architecture model and component-based development
	style, supported by model transformations to instantiate the project-specific
	components and associated development assets. © 2010 Springer-Verlag
	Berlin Heidelberg.},
  author_keywords = {Decision Models; High Integrity; M2M; Reference Architectures; Safety
	Critical; Software Product Lines; SPARK; UML},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-77956576602&partnerID=40&md5=2eb96d7edbb2a80c5495ef734a09720b}
}

@CONFERENCE{Hutchesson201155,
  author = {Hutchesson, S.a , McDermid, J.b },
  title = {Towards cost-effective high-assurance software product lines: The
	need for property-preserving transformations},
  year = {2011},
  pages = {55-64},
  note = {cited By (since 1996) 0},
  abstract = {Generative programming and model transformation techniques are becoming
	widely used for the development of software components for product
	lines. The ability to develop components with identified common and
	variable parts, and rapidly instantiate product-specific versions
	is key to many software product line approaches. However if this
	approach is to be truly cost effective for high assurance applications,
	the instantiation process must be property-preserving, any verification
	evidence acquired on the product-line component must be demonstrably
	applicable to the instantiated component. In this paper we outline
	an approach that uses static analysis techniques and the SPARK language
	that can potentially demonstrate the correctness of model transformations.
	© 2011 IEEE.},
  affiliation = {University of York, Aero Engine Controls, Derby, United Kingdom; Department
	of Computer Science, University of York, York, United Kingdom},
  art_number = {6030046},
  author_keywords = {DO-178B/ED-12B; High Integrity; M2M; Safety Critical; Software Product
	Lines; SPARK; Static Analysis; UML; Verification},
  document_type = {Conference Paper},
  journal = {Proceedings - 15th International Software Product Line Conference,
	SPLC 2011},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-80054074251&partnerID=40&md5=0d669b600f5191839638b32b85cfe8ab}
}

@CONFERENCE{Im2008180,
  author = {Im, K., Im, T., McGregor, J.D.},
  title = {Automating test case definition using a domain specific language},
  year = {2008},
  pages = {180-185},
  note = {cited By (since 1996) 0},
  abstract = {Effective test cases are critical to the success of a development
	effort but their creation requires large amounts of critical resources
	such as domain expertise. This study explores an approach to automating
	test case definition in the context of applying a model driven approach
	to the development of a software product line. In this study, test
	cases are automatically extracted from use cases, which are specified
	using a domain specific language (DSL). DSLs are easier for domain
	experts to use than formal specification languages and are more narrowly
	focused than natural languages making it easier to build tools. The
	task is further simplified by restricting the DSL to the scope of
	the software product line under development. The structure of the
	DSL and proven patterns of test design provide the clues necessary
	to be able to automatically extract the test cases. A chain of model-driven
	tools is used to automate the system test process, which begins with
	a use case model and ends with automatic execution of system tests.
	Copyright 2008 ACM.},
  affiliation = {School of Computing, Clemson University, Clemson, SC 29634, United
	States},
  art_number = {1593152},
  author_keywords = {Domain specific language; Ontology; Software product line; Software
	testing},
  document_type = {Conference Paper},
  journal = {Proceedings of the 46th Annual Southeast Regional Conference on XX,
	ACM-SE 46},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-70450054933&partnerID=40&md5=83baa57b6e3e35e3cfc5232f596c18a9}
}

@CONFERENCE{Irazábal2011124,
  author = {Irazábal, J., Pons, C.},
  title = {Supporting modularization in textual DSL development},
  year = {2011},
  pages = {124-130},
  note = {cited By (since 1996) 0},
  abstract = {A domain-specific language DSL provides a notation tailored towards
	an application domain. The closer the language is to their target
	domain, the more useful the language is for developers. But this
	increment in the level of specificity raises the issue of duplication
	of concepts among different languages, and leads to the definition
	of a family of languages. Despite the advance in tool support for
	defining the abstract and concrete syntaxes of DSLs, developing a
	family of DSLs still requires a significant amount of duplicated
	effort. In this work we present an infrastructure for implementing
	families of textual DSLs. We introduce a technique based on XText
	that reduces the effort required to create editors and interpreters
	by enabling the modularization of the common features and the smooth
	specification of variability between the DSLs. © 2010 IEEE.},
  affiliation = {Facultad de Informática, Universidad Nacional de La Plata, CONICET,
	Consejo Nacional de Investigaciones Científicas Y Técnicas, Buenos
	Aires, Argentina},
  art_number = {5750504},
  author_keywords = {Domain specific language; DSL},
  document_type = {Conference Paper},
  journal = {Proceedings - International Conference of the Chilean Computer Science
	Society, SCCC},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-79955931980&partnerID=40&md5=85d162d25fd61706e70ae91c46eafd6b}
}

@CONFERENCE{Jablonski2009109,
  author = {Jablonski, S., Volz, B., Dornstauder, S.},
  title = {On the implementation of tools for domain specific process modelling},
  year = {2009},
  pages = {109-120},
  note = {cited By (since 1996) 0},
  abstract = {Business process modelling becomes more productive when modellers
	can use process modelling languages which optimally fit to the application
	domain. Domain specific modelling is the discipline that deals with
	the proliferation of domain specific modelling languages. The general
	tenor is that the more a modelling language fits to an application
	domain, the more efficient and effective an application can be modelled.
	In this paper we address the issue of providing domain specific languages
	in a systematic and structural way without having to implement modelling
	tools for each domain specific language separately. Our approach
	is based on a two dimensional meta modelling stack.},
  affiliation = {University of Bayreuth, Bayreuth, Germany},
  document_type = {Conference Paper},
  journal = {ENASE 2009 - 4th International Conference on Evaluation of Novel
	Approaches to Software Engineering, Proceedings},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-74549225726&partnerID=40&md5=a0fcd8316075a458ac31c2d1b3ad222d}
}

@CONFERENCE{Jablonski20081011,
  author = {Jablonski, S., Volz, B., Dornstauder, S.},
  title = {A meta modeling framework for domain specific process management},
  year = {2008},
  pages = {1011-1016},
  note = {cited By (since 1996) 0},
  abstract = {Process Management has become an acknowledged technology for application
	integration. However, different applications leverage from different
	process modeling capabilities. Thus, domain specific process management
	becomes more and more relevant. In this paper we present our solution
	for an abstract process modeling method and language based on an
	extensible meta modeling framework which has two main advantages
	compared to standard MDA tools. First, we can easily implement modeling
	patterns (here: powertypes and type/usage concept). Second, we can
	use more than two meta layers which results in a more clear structure
	and in higher flexibility (here a separation between general process
	modeling principles and domain specific languages that can better
	express domain specific semantics). © 2008 IEEE.},
  affiliation = {Department of Applied Computer Science IV, University of Bayreuth,
	Germany},
  art_number = {4591712},
  document_type = {Conference Paper},
  journal = {Proceedings - International Computer Software and Applications Conference},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-51949086842&partnerID=40&md5=0e4411bee7187cc0eca012d29d0b55e3}
}

@ARTICLE{Jackson2009451,
  author = {Jackson, E.a , Sztipanovits, J.b },
  title = {Formalizing the structural semantics of domain-specific modeling
	languages},
  journal = {Software and Systems Modeling},
  year = {2009},
  volume = {8},
  pages = {451-478},
  number = {4},
  note = {cited By (since 1996) 5},
  abstract = {Model-based approaches to system design are now widespread and successful.
	These approaches make extensive use of model structure to describe
	systems using domain-specific abstractions, to specify and implement
	model transformations, and to analyze structural properties of models.
	In spite of its general importance the structural semantics of modeling
	languages are not well-understood. In this paper we develop the formal
	foundations for the structural semantics of domain-specific modeling
	languages (DSML), including the mechanisms by which metamodels specify
	the structural semantics of DSMLs. Additionally, we show how our
	formalization can complement existing tools, and how it yields algorithms
	for the analysis of DSMLs and model transformations. © Springer-Verlag
	2008.},
  affiliation = {Foundations of Software Engineering, Microsoft Research, Redmond,
	WA, United States; Institute for Software Integrated Systems, Vanderbilt
	University, Nashville, TN, United States},
  author_keywords = {Domain-specific modeling languages; Formal logic; Horn logic; Metamodeling;
	Model-based Design; Structural semantics},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-69249221534&partnerID=40&md5=c3f642b7a005703212ea82ff551f2749}
}

@CONFERENCE{Jackson200653,
  author = {Jackson, E.K., Sztipanovits, J.},
  title = {Towards a formal foundation for domain specific modeling languages},
  year = {2006},
  pages = {53-62},
  note = {cited By (since 1996) 6},
  abstract = {Embedded system design is inherently domain specific and typically
	model driven.As a result, design methodologies like OMG's model driven
	architecture (MDA)and model integrated computing (MIC)evolved to
	support domain specific modeling language(DSMLs). The success of
	the DSML approach has encouraged work on the heterogeneous composition
	of DSMLs, model transformations between DSMLs, approximations of
	formal properties within DSMLs, and reuse of DSML semantics. However,
	in the effort to produce a mature design approach that can handle
	both the structural and behavioral semantics of embedded system design,many
	foundational issues concerning DSMLs have been overlooked. In this
	paper we present a formal foundation for DSMLs and for their construction
	within metamodeling frameworks. This foundation allows us to algorithmically
	decide if two DSMLs or metamodels are equivalent, if model transformations
	preserve properties, and if metamodeling frameworks have metametamodels.
	These results are key to building correct embedded systems with DSMLs.
	Copyright 2006 ACM.},
  affiliation = {Institute for Software Integrated Systems, Vanderbilt University,
	Station B, Nashville, TN 37235},
  author_keywords = {Embedded systems; Formal logic; Horn logic; Metamodeling; Semantics},
  document_type = {Conference Paper},
  journal = {IEEE International Conference on Embedded Software, EMSOFT 2006},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-34547463624&partnerID=40&md5=dfa9decf922270c76e383e8f1c453276}
}

@ARTICLE{Jackson201044,
  author = {Jackson, E.K.a , Schulte, W.a , Balasubramanian, D.b , Karsai, G.b
	},
  title = {Reusing model transformations while preserving properties},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2010},
  volume = {6013 LNCS},
  pages = {44-58},
  note = {cited By (since 1996) 0},
  abstract = {Model transformations are indispensable to model-based development
	(MBD) where they act as translators between domain-specific languages
	(DSLs). As a result, transformations must be verified to ensure they
	behave as desired. Simultaneously, transformations may be reused
	as requirements evolve. In this paper we present novel algorithms
	to determine if a reused transformation preserves the same properties
	as the original, without expensive re-verification. We define a type
	of behavioral equivalence, called lifting equivalence, relating an
	original transformation to its reused version. A reused transformation
	that is equivalent to the original will preserve all compatible universally
	quantified properties. We describe efficient algorithms for verifying
	lifting equivalence, which we have implemented in our FORMULA [1,
	2] framework. © 2010 Springer-Verlag.},
  affiliation = {Microsoft Research, United States; Vanderbilt University, United States},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-77951286977&partnerID=40&md5=622ebebd51cc3e1045775b205242c160}
}

@CONFERENCE{Jacob201155,
  author = {Jacob, F.},
  title = {CUDACL+: A framework for GPU programs},
  year = {2011},
  pages = {55-57},
  note = {cited By (since 1996) 0},
  abstract = {Graphical Processing Units (GPUs) provide an excellent execution platform
	for several classes of computation intensive problems. Even though
	there are vendor-specific Application Programming Interfaces (APIs)
	for GPU programming, they all share a high-level of similarity. In
	this extended abstract, we introduce a transformation frame-work
	through which sequential programs from legacy systems can be executed
	in any of the two common GPU programming APIs: OpenCL and CUDA. Our
	study shows that blocks of independent sequential code can be converted
	automatically to an equivalent representation in OpenCL and CUDA.
	In some cases, the transformation requires additional information
	from the programmer regarding the specific computation and the GPU
	configuration. Our approach provides the design decisions for a Domain-Specific
	Language (DSL) to specify the additional information.},
  affiliation = {Department of Computer Science, University of Alabama, United States},
  author_keywords = {CUDA; CUDACL; OpenCL},
  document_type = {Conference Paper},
  journal = {SPLASH'11 Compilation - Proceedings of OOPSLA'11, Onward! 2011, GPCE'11,
	DLS'11, and SPLASH'11 Companion},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-81355139720&partnerID=40&md5=20076d5691ca5ae27e4a13da607967f4}
}

@CONFERENCE{Jacobi2010479,
  author = {Jacobi, S.a , Hahn, C.b , Raber, D.c },
  title = {Integration of multiagent systems and service oriented architectures
	in the steel industry},
  year = {2010},
  volume = {2},
  pages = {479-482},
  note = {cited By (since 1996) 0},
  abstract = {In the course of globalization competitive pressure is rising in most
	industrial sectors. High quality products are basic prerequisites
	for companies of high wage countries to be present on the global
	market. Improved adherence to delivery date, increased flexibility
	despite to decreased production costs are some examples of the challenges
	to be managed just to keep current positions. In general, these requirements
	are mostly requirements on the processes-not on the actual products.
	Economic efficiency is not any longer just a property of products
	and quality, but more and more a property of processes. Thus, process
	capability is getting more important beside production capability.
	This paper shows how service-oriented architectures (SOA) and multi-agent
	systems (MAS) can be integrated using a model-driven approach. In
	fact, a model transformation from SoaML - a metamodel for SOA - to
	DSML4MAS - a domain-specific modeling language for MAS - is utilized
	for the integration. The relevance of this approach is proven by
	applying it to a real-world industry scenario. This includes modeling
	a segment of a production chain of Saarstahl AG - a global respected
	steel manufacturer. The presented approach helps to increase flexibility
	of mid and short term planning and scheduling along the chosen segment
	and thus improve processes. © 2010 IEEE.},
  affiliation = {Saarstahl AG, Hofstattstrasse 106, 66330 Völklingen, Germany; Saarstahl
	AG, DFKI GmbH, Hofstattstrasse 106, 66330 Völklingen, Germany; DFKI
	GmbH, Stuhlsatzenhausweg 3, 66123 Saarbrücken, Germany},
  art_number = {5614707},
  document_type = {Conference Paper},
  journal = {Proceedings - 2010 IEEE/WIC/ACM International Conference on Intelligent
	Agent Technology, IAT 2010},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-78649878237&partnerID=40&md5=47e6305c438d94b07b4787c946bddcae}
}

@CONFERENCE{Jaecksch2010117,
  author = {Jaecksch, B.a , Faerber, F.a , Lehner, W.b },
  title = {Cherry picking in database languages},
  year = {2010},
  pages = {117-122},
  note = {cited By (since 1996) 0},
  abstract = {To avoid expensive round-trips between the application layer and the
	database layer it is crucial that data-intensive processing and calculations
	happen close to where the data resides - ideally within the database
	engine. However, each application has its own domain and provides
	domain-specific languages (DSL) as a user interface to keep interactions
	confined within the well-known metaphors of the respective domain.
	Revealing the innards of the underlying data layer by forcing users
	to formulate problems in terms of a general database language is
	often not an option. To bridge that gap, we propose an approach to
	transform and directly compile a DSL into a general database execution
	plan using graph transformations. We identify the commonalities and
	mismatches between different models and show which parts can be cherry-picked
	for direct translation. Finally, we argue that graph transformations
	can be used in general to translate a DSL into an executable plan
	for a database. Copyright 2010 ACM.},
  affiliation = {SAP AG, Dietmar-Hopp-Allee 16, 69190 Walldorf, Germany; Technische
	Universität, Dresden Database Technology Group, 01062 Dresden, Germany},
  document_type = {Conference Paper},
  journal = {ACM International Conference Proceeding Series},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-78649968313&partnerID=40&md5=6938df5a89ff5ef32fc48a3b9d60ed5b}
}

@ARTICLE{Jakumeit2010263,
  author = {Jakumeit, E., Buchwald, S., Kroll, M.},
  title = {GrGen.NET: The expressive, convenient and fast graph rewrite system},
  journal = {International Journal on Software Tools for Technology Transfer},
  year = {2010},
  volume = {12},
  pages = {263-271},
  number = {3},
  note = {cited By (since 1996) 2},
  abstract = {GrGen. NET is a generative programming system for graph rewriting,
	transforming intuitive and expressive rewrite rule specifications
	into highly efficient. NET code. The user is supported by a convenient
	environment consisting of a graph viewer, an interactive shell with
	integrated debugging support, and an elegant domain-specific language
	for the combination of rewrite rules. After rapid prototyping with
	these tools, the resulting graph transformation programmes can be
	easily integrated into arbitrary. NET applications to serve as the
	algorithmic kernel. Expressiveness, convenience, and speed are exemplified
	by GrGen-solutions to the case studies AntWorld, Refactoring, and
	Conference Scheduling-besides others. © 2010 Springer-Verlag.},
  affiliation = {Institut für Programmstrukturen und Datenorganisation, Universität
	Karlsruhe, Karlsruhe, Germany},
  author_keywords = {Domain-specific language; General purpose graph transformation; Generative
	programming tool; Graph rewriting; Search-plan-driven graph pattern
	matching},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-77953957966&partnerID=40&md5=8da5a3c23a9ea875e7c6b8bbb0a0d2c3}
}

@CONFERENCE{Jansen2010,
  author = {Jansen, J.M.a , Plasmeijer, R.b , Koopman, P.b , Achten, P.b },
  title = {Embedding a web-based workflow management system in a functional
	language},
  year = {2010},
  note = {cited By (since 1996) 0},
  abstract = {Workflow management systems guide and monitor tasks performed by humans
	and computers. The workflow specifications are usually expressed
	in special purpose (graphical) formalisms. These formalisms impose
	severe restrictions on what can be expressed. Modern workflow management
	systems should handle intricate data dependencies, offer a webbased
	interface, and should adapt to dynamically changing situations, all
	based on a sound formalism. To address these challenges, we have
	developed the iTask system, which is a novel workflow management
	system. We entirely embed the iTask specification language in a modern
	general purpose functional language, and generate a complete workflow
	application. In this paper we report our experiences in developing
	the iTask system. It not only inherits state-of-the-art programming
	language concepts such as generic programming and a hybrid static/dynamic
	type system from the host language Clean, but also offers a number
	of novel concepts to generate complex, real-world, multi-user, web
	based workflow applications. © ACM 2010.},
  affiliation = {Faculty of Military Sciences, Netherlands Defence Academy, Den Helder,
	Netherlands; Institute for Computing and Information Sciences (ICIS),
	Radboud University, Nijmegen, Netherlands},
  art_number = {7},
  author_keywords = {Embedded domain specific language; Experience paper; Functional combinator
	library; Workflow system},
  document_type = {Conference Paper},
  journal = {Proceedings of the 10th Workshop on Language Descriptions, Tools
	and Applications, LDTA 2010},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-78649800278&partnerID=40&md5=027f093fd43d94f0802780aaa2140e77}
}

@ARTICLE{Jansen2006399,
  author = {Jansen, M., Girardi, R.},
  title = {GENMADEM: A methodology for generative Multi-Agent Domain Engineering},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2006},
  volume = {4039 LNCS},
  pages = {399-402},
  note = {cited By (since 1996) 2},
  abstract = {The generative approach is one of the most productive ways to promote
	the automatic reuse in software product lines. Multi-Agent Domain
	Engineering is a process to build multi-agent system families. This
	paper describes GENMADEM, an ontology-based methodology for generative
	multiagent domain engineering whose main products are ontology-based
	domain models, domain specific languages and application generators.
	© Springer-Verlag Berlin Heidelberg 2006.},
  affiliation = {Federal University of Maranhão (UFMA), Campus do Bacanga, Av. dos
	Portugueses, s/n, CEP 65080-040, Sao Luis-MA, Brazil},
  author_keywords = {Domain Engineering; Domain Specific Languages; Generative Software
	Reuse; Generators; Multi-Agent Systems Development Methodologies},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-33746216343&partnerID=40&md5=ab15513ec4dc0f25168c003ad80cf255}
}

@CONFERENCE{Jaroucheh2010219,
  author = {Jaroucheh, Z., Liu, X., Smith, S.},
  title = {Apto: A MDD-based generic framework for context-aware deeply adaptive
	service-based processes},
  year = {2010},
  pages = {219-226},
  note = {cited By (since 1996) 0},
  abstract = {Context-awareness and adaptability are important and desirable properties
	of service-based processes designed to provide personalized services.
	Most of the existing approaches focus on the adaptation at the process
	instance level [1] which involves extending the standard Business
	Process Execution Language (BPEL) and its engine or creating their
	own process languages (e.g. [2]). However, the approach proposed
	here aims to apply an adaptation to processes modeled or developed
	without any adaptation possibility in mind and independently of specific
	usage contexts. In addition, most of the existing approaches tackle
	the adaptation on the process instance or definition levels by explicitly
	specifying some form of variation points. This, however, leads to
	a contradiction between how the architect logically views and interprets
	differences in the process family and the actual modeling constructs
	through which the logical differences must be expressed. We introduce
	the notion of an evolution fragment and evolution primitive to capture
	the variability in a more logical and independent way. Finally, the
	proposed approach intends to support the viewpoint of context-aware
	adaptation as a crosscutting concern with respect to the core "business
	logic" of the process. In this way, the design of the process core
	can be decoupled from the design of the adaptation logic. To this
	end, we leverage ideas from the domain of model-driven development
	(MDD) and generative programming. © 2010 IEEE.},
  affiliation = {School of Computing, Edinburgh Napier University, United Kingdom},
  art_number = {5552781},
  author_keywords = {Adaptive service-based processes; BPEL; Context-awareness; MDD},
  document_type = {Conference Paper},
  journal = {ICWS 2010 - 2010 IEEE 8th International Conference on Web Services},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-77957277559&partnerID=40&md5=4bb5b1a7560c097b4229093622c1731e}
}

@ARTICLE{Jarzabek2000237,
  author = {Jarzabek, S., Seviora, R.},
  title = {Engineering components for ease of customisation and evolution},
  journal = {IEE Proceedings: Software},
  year = {2000},
  volume = {147},
  pages = {237-248},
  number = {6},
  note = {cited By (since 1996) 9},
  abstract = {Building software systems out of prefabricated components is a very
	attractive vision. Distributed component platforms (DCP) and their
	visual-development environments bring this vision closer to reality
	than ever. At the same time, some experiences with component libraries
	warn us about potential problems that arise when software-system
	families or systems evolve over many years of changes. Indeed, implementation-level
	components, when affected by many independent changes, tend to grow
	in both size and number, impeding reuse. This unwanted effect is
	analysed in detail. It is argued that components affected by frequent
	unexpected changes require higher levels of flexibility than the
	'plug-and-play' paradigm is able to provide. A program-construction
	environment is proposed, based on generative programming techniques,
	to help in customisation and evolution of components that require
	much flexibility. This solution allows the benefits of DCPs to be
	reaped during runtime and, at the same time, keeps components under
	control during system construction and evolution. Salient features
	of a construction environment for component-based systems are discussed.
	Its implementation with commercial reuse technology Fusion™ is described,
	illustrating with examples from domain-engineering projects. The
	main lesson learnt from the project is that generative-programming
	techniques can extend the strengths of the component-based approach
	in two important ways. First, generative-programming techniques automate
	routine component customisation and composition tasks and allow developers
	work more productively, at a higher abstraction level. Secondly,
	as custom components with required properties are generated on demand,
	it is not necessary to store and manage multiple versions of components;
	components do not overly grow in size, helping developers keep the
	complexity of an evolving system under control.},
  affiliation = {Department of Computer Science, School of Computing, National University
	of Singapore, Singapore 117543, Singapore},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-0034452439&partnerID=40&md5=558ccf34d4066200e988f2086a8ae82f}
}

@CONFERENCE{Jarzabek2011920,
  author = {Jarzabek, S., Trung, H.D.},
  title = {Flexible generators for software reuse and evolution (NIER track)},
  year = {2011},
  pages = {920-923},
  note = {cited By (since 1996) 0},
  abstract = {Developers tend to use models and generators during initial development,
	but often abandon them later in software evolution and reuse. One
	reason for that is that code generated from models (e.g., UML) is
	often manually modified, and changes cannot be easily propagated
	back to models. Once models become out of sync with code, any future
	re-generation of code overrides manual modifications. We propose
	a flexible generator solution that alleviates the above problem.
	The idea is to let developers weave arbitrary manual modifications
	into the generation process, rather than modify already generated
	code. A flexible generator stores specifications of manual modifications
	in executable form, so that weaving can be automatically re-done
	any time code is regenerated from modified models. In that way, models
	and manual modification can evolve independently but in sync with
	each other, and the generated code never gets directly changed. As
	a proof of concept, we have already built a flexible generator prototype
	by a merger of conventional generation system and variability technique
	to handle manual modifications. We believe a flexible generator approach
	alleviates an important problem that hinders wide spread adoption
	of MDD in software practice. © 2011 ACM.},
  affiliation = {Department of Computer Science, School of Computing, National University
	of Singapore, Singapore, Singapore},
  author_keywords = {domain-specific languages; generators; software product lines; software
	reuse},
  document_type = {Conference Paper},
  journal = {Proceedings - International Conference on Software Engineering},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-79959861762&partnerID=40&md5=d27b3135348beca1f5fdfe216d3764cc}
}

@ARTICLE{Jarzabek2006267,
  author = {Jarzabek, S.a , Li, S.b },
  title = {Unifying clones with a generative programming technique: A case study},
  journal = {Journal of Software Maintenance and Evolution},
  year = {2006},
  volume = {18},
  pages = {267-292},
  number = {4},
  note = {cited By (since 1996) 7},
  abstract = {Software clones - similar program structures repeated in variant forms
	- increase the risk of update anomalies, blow up the program size
	and complexity, possibly contributing to high maintenance costs.
	Yet, programs are often polluted by clones. In this paper, we present
	a case study of cloning in the Java Buffer library, JDK 1.5. We found
	that at least 68% of the code in the Buffer library was contained
	in cloned classes or class methods. Close analysis of program situations
	that led to cloning revealed difficulties in eliminating clones with
	conventional program design techniques. As a possible solution, we
	applied a generative technique of XVCL (XML-based Variant Configuration
	Language) to represent similar classes and methods in generic, adaptable
	form. Concrete buffer classes could be automatically produced from
	the generic structures. We argue, on analytical and empirical grounds,
	that unifying clones reduced conceptual complexity and enhanced the
	changeability of the Buffer library at rates proportional to code
	size reduction (68%). We evaluated our solution in qualitative and
	quantitative ways, and conducted a controlled experiment to support
	this claim. The approach presented in the paper can be used to enhance
	genericity and changeability of any program, independently of an
	application domain or programming language. As the solution is not
	without pitfalls, we discuss trade-offs involved in its project application.
	Copyright © 2006 John Wiley & Sons, Ltd.},
  affiliation = {Department of Computer Science, School of Computing, National University
	of Singapore, Lower Kent Ridge Road, Singapore 117543, Singapore;
	Department of Banking Information Engineering, School of Economics
	and Finance, Xi'An Jiaotong University, Xi'an 710061, China},
  author_keywords = {Class libraries; Generative programming; Maintainability; Object-oriented
	methods; Reusability},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-33747790264&partnerID=40&md5=67787cb28c74f2b9dd00a19ce23f689b}
}

@CONFERENCE{Jarzabek20061053,
  author = {Jarzabek, S.a , Pettersson, U.b },
  title = {Cost-effective engineering of web applications pragmatic reuse: Building
	web application product lines},
  year = {2006},
  volume = {2006},
  pages = {1053-1054},
  note = {cited By (since 1996) 0},
  abstract = {Web Applications (WA) are developed and maintained under tight schedules.
	Much similarity across WAs creates opportunities for cutting development
	cost and easing evolution via reuse. This tutorial shows a practical
	way to exploit similarity patterns - at architecture and code levels
	- to simplify the design of WAs, helping to meet the unique challenges
	of Web engineering.},
  affiliation = {Department of Computer Science, School of Computing, National University
	of Singapore, Singapore; Technology Office, ST Electronics (Info-Software
	Systems) Pte. Ltd.},
  author_keywords = {Generative programming; Maintenance; Reuse; Software product lines;
	Web engineering},
  document_type = {Conference Paper},
  journal = {Proceedings - International Conference on Software Engineering},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-34247104150&partnerID=40&md5=f45d4ffe47b7524a8cfe6259edef11ab}
}

@CONFERENCE{Jarzabek2006608,
  author = {Jarzabek, S.a , Pettersson, U.b },
  title = {Research journey towards industrial application of reuse technique},
  year = {2006},
  volume = {2006},
  pages = {608-611},
  note = {cited By (since 1996) 0},
  abstract = {Component-based reuse in mission critical Command and Control system
	domain was a starting point for a long lasting research collaboration
	between National University of Singapore (NUS) and ST Electronics
	Pte. Ltd. (STEE). STEE industrial projects as well as NUS lab studies
	revealed limitations of conventional architecture-centric, component-based
	reuse in the area of generic design to unify similarity patterns
	(e.g., similar classes, components or architectural patterns) commonly
	found in software. Further research showed that meta-level extensions
	to conventional techniques could strengthen their generic design
	capabilities, considerably improving effectiveness of reuse solutions,
	and increasing productivity gains due to reuse. These experiences
	led to development of "mixed strategy" approach based on synergistic
	application of meta-level generative programming technique of XVCL,
	together with conventional programming techniques. In the paper,
	we describe university-industry collaboration that proved beneficial
	for both parties: STEE advanced reuse practice via application of
	XVCL in several software product line projects. Early inputs from
	STEE helped NUS team validate and refine XVCL reuse methods, and
	expand into new research directions. We describe a sequence of projects
	that led to successful application of XVCL in industrial projects.
	We describe experiences from those projects and their significance
	for both industrial practice and understanding principles of flexible
	software, i.e., software that can be easily changed and adapted to
	various reuse contexts.},
  affiliation = {Department of Computer Science, National University of Singapore,
	Singapore; Technology Office, ST Electronics (Info-Software Systems)
	Pte. Ltd.},
  author_keywords = {Generic design; Maintenance; Reuse; Software product lines},
  document_type = {Conference Paper},
  journal = {Proceedings - International Conference on Software Engineering},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-34247124195&partnerID=40&md5=2804d5e71e1e631e76fada43c6424d67}
}

@CONFERENCE{Jarzabek2003,
  author = {Jarzabek, S.a , Shubiao, L.b },
  title = {Eliminating redundancies with a "composition with adaptation" meta-programming
	technique},
  year = {2003},
  pages = {237-246},
  note = {cited By (since 1996) 0},
  abstract = {Redundant code obstructs program understanding and contributes to
	high maintenance costs. While most experts agree on that, opinions
	- on how serious the problem of redundancies really is and how to
	tackle it - differ. In this paper, we present the study of redundancies
	in the Java Buffer library, JDK 1.4.1, which was recently released
	by Sun. We found that at least 68% of code in the Buffer library
	is redundant in the sense that it recurs in many classes in the same
	or slightly modified form. We effectively eliminated that 68% of
	code at the meta-level using a technique based on "composition with
	adaptation" called XVCL. We argue that such a program solution is
	easier to maintain than buffer classes with redundant code. In this
	experiment, we have designed our meta-representation so that we could
	produce buffer classes in exactly the same form as they appear in
	the original Buffer library. While we have been tempted to re-design
	the buffer classes, we chose not to do so, in order to allow for
	the seamless integration of the XVCL solution into contemporary programming
	methodologies and systems. This decision has not affected the essential
	results reported in this paper. © 2003 ACM.},
  affiliation = {Department of Computer Science, School of Computing, National University
	of Singapore, Lower Kent Ridge Road, Singapore 117543, Singapore;
	Department of Banking Information Engineering, School of Economics
	and Finance, Xi'an Jiaotong University, Xi'an 710061, China},
  author_keywords = {class libraries; generative programming; meta-programming; object-oriented
	methods},
  document_type = {Conference Paper},
  journal = {Proceedings of the ACM SIGSOFT Symposium on the Foundations of Software
	Engineering},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-77954517211&partnerID=40&md5=45a5a6293110d32c2d29852245860e41}
}

@CONFERENCE{Jarzabek2003237,
  author = {Jarzabek, S.a , Shubiao, L.b },
  title = {Eliminating Redundancies with a "Composition with Adaptation" Meta-programming
	Technique},
  year = {2003},
  pages = {237-246},
  note = {cited By (since 1996) 21},
  abstract = {Redundant code obstructs program understanding and contributes to
	high maintenance costs. While most experts agree on that, opinions
	- on how serious the problem of redundancies really is and how to
	tackle it - differ. In this paper, we present the study of redundancies
	in the Java Buffer library, JDK 1.4.1, which was recently released
	by Sun. We found that at least 68% of code in the Buffer library
	is redundant in the sense that it recurs in many classes in the same
	or slightly modified form. We effectively eliminated that 68% of
	code at the meta-level using a technique based on "composition with
	adaptation" called XVCL. We argue that such a program solution is
	easier to maintain than buffer classes with redundant code. In this
	experiment, we have designed our meta-representation so that we could
	produce buffer classes in exactly the same form as they appear in
	the original Buffer library. While we have been tempted to re-design
	the buffer classes, we chose not to do so, in order to allow for
	the seamless integration of the XVCL solution into contemporary programming
	methodologies and systems. This decision has not affected the essential
	results reported in this paper.},
  affiliation = {Department of Computer Science, School of Computing, National University
	of Singapore, Lower Kent Ridge Road, Singapore 117543; Dept. of Banking
	Info. Engineering, School of Economics and Finance, Xi'an Jiaotong
	University, Xi'an 710061, China},
  author_keywords = {Class libraries; Generative programming; Meta-programming; Object-Oriented
	methods},
  document_type = {Conference Paper},
  journal = {Proceedings of the Joint European Software Engineering Conference
	(ESEC) and SIGSOFT Symposium on the Foundations of Software Engineering
	(FSE-11)},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-1542286883&partnerID=40&md5=b0c8a7f91bd41da2c86da1ffc8bc690d}
}

@CONFERENCE{Javed2004404,
  author = {Javed, F.a , Bryant, B.R.a , Črepinšek, M.b , Mernik, M.b , Sprague,
	A.a },
  title = {Context-free grammar induction using genetic programming},
  year = {2004},
  pages = {404-405},
  note = {cited By (since 1996) 7},
  abstract = {While grammar inference is used in areas like natural language acquisition,
	syntactic pattern recognition, etc., its application to the programming
	language problem domain has been limited. We propose a new application
	area for grammar induction which intends to make domain-specific
	language development easier and finds a second application in renovation
	tools for legacy systems. The genetic programming approach is used
	for grammatical inference. Our earlier work used grammar-specific
	heuristic operators in tandem with non-random construction of the
	initial grammar population and succeeded in inducing small grammars.
	Copyright 2004 ACM.},
  affiliation = {Department of Computer and Information Sciences, University of Alabama
	at Birmingham, 1300 University Boulevard, Birmingham, AL 35294-1170,
	United States; Faculty of Electrical Engineering and Computer Science,
	University of Maribor, Smetanova 17, 2000 Maribor, Slovenia},
  author_keywords = {Context-free grammars; Genetic programming; Grammar-induction},
  document_type = {Conference Paper},
  journal = {Proceedings of the Annual Southeast Conference},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-24344447996&partnerID=40&md5=3de55843ef70fe19db4a9a48fea8f235}
}

@ARTICLE{Javed2008707,
  author = {Javed, F.a , Mernik, M.b , Bryant, B.R.a c , Sprague, A.a },
  title = {An unsupervised incremental learning algorithm for domain-specific
	language development},
  journal = {Applied Artificial Intelligence},
  year = {2008},
  volume = {22},
  pages = {707-729},
  number = {7-8},
  note = {cited By (since 1996) 5},
  abstract = {While grammar inference (or grammar induction) has found extensive
	application in the areas of robotics, computational biology, and
	speech recognition, its application to problems in programming language
	and software engineering domains has been limited. We have found
	a new application area for grammar inference which intends to make
	domain-specific language development easier for domain experts not
	well versed in programming language design, and finds a second application
	in construction of renovation tools for legacy software systems.
	As a continuation of our previous efforts to infer context-free grammars
	(CFGs) for domain-specific languages which previously involved a
	genetic-programming based CFG inference system, we discuss extensions
	to the inference capabilities of GenInc, an incremental learning
	algorithm for inferring CFGs. We show that these extensions enable
	GenInc to infer more comprehensive grammars, discuss the results
	of applying GenInc to various domain-specific languages and evaluate
	the results using a comprehensive suite of grammar metrics.},
  affiliation = {Department of Computer and Information Sciences, University of Alabama
	at Birmingham, Birmingham, AL, United States; Faculty of Electrical
	Engineering and Computer Science, University of Maribor, Maribor,
	Slovenia; Department of Computer and Information Sciences, University
	of Alabama at Birmingham, 1300 University Boulevard, Birmingham,
	AL 35294-1170, United States},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-49749096069&partnerID=40&md5=6bc7887b53e1f96883e93c82dc65d831}
}

@CONFERENCE{Jerad2005202,
  author = {Jerad, C.a , Barkaoui, K.b },
  title = {On the use of rewriting logic for verification of distributed software
	architecture description based LfP},
  year = {2005},
  pages = {202-208},
  note = {cited By (since 1996) 5},
  abstract = {Software architecture description languages (ADLs) allow software
	designers to focus on high level aspects of an application by abstracting
	from the details of the components that compose architecture. It
	is precisely this abstraction that makes ADLs suitable for verification
	using model checking techniques. ADLs are, in a way, domain-specific
	languages for aspects such as coordination and distribution. LfP
	(Language for Prototyping) is a formal approach for distributed software
	architectures that is based on RM-ODP and that can be linked to an
	UML methodology. We propose in this paper a rewriting of the LfP
	semantics, specified in rewriting logic which is well suited for
	axiomatization of concurrent languages. Using the Maude system, a
	high-performance interpreter based on rewriting logic, we illustrate
	through an example how this rewriting semantics can be exploited
	for verification aspects related to distributed object interactions.
	© 2005 IEEE.},
  affiliation = {LSTS, ENIT, BP 37, Le Belvedere 1002 Tunis, Tunisia; CEDRIC, CNAM,
	292, Rue Saint-Martin, Paris 75003, France},
  document_type = {Conference Paper},
  journal = {Proceedings of the International Workshop on Rapid System Prototyping},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-26444447120&partnerID=40&md5=0fe1f26ed817acb1ccb07ba8ef498b49}
}

@CONFERENCE{Jersak2002121,
  author = {Jersak, M., Richter, K., Henia, R., Ernst, R., Slomka, F.},
  title = {Transformation of SDL specifications for system-level timing analysis},
  year = {2002},
  pages = {121-126},
  note = {cited By (since 1996) 0},
  abstract = {Complex embedded systems are typically specified using multiple domain-specific
	languages. After code-generation, the implementation is simulated
	and tested. Validation of non-functional properties, in particular
	timing, remains a problem because full test coverage cannot be achieved
	for realistic designs. The alternative, formal timing analysis, requires
	a system representation based on key application and architecture
	properties. These properties must first be extracted from a system
	specification to enable analysis. In this paper we present a suitable
	transformation of SDL specifications for system-level timing analysis.
	We show ways to vary modeling accuracy in order to apply available
	formal techniques. A practical approach utilizing a recently developed
	system model is presented.},
  affiliation = {Inst. of Computer Engineering (IDA), Technical Univ. of Braunschweig,
	D-38106 Braunschweig, Germany},
  document_type = {Conference Paper},
  journal = {Hardware/Software Codesign - Proceedings of the International Workshop},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-0036047122&partnerID=40&md5=1ac8417cc9d290779ba28fe75abb5b57}
}

@CONFERENCE{Jia2011220,
  author = {Jia, X., Jones, C.},
  title = {Dynamic languages as modeling notations in model driven engineering},
  year = {2011},
  volume = {2},
  pages = {220-225},
  note = {cited By (since 1996) 0},
  abstract = {There has been a gradual but steady convergence of dynamic programming
	languages with modeling languages. Modern dynamic languages such
	as Groovy and Ruby provide for the creation of domain-specific languages
	that can provide a level of abstraction comparable to that of modeling
	languages such as UML. This convergence makes dynamic languages suitable
	as modeling languages but with benefits that traditional modeling
	languages do not provide. One area that can benefit from this convergence
	is model driven engineering. By using a dynamic language as an augmentation
	to MDE's traditional UML notation, it is possible to create models
	that are executable, exhibit flexible type checking, and which provide
	a smaller cognitive gap between business users, modelers and developers.},
  affiliation = {College of Computing and Digital Media, DePaul University, 243 S.
	Wabash Ave., Chicago, IL, United States},
  author_keywords = {Dynamic language; Model driven engineering; Modeling language},
  document_type = {Conference Paper},
  journal = {ICSOFT 2011 - Proceedings of the 6th International Conference on
	Software and Database Technologies},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-80052557093&partnerID=40&md5=e182bf6daeb1488a1f56eb6b8fdc2de3}
}

@CONFERENCE{Jiang20101696,
  author = {Jiang, T.a , Wang, X.a , Yu, Y.b },
  title = {A formal definition of the structural semantics of Domain-Specific
	Modeling languages},
  year = {2010},
  pages = {1696-1699},
  note = {cited By (since 1996) 0},
  abstract = {As a Model-Driven Development methodology (MDD) for the specific domain,
	Domain-Specific Modeling (DSM) has been widely and successfully used
	in system design and analysis of specific areas. In spite of its
	general important, due to informal definition of Domain-Specific
	Modeling Language (DSMLs), the structural semantics of DSMLs cannot
	be strictly described and the properties based on it also cannot
	be analyzed and validated. In response, the paper proposes a formal
	definition method of the structural semantics of DSMLs. Firstly,
	a formal definition of domain indicating structural semantics of
	DSMLs based on algebra is presented to unify DSMLs and its models
	in the domain, secondly, a mapping mechanism from domain to the corresponding
	first-order logic system is established to finish analysis and validation
	of properties of domain such as consistency based on first-order
	logical inference, based on this, the method of formalization and
	consistency analysis and validation of structural semantics of DSMLs
	based on first-order logic is presented, finally, the formalization
	automatic mapping engine for model and metamodel is introduced to
	show the application of formalization of structural semantics in
	analysis and validation of properties of models. © 2010 IEEE.},
  affiliation = {School of Mathematics and Computer Science, Yunnan University of Nationalities,
	Kunming, China; School of Software, Yunnan University, Kunming, China},
  art_number = {5689083},
  author_keywords = {Consistency; Domain; Domain mapping; Domain-specific modeling language
	(dsmls); First-order logic; Structural semantics},
  document_type = {Conference Paper},
  journal = {2nd International Conference on Information Science and Engineering,
	ICISE2010 - Proceedings},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-79951993696&partnerID=40&md5=cfbd0a6155ea66d7f6bdd7b6d93b1b11}
}

@ARTICLE{Jiménez200930,
  author = {Jiménez, M.a , Rosique, F.a , Sánchez, P.a , Álvarez, B.a , Iborra,
	A.b },
  title = {Habitation: A domain-specific language for home automation},
  journal = {IEEE Software},
  year = {2009},
  volume = {26},
  pages = {30-38},
  number = {4},
  note = {cited By (since 1996) 6},
  abstract = {Developers need suitable tools to develop home automation systems
	while enhancing quality and productivity. One solution is to use
	domain-specific languages (DSLs) within a model-driven approach.
	The Habitation DSL provides a powerful visual development environment,
	including a catalog of reusable functional units and a set of home
	automation interconnection primitives. The model-driven approach
	offers mechanisms to automatically generate code to enhance the quality
	and portability of home automation systems. The result is an Eclipse-based
	tool whose usability the authors have validated in a case study.
	© 2009 IEEE.},
  affiliation = {Technical University of Cartagena, Cartagena, Germany; Electronics
	Technology Department, Technical University of Cartagena, Cartagena,
	Germany},
  author_keywords = {Catalogs; Computational modeling; Computer integrated manufacturing;
	Domain-specific languages; DSL; Home automation; Model-driven engineering;
	Software; Unified modeling language; Visual languages},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-67650501107&partnerID=40&md5=3e88f95de6e56ab131426f439a4d472f}
}

@ARTICLE{Johann2001144,
  author = {Johann, P.a , Visser, E.b },
  title = {Fusing logic and control with local transformations: An example optimization},
  journal = {Electronic Notes in Theoretical Computer Science},
  year = {2001},
  volume = {57},
  pages = {144-162},
  note = {cited By (since 1996) 3},
  abstract = {Abstract programming supports the separation of logical concerns from
	issues of control in program construction. While this separation
	of concerns leads to reduced code size and increased reusability
	of code, its main disadvantage is the computational overhead it incurs.
	Fusion techniques can be used to combine the reusability of abstract
	programs with the efficiency of specialized programs. In this paper
	we illustrate some of the ways in which rewriting strategies can
	be used to separate the definition of program transformation rules
	from the strategies under which they are applied. Doing so supports
	the generic definition of program transformation components. Fusion
	techniques for strategies can then be used to specialize such generic
	components. We show how the generic innermost rewriting strategy
	can be optimized by fusing it with the rules to which it is applied.
	Both the optimization and the programs to which the optimization
	applies are specified in the strategy language Stratego. The optimization
	is based on small transformation rules that are applied locally under
	the control of strategies, using special knowledge about the contexts
	in which the rules are applied. © 2001 Published by Elsevier Science
	B. V.},
  affiliation = {Department of Mathematics and Computer Science, Dickinson College,
	Carlisle, PA 17013, United States; Institute of Information and Computing
	Sciences, Universiteit Utrecht, P.O. Box 80089, 3508 TB Utrecht,
	Netherlands},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-18244410363&partnerID=40&md5=814eb74459c29b5ddb45873e23e16f70}
}

@ARTICLE{Johann20001,
  author = {Johann, P.a , Visser, E.b },
  title = {Warm fusion in Stratego: A case study in generation of program transformation
	systems},
  journal = {Annals of Mathematics and Artificial Intelligence},
  year = {2000},
  volume = {29},
  pages = {1-34},
  number = {1-4},
  note = {cited By (since 1996) 8},
  abstract = {Stratego is a domain-specific language for the specification of program
	transformation systems. The design of Stratego is based on the paradigm
	of rewriting strategies: user-definable programs in a little language
	of strategy operators determine where and in what order transformation
	rules are (automatically) applied to a program. The separation of
	rules and strategies supports modularity of specifications. Stratego
	also provides generic features for specification of program traversals.
	In this paper we present a case study of Stratego as applied to a
	non-trivial problem in program transformation. We demonstrate the
	use of Stratego in eliminating intermediate data structures from
	(also known as deforesting) functional programs via the warm fusion
	algorithm of Launchbury and Sheard. This algorithm has been specified
	in Stratego and embedded in a fully automatic transformation system
	for kernel Haskell. The entire system consists of about 2600 lines
	of specification code, which breaks down into 1850 lines for a general
	framework for Haskell transformation and 750 lines devoted to a highly
	modular, easily extensible specification of the warm fusion transformer
	itself. Its successful design and construction provides further evidence
	that programs generated from Stratego specifications are suitable
	for integration into real systems, and that rewriting strategies
	are a good paradigm for the implementation of such systems.},
  affiliation = {Department of Mathematics, Bates College, Lewiston, ME 04240, United
	States; Inst. of Info. and Comp. Sciences, Universiteit Utrecht,
	P.O. Box 80089, 3508 TB Utrecht, Netherlands},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-0034559071&partnerID=40&md5=89550935c4b7e7c1c5fc1e950092a2f2}
}

@ARTICLE{Johannes2009546,
  author = {Johannes, J.a , Zschaler, S.b , Fernández, M.A.c , Castillo, A.c
	, Kolovos, D.S.d , Paige, R.F.d },
  title = {Abstracting complex languages through transformation and composition},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2009},
  volume = {5795 LNCS},
  pages = {546-550},
  note = {cited By (since 1996) 2},
  abstract = {Domain-specific languages (DSLs) can simplify the development of complex
	software systems by providing domain-specific abstractions. However,
	the complexity of some domains has led to a number of DSLs that are
	themselves complex, limiting the original benefits of using DSLs.
	We show how to develop DSLs as abstractions of other DSLs by transfering
	translational approaches for textual DSLs into the domain of modelling
	languages. We argue that existing model transformation languages
	are at too low a level of abstraction for succinctly expressing transformations
	between abstract and concrete DSLs. Patterns identified in such model
	transformations can be used to raise the level of abstraction. We
	show how we can allow part of the transformation to be expressed
	using the concrete syntax of the concrete DSL. © 2009 Springer Berlin
	Heidelberg.},
  affiliation = {Technische Universität Dresden, Germany; Computing Department, Lancaster
	University; Telefónica Research and Development; Department of Computer
	Science, University of York, Denmark},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-77249160851&partnerID=40&md5=762bde23a295ad94b5327d6b152eaf7d}
}

@CONFERENCE{Johnson2008117,
  author = {Johnson, G.},
  title = {FlatCAD and flatlang: Kits by code},
  year = {2008},
  pages = {117-120},
  note = {cited By (since 1996) 2},
  abstract = {The FlatCAD system lets you create physical construction kits by coding
	in the LOGO-like FlatLang language. Designers often use structured
	CAD tools to specify physical form. Programming offers an alternative
	and powerful method for designing shapes. This paper describes our
	experimental domain-specific language used to program and manufacture
	physical shape in the domain of construction kits. © 2008 IEEE.},
  affiliation = {Carnegie Mellon University},
  art_number = {4639070},
  document_type = {Conference Paper},
  journal = {Proceedings - 2008 IEEE Symposium on Visual Languages and Human-Centric
	Computing, VL/HCC 2008},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-56349099300&partnerID=40&md5=f13af6d7ab3637441f67c389ed961fb4}
}

@CONFERENCE{Johnson2006,
  author = {Johnson, T.A., Eigenmann, R.},
  title = {Context-sensitive domain-independent algorithm composition and selection},
  year = {2006},
  volume = {2006},
  pages = {181-192},
  note = {cited By (since 1996) 0},
  abstract = {Progressing beyond the productivity of present-day languages appears
	to require using domain-specific knowledge. Domain-specific languages
	and libraries (DSLs) proliferate, but most optimizations and language
	features have limited portability because each language's semantics
	are related closely to its domain. We explain how any DSL compiler
	can use a domain-independent AI planner to implement algorithm composition
	as a language feature. Our notion of composition addresses a common
	DSL problem: good library designers tend to minimize redundancy by
	including only fundamental procedures that users must chain together
	into call sequences. Novice users are confounded by not knowing an
	appropriate sequence to achieve their goal. Composition allows the
	programmer to define and call an abstract algorithm (AA) like a procedure.
	The compiler replaces an AA call with a sequence of library calls,
	while considering the calling context. Because AI planners compute
	a sequence of operations to reach a goal state, the compiler can
	implement composition by analyzing the calling context to provide
	the planner's initial state. Nevertheless, mapping composition onto
	planning is not straightforward because applying planning to software
	requires extensions to classical planning, and procedure specifications
	may be incomplete when expressed in a planning language. Compositions
	may not be provably correct, so our approach mitigates semantic incompleteness
	with unobtrusive programmer-compiler interaction. This tradeoff is
	key to making composition a practical and natural feature of otherwise
	imperative languages, whose users eschew complex logical specifications.
	Compositions satisfying an AA may not be equal in performance, memory
	usage, or precision and require selection of a preferred solution.
	We examine language design and implementation issues, and we perform
	a case study on the BioPerl bioinformatics library. Copyright © 2006
	ACM.},
  affiliation = {School of Electrical and Computer Engineering, Purdue University,
	West Lafayette, IN 47907-2035},
  author_keywords = {Algorithm composition; Algorithm selection; Automated planning; Bioinformatics;
	Domain-specific languages},
  document_type = {Conference Paper},
  journal = {Proceedings of the ACM SIGPLAN Conference on Programming Language
	Design and Implementation (PLDI)},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-33746075585&partnerID=40&md5=c0c4e11b44588f9fe42f7f02ced1ee27}
}

@ARTICLE{Johnson2006181,
  author = {Johnson, T.A., Eigenmann, R.},
  title = {Context-sensitive domain-independent algorithm composition and selection},
  journal = {ACM SIGPLAN Notices},
  year = {2006},
  volume = {41},
  pages = {181-192},
  number = {6},
  note = {cited By (since 1996) 0},
  abstract = {Progressing beyond the productivity of present-day languages appears
	to require using domain-specific knowledge. Domain-specific languages
	and libraries (DSLs) proliferate, but most optimizations and language
	features have limited portability because each language's semantics
	are related closely to its domain. We explain how any DSL compiler
	can use a domain-independent AI planner to implement algorithm composition
	as a language feature. Our notion of composition addresses a common
	DSL problem: good library designers tend to minimize redundancy by
	including only fundamental procedures that users must chain together
	into call sequences. Novice users are confounded by not knowing an
	appropriate sequence to achieve their goal. Composition allows the
	programmer to define and call an abstract algorithm (AA) like a procedure.
	The compiler replaces an AA call with a sequence of library calls,
	while considering the calling context. Because AI planners compute
	a sequence of operations to reach a goal state, the compiler can
	implement composition by analyzing the calling context to provide
	the planner's initial state. Nevertheless, mapping composition onto
	planning is not straightforward because applying planning to software
	requires extensions to classical planning, and procedure specifications
	may be incomplete when expressed in a planning language. Compositions
	may not be provably correct, so our approach mitigates semantic incompleteness
	with unobtrusive programmer-compiler interaction. This tradeoff is
	key to making composition a practical and natural feature of otherwise
	imperative languages, whose users eschew complex logical specifications.
	Compositions satisfying an AA may not be equal in performance, memory
	usage, or precision and require selection of a preferred solution.
	We examine language design and implementation issues, and we perform
	a case study on the BioPerl bioinformatics library. Copyright © 2006
	ACM.},
  affiliation = {School of Electrical and Computer Engineering, Purdue University,
	West Lafayette, IN 47907-2035},
  author_keywords = {Algorithm composition; Algorithm selection; Automated planning; Bioinformatics;
	Domain-specific languages},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-33745192090&partnerID=40&md5=b7116fac6bf332a80ec533c6f802d248}
}

@ARTICLE{Johnstone2010145,
  author = {Johnstone, A.a , Mosses, P.D.b , Scott, E.a },
  title = {An agile approach to language modelling and development},
  journal = {Innovations in Systems and Software Engineering},
  year = {2010},
  volume = {6},
  pages = {145-153},
  number = {1},
  note = {cited By (since 1996) 1},
  abstract = {We have developed novel techniques for component-based specification
	of programming languages. In our approach, the semantics of each
	fundamental programming construct is specified independently, using
	an inherently modular framework such that no reformulation is needed
	when constructs are combined. A language specification consists of
	an unrestricted context-free grammar for the syntax of programs,
	together with an analysis of each language construct in terms of
	fundamental constructs. An open-ended collection of fundamental constructs
	is currently being developed. When supported by appropriate tools,
	our techniques allow a more agile approach to the design, modelling,
	and implementation of programming and domain-specific languages.
	In particular, our approach encourages language designers to proceed
	incrementally, using prototype implementations generated from specifications
	to test tentative designs. The components of our specifications are
	independent and highly reusable, so initial language specifications
	can be rapidly produced, and can easily evolve in response to changing
	design decisions. In this paper, we outline our approach, and relate
	it to the practices and principles of agile modelling. © Springer-Verlag
	London Limited 2009.},
  affiliation = {Department of Computer Science, Royal Holloway, University of London,
	Egham TW20 0EX, United Kingdom; Department of Computer Science, Swansea
	University, Singleton Park, Swansea SA2 8PP, United Kingdom},
  author_keywords = {Agile methods; Programming language models; Semantics; Syntax},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-77949283661&partnerID=40&md5=549fa64cd8bdb61a56aabc36bf1463c6}
}

@CONFERENCE{Jones2008,
  author = {Jones, M.P.},
  title = {Experience report: Playing the DSL card - A domain specific language
	for component configuration},
  year = {2008},
  pages = {87-90},
  note = {cited By (since 1996) 0},
  abstract = {This paper describes our experience using a functional language, Haskell,
	to build an embedded, domain-specific language (DSL) for component
	configuration in large-scale, real-time, embedded systems. Prior
	to the introduction of the DSL, engineers would describe the steps
	needed to configure a particular system in a hand-written XML document.
	In this paper, we outline the application domain, give a brief overview
	of the DSL that we developed, and provide concrete data to demonstrate
	its effectiveness. In particular, we show that the DSL has several
	significant benefits over the original, XML-based approach including
	reduced code size, increased modularity and scalability, and detection
	and prevention of common defects. For example, using the DSL, we
	were able to produce clear and intuitive descriptions of component
	configurations that were sometimes less than 1/30 of the size of
	the original XML. Copyright © 2008 ACM.},
  affiliation = {Portland State University, Portland, OR, United States},
  author_keywords = {Component configuration; Domain-specific languages; Functional programming;
	Haskell; Timber},
  document_type = {Conference Paper},
  journal = {Proceedings of the ACM SIGPLAN International Conference on Functional
	Programming, ICFP},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-59249102929&partnerID=40&md5=2792d1b4b08bfb6f51adf24c5246c9f8}
}

@ARTICLE{Jones200887,
  author = {Jones, M.P.},
  title = {Experience report: Playing the DSL card a domain specific language
	for component configuration},
  journal = {ACM SIGPLAN Notices},
  year = {2008},
  volume = {43},
  pages = {87-90},
  number = {9},
  note = {cited By (since 1996) 0},
  abstract = {This paper describes our experience using a functional language, Haskell,
	to build an embedded, domain-specific language (DSL) for component
	configuration in large-scale, real-time, embedded systems. Prior
	to the introduction of the DSL, engineers would describe the steps
	needed to configure a particular system in a handwritten XML document.
	In this paper, we outline the application domain, give a brief overview
	of the DSL that we developed, and provide concrete data to demonstrate
	its effectiveness. In particular, we show that the DSL has several
	significant benefits over the original, XML-based approach including
	reduced code size, increased modularity and scalability, and detection
	and prevention of common defects. For example, using the DSL, we
	were able to produce clear and intuitive descriptions of component
	configurations that were sometimes less than 1/30 of the size of
	the original XML. Copyright © 2008 ACM.},
  affiliation = {Portland State University, Portland, OR, United States},
  author_keywords = {Component configuration; Domain-specific languages; Functional programming;
	Haskell; Timber},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-67650034880&partnerID=40&md5=b5d7238213458fb595b3046284dd4b0c}
}

@ARTICLE{Jouault2006171,
  author = {Jouault, F., Bézivin, J.},
  title = {KM3: A DSL for metamodel specification},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2006},
  volume = {4037 LNCS},
  pages = {171-185},
  note = {cited By (since 1996) 63},
  abstract = {We consider in this paper that a DSL (Domain Specific Language) may
	be defined by a set of models. A typical DSL is the ATLAS Transformation
	Language (ATL). An ATL program transforms a source model (conforming
	to a source metamodel) into a target model (conforming to a target
	metamodel). Being itself a model, the transformation program conforms
	to the ATL metamodel. The notion of metamodel is thus used to define
	the source DSL, the target DSL and the transformation DSL itself.
	As a consequence we can see that agility to define metamodels and
	precision of these definitions is of paramount importance in any
	model engineering activity. In order to fullfill the goals of agility
	and precision in the definition of our metamodels, we have been using
	a notation called KM3 (Kernel MetaMetaModel). KM3 may itself be considered
	as a DSL for describing metamodels. This paper presents the rationale
	for using KM3, some examples of its use and a precise definition
	of the language. © IFIP International Federation for Information
	Processing 2006.},
  affiliation = {ATLAS Team, INRIA, LINA},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-33746216410&partnerID=40&md5=e55890e4b5e8a7bf7cbb74db527b6340}
}

@CONFERENCE{Jouault2006249,
  author = {Jouault, F., Bézivin, J., Kurtev, I.},
  title = {TCS: A DSL for the specification of textual concrete syntaxes in
	model engineering},
  year = {2006},
  pages = {249-254},
  note = {cited By (since 1996) 46},
  abstract = {Domain modeling promotes the description of various facets of information
	systems by a coordinated set of domain-specific languages (DSL).
	Some of them have visual/graphical and other may have textual concrete
	syntaxes. Model Driven Engineering (MDE) helps defining the concepts
	and relations of the domain by the way of metamodel elements. For
	visual languages, it is necessary to establish links between these
	concepts and relations on one side and visual symbols on the other
	side. Similarly, with textual languages it is necessary to establish
	links between metamodel elements and syntactic structures of the
	textual DSL. To successfully apply MDE in a wide range of domains
	we need tools for fast implementation of the expected growing number
	of DSLs. Regarding the textual syntax of DSLs, we believe that most
	current proposals for bridging the world of models (MDE) and the
	world of grammars (Grammarware) are not completely adapted to this
	need. We propose a generative solution based on a DSL called TCS
	(Textual Concrete Syntax). Specifications expressed in TCS are used
	to automatically generate tools for model-to-text and text-to-model
	transformations. The proposed approach is illustrated by a case study
	in the definition of a telephony language. Copyright © 2006 ACM.},
  affiliation = {ATLAS Team, INRIA, LINA},
  author_keywords = {Concrete syntax; DSL; Model driven engineering},
  document_type = {Conference Paper},
  journal = {Proceedings of the 5th International Conference on Generative Programming
	and Component Engineering, GPCE'06},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-34547461164&partnerID=40&md5=6d6b93e98edf309c0b68986f31ead144}
}

@CONFERENCE{Jouault20102011,
  author = {Jouault, F.a , Vanhooff, B.b , Bruneliere, H.a , Doux, G.a , Berbers,
	Y.b , Bezivin, J.a },
  title = {Inter-DSL coordination support by combining megamodeling and model
	weaving},
  year = {2010},
  pages = {2011-2018},
  note = {cited By (since 1996) 1},
  abstract = {Model-Driven Engineering (MDE) advocates the use of models at every
	step of the software development process. Within this context, a
	team of engineers collectively and collaboratively contribute to
	a large set of interrelated models. Even if the main focus can be
	on a single model (e.g. a class diagram model), related elements
	in other models (e.g. a requirement model) often have to be considered
	and/or accessed. Moreover, all the involved models do not necessarily
	conform to the same metamodel and thus may have been built using
	different independent Domain-Specific Languages (DSLs). Such a situation
	has already been frequently observed in many large-scale industrial
	deployments of MDE. Manually coordinating all the involved models,
	i.e. being able to both manage and use the links existing between
	them, can become a cumbersome and difficult task. As a proposal to
	solve this inter-DSL coordination issue, we introduce in this paper
	a generic and extensible inter-model traceability and navigation
	environment based on the complementary use of megamodeling and model
	weaving. We illustrate our solution with a concrete working example.
	© 2010 ACM.},
  affiliation = {AtlanMod Team, INRIA RBA Center, EMN, 4, rue Alfred Kastler, 44307
	Nantes, France; Department of Computer Science, K.U. Leuven, Celestijnenlaan
	200A, B-3001 Heverlee, Belgium},
  author_keywords = {coordination; domain-specific languages; megamodeling; model weaving;
	model-driven engineering},
  document_type = {Conference Paper},
  journal = {Proceedings of the ACM Symposium on Applied Computing},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-77954719745&partnerID=40&md5=27852d693a80ad86173aa4859f4b0030}
}

@ARTICLE{Jouvelot2011113,
  author = {Jouvelot, P.a , Orlarey, Y.b },
  title = {Dependent vector types for data structuring in multirate Faust},
  journal = {Computer Languages, Systems and Structures},
  year = {2011},
  volume = {37},
  pages = {113-131},
  number = {3},
  note = {cited By (since 1996) 0},
  abstract = {Faust is a functional programming language dedicated to the specification
	of executable monorate synchronous musical applications. To extend
	Faust capabilities to important domains such as FFT-based spectral
	processing, we introduce here a multirate extension of the core Faust
	language. The novel idea is to link rate changes to data structure
	manipulation operations. Creating a vector-valued output signal divides
	the rate of input signals by the vector size, while serializing vectors
	multiplies rates accordingly. As duals to vectors, we also introduce
	record-like data structures, which are used to gather data but do
	not change signal rates. This interplay between data structures and
	rates is made possible in the language static semantics by the introduction
	of dependent types. We present a typing semantics, a denotational
	semantics and correctness theorems that show that this data structuring/multirate
	extension preserves the language synchronous characteristics. This
	new design is under implementation in the Faust compiler. © 2011
	Elsevier Ltd. All rights reserved.},
  affiliation = {CRI, Mathématiques et Systèmes, MINES ParisTech, 35 rue Saint-Honoré,
	77305 Fontainebleau, France; Grame, 9 rue du Garet, 69202 Lyon Cedex
	01, France},
  author_keywords = {Denotational semantics; Dependent type systems; Domain specific languages;
	Multirate computing; Static semantics; Synchronous signal processing},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-79955462935&partnerID=40&md5=4542d7f016d9289fc8e32e7ce4a92f12}
}

@ARTICLE{Juergens200655,
  author = {Juergens, E., Pizka, M.},
  title = {The Language Evolver Lever - Tool Demonstration -},
  journal = {Electronic Notes in Theoretical Computer Science},
  year = {2006},
  volume = {164},
  pages = {55-60},
  number = {2 SPEC. ISS.},
  note = {cited By (since 1996) 0},
  abstract = {Since many domains are constantly evolving, the associated domain
	specific languages (DSL) inevitably have to evolve too, to retain
	their value. But the evolution of a DSL can be very expensive, since
	existing words of the language (i.e. programs) and tools have to
	be adapted according to the changes of the DSL itself. In such cases,
	these costs seriously limit the adoption of DSLs. This paper presents
	Lever, a tool for the evolutionary development of DSLs. Lever aims
	at making evolutionary changes to a DSL much cheaper by automating
	the adaptation of the DSL parser as well as existing words and providing
	additional support for the correct adaptation of existing tools (e.g.
	program generators). This way, Lever simplifies DSL maintenance and
	paves the ground for bottom-up DSL development. © 2006 Elsevier B.V.
	All rights reserved.},
  affiliation = {Institut für Informatik, Technische Universität München, Boltzmanstr.
	3, 85748 Garching, Germany},
  author_keywords = {bottom-up language development; coupled transformation; domain specific
	languages; language evolution},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-33750089014&partnerID=40&md5=bb5852e8e7b9698c5f2c822d03cb98bb}
}

@ARTICLE{Jugel2010354,
  author = {Jugel, U.},
  title = {Generating smart wrapper libraries for arbitrary APIs},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2010},
  volume = {5969 LNCS},
  pages = {354-373},
  note = {cited By (since 1996) 2},
  abstract = {"Library design is language design" [1]. The development of a smart
	program library is very similar to the creation of a domain specific
	language (DSL). Both are currently created in an ad-hoc manner, taking
	account of best practices and software patterns. Creating new languages
	and the tools needed to integrate them can be very cumbersome. We
	propose a reproducible, model-driven methodology to add automation
	to the DSL-creation process. Our novel approach presents an easy
	way to design and generate smart, API-wrapping libraries, similar
	to internal DSLs. These libraries increase the usability of an existing
	API and can be easily integrated into existing software development
	tool chains. To generate these DSLs, we propose an enhanced code
	generation that applies usability-enhancing software patterns. Our
	current generator leverages the Expression Builder pattern, which
	is described in detail. We validate our methodology and our enhanced
	code generation by applying it to Java APIs resulting in smart Java
	libraries that we call "dotLings". © 2010 Springer-Verlag.},
  affiliation = {SAP Research Center Dresden, Chemnitzer Str. 48, Dresden 01187, Germany},
  author_keywords = {API-usability; Code generation; Domain specific languages; Language
	integration; Model-driven},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-77951532610&partnerID=40&md5=b7d48c8a225aeef0e5a8ff3a111e8e0f}
}

@CONFERENCE{Jun2007,
  author = {Jun, C.a , Goyal, A.b , Midkiff, S.P.a , Caruthers, J.M.b },
  title = {An optimizing compiler for parallel chemistry simulations},
  year = {2007},
  note = {cited By (since 1996) 0},
  abstract = {Well designed domain specific languages enable the easy expression
	of problems, the application of domain specific optimizations, and
	dramatic improvements in productivity for their users. In this paper
	we describe a compiler for polymer chemistry, and in particular rubber
	chemistry, that achieves all of these goals. The compiler allows
	the development of a system of ordinary differential equations describing
	a complex rubber reaction - a task that used to require months -
	to be done in days. The generated code, like much machine generated
	code, is more complex than human written code, and stresses commercial
	compilers to the point of failure. However, because of knowledge
	of the form of ODEs generated, the compiler can perform specialized
	common sub-expression and other algebraic optimizations that simplifies
	the code sufficiently to allow it to be compiled (eliminating all
	but 6.9% of the operations in our largest program) and to provide
	five times faster performance on our largest benchmark codes. ©2007
	IEEE.},
  affiliation = {Purdue University, School of Electrical and Computer Engineering,
	West Lafayette, IN 47907; Purdue University, School of Chemical Engineering,
	West Lafayette, IN 47907},
  art_number = {4228020},
  document_type = {Conference Paper},
  journal = {Proceedings - 21st International Parallel and Distributed Processing
	Symposium, IPDPS 2007; Abstracts and CD-ROM},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-34548770003&partnerID=40&md5=8502add0e691ca21d06530af8df45b10}
}

@ARTICLE{Jun2005237,
  author = {Jun, Y., Jarzabek, S.},
  title = {Applying a generative technique for enhanced genericity and maintainability
	on the J2EE platform},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2005},
  volume = {3676 LNCS},
  pages = {237-255},
  note = {cited By (since 1996) 1},
  abstract = {One of the themes in building reusable and maintainable software is
	identifying similarities and designing generic solutions to unify
	similarity patterns. In this paper, we analyze capabilities of J2EE
	to effectively unify similarity patterns found in Web Portals (WP).
	Our experimentation involved a family of WPs to support information
	sharing and team collaboration, built by our industry partner. While
	J2EE provides useful mechanisms for reuse of common services across
	components, we found its limitations in systematic across-the-board
	reuse in application domain-specific areas. To solve these problems,
	we applied a generative programming (GP) technique of XVCL on top
	of J2EE. By unifying similarity patterns, we increased the clarity
	of portal's conceptual structure as perceived by developers, reducing
	also the size of the original J2EE WP by 61%. Our solution enhanced
	traceability of information that mattered during changes. Based on
	that we hypothesized that XVCL-enhanced J2EE WP would be easier to
	maintain than the original J2EE WP. In the paper, we describe our
	solution and evaluate its engineering merits in both quantitative
	and qualitative ways. © Springer-Verlag Berlin Heidelberg 2005.},
  affiliation = {Department of Computer Science, School of Computing, National University
	of Singapore, Lower Kent Ridge Road, Singapore 117543, Singapore},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-33646146180&partnerID=40&md5=e78fd0b13afaa7eee7fb0f6564d063cc}
}

@CONFERENCE{Jung20053207,
  author = {Jung, E.a , Kapoor, C.a , Batory, D.b },
  title = {Automatic code generation for actuator interfacing from a declarative
	specification},
  year = {2005},
  pages = {3207-3212},
  note = {cited By (since 1996) 1},
  abstract = {Common software design practices use object- oriented (OO) frameworks
	that structure software in terms of objects, classes, and packages;
	designers then create programs by inheritance and composition of
	classes and objects. Operational Software Components for Advanced
	Robotics (OSCAR) is one such framework for robot control software
	with abstractions for generalized kinematics, dynamics, performance
	criteria, decision making, and hardware interfacing. Even with OSCAR,
	writing new programs still requires a significant amount of manual
	labor. Feature-Oriented Programming (FOP) is method for software
	design that models and specifies programs in terms of features, where
	a feature encapsulates the common design decisions that occur in
	a domain. A set of features then forms a domain model for a Product
	Line Architecture. Product variants in this product line can then
	be generated from a declarative specification. FOP and related technologies
	are emerging software engineering techniques for automatically generating
	programs. Our research applies FOP to robot controller software.
	As an example, the domain of hardware interfacing is analyzed and
	41 features identified. A GUI for specifying and generating programs
	is presented as well. Analysis of features shows 200 possible different
	programs could be generated. © 2005 IEEE.},
  affiliation = {Dept. of Mechanical Engineering, Robotics Research Group, Austin,
	TX, United States; Dept. of Computer Science, Product Line Architecture
	Research Group, University of Texas at Austin, Austin, TX, United
	States},
  art_number = {1545465},
  author_keywords = {Feature oriented programming; Generative programming; Product line;
	Robotics},
  document_type = {Conference Paper},
  journal = {2005 IEEE/RSJ International Conference on Intelligent Robots and
	Systems, IROS},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-79956095750&partnerID=40&md5=276ee89f77f0e6d6ed293dd04f8ef943}
}

@ARTICLE{Jézéquel2011201,
  author = {Jézéquel, J.-M., Barais, O., Fleurey, F.},
  title = {Model driven language engineering with Kermeta},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2011},
  volume = {6491 LNCS},
  pages = {201-221},
  note = {cited By (since 1996) 0},
  abstract = {In many domains such as telecom, aerospace and automotive industries,
	engineers rely on Domain Specific Modeling Languages (DSML) to solve
	the complex issues of engineering safety critical software. Traditional
	Language Engineering starts with the grammar of a language to produce
	a variety of tools for processing programs expressed in this language.
	Recently however, many new languages tend to be first defined through
	metamodels, i.e. models describing their abstract syntax. Relying
	on well tooled standards such as E-MOF, this approach makes it possible
	to readily benefit from a set of tools such as reflexive editors,
	or XML serialization of models. This article aims at showing how
	Model Driven Engineering can easily complement these off-the-shelf
	tools to obtain a complete environment for such a language, including
	interpreter, compiler, pretty-printer and customizable editors. We
	illustrate the conceptual simplicity and elegance of this approach
	using the running example of the well known LOGO programming language,
	developed within the Kermeta environment. © 2011 Springer-Verlag.},
  affiliation = {INRIA, University of Rennes1, Campus Universitaire de Beaulieu, 35042
	Rennes Cedex, France},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-79251584021&partnerID=40&md5=ed4c08f7828e319fb61eb2f9ac05439c}
}

@ARTICLE{Jürjens200954,
  author = {Jürjens, J.},
  title = {A domain-specific language for cryptographic protocols based on streams},
  journal = {Journal of Logic and Algebraic Programming},
  year = {2009},
  volume = {78},
  pages = {54-73},
  number = {2},
  note = {cited By (since 1996) 1},
  abstract = {Developing security-critical systems is difficult and there are many
	well-known examples of security weaknesses exploited in practice.
	Thus a sound methodology supporting secure systems development is
	urgently needed. In particular, an important missing link in the
	construction of secure systems is finding a practical way to create
	reliably secure crypto protocol implementations. We present an approach
	that aims to address this need by making use of a domain-specific
	language for crypto protocol implementations. One can use this language
	to construct a compact and precise yet executable representation
	of a cryptographic protocol. This high-level program can be verified
	against the security goals using automated theorem provers for first
	order logic. One can then use it to provide assurance for legacy
	implementations of crypto protocols by generating test-cases. © 2008
	Elsevier Inc. All rights reserved.},
  affiliation = {Department of Computing, The Open University, GB},
  author_keywords = {Cryptographic protocols; Security analysis},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-57549106408&partnerID=40&md5=acc90f460df05fcb058b59de0209fbba}
}

@CONFERENCE{Kabanov2008189,
  author = {Kabanov, J., Raudjärv, R.},
  title = {Embedded typesafe domain specific languages for Java},
  year = {2008},
  pages = {189-197},
  note = {cited By (since 1996) 5},
  abstract = {Projects like jMock and Hibernate Criteria Query introduced embedded
	DSLs into Java. We describe two case studies in which we develop
	embedded typesafe DSLs for building SQL queries and engineering Java
	bytecode. We proceed to extract several patterns useful for developing
	typesafe DSLs for arbitrary domains. Unlike most previous Java DSLs
	we find that mixing the Fluent Interface idiom with static functions,
	metadata and closures provides for a better user experience than
	pure method chaining. We also make very liberal use of the Java 5
	Generics to improve the type safety properties of the DSLs. © 2008
	ACM.},
  affiliation = {Dept. of Computer Science, University of Tartu, Liivi 2, Tartu, Estonia},
  document_type = {Conference Paper},
  journal = {Principles and Practice of Programming in Java - Proceedings of the
	6th International Conference, PPPJ 2008},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-59249096516&partnerID=40&md5=ef2ed15e85cc6d5a8db83598a14fbc95}
}

@CONFERENCE{Kaewkasi2008,
  author = {Kaewkasi, C., Gurd, J.R.},
  title = {Groovy AOP: A dynamic AOP system for a JVM-based language},
  year = {2008},
  note = {cited By (since 1996) 0},
  abstract = {Groovy AOP is a general-purpose AOP system for Groovy, a JVM-based
	dynamic language. Groovy AOP provides a hybrid dynamic AOP implementation
	based on both metaprogramming and bytecode transformation. It implements
	the pointcut-advice model of AspectJ. Based on Groovy syntax, Groovy
	AOP introduces a domain-specific language for declaration of aspects,
	pointcut expressions, and advice. At runtime, it utilises the dynamic
	compilation capability of the JVM to convert advice codes woven by
	meta-programming into bytecodes. Preliminary results show that this
	dynamic weaving technique preserves the nature of a dynamic language,
	while reducing runtime overheads. Copyright © 2008 ACM.},
  affiliation = {School of Computer Science, University of Manchester, Manchester,
	United Kingdom},
  art_number = {3},
  author_keywords = {Aspect-oriented programming; Dynamic languages; Virtual machine},
  document_type = {Conference Paper},
  journal = {ACM International Conference Proceeding Series},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-59249090152&partnerID=40&md5=416161df012f7e954313bb4868064ae1}
}

@CONFERENCE{Kaiser200993,
  author = {Kaiser, M., Lammel, R.},
  title = {An isabelle/HOL-based model of stratego-like traversal strategies},
  year = {2009},
  pages = {93-104},
  note = {cited By (since 1996) 0},
  abstract = {Traversal strategies are at the heart of transformational programming
	with rewriting-based frameworks such as Stratego/XT or Tom and specific
	approaches for generic functional programming such as Strafunski
	or "Scrap your boilerplate". Such traversal strategies are distinctively
	based on one-layer traversal primitives from which traversal schemes
	are derived by recursive closure. We describe a mechanized, formal
	model of such strategies. The model covers two different semantics
	of strategies, strategic programming laws, termination conditions
	for strategy combinators as well as properties related to the success/failure
	behavior of strategies. The model has been mechanized in Isabelle/HOL.
	Copyright © 2009 ACM.},
  affiliation = {Software Languages Team, Universitat Koblenz-Landau},
  author_keywords = {Domain specific languages; Generic functional programming; Isabelle/HOL;
	Rewriting; Software transformation; Stratego; Traversal strategies},
  document_type = {Conference Paper},
  journal = {PPDP'09 - Proceedings of the 11th International ACM SIGPLAN Symposium
	on Principles and Practice of Declarative Programming},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-70450277247&partnerID=40&md5=e7f3a039ca90c11416d44ac2ef42f6a7}
}

@ARTICLE{Kakkar199987,
  author = {Kakkar, P., Hicks, M., Moore, J., Gunter, C.A.},
  title = {Specifying the PLAN network programming langauge},
  journal = {Electronic Notes in Theoretical Computer Science},
  year = {1999},
  volume = {26},
  pages = {87-104},
  note = {cited By (since 1996) 4},
  abstract = {We discuss how the specification of the PLAN programming language
	supports the design objectives of the language. The specification
	aims to provide a mathematically precise operational semantics that
	can serve as a standard for implementing interpreters and portable
	programs. The semantics should also support proofs of key properties
	of PLAN that would hold of all conformant implementations. This paper
	discusses two such properties. (1) Type checking is required, but
	interpreters are given significant flexibility about when types are
	checked; the specification must support a clear description of the
	possible behaviors of a network of conformant implementations. (2)
	It is essential to have guarantees about how PLAN programs use global
	resources, but the specification must be flexible about extensions
	in the network service layer. We illustrate on of kind of issue that
	will arise in using to specification to prove properties of the network
	based on the choice of services. © 1999 Published by Elsevier Science
	B.V.},
  affiliation = {Department of CIS University of Pennsylvania, Philadelphia, United
	States},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-0442270540&partnerID=40&md5=4cb3ca7b974eeeea014b34e14fbf78ca}
}

@ARTICLE{Kalgin2011166,
  author = {Kalgin, K.},
  title = {Domain specific language and translator for cellular automata models
	of physico-chemical processes},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2011},
  volume = {6873 LNCS},
  pages = {166-174},
  note = {cited By (since 1996) 0},
  abstract = {A new domain specific language CACHE and its translator into C and
	Processing are presented. The domain is a set of cellular automata
	models of physico-chemical processes. The language and the translator
	are intended for using by researchers studying such processes. The
	translator allows to obtain both serial and parallel programs on
	C language. Multicores and clusters as target parallel architectures
	are supported. Additionally, one can easily visualize the process
	interactively, create a movie, and publish a Java-applet in the Internet
	using Processing. © 2011 Springer-Verlag Berlin Heidelberg.},
  affiliation = {Supercomputer Software Department, Institute of Computational Mathematics
	and Mathematical Geophysics, Russian Academy of Sciences, Russian
	Federation},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-80053129882&partnerID=40&md5=c2f8b9d8d066c5ca6689e5271fc4df74}
}

@ARTICLE{Kalnina2009356,
  author = {Kalnina, E., Kalnins, A.},
  title = {DSL tool development with transformations and static mappings},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2009},
  volume = {5421},
  pages = {356-370},
  note = {cited By (since 1996) 1},
  abstract = {A tool development framework for domain-specific languages combining
	mapping and transformation based approaches is proposed in this research
	project. The combination of both approaches permits to use advantages
	and eliminate disadvantages as far as possible. First results are
	described including draft architecture for the framework implementing
	proposed ideas. A sketch of mapping definition facilities is presented.
	Initial implementation proposals are described as well. A template
	based graphical generation language Template MOLA for implementation
	algorithm description is introduced.},
  affiliation = {University of Latvia, IMCS, Raina bulvaris 29, LV-1459 Riga, Latvia},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-67650132992&partnerID=40&md5=4bca2a623c855695fe92774ea394e312}
}

@ARTICLE{Kamin1998149,
  author = {Kamin, S.N.},
  title = {Research on domain-specific embedded languages and program generators},
  journal = {Electronic Notes in Theoretical Computer Science},
  year = {1998},
  volume = {14},
  pages = {149-168},
  note = {cited By (since 1996) 3},
  abstract = {Embedding is the process of implementing a language by defining functions
	in an existing "host" Language; the host language with these added
	functions is the new language. As a consequence; the new language
	comes equipped with all the features of the host language, with no
	additional work on the part of the language designer. Embedding works
	particularly well when the host language is a functional language.
	We describe several examples of embedded languages. The first is
	a language for specifying simple pictures. The others are program
	generators, that is, languages used to specify programs in other
	languages. In all of these examples, the host language is Standard
	ML; in the program generating languages, the target language is C++.
	The power obtained from the host language is the main emphasis of
	our presentation. © 1998 Published by Elsevier Science B.V.},
  affiliation = {Computer Science Department, University of Illinois at Urbana-Champaign,
	Champaign, IL, United States},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-18944385795&partnerID=40&md5=3a85cc4994142f7c1cf4273879880da0}
}

@ARTICLE{Kandare2010419,
  author = {Kandare, G., Strmčnik, S., Godena, G.},
  title = {Domain specific model-based development of software for programmable
	logic controllers},
  journal = {Computers in Industry},
  year = {2010},
  volume = {61},
  pages = {419-431},
  number = {5},
  note = {cited By (since 1996) 0},
  abstract = {Procedural process control is responsible for coordination of control
	units that perform basic control in a typical industrial control
	system. Basic control, in turn, performs actions necessary for maintaining
	a desired state of process variables and equipment. Software in the
	domain of procedural process control consists of modules responsible
	for management of startup and shutdown sequences, exception handling
	and module communication. In this work we present the domain specific
	modeling language (DSL) ProcGraph together with its corresponding
	code generation tool that was designed for the development of software
	in the domain of procedural process control systems. The advantage
	of using a domain specific language is that not only the programmers,
	but also domain experts are able to understand and modify the code.
	The DSL code is self-documenting, as it is expressed in the idiom
	of the problem domain. In the article we present a formal description
	of the ProcGraph language. Furthermore, we describe how the formal
	model is used in the implementation of the automatic IEC 1131-3 code
	generator. © 2009 Elsevier B.V. All rights reserved.},
  affiliation = {Jozef Stefan Institute, Jamova 39, SI-1000 Ljubljana, Slovenia},
  author_keywords = {Domain specific languages; Procedural process control; Programable
	logic controllers; Software engineering},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-77953325325&partnerID=40&md5=3c2ac892a0a7c12e7015b34d31070471}
}

@CONFERENCE{Karaila2005158,
  author = {Karaila, M.a , Systä, T.b },
  title = {Maintenance and analysis of visual programs - An industrial case},
  year = {2005},
  pages = {158-167},
  note = {cited By (since 1996) 1},
  abstract = {A domain-specific visual language, Function Block Language (FBL),
	is used in Metso Automation for writing automation control programs.
	The same engineering environment is used for both forward and reverse
	engineering activities, providing convenient support for the maintenance
	and evolution of FBL programs. Various data and program analysis
	methods are applied to study the FBL programs stored in project library
	archives. Metadata stored about the program allows various kinds
	of queries and enables focusing the analysis to certain kinds of
	programs. The application of the provided analysis methods further
	aids the maintenance and reuse activities. Software and data reverse
	engineering techniques are traditionally used to support program
	and data comprehension, respectively. In this paper we show how corresponding
	techniques can be used to analyze visual programs. The visual language
	under study in this paper is FBL. FBL and the analysis techniques
	proposed have been used in real-world projects at Metso Automation.
	© 2005 IEEE.},
  affiliation = {Energy and Process Automation, Research and Technology Department,
	Metso Automation Inc., P.O.Box 237, FIN-33101, Tampere, Finland;
	Tampere University of Technology, Institute of Software Systems,
	P.O.Box 553, FIN-33101, Tampere, Finland},
  author_keywords = {Domain Specific Languages; Maintenance; Reverse Engineering; Visual
	Programming},
  document_type = {Conference Paper},
  journal = {Proceedings of the European Conference on Software Maintenance and
	Reengineering, CSMR},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-26844505117&partnerID=40&md5=4fc6aac428519b29607cc0015a7aecdb}
}

@ARTICLE{Karaila200529,
  author = {Karaila, M.a , Systä, T.b },
  title = {On the role of metadata in visual language reuse and reverse engineering
	- An industrial case},
  journal = {Electronic Notes in Theoretical Computer Science},
  year = {2005},
  volume = {137},
  pages = {29-41},
  number = {3},
  note = {cited By (since 1996) 1},
  abstract = {Collecting metadata on a family of programs is useful not only for
	generating statistical data on the programs but also for future re-engineering
	and reuse purposes. In this paper we discuss an industrial case where
	a project library is used to store visual programs and a database
	to store the metadata on these programs. The visual language in question
	is a domain-specific language, Function Block Language (FBL) that
	is used in Metso Automation for writing automation control programs.
	For reuse, program analysis and re-engineering activities and various
	data and program analysis methods are applied to study the FBL programs.
	Metadata stored in a database is used to provide advanced program
	analysis support; from the large amount of programs, the metadata
	allows focusing the analysis to certain kinds of programs. In this
	paper, we discuss the role and usage of the metadata in program analysis
	techniques applied to FBL programs. © 2005 Elsevier B.V. All rights
	reserved.},
  affiliation = {Energy and Process Automation, Research and Technology Department,
	Metso Automation Inc., P.O.Box 237, FIN-33101, Tampere, Finland;
	Institute of Software Systems, Tampere University of Technology,
	P.O.Box 553, FIN-33101, Tampere, Finland},
  author_keywords = {Domain-specific languages; Metadata-driven program analysis; Reuse;
	Reverse engineering; Visual languages},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-24344440799&partnerID=40&md5=a4b1fed0de4fa15c7602e746c73c4a06}
}

@CONFERENCE{Karakoidas2009109,
  author = {Karakoidas, V., Spinellis, D.},
  title = {J%: Integrating Domain Specific Languages with Java},
  year = {2009},
  pages = {109-113},
  note = {cited By (since 1996) 0},
  abstract = {J% (J-mod), is a Java language extension that supports integration
	with Domain-Specific Languages. The integration is realized through
	an architecture that permits external modules to support DSLs. The
	DSL statements can be syntactically checked at compile-time. An additional
	facility allows the static type checking of Java variables that appear
	within DSL code. To support this process each DSL module comes as
	a library that is used both at compile time and during program execution.
	© 2009 IEEE.},
  affiliation = {Department of Management Science and Technology, Athens University
	of Economics and Business},
  art_number = {5298887},
  document_type = {Conference Paper},
  journal = {PCI 2009 - 13th Panhellenic Conference on Informatics},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-70849122238&partnerID=40&md5=52e6c7ad507a4ea4884ffd393eb5c33c}
}

@ARTICLE{Karakoidas2008557,
  author = {Karakoidas, V., Spinellis, D.},
  title = {FIRE/J - Optimizing regular expression searches with generative programming},
  journal = {Software - Practice and Experience},
  year = {2008},
  volume = {38},
  pages = {557-573},
  number = {6},
  note = {cited By (since 1996) 0},
  abstract = {Regular expressions are a powerful tool for analyzing and manipulating
	text. Their theoretical background lies within automata theory and
	formal languages. The FIRE/J (fast implementation of regular expressions
	for Java) regular expression library is designed to provide maximum
	execution speed while remaining portable across different machine
	architectures. To achieve that, FIRE/J transforms each regular expression
	into a tailor-made class file, which is compiled directly to Java
	virtual machine (JVM) bytecodes. The library is compatible with the
	POSIX standard. Copyright © 2007 John Wiley & Sons, Ltd.},
  affiliation = {Department of Management Science and Technology, Athens University
	of Economics and Business, Patission Ave 74, GR-10434, Athens, Greece},
  author_keywords = {Automata; Domainspecific languages (DSL); Generative programming;
	Java; Java virtual machine (JVM); Just-in time (JIT); Regular expressions},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-43949093090&partnerID=40&md5=27c6d9362c919d9a2383775ac4fc2584}
}

@CONFERENCE{Kardas2010,
  author = {Kardas, G.a , Demirezen, Z.b , Challenger, M.a },
  title = {Towards a DSML for semantic web enabled multi-agent systems},
  year = {2010},
  note = {cited By (since 1996) 0},
  abstract = {Software agents are considered as autonomous software components which
	are capable of acting to meet its design objectives. To perform their
	tasks and interact with each other, agents constitute systems called
	Multi-agent systems (MAS). Although agent researchers have a great
	effort in MAS metamodeling and model-driven MAS development, a significant
	deficiency exists in current studies when we consider providing a
	complete Domain Specific Modeling Language (DSML) for MASs. We believe
	that a DSML increases the descriptive power of a MAS metamodel, defines
	the system semantics and hence supports a more fruitful methodology
	for the development of MASs especially working on the new challenging
	environments such as the Semantic Web. In this paper, we introduce
	a new DSML for MASs with its abstract syntax, the textual concrete
	syntax and the interpreter mechanism. The practical use of the DSML
	is illustrated with a case study which considers the modeling of
	a multi-agent based e-barter system. Copyright 2010 ACM.},
  affiliation = {International Computer Institute, Ege University, 35100 Bornova, Izmir,
	Turkey; Department of Computer and Information Sciences, University
	of Alabama, Birmingham, AL 35294-1170, United States},
  art_number = {1},
  author_keywords = {Domain specific modeling language; Metamodel; Model-driven engineering;
	Multi-agent system; Semantic web},
  document_type = {Conference Paper},
  journal = {ECOOP 2010 Workshop Proceedings - International Workshop on Formalization
	of Modeling Languages, FML'10},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-79952712328&partnerID=40&md5=c059eea66bb08d0e2c7d9c89693862e4}
}

@ARTICLE{Kariotis200999,
  author = {Kariotis, P.S., Procter, A.M., Harrison, W.L.},
  title = {Making monads first-class with template Haskell?},
  journal = {ACM SIGPLAN Notices},
  year = {2009},
  volume = {44},
  pages = {99-110},
  number = {2},
  note = {cited By (since 1996) 0},
  abstract = {Monads as an organizing principle for programming and semantics are
	notoriously difficult to grasp, yet they are a central and powerful
	abstraction in Haskell. This paper introduces a domain-specific language,
	MonadLab, that simplifies the construction of monads, and describes
	its implementation in Template Haskell. MonadLab makes monad construction
	truly first class, meaning that arcane theoretical issues with respect
	to monad transformers are completely hidden from the programmer.
	The motivation behind the design of MonadLab is to make monadic programming
	in Haskell simpler while providing a tool for non-Haskell experts
	that will assist them in understanding this powerful abstraction.
	Copyright © 2008 ACM.},
  affiliation = {Department of Computer Science, University of Missouri, Columbia,
	MO, United States},
  author_keywords = {Domain-specific languages; Monads; Staged programming},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-67650812100&partnerID=40&md5=5d17e1be33d14d492ba3117f9c3e908b}
}

@CONFERENCE{Kariotis200899,
  author = {Kariotis, P.S., Procter, A.M., Harrison, W.L.},
  title = {Making monads first-class with template Haskell},
  year = {2008},
  pages = {99-110},
  note = {cited By (since 1996) 2},
  abstract = {Monads as an organizing principle for programming and semantics are
	notoriously difficult to grasp, yet they are a central and powerful
	abstraction in Haskell. This paper introduces a domain-specific language,
	MonadLab, that simplifies the construction of monads, and describes
	its implementation in Template Haskell. MonadLab makes monad construction
	truly first class, meaning that arcane theoretical issues with respect
	to monad transformers are completely hidden from the programmer.
	The motivation behind the design of MonadLab is to make monadic programming
	in Haskell simpler while providing a tool for non-Haskell experts
	that will assist them in understanding this powerful abstraction.
	Copyright © 2008 ACM.},
  affiliation = {Department of Computer Science, University of Missouri, Columbia,
	MO, United States},
  author_keywords = {Domain-specific languages; Monads; Staged programming},
  document_type = {Conference Paper},
  journal = {Haskell'08 - Proceedings of the ACM SIGPLAN 2008 Haskell Symposium},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-63149130073&partnerID=40&md5=fce3646ef57b13d2bd43a22a6240a6d1}
}

@CONFERENCE{Karrenberg2011141,
  author = {Karrenberg, R., Hack, S.},
  title = {Whole-function vectorization},
  year = {2011},
  pages = {141-150},
  note = {cited By (since 1996) 0},
  abstract = {Data-parallel programming languages are an important component in
	today's parallel computing landscape. Among those are domain-specific
	languages like shading languages in graphics (HLSL, GLSL, RenderMan,
	etc.) and "general-purpose" languages like CUDA or OpenCL. Current
	implementations of those languages on CPUs solely rely on multi-threading
	to implement parallelism and ignore the additional intra-core parallelism
	provided by the SIMD instruction set of those processors (like Intel's
	SSE and the upcoming AVX or Larrabee instruction sets). In this paper,
	we discuss several aspects of implementing dataparallel languages
	on machines with SIMD instruction sets. Our main contribution is
	a language- and platform-independent code transformation that performs
	whole-function vectorization on low-level intermediate code given
	by a control flow graph in SSA form. We evaluate our technique in
	two scenarios: First, incorporated in a compiler for a domain-specific
	language used in realtime ray tracing. Second, in a stand-alone OpenCL
	driver. We observe average speedup factors of 3.9 for the ray tracer
	and factors between 0.6 and 5.2 for different OpenCL kernels. © 2011
	IEEE.},
  affiliation = {Saarland University, Germany},
  art_number = {5764682},
  document_type = {Conference Paper},
  journal = {Proceedings - International Symposium on Code Generation and Optimization,
	CGO 2011},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-79957502935&partnerID=40&md5=acb1a64371c5b097f064bc6cebf537a2}
}

@ARTICLE{Karsai2004243,
  author = {Karsai, G., Agrawal, A.},
  title = {Graph transformationsin OMG's model-driven architecture (Invited
	Talk)},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2004},
  volume = {3062},
  pages = {243-259},
  note = {cited By (since 1996) 3},
  abstract = {The Model-DrivenArchitecture (MDA) vision of the Object Management
	Group offers a unique opportunity for introducing Graph Transformation
	(GT) technology to the software industry. The paper proposes a domain-specific
	refinement of MDA, and describes a practical manifestation of MDA
	called Model-Integrated Computing (MIC). MIC extends MDA towards
	domain-specific modeling languages, and it is well supported by various
	generic tools that include model transformation tools based on graph
	transformations. The MIC tools are metaprogrammable, i.e. they can
	be tailored for specific domains using metamodels that include metamodels
	of transformations. The paper describes the development process and
	the supporting tools of MIC, and it raises a number of issues for
	future research on GT in MDA. ©Springer-Verlag 2004.},
  affiliation = {Institute Forsoftware Integrated Systems (ISIS), Vanderbilt University,
	Nashville, TN, United States},
  author_keywords = {Domain-specific modeling languages; Formal specifications; Graph transformations;
	Graphgrammars; Model-driven architecture; Model-integrated computing},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-21144441196&partnerID=40&md5=d33d73e509c3479f177494ac0cee7c39}
}

@ARTICLE{Karsai20031296,
  author = {Karsai, G., Agrawal, A., Shi, F., Sprinkle, J.},
  title = {On the use of graph transformation in the formal specification of
	model interpreters},
  journal = {Journal of Universal Computer Science},
  year = {2003},
  volume = {9},
  pages = {1296-1321},
  number = {11},
  note = {cited By (since 1996) 59},
  abstract = {Model-based development necessitates the transformation of models
	between different stages and tools of the design process. These transformations
	must be precisely, preferably formally, specified, such that end-to-end
	semantic interoperability is maintained. The paper introduces a graph-transformation-
	based technique for specifying these model transformations, gives
	a formal definition for the semantics of the transformation language,
	describes an implementation of the language, and illustrates its
	use through an example. © J.UCS.},
  affiliation = {Institute for Software Integrated Systems (ISIS), Vanderbilt University,
	Nashville, TN, United States},
  author_keywords = {Domain-specific modeling languages; Formal specifications; Graph grammars;
	Graph transformations; Model-driven architecture; Model-Integrated
	Computing},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-23844447942&partnerID=40&md5=228ee58c382420933cf943136a9de492}
}

@ARTICLE{Karsai2005157,
  author = {Karsai, G., Lang, A., Neema, S.},
  title = {Design patterns for open tool integration},
  journal = {Software and Systems Modeling},
  year = {2005},
  volume = {4},
  pages = {157-170},
  number = {2},
  note = {cited By (since 1996) 13},
  abstract = {Design tool integration is a highly relevant area of software engineering
	that can greatly improve the efficiency of development processes.
	Design patterns have been widely recognized as important contributors
	to the success of software systems. This paper describes and compares
	two large-grain, architectural design patterns that solve specific
	design tool integration problems. Both patterns have been implemented
	and used in real-life engineering processes. © Springer-Verlag 2004.},
  affiliation = {Institute for Software-Integrated Systems, Vanderbilt University,
	P.O. Box 1829B, Nashville, TN 37235, United States},
  author_keywords = {Design patterns; Generative programming; Metamodels; Software architecture;
	Tool integration framework},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-19644393677&partnerID=40&md5=f3a0b4aaa82b362f962eaf6904bc1968}
}

@ARTICLE{Kastens20065,
  author = {Kastens, U., Schmidt, C.},
  title = {Visual patterns associated to abstract trees},
  journal = {Electronic Notes in Theoretical Computer Science},
  year = {2006},
  volume = {148},
  pages = {5-18},
  number = {1 SPEC. ISS.},
  note = {cited By (since 1996) 0},
  abstract = {Visual languages have an important role in modeling systems, specification
	of software, and in specific application domains. By using visual
	properties like spatial placement or line connections complex structures
	can be presented, so that humans can understand them quickly. Visual
	languages can be based on domain-specific metaphors, so that domain
	specialists can use their conventional way of description and abstraction.
	For working with a visual language, a specialized graphical frontend
	is needed. In contrast to textual languages, general purpose editors
	are insufficient for visual languages, because each visual language
	has its particular graphical requirements. The frontend should provide
	methods to aid efficient drawing and restructuring of visual expressions.
	Often, language-specific structure editors are used as frontends
	for visual languages. The visual program is stored in a language-dependent
	data structure. The user interacts with one or more visual representations.
	Edit operations are directly applied to the underlying structure
	and after a change the graphical representation is recomputed. The
	implementation of visual languages requires a wide range of conceptual
	and technical knowledge from issues of user interface design and
	graphical implementation to aspects of analysis and transformation
	for languages in general. We present a powerful toolset that incorporates
	such knowledge [C. Schmidt and U. Kastens. Implementation of visual
	languages using pattern-based specifications. Software - Practice
	and Experience, 35(2):121-131, Nov. 2003]. It generates editors from
	high level specifications: A language is specified by identifying
	certain patterns in the language structure, selecting a visual representation
	from a set of precoined solutions, and associating the pattern to
	constructs of the abstract grammar. A complete visual structure editor
	is generated from such a specification. It represents visual programs
	by attributed abstract trees. Therefore, further phases of processing
	visual programs can be generated by state-of-the-art tools for compiler
	construction. Even challenging visual languages can be implemented
	with reasonable small effort and with rather limited technical knowledge.
	The approach is suitable for a large variety of visual language styles.
	© 2006 Elsevier B.V. All rights reserved.},
  affiliation = {Universität Paderborn, Fakultät für Elektrotechnik, Informatik und
	Mathematik, Fürstenallee 11, 33102 Paderborn},
  author_keywords = {Domain specific languages; Graphical user interface; Trees; Visual
	languages},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-31044439531&partnerID=40&md5=4567738b284bf6e83ade3a1eb06bc216}
}

@CONFERENCE{Kats2010,
  author = {Kats, L.C.L., Visser, E.},
  title = {The spoofax language workbench: Rules for declarative specification
	of languages and IDEs},
  year = {2010},
  pages = {444-463},
  note = {cited By (since 1996) 2},
  abstract = {Spoofax is a language workbench for efficient, agile development of
	textual domain-specific languages with state-of-the-art IDE support.
	Spoofax integrates language processing techniques for parser generation,
	meta-programming, and IDE development into a single environment.
	It uses concise, declarative specifications for languages and IDE
	services. In this paper we describe the architecture of Spoofax and
	introduce idioms for high-level specifications of language semantics
	using rewrite rules, showing how analyses can be reused for transformations,
	code generation, and editor services such as error marking, reference
	resolving, and content completion. The implementation of these services
	is supported by language-parametric editor service classes that can
	be dynamically loaded by the Eclipse IDE, allowing new languages
	to be developed and used side-by-side in the same Eclipse environment.
	© 2010 ACM.},
  affiliation = {Delft University of Technology, Netherlands},
  author_keywords = {Languages},
  document_type = {Conference Paper},
  journal = {Proceedings of the Conference on Object-Oriented Programming Systems,
	Languages, and Applications, OOPSLA},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-78650135500&partnerID=40&md5=77162c2b191474147ab7b1fe5e4e68ca}
}

@CONFERENCE{Kats2010237,
  author = {Kats, L.C.L., Visser, E.},
  title = {The spoofax language workbench},
  year = {2010},
  pages = {237-238},
  note = {cited By (since 1996) 0},
  abstract = {Spoofax is a language workbench for efficient, agile development of
	textual domain-specific languages with state-of-the-art IDE support.
	It provides a comprehensive environment that integrates syntax definition,
	program transformation, code generation, and declarative specification
	of IDE components.},
  affiliation = {Delft University of Technology, Netherlands},
  author_keywords = {Languages},
  document_type = {Conference Paper},
  journal = {Proceedings of the ACM International Conference Companion on Object
	Oriented Programming Systems Languages and Applications Companion,
	SPLASH '10},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-78650149094&partnerID=40&md5=ad9834ac869e68525451b08d0bc97e9e}
}

@ARTICLE{Kats2010444,
  author = {Kats, L.C.L., Visser, E.},
  title = {The spoofax language workbench: Rules for declarative specification
	of languages and IDEs},
  journal = {ACM SIGPLAN Notices},
  year = {2010},
  volume = {45},
  pages = {444-463},
  number = {10},
  note = {cited By (since 1996) 3},
  abstract = {Spoofax is a language workbench for efficient, agile development of
	textual domain-specific languages with state-ofthe-art IDE support.
	Spoofax integrates language processing techniques for parser generation,
	meta-programming, and IDE development into a single environment.
	It uses concise, declarative specifications for languages and IDE
	services. In this paper we describe the architecture of Spoofax and
	introduce idioms for high-level specifications of language semantics
	using rewrite rules, showing how analyses can be reused for transformations,
	code generation, and editor services such as error marking, reference
	resolving, and content completion. The implementation of these services
	is supported by language-parametric editor service classes that can
	be dynamically loaded by the Eclipse IDE, allowing new languages
	to be developed and used side-by-side in the same Eclipse environment.
	Copyright © 2010 ACM.},
  affiliation = {Delft University of Technology, Netherlands},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-79551667411&partnerID=40&md5=377c3fdd6d8ede286e689b08eea765e7}
}

@CONFERENCE{Kats2008,
  author = {Kats, L.C.L.a , Bravenboer, M.b , Visser, E.a },
  title = {Mixing source and bytecode a case for compilation by normalization},
  year = {2008},
  pages = {91-107},
  note = {cited By (since 1996) 3},
  abstract = {Language extensions increase programmer productivity by providing
	concise, often domain-specific syntax, and support for static verification
	of correctness, security, and style constraints. Language extensions
	can often be realized through translation to the base language, supported
	by preprocessors and extensible compilers. However, various kinds
	of extensions require further adaptation of a base compiler's internal
	stages and components, for example to support separate compilation
	or to make use of low-level primitives of the platform (e.g., jump
	instructions or unbalanced synchronization). To allow for a more
	loosely coupled approach, we propose an open compiler model based
	on normalization steps from a high-level language to a subset of
	it, the core language. We developed such a compiler for a mixed Java
	and (core) bytecode language, and evaluate its effectiveness for
	composition mechanisms such as traits, as well as statement-level
	and expression-level language extensions. Copyright © 2008 ACM.},
  affiliation = {Department of Software Technology, Delft University of Technology,
	Netherlands; Department of Computer and Information Science, University
	of Oregon, United States},
  author_keywords = {Bytecode; Compilers; Domain-specific languages; Dryad compiler; Embedded
	languages; Iterators; Java; Language extensions; Meta programming;
	SDF; Source tracing; Stratego; Traits},
  document_type = {Conference Paper},
  journal = {Proceedings of the Conference on Object-Oriented Programming Systems,
	Languages, and Applications, OOPSLA},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-63549097326&partnerID=40&md5=edf38c271079b783a120f4b26a67e254}
}

@ARTICLE{Kats200891,
  author = {Kats, L.C.L.a , Bravenboer, M.b , Visser, E.a },
  title = {Mixing source and bytecode a case for compilation by normalization},
  journal = {ACM SIGPLAN Notices},
  year = {2008},
  volume = {43},
  pages = {91-107},
  number = {10},
  note = {cited By (since 1996) 1},
  abstract = {Language extensions increase programmer productivity by providing
	concise, often domain-specific syntax, and support for static verification
	of correctness, security, and style constraints. Language extensions
	can often be realized through translation to the base language, supported
	by preprocessors and extensible compilers. However, various kinds
	of extensions require further adaptation of a base compiler's internal
	stages and components, for example to support separate compilation
	or to make use of low-level primitives of the platform (e.g., jump
	instructions or unbalanced synchronization). To allow for a more
	loosely coupled approach, we propose an open compiler model based
	on normalization steps from a high-level language to a subset of
	it, the core language. We developed such a compiler for a mixed Java
	and (core) bytecode language, and evaluate its effectiveness for
	composition mechanisms such as traits, as well as statement-level
	and expression-level language extensions. Copyright © 2008 ACM.},
  affiliation = {Department of Software Technology, Delft University of Technology,
	Netherlands; Department of Computer and Information Science, University
	of Oregon, United States},
  author_keywords = {Bytecode; Compilers; Domain-specific languages; Dryad compiler; Embedded
	languages; Iterators; Java; Language extensions; Meta programming;
	SDF; Source tracing; Stratego; Traits},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-67650073142&partnerID=40&md5=47f1d8d6da518e9d28f88e4497ce433c}
}

@ARTICLE{Kats2010149,
  author = {Kats, L.C.L.a , Kalleberg, K.T.b , Visser, E.a },
  title = {Domain-specific languages for composable editor plugins},
  journal = {Electronic Notes in Theoretical Computer Science},
  year = {2010},
  volume = {253},
  pages = {149-163},
  number = {7},
  note = {cited By (since 1996) 0},
  abstract = {Modern IDEs increase developer productivity by incorporating many
	different kinds of editor services. These can be purely syntactic,
	such as syntax highlighting, code folding, and an outline for navigation;
	or they can be based on the language semantics, such as in-line type
	error reporting and resolving identifier declarations. Building all
	these services from scratch requires both the extensive knowledge
	of the sometimes complicated and highly interdependent APIs and extension
	mechanisms of an IDE framework, and an in-depth understanding of
	the structure and semantics of the targeted language. This paper
	describes Spoofax/IMP, a meta-tooling suite that provides high-level
	domain-specific languages for describing editor services, relieving
	editor developers from much of the framework-specific programming.
	Editor services are defined as composable modules of rules coupled
	to a modular SDF grammar. The composability provided by the SGLR
	parser and the declaratively defined services allows embedded languages
	and language extensions to be easily formulated as additional rules
	extending an existing language definition. The service definitions
	are used to generate Eclipse editor plugins. We discuss two examples:
	an editor plugin for WebDSL, a domain-specific language for web applications,
	and the embedding of WebDSL in Stratego, used for expressing the
	(static) semantic rules of WebDSL. © 2010 Elsevier B.V. All rights
	reserved.},
  affiliation = {Department of Software Technology, Delft University of Technology,
	Delft, Netherlands; Faculty of Medicine, University of Bergen, Bergen,
	Norway},
  author_keywords = {Domain specific language; editor plugin; integrated development environment},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-77956408206&partnerID=40&md5=a805745c0943b6ae52fa93e1c017b9ca}
}

@CONFERENCE{Kats2011139,
  author = {Kats, L.C.L.a , Vermaas, R.b , Visser, E.a },
  title = {Integrated language definition testing: Enabling Test-Driven Language
	Development},
  year = {2011},
  pages = {139-153},
  note = {cited By (since 1996) 0},
  abstract = {The reliability of compilers, interpreters, and development environments
	for programming languages is essential for effective software development
	and maintenance. They are often tested only as an afterthought. Languages
	with a smaller scope, such as domain-specific languages, often remain
	untested. General-purpose testing techniques and test case generation
	methods fall short in providing a low-threshold solution for test-driven
	language development. In this paper we introduce the notion of a
	language-parametric testing language (LPTL) that provides a reusable,
	generic basis for declaratively specifying language definition tests.
	We integrate the syntax, semantics, and editor services of a language
	under test into the LPTL for writing test inputs. This paper describes
	the design of an LPTL and the tool support provided for it, shows
	use cases using examples, and describes our implementation in the
	form of the Spoofax testing language. Copyright is held by the author
	/ owner(s).},
  affiliation = {Delft University of Technology, Netherlands; LogicBlox, Netherlands},
  author_keywords = {Compilers; Domain-specific language; Grammarware; Language embedding;
	Language engineering; Language workbench; Parsers; Test-driven development;
	Testing},
  document_type = {Conference Paper},
  journal = {Proceedings of the Conference on Object-Oriented Programming Systems,
	Languages, and Applications, OOPSLA},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-81455154925&partnerID=40&md5=a1fda534cbd226b1489b56198b0ff501}
}

@CONFERENCE{Kats201125,
  author = {Kats, L.C.L.a , Vermaas, R.b , Visser, E.a },
  title = {Testing domain-specific languages},
  year = {2011},
  pages = {25-26},
  note = {cited By (since 1996) 0},
  abstract = {The Spoofax testing language provides a new approach to testing domain-specific
	languages as they are developed. It allows test cases to be written
	using fragments of the language under test, providing full IDE support
	for writing test cases and supporting tests for language syntax,
	semantics, and editor services.},
  affiliation = {Delft University of Technology, Netherlands; LogicBlox, Netherlands},
  author_keywords = {Compilers; Domain-specific language; Grammarware; Language embedding;
	Language engineering; Language workbench; Parsers; Test-driven development;
	Testing},
  document_type = {Conference Paper},
  journal = {SPLASH'11 Compilation - Proceedings of OOPSLA'11, Onward! 2011, GPCE'11,
	DLS'11, and SPLASH'11 Companion},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-81355123393&partnerID=40&md5=2a2c50283d4320bf3291edee4bc28adf}
}

@CONFERENCE{Kavimandan2007,
  author = {Kavimandan, A., Gokhale, A.},
  title = {Automated middleware QoS configuration techniques using model transformations},
  year = {2007},
  note = {cited By (since 1996) 0},
  abstract = {This paper provides following three contributions to the study of
	developing and applying model driven engineering (MDE) techniques
	to Quality of Service (QoS) configuration of distributed real-time
	and embedded (DRE) systems. First, we describe the challenges associated
	with mapping domain-level QoS policies of DRE systems to middleware
	configuration space. Second, we discuss a domain specific modeling
	language (DSML) to capture QoS requirements of DRE system at a higher
	level of abstraction, simplifying the system QoS specification process.
	Third, we describe model transformations to automate the mapping
	of domain-specific QoS requirements.Our results indicate that our
	approach provides significant benefits in terms of productivity,
	scalability, reusability and automation of middleware QoS mapping
	compared to traditional QoS configuration techniques for publish/subscribe-based
	DRE systems. ©2008 IEEE.},
  affiliation = {Dept. of EECS, Vanderbilt University, Nashville, TN, United States},
  art_number = {4566948},
  document_type = {Conference Paper},
  journal = {Proceedings - IEEE International Enterprise Distributed Object Computing
	Workshop, EDOC},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-52049106833&partnerID=40&md5=3167158b99aac0b2a03acebd32967d2d}
}

@ARTICLE{Keller2007116,
  author = {Keller, G.a , Chaffey-Millar, H.b , Chakravarty, M.M.T.a , Stewart,
	D.a , Barner-Kowollik, C.b },
  title = {Specialising simulator generators for high-performance Monte-Carlo
	methods},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2007},
  volume = {4902 LNCS},
  pages = {116-132},
  note = {cited By (since 1996) 0},
  abstract = {We address the tension between software generality and performance
	in the domain of simulations based on Monte-Carlo methods. We simultaneously
	achieve generality and high performance by a novel development methodology
	and software architecture centred around the concept of a specialising
	simulator generator. Our approach combines and extends methods from
	functional programming, generative programming, partial evaluation,
	and runtime code generation. We also show how to generate parallelised
	simulators. We evaluated our approach by implementing a simulator
	for advanced forms of polymerisation kinetics. We achieved unprecedented
	performance, making Monte-Carlo methods practically useful in an
	area that was previously dominated by deterministic PDE solvers.
	This is of high practical relevance, as Monte-Carlo simulations can
	provide detailed microscopic information that cannot be obtained
	with deterministic solvers. © Springer-Verlag Berlin Heidelberg 2008.},
  affiliation = {Programming Languages and Systems, School of Computer Science and
	Engineering, University of New South Wales; Centre for Advanced Macromolecular
	Design, School of Chemical Sciences and Engineering, University of
	New South Wales},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-38549142856&partnerID=40&md5=4719a6e0b38fb49d2bdca3860a3db31f}
}

@CONFERENCE{Keller20074508,
  author = {Keller, R.E., Poli, R.},
  title = {Linear genetic programming of parsimonious metaheuristics},
  year = {2007},
  pages = {4508-4515},
  note = {cited By (since 1996) 4},
  abstract = {We use a form of grammar-based linear Genetic Programming (GP) as
	a hyperheuristic, i.e., a search heuristic on the space of heuristics.
	This technique is guided by domain-specific languages that one designs
	taking inspiration from elementary components of specialised heuristics
	and metaheuristics for a domain. We demonstrate this approach for
	traveling-salesperson problems for which we test different languages,
	including one containing a looping construct. Experimentation with
	benchmark instances from the TSPLIB shows that the GP hyperheuristic
	routinely and rapidly produces parsimonious metaheuristics that find
	tours whose lengths are highly competitive with the best real-valued
	lengths from literature. © 2007 IEEE.},
  affiliation = {Department of Computer Science, University of Essex, United Kingdom},
  art_number = {4425062},
  document_type = {Conference Paper},
  journal = {2007 IEEE Congress on Evolutionary Computation, CEC 2007},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-55749111191&partnerID=40&md5=1dd0a298ce393cd4389d84ae3495e9a4}
}

@CONFERENCE{Kennedy200718,
  author = {Kennedy, A.D., Binoth, T., Rippon, T.},
  title = {Automating renormalization of quantum field theories},
  year = {2007},
  pages = {18-27},
  note = {cited By (since 1996) 0},
  abstract = {We give an overview of state-of-the-art multi-loop Feynman diagram
	computations, and explain how we use symbolic manipulation to generate
	renormalized integrals that are then evaluated numerically. We explain
	how we automate BPHZ renormalization using "henges" and "sectors",
	and give a brief description of the symbolic tensor and Dirac -matrix
	manipulation that is required. We shall compare the use of general
	computer algebra systems such as Maple with domain-specific languages
	such as FORM highlighting in particular memory management issues.
	Copyright 2007 ACM.},
  affiliation = {School of Physics, University of Edinburgh, King's Buildings, Mayfield
	Road, Edinburgh, EH9 3JZ, United Kingdom},
  author_keywords = {Feynman diagrams; Quantum field theory; Renormalization theory},
  document_type = {Conference Paper},
  journal = {SNC'07 - Proceedings of the 2007 International Workshop on Symbolic-Numeric
	Computation},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-36448983520&partnerID=40&md5=f4a22162099d3ecee3d5482eecfc5c26}
}

@ARTICLE{Kent20039,
  author = {Kent, S.},
  title = {Model driven language engineering},
  journal = {Electronic Notes in Theoretical Computer Science},
  year = {2003},
  volume = {72},
  pages = {9},
  number = {4},
  note = {cited By (since 1996) 0},
  abstract = {Model driven approaches to software engineering are discussed. These
	methods help to make business, architecture and design models that
	are not discarded once the code gets built, but can be exercised
	independently. This is valuable when an application needs to be updated
	and changed, as up-to-date models will help to understand and evolve
	using the same abstractions originally used to build it. Model driven
	language engineering is required to support the model driven software
	engineering.},
  affiliation = {University of Kent at, Canterbury, United Kingdom},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-18944395455&partnerID=40&md5=165a4931c5f2bfbc9047dde659089560}
}

@CONFERENCE{Kerzhner20101399,
  author = {Kerzhner, A.A., Paredis, C.J.J.},
  title = {Using domain specific languages to capture design synthesis knowledge
	for model-based systems engineering},
  year = {2010},
  volume = {2},
  number = {PART B},
  pages = {1399-1409},
  note = {cited By (since 1996) 0},
  abstract = {Design synthesis is a fundamental engineering task that involves the
	generation of a structural specification from a desired functional
	specification. Although the use of computer tools is common throughout
	the design process, design synthesis is often a task left to the
	designer. Formally capturing design synthesis knowledge in models
	and applying computational synthesis may result in better exploration
	of the design space and eliminate repetitive design tasks. In this
	paper, a graph-based framework for capturing and combining design
	synthesis knowledge is presented for scenarios involving the composition
	of well defined components into larger systems. This approach fits
	in the context of Model-Based Systems Engineering where a variety
	of formal models are used to represent knowledge about a system.
	This approach uses the Systems Modeling Language developed by The
	Object Management Group (OMG SysML™ to define both models of possible
	components and possible system architectures. The framework is illustrated
	by combining it with an evolutionary algorithm and applying it to
	an example problem of hydraulic circuit synthesis. Copyright © 2009
	by ASME.},
  affiliation = {Systems Realization Laboratory, Georgia Institute of Technology, G.W.
	Woodruff School of Mechanical Engineering, Atlanta, GA 30332, United
	States},
  document_type = {Conference Paper},
  journal = {Proceedings of the ASME International Design Engineering Technical
	Conferences and Computers and Information in Engineering Conference
	2009, DETC2009},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-77953745482&partnerID=40&md5=dcdaf0c246d3da7048d4c94ef758e946}
}

@CONFERENCE{Kiczales200714,
  author = {Kiczales, G.},
  title = {Making the code look like the design - Aspects and other recent work},
  year = {2007},
  pages = {14},
  note = {cited By (since 1996) 0},
  abstract = {The idea that programs should clearly reflect the design decisions
	they embody has a long history. Higher-level languages, syntactic
	macros, domain-specific languages, and intentional programming are
	different approaches to this common goal. Recent work from several
	areas, including aspect-oriented programming, has significantly advanced
	our ability to make code expressive. At the same time, it forces
	us to reconsider a number of basic assumptions, including what is
	a program, what is a module, what is a language, and what is an editor.
	Gregor Kiczales is Professor of Computer Science at the University
	of British Columbia. His work is directed at enabling programmers
	to write programs that, as much as possible, look like their design.
	He has pursued this goal in a number of projects. He led the Xerox
	PARC teams that developed aspect-oriented programming and AspectJ.
	He is author, with Danny Bobrow and Jim des Rivieres of "The Art
	of the Metaobject Protocol". He was one of the designers of the Common
	Lisp Object System (CLOS), and developed the standard PCL implementation
	of CLOS. © 2007 IEEE.},
  affiliation = {University of British Columbia, Canada},
  art_number = {4268236},
  document_type = {Conference Paper},
  journal = {IEEE International Conference on Program Comprehension},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-34948862239&partnerID=40&md5=54f062c32214001ded592aeb6cb8e965}
}

@CONFERENCE{Kidd2007,
  author = {Kidd, E.},
  title = {Terrorism response training in scheme},
  year = {2007},
  note = {cited By (since 1996) 0},
  abstract = {The Interactive Media Lab (IML) builds shrink-wrapped educational
	software for medical professionals and first responders. We have
	teams focusing on media production, script-level authoring, and low-level
	engine development. Our most recent project is Virtual Terrorism
	Response Academy. VTRA uses 3D simulations to teach students about
	radiological, chemical and biological weapons. Our software is now
	undergoing trials at government training centers and metropolitan
	police departments. VTRA consists of approximately 60,000 lines of
	Scheme, and a similar amount of C++. All of our product-specific
	code is in Scheme, and we make extensive use of macros and domain-specific
	languages. From 1987 to 2002, we used a C++ multimedia engine scripted
	in 5L, the "Lisp-Like Learning Lab Language". This was Lisp-like
	in name only; it used a prefix syntax, but didn't even support looping,
	recursion, or data structures. We needed something better for our
	next project! We ultimately chose to use Scheme, because (1) it was
	a well-known, general-purpose programming language, and (2) we could
	customize it extensively using macros. Migrating to Scheme proved
	tricky, because we needed to keep releasing products while we were
	building the new Scheme environment. We began by carefully refactoring
	our legacy codebase, allowing us to maintain our old and new interpreters
	in parallel. We then rewrote the front-end in a single, eight-day
	hacking session. But even once the Scheme environment was ready,
	few of our employees wanted to use it. In an effort to make Scheme
	programming more accessible, we invested significant effort in building
	an IDE. Today, our environment is much more popular-a third of our
	employees use it on a regular basis, including several professional
	artists. After migrating to Scheme, we added support for 3D simulations.
	And Scheme proved its worth almost immediately: we faced several
	hard technical problems, which we solved by building domain-specific
	languages using Scheme macros. First, we needed to simulate radiation
	meters. For this, we used a reactive programming language to implement
	a Model-View-Controller system. Second, we needed to guide students
	through the simulation and make teaching points. For this, we relied
	on a "goal system", which tracks what students need to accomplish
	and provides hints along the way. In both these cases, Scheme proved
	to be a significant competitive advantage. Not all problems have
	clean imperative solutions. A language which supports functional
	programming, macros, and combinator libraries allows us to do things
	our competitors can't. This summer, we'll be releasing our engine
	as open source, and starting work on a GUI editor. We welcome users
	and developers!. © 2007 ACM.},
  affiliation = {Dartmouth Medical School, United States},
  art_number = {6},
  document_type = {Conference Paper},
  journal = {Proceedings of the 4th ACM SIGPLAN Workshop on Commercial Users of
	Functional Programming, CUFP'07},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-79958711317&partnerID=40&md5=2ee5c77ef677cf5e947708f9655ad456}
}

@ARTICLE{Kienle200164,
  author = {Kienle, H.M.},
  title = {Using smgn for rapid protoptyping of small domain-specific languages},
  journal = {SIGPLAN Notices (ACM Special Interest Group on Programming Languages)},
  year = {2001},
  volume = {36},
  pages = {64-72},
  number = {9},
  note = {cited By (since 1996) 2},
  abstract = {This paper presents smgn, a, grammar-based tool that provides support
	for scanning, parsing, and automatic parse tree construction. The
	parse tree can be easily navigated and manipulated with a specific
	macro language while conveniently generating textual output. smgn
	is easy to learn and well suited for rapid prototyping of small domain-specific
	languages. It is part of the SUIF compiler system, where it has been
	used for the rapid development of the Hoof domain-specific language.
	Furthermore, smgn was recently employed for the rapid development
	of another domain-specific language, called Bauhaus IMDL. These successful
	experiences motivate the promotion of smgn in the hope that other
	researchers that face the task of implementing a domain-specific
	language will find smgn equally helpful.},
  affiliation = {Department of Computer Science, University of Stuttgart, Breitwiesenstr.
	20-22, D-70565 Stuttgart, Germany},
  author_keywords = {Domain-specific language; Domain-specific processor; Language prototyping;
	Rapid prototyping; SUIF compiler system},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-17244381034&partnerID=40&md5=43c4f3bce6cbbcb7404d2863822bb99f}
}

@ARTICLE{Killian2007179,
  author = {Killian, C., Anderson, J.W., Braud, R., Jhala, R., Vahdat, A.},
  title = {Mace: Language support for building distributed systems},
  journal = {ACM SIGPLAN Notices},
  year = {2007},
  volume = {42},
  pages = {179-188},
  number = {6},
  note = {cited By (since 1996) 8},
  abstract = {Building distributed systems is particularly difficult because of
	the asynchronous, heterogeneous, and failure-prone environment where
	these systems must run. Tools for building distributed systems must
	strike a compromise between reducing programmer effort and increasing
	system efficiency. We present Mace, a C++ language extension and
	source-to-source compiler that translates a concise but expressive
	distributed system specification into a C++ implementation. Mace
	overcomes the limitations of low-level languages by providing a unified
	framework for networking and event handling, and the limitations
	of high-level languages by allowing programmers to write program
	components in a controlled and structured manner in C++. By imposing
	structure and restrictions on how applications can be written, Mace
	supports debugging at a higher level, including support for efficient
	model checking and causal-path debugging. Because Mace programs compile
	to C++, programmers can use existing C++ tools, including optimizers,
	profilers, and debuggers to analyze their systems. © 2007 ACM.},
  affiliation = {University of California, San Diego},
  author_keywords = {Concurrency; Debugging; Distributed systems; Domain specific languages;
	Event driven programming; Mace; Model checking},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-67650033385&partnerID=40&md5=f1f2150c8450efe9eba8675c1a8c9dc0}
}

@CONFERENCE{Killian2007,
  author = {Killian, C.E., Anderson, J.W., Braud, R., Jhala, R., Vahdat, A.M.},
  title = {Mace: Language support for building distributed systems},
  year = {2007},
  pages = {179-188},
  note = {cited By (since 1996) 9},
  abstract = {Building distributed systems is particularly difficult because of
	the asynchronous, heterogeneous, and failure-prone environment where
	these systemsmust run. Tools for building distributed systems must
	strike a compromise between reducing programmer effort and increasing
	system efficiency. We present Mace, a C++ language extension and
	source-to-source compiler that translates a concise but expressive
	distributed system specification into a C++ implementation. Mace
	overcomes the limitations of low-level languages by providing a unified
	framework for networking and event handling, and the limitations
	of high-level languages by allowing programmers to write program
	components in a controlled and structured manner in C++. By imposing
	structure and restrictions on how applications can be written, Mace
	supports debugging at a higher level, including support for efficient
	model checking and causal-path debugging. Because Mace programs compile
	to C++, programmers can use existing C++ tools, including optimizers,
	profilers, and debuggers to analyze their systems. Copyright © 2007
	ACM.},
  affiliation = {University of California, San Diego},
  author_keywords = {Concurrency; Debugging; Distributed systems; Domain specific languages;
	Event driven programming; Mace; Model checking},
  document_type = {Conference Paper},
  journal = {Proceedings of the ACM SIGPLAN Conference on Programming Language
	Design and Implementation (PLDI)},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-35448934440&partnerID=40&md5=77d8557144abddc1a85ce056731cf9e8}
}

@CONFERENCE{Kim2010,
  author = {Kim, M.-Y., Goebel, R.},
  title = {Detection and normalization of medical terms using domain-specific
	term frequency and adaptive ranking},
  year = {2010},
  note = {cited By (since 1996) 0},
  abstract = {As the volume of clinic notes written in natural language is rapidly
	increasing, physicians need a tool to automatically extract information
	about diseases/treatments. The main problem in extracting medical
	information is that physicians use variant words to describe the
	same disease/treatment. In order to help physicians interpret and
	share disease/treatment information in clinic notes, we need to reliably
	and effectively detect and normalize the medical terms. In this study,
	we perform detection/normalization of medical terms using a UMLS
	meta-thesaurus combined with a document retrieval technique. We regard
	a medical sentence as a query, and a UMLS ontology entry as a document,
	and try to apply a language modeling-based information retrieval
	method as currently used in the document retrieval field. Because
	the term frequency in the UMLS dictionary is uniform, we employ a
	domain-specific term frequency instead of traditional term frequency.
	To retrieve only the relevant terms in 900,000 UMLS entries, we also
	propose an adaptive ranking method which dynamically determines the
	relevant documents for each query without using static cut-off threshold.
	The experimental results outperform the previous methods in detecting
	and normalizing medical terms in Medline clinical trials, and our
	approach can be used in normalizing the real diagnosis list in the
	patient charts of physicians. © 2010 IEEE.},
  affiliation = {Department of Computing Science, University of Alberta, Canada},
  art_number = {5687670},
  document_type = {Conference Paper},
  journal = {Proceedings of the IEEE/EMBS Region 8 International Conference on
	Information Technology Applications in Biomedicine, ITAB},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-79951616814&partnerID=40&md5=b9b6a42044fe532ed5e23c644e9d1d49}
}

@ARTICLE{Kiselyov2009360,
  author = {Kiselyov, O.a , Shan, C.-C.b },
  title = {Embedded probabilistic programming},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2009},
  volume = {5658 LNCS},
  pages = {360-384},
  note = {cited By (since 1996) 2},
  abstract = {Two general techniques for implementing a domain-specific language
	(DSL) with less overhead are the finally-tagless embedding of object
	programs and the direct-style representation of side effects. We
	use these techniques to build a DSL for probabilistic programming,
	for expressing countable probabilistic models and performing exact
	inference and importance sampling on them. Our language is embedded
	as an ordinary OCaml library and represents probability distributions
	as ordinary OCaml programs. We use delimited continuations to reify
	probabilistic programs as lazy search trees, which inference algorithms
	may traverse without imposing any interpretive overhead on deterministic
	parts of a model. We thus take advantage of the existing OCaml implementation
	to achieve competitive performance and ease of use. Inference algorithms
	can easily be embedded in probabilistic programs themselves. © IFIP
	International Federation for Information Processing 2009.},
  affiliation = {FNMOC; Rutgers University},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-69049105479&partnerID=40&md5=26c138eb0fec7c469ac116ac5dbfd1a2}
}

@ARTICLE{Klarlund1999378,
  author = {Klarlund, N., Schwartzbach, M.I.},
  title = {A domain-specific language for regular sets of strings and trees},
  journal = {IEEE Transactions on Software Engineering},
  year = {1999},
  volume = {25},
  pages = {378-386},
  number = {3},
  note = {cited By (since 1996) 4},
  abstract = {We propose a new high-level programming notation, called FIDO, that
	we have designed to concisely express regular sets of strings or
	trees. In particular, it can be viewed as a domain-specific language
	for the expression of finite-state automata on large alphabets (of
	sometimes astronomical size). FIDO is based on a combination of mathematical
	logic and programming language concepts. This combination shares
	no similarities with usual logic programming languages. FIDO compiles
	into finite-state string or tree automata, so there is no concept
	of run-time. It has already been applied to a variety of problems
	of considerable complexity and practical interest. In the present
	paper, we motivate the need for a language like FIDO, and discuss
	our design and its implementation. Also, we briefly discuss design
	criteria for domain-specific languages that we have learned from
	the work with FIDO. We show how recursive data types, unification,
	implicit coercions, and subtyping can be merged with a variation
	of predicate logic, called the Monadic Second-order Logic (M2L) on
	trees. FIDO is translated first into pure M2L via suitable encodings,
	and finally into finite-state automata through the MONA tool. © 1999
	IEEE.},
  affiliation = {ATandT Labs-Research, University of Aarhus, Department of Computer
	Science, Ny Munkegaardsgade, 8000 Aarhus C, Denmark},
  author_keywords = {Domain-specific languages; Logic; Regular sets; Strings; Trees},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-0032594218&partnerID=40&md5=da7f7387c7b32ce788a9f91523147bfd}
}

@ARTICLE{Kleppe2007114,
  author = {Kleppe, A.},
  title = {Towards the generation of a text-based IDE from a language metamodel},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2007},
  volume = {4530 LNCS},
  pages = {114-129},
  note = {cited By (since 1996) 3},
  abstract = {In the model driven world languages are usually specified by a (meta)
	model of their abstract syntax. For textual languages this is different
	from the traditional approach, where the language is specified by
	a (E)BNF grammar. Support for the designer of textual languages,
	e.g. a parser generator, is therefore normally based on grammars.
	This paper shows that similar support for language design based on
	metamodels is not only possible, but is even more powerful than the
	support based on grammars. In this paper we describe how an integrated
	development environment for a language can be generated from the
	language's abstract syntax metamodel, thus providing the language
	designer with the possibility to quickly, and with little effort,
	create not only a new language but also the tooling necessary for
	using this language. © Springer-Verlag Berlin Heidelberg 2007.},
  affiliation = {University Twente, Netherlands},
  author_keywords = {Compilers; Domain specific languages; Generation; IDE; Metamodeling;
	Parsing; Text-based languages},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-37149008756&partnerID=40&md5=85afe222d160bd0ec8a01982f942aee3}
}

@ARTICLE{Kleppe2005220,
  author = {Kleppe, A.},
  title = {Towards general purpose, high level, software languages},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2005},
  volume = {3748 LNCS},
  pages = {220-238},
  note = {cited By (since 1996) 1},
  abstract = {A highly significant benefit of MDA is that it raises the level of
	abstraction at which the soft-ware developer is able to work. However,
	the languages available to the developer have not seen much change
	in the last decade. Modeling languages offer high level concepts,
	but the pre-dominant modeling language (UML) offers too little expressive
	power to be able to specify a system completely. Meanwhile, the level
	of abstraction of most programming language con-cepts is the same
	as 10 to 15 years ago. Although transformation tools may to some
	extent bridge the gap between modeling and programming languages,
	in practice the developer still needs to do both modeling and programming.
	This means switching between the two levels of abstractions, which
	is difficult for most people. We argue that a general purpose, high
	level, software language is necessary to get MDA adopted. This language
	will enable any developer to focus on the problem at hand while the
	supporting tools - transformation tools or generators- take care
	of the nitty gritty details. This paper introduces an early version
	of such a language, which brings together a number of powerful concepts
	from various sources: UML, OCL, design patterns, existing programming
	languages, and eventually aspect-oriented languages. © Springer-Verlag
	Berlin Heidelberg 2005.},
  affiliation = {Klasse Objecten, Netherlands},
  author_keywords = {Design patterns; Domain specific languages; MDA; Model transformations;
	Modeling language; OCL; Programming language; UML},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-33646530945&partnerID=40&md5=deed5959a2d28d755b5e86691a83ac5e}
}

@ARTICLE{Klint20083,
  author = {Klint, P., Kooiker, A.T., Vinju, J.J.},
  title = {Language Parametric Module Management for IDEs},
  journal = {Electronic Notes in Theoretical Computer Science},
  year = {2008},
  volume = {203},
  pages = {3-19},
  number = {2},
  note = {cited By (since 1996) 0},
  abstract = {An integrated development environment (IDE) monitors all the changes
	that a user makes to source code modules and responds accordingly
	by flagging errors, by reparsing, by rechecking, or by recompiling
	modules and by adjusting visualizations or other information derived
	from a module. A module manager is the central component of the IDE
	that is responsible for this behavior. Although the overall functionality
	of a module manager in a given IDE is fixed, its actual behavior
	strongly depends on the programming languages it has to support.
	What is a module? How do modules depend on each other? What is the
	effect of a change to a module? We propose a concise design for a
	language parametric module manager: a module manager that is parameterized
	with the module behavior of a specific language. We describe the
	design of our module manager and discuss some of its properties.
	We also report on the application of the module manager in the construction
	of IDEs for the specification language Asf+Sdf as well as for Java.
	Our overall goal is the rapid development (generation) of IDEs for
	programming languages and domain specific languages. The module manager
	presented here represents a next step in the creation of such generic
	language workbenches. © 2008 Elsevier B.V. All rights reserved.},
  affiliation = {Interactive Software Development and Renovation, Centrum voor Wiskunde
	en Informatica, P.O. Box 94079, NL-1090 GB Amsterdam, Netherlands},
  author_keywords = {IDE; language parametric; modal logic; module management},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-41349085600&partnerID=40&md5=bc3fcec10f021bc036523f17bd7b9371}
}

@ARTICLE{Klint2011222,
  author = {Klint, P., Van Der Storm, T., Vinju, J.},
  title = {EASY meta-programming with Rascal},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2011},
  volume = {6491 LNCS},
  pages = {222-289},
  note = {cited By (since 1996) 0},
  abstract = {Rascal is a new language for meta-programming and is intended to solve
	problems in the domain of source code analysis and transformation.
	In this article we give a high-level overview of the language and
	illustrate its use by many examples. Rascal is a work in progress
	both regarding implementation and documentation. More information
	is available at http://www.rascal-mpl.org/. © 2011 Springer-Verlag.},
  affiliation = {Centrum Wiskunde and Informatica, Universiteit Van Amsterdam, Netherlands},
  author_keywords = {domain-specific languages; metaprogramming; source code analysis;
	source code transformation},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-79251554063&partnerID=40&md5=e74dfc59884809084818bff429ee211c}
}

@CONFERENCE{Klint2010,
  author = {Klint, P., Van Der Storm, T., Vinju, J.},
  title = {On the impact of DSL tools on the maintainability of language implementations},
  year = {2010},
  note = {cited By (since 1996) 1},
  abstract = {Does the use of DSL tools improve the maintainability of language
	implementations compared to implementations from scratch? We present
	empirical results on aspects of maintainability of six implementations
	of the same DSL using different languages (Java, JavaScript, C#)
	and DSL tools (ANTLR, OMeta, Microsoft "M"). Our evaluation indicates
	that the maintainability of language implementations is indeed higher
	when constructed using DSL tools. © ACM 2010.},
  affiliation = {Centrum Wiskunde and Informatica, Science Park 123, Amsterdam, Netherlands},
  art_number = {10},
  author_keywords = {Domain specific languages; Language engineering; Maintainability;
	Tools},
  document_type = {Conference Paper},
  journal = {Proceedings of the 10th Workshop on Language Descriptions, Tools
	and Applications, LDTA 2010},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-78649764780&partnerID=40&md5=1fb87ec0a116b106671bd0b67d76b169}
}

@CONFERENCE{Klint2009168,
  author = {Klint, P., Van Der Storm, T., Vinju, J.},
  title = {RASCAL: A domain specific language for source code analysis and manipulation},
  year = {2009},
  pages = {168-177},
  note = {cited By (since 1996) 6},
  abstract = {Many automated software engineering tools require tight integration
	of techniques for source code analysis and manipulation. State-of-the-art
	tools exist for both, but the domains have remained notoriously separate
	because different computational paradigms fit each domain best. This
	impedance mismatch hampers the development of new solutions because
	the desired functionality and scalability can only be achieved by
	repeated and ad hoc integration of different techniques. RASCAL is
	a domain-specific language that takes away most of this boilerplate
	by integrating source code analysis and manipulation at the conceptual,
	syntactic, semantic and technical level. We give an overview of the
	language and assess its merits by implementing a complex refactoring.
	© 2009 IEEE.},
  affiliation = {Centrum Wiskunde and Informatica, Informatics Institute, University
	of Amsterdam, Mongolia},
  art_number = {5279910},
  document_type = {Conference Paper},
  journal = {9th IEEE International Working Conference on Source Code Analysis
	and Manipulation, SCAM 2009},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-72349086751&partnerID=40&md5=8811586b146a14eb31d0afa3064e88a3}
}

@CONFERENCE{Kloos200939,
  author = {Kloos, J., Eschbach, R.},
  title = {Generating system models for a highly configurable train control
	system using a domain-specific language: A case study},
  year = {2009},
  pages = {39-47},
  note = {cited By (since 1996) 0},
  abstract = {In this work, we present a results from case study on testing a highly
	configurable, safety-critical system from the railway domain using
	model-based risk-oriented testing. In the construction of the system
	and test models, we face the following problems: (i) A domain expert
	will usually not be knowledgeable in the construction of system models,
	but has very detailed knowledge which configurations of the system
	will be especially critical (e.g., prone to head-on collisions).
	Thus, a method for the construction of system and test models from
	domain-specific descriptions is necessary. (ii) The system model
	shall be validatable against the system's requirements. (iii) The
	verification of the system model against safety requirements should
	be possible. We will demonstrate an approach based on DSLs, compositional
	construction of Mealy machines and a proof technique as a solution
	to these three problems. © 2009 IEEE.},
  affiliation = {Fraunhofer Institute for Experimental Software Engineering, Fraunhofer-Platz
	1, 67663 Kaiserslautern, Germany},
  art_number = {4976369},
  document_type = {Conference Paper},
  journal = {IEEE International Conference on Software Testing, Verification,
	and Validation Workshops, ICSTW 2009},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-69949110633&partnerID=40&md5=d19a5c0739d1840e74896b97819b1c8e}
}

@CONFERENCE{Knaus2008823,
  author = {Knaus, C.Y.},
  title = {Essential programming paradigm},
  year = {2008},
  pages = {823-825},
  note = {cited By (since 1996) 0},
  abstract = {The chronic difficulty of software maintenance can be traced back
	to widely held assumptions that inhibit progress in computer science.
	In the last instance, the idiosyncrasies of programming paradigms
	must be held accountable for bad software design. The characteristics
	of an alternative programming paradigm without such drawbacks is
	outlined.},
  author_keywords = {Design patterns; Domain specific languages; Programming paradigm},
  document_type = {Conference Paper},
  journal = {Proceedings of the Conference on Object-Oriented Programming Systems,
	Languages, and Applications, OOPSLA},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-63349084103&partnerID=40&md5=1d0f84c37ed695221577aefee7174048}
}

@CONFERENCE{Knoell2009,
  author = {Knöll, R., Mezini, M.},
  title = {π: A pattern language},
  year = {2009},
  pages = {503-521},
  note = {cited By (since 1996) 1},
  abstract = {Current programming languages and techniques realize many features
	which allow their users to extend these languages on a semantic basis:
	classes, functions, interfaces, aspects and other entities can be
	defined. However, there is a lack of modern programming languages
	which are both semantically and syntactically extensible from within
	the language itself, i.e., with no additional tool or meta-language.
	In this paper we present π as an approach that aims to overcome this
	lack. π provides an abstraction mechanism based on parameterized
	symbols which is capable of semantically and syntactically unifying
	programming concepts like variables, control-structures, procedures
	and functions into one concept: the pattern. We have evaluated the
	abstraction potential and the syntactic extensibility of π by successfully
	creating patterns for the aforementioned programming concepts. π
	could serve as a tool for designing new experimental languages and
	might generally influence the view we have on current programming
	concepts. Copyright © 2009 ACM.},
  affiliation = {Faculty of Computer Science, TUD - Technische Universität Darmstadt},
  author_keywords = {Domain specific languages; Extensibility; Language design; Language
	extension; Macros; Pattern language; Patterns; Semiotics},
  document_type = {Conference Paper},
  journal = {Proceedings of the Conference on Object-Oriented Programming Systems,
	Languages, and Applications, OOPSLA},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-72249120376&partnerID=40&md5=75f687f3c2be83cf6a3eb3b112951624}
}

@ARTICLE{Knöll2009503,
  author = {Knöll, R., Mezini, M.},
  title = {π-a Pattern language},
  journal = {ACM SIGPLAN Notices},
  year = {2009},
  volume = {44},
  pages = {503-521},
  number = {10},
  note = {cited By (since 1996) 1},
  abstract = {Current programming languages and techniques realize many features
	which allow their users to extend these languages on a semantic basis:
	classes, functions, interfaces, aspects and other entities can be
	defined. However, there is a lack of modern programming languages
	which are both semantically and syntactically extensible from within
	the language itself, i.e., with no additional tool or meta-language.
	In this paper we present π as an approach that aims to overcome this
	lack. π provides an abstraction mechanism based on parameterized
	symbols which is capable of semantically and syntactically unifying
	programming concepts like variables, control-structures, procedures
	and functions into one concept: the pattern. We have evaluated the
	abstraction potential and the syntactic extensibility of π by successfully
	creating patterns for the aforementioned programming concepts. π
	could serve as a tool for designing new experimental languages and
	might generally influence the view we have on current programming
	concepts. © 2009 ACM.},
  affiliation = {Faculty of Computer Science, TUD-Technische Universität Darmstadt},
  author_keywords = {Domain specific languages; Extensibility; Language design; Language
	extension; Macros; Pattern language; Patterns; Semiotics},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-70350656218&partnerID=40&md5=d7e8db62125f9061ef204c0763bcb6eb}
}

@CONFERENCE{Koegel2010163,
  author = {Koegel, M., Herrmannsdoerfery, M., Liz, Y., Helmingx, J., David,
	J.},
  title = {Comparing state- and operation-based change tracking on models},
  year = {2010},
  pages = {163-172},
  note = {cited By (since 1996) 0},
  abstract = {In recent years, models are increasingly used throughout the entire
	lifecycle in software development projects. In effect, the need for
	collaborating on these models emerged, requiring change tracking
	and versioning. However, many researchers have shown that existing
	methods and tools for Version Control (VC) do not work well on graph-like
	models, such as UML, SysML or domain-specific modeling languages.
	To alleviate this, alternative techniques and methods have been proposed
	which can be classified into state-based and operation-based approaches.
	Existing research shows advantages of operation-based over state-based
	approaches in selected use cases, such as conflict detection or merging.
	However, there are only few results available on the advantages of
	operation-based approaches in the most common use case of a VC system:
	review and understand change. In this paper, we present and discuss
	both approaches and their use cases. Moreover, we present the results
	of an empirical study to compare a state-based with an operation-based
	approach for the use case of reviewing and understanding change.
	For this study, we have mined an operation-based model repository
	and interviewed users to assess their understanding of randomly selected
	changes. Our results indicate that users better understand complex
	changes in the operation-based representation. © 2010 IEEE.},
  affiliation = {Institut für Informatik, Technische Universität München, Boltzmannstrasse
	3, 87548 Garching, Germany},
  art_number = {5630213},
  document_type = {Conference Paper},
  journal = {Proceedings - IEEE International Enterprise Distributed Object Computing
	Workshop, EDOC},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-79951932158&partnerID=40&md5=feb3e5ef86f8dc2c5199b6d7d37008f4}
}

@CONFERENCE{Kojarski200353,
  author = {Kojarski, S., Lorenz, D.H.},
  title = {Domain driven web development with WebJinn},
  year = {2003},
  pages = {53-65},
  note = {cited By (since 1996) 5},
  abstract = {Web application development cuts across the HTTP protocol, the client-side
	presentation language (HTML, XML), the server-side technology (Servlets,
	JSP, ASP, PHP), and the underlying resource (files, database, information
	system). Consequently, web development concerns including functionality,
	presentation, control, and structure cross-cut, leading to tangled
	and scattered code that is hard to develop, maintain, and reuse.
	In this paper we analyze the cause, consequence, and remedy for this
	crosscutting. We distinguish between intra-crosscutting that results
	in code tangling and inter-crosscutting that results in code scattering.
	To resolve inter-crosscutting, we present a new web application development
	model named XP that introduces extension points as place-holders
	for structure-dependent code. We present another model named DDD
	that incorporates XP into the Model-View-Controller (MVC) model to
	resolve both intra- and inter-crosscutting. WebJinn is a novel domain-driven
	web development framework that implements the DDD model. WebJinn
	has been used to develop web applications at several web sites. Domain
	driven web development with WebJinn benefits from a significant improvement
	in code reuse, adaptability, and maintainability.},
  affiliation = {Northeastern University, College of Computer and Information Science,
	Boston, MA 02115, United States},
  author_keywords = {Adaptability; Aspect-oriented programming (AOP); Crosscutting concerns;
	Dynamic pages; Generative programming; Inter-crosscutting; Intra-crosscutting;
	JSP; Model-view-controller (MVC); Reusability; Scattering; Struts;
	Tangling; Web application; Web development; Web programming},
  document_type = {Conference Paper},
  journal = {Proceedings of the Conference on Object-Oriented Programming Systems,
	Languages, and Applications, OOPSLA},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-51849165875&partnerID=40&md5=690204bc1ea2365bb9b233c03ecea582}
}

@CONFERENCE{Kollár2009667,
  author = {Kollár, J., Václavík, P., Wassermann, L.},
  title = {Data-driven executable language model},
  year = {2009},
  volume = {4},
  pages = {667-674},
  note = {cited By (since 1996) 2},
  abstract = {Executable language model driven by data streams is proposed. At the
	same time, this model is language architecture developed from context-free
	grammar enriched with communication channels. Four types of formal
	communication channels and one type of informal communication channel
	were identified for functional languages, to provide systematic background
	for human-machine communication. Formal channel positions are determined
	by a grammar, not by a programmer. Data streams are aproximately
	as concise as computer machine code but they are semantically equivalent
	to high-level programs. Using simple example of functional language
	we present the principle of functional language architecture construction
	and its driving by data stream. In particular, we show how the program
	is initially recorded, and how it can be repeatedly generated, either
	in original or in a modified version. Data streams radically decrease
	structural complexity of current programs, preserving their semantics,
	since they are not executed at low-level computer architecture but
	at high-level language architecture. © 2009 IEEE.},
  affiliation = {Department of Computers and Informatics, Technical University of Košice,
	Letná 9, 042 00 Košice, Slovakia},
  art_number = {5352766},
  author_keywords = {Data driven program generation; Domain specific languages; Executable
	modeling; Language architectures; Language models; Model and language
	semantics},
  document_type = {Conference Paper},
  journal = {Proceedings of the International Multiconference on Computer Science
	and Information Technology, IMCSIT '09},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-77953935841&partnerID=40&md5=1d7f91f8a893b80ef962e70ceef2809d}
}

@CONFERENCE{Kolovos2008356,
  author = {Kolovos, D.S., Paige, R.F., Polack, F.A.C.},
  title = {Detecting and repairing inconsistencies across heterogeneous models},
  year = {2008},
  pages = {356-364},
  note = {cited By (since 1996) 5},
  abstract = {With the advent of Domain Specific Languages for Model Engineering,
	detecting inconsistencies between models is becoming increasingly
	challenging. Nowadays, it is not uncommon for models participating
	in the same development process to be captured using different modelling
	languages and even different modelling technologies. We present a
	classification of the types of relationships that can arise between
	models participating in a software development process and outline
	the types of inconsistencies each relationship can suffer from. From
	this classification we identify a set of requirements for a generic
	inconsistency detection and reconciliation mechanism and use a case
	study to demonstrate how those requirements are implemented in the
	Epsilon Validation Language (EVL), a task-specific language developed
	in the context of the Epsilon GMT component. © 2008 IEEE.},
  affiliation = {Department of Computer Science, University of York, YO10 5DD, York,
	United Kingdom},
  art_number = {4539563},
  document_type = {Conference Paper},
  journal = {Proceedings of the 1st International Conference on Software Testing,
	Verification and Validation, ICST 2008},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-50649122990&partnerID=40&md5=bb4a6290ffad9ad73652c52446c3bcfd}
}

@CONFERENCE{Kononenko201018,
  author = {Kononenko, I.S., Sidorova, E.A.},
  title = {Language resources in ontology-driven information systems},
  year = {2010},
  pages = {18-23},
  note = {cited By (since 1996) 0},
  abstract = {The role of the ontology is discussed in the context of the development
	of information system which uses natural language processing services
	for automatic populating and updating the system's content. The problem
	of creation of language resources for text processing is particularly
	addressed and exemplified by the development of information thesaurus
	on catalysis. A number of techniques for recognizing lexical structures
	and lexical-semantic relations in a domain-specific text corpus are
	presented, concentrating on techniques that can serve as a basis
	for an automatized construction of the thesaurus vocabulary and relations.},
  affiliation = {A.P. Ershov Institute of Informatics Systems, Russian Academy of Science,
	Novosibirsk, Russian Federation},
  author_keywords = {Domain ontology; Language resource; Lexical pattern; Natural language
	service; Terminology; Thesaurus},
  document_type = {Conference Paper},
  journal = {RPC 2010 - 1st Russia and Pacific Conference on Computer Technology
	and Applications},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-79959797451&partnerID=40&md5=2ad4ddcfd289f054bfc8a71363eb5d45}
}

@ARTICLE{Kos2011361,
  author = {Kos, T.a , Kosar, T.b , Knez, J.a , Mernik, M.b },
  title = {From DCOM interfaces to domain-specific modeling language: A case
	study on the sequencer},
  journal = {Computer Science and Information Systems},
  year = {2011},
  volume = {8},
  pages = {361-378},
  number = {2},
  note = {cited By (since 1996) 0},
  abstract = {Software development is a demanding process, since it involves different
	parties to perform a desired task. The same case applies to the development
	of measurement systems-measurement system producers often provide
	interfaces to their products, after which the customers' programming
	engineers use them to build software according to the instructions
	and requirements of domain experts from the field of data acquisition.
	Until recently, the customers of the measurement system DEWESoft
	were building measuring applications, using prefabricated DCOM objects.
	However, a significant amount of interaction between customers' programming
	engineers and measurement system producers is necessary to use DCOM
	objects. Therefore, a domain-specific modeling language has been
	developed to enable domain experts to program or model their own
	measurement procedures without interacting with programming engineers.
	In this paper, experiences gained during the shift from using the
	DEWESoft product as a programming library to domain-specific modeling
	language are provided together with the details of a Sequencer, a
	domain-specific modeling language for the construction of measurement
	procedures.},
  affiliation = {DEWESoft d.o.o, Gabrsko 11a, 1420 Trbovlje, Slovenia; University of
	Maribor, Faculty of Electrical Engineering and Computer Sciences,
	Smetanova ulica 17, 2000 Maribor, Slovenia},
  author_keywords = {Data acquisition; Domain-specific modeling languages; Measurement
	systems},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-80755136750&partnerID=40&md5=e1ca75b712a3ea1532e002bd849d271a}
}

@CONFERENCE{Kos2011135,
  author = {Kos, T.a , Kosar, T.b , Mernik, M.b , Knez, J.a },
  title = {Ladybird: Debugging support in the sequencer},
  year = {2011},
  pages = {135-139},
  note = {cited By (since 1996) 0},
  abstract = {Domain-specific modeling language (DSML) allows domain-experts to
	play a vital role in software development lifecycle, making them
	programmers/modelers of new systems. Although, there are reports
	of numerous DSMLs and their advantages, there are some obstacles
	working against the more widespread adoption of DSMLs in practice.
	One of them is a lack of supporting tools in most of reported DSMLs,
	which would assist modelers and make them more efficient. This paper
	presents DSML called Sequencer, where debugging facilities were integrated
	in the development environment. Debugging support, such as different
	execution modes, steps, breakpoints, animations, variable views,
	stack traces and others have been developed for the Sequencer.},
  affiliation = {DEWESoft d.o.o., Gabrsko 11a, 1420 Trbovlje, Slovenia; Faculty of
	Electrical Engineering and Computer Science, Smetanova ulica 17,
	2000 Maribor, Slovenia},
  author_keywords = {Breakpoints; Data acquisition; Debugging; Measurement systems; Programming
	language; Vehicle testing},
  document_type = {Conference Paper},
  journal = {Applications of Mathematics and Computer Engineering - American Conference
	on Applied Mathematics, AMERICAN-MATH'11, 5th WSEAS International
	Conference on Computer Engineering and Applications, CEA'11},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-79958740715&partnerID=40&md5=10bd8637c355afe475000ddf35d9c364}
}

@ARTICLE{Kosar2008390,
  author = {Kosar, T.a , Martínez López, P.E.b , Barrientos, P.A.b , Mernik,
	M.a },
  title = {A preliminary study on various implementation approaches of domain-specific
	language},
  journal = {Information and Software Technology},
  year = {2008},
  volume = {50},
  pages = {390-405},
  number = {5},
  note = {cited By (since 1996) 17},
  abstract = {Various implementation approaches for developing a domain-specific
	language are available in literature. There are certain common beliefs
	about the advantages/disadvantages of these approaches. However,
	it is hard to be objective and speak in favor of a particular one,
	since these implementation approaches are normally compared over
	diverse application domains. The purpose of this paper is to provide
	empirical results from ten diverse implementation approaches for
	domain-specific languages, but conducted using the same representative
	language. Comparison shows that these discussed approaches differ
	in terms of the effort need to implement them, however, the effort
	needed by a programmer to implement a domain-specific language should
	not be the only factor taken into consideration. Another important
	factor is the effort needed by an end-user to rapidly write correct
	programs using the produced domain-specific language. Therefore,
	this paper also provides empirical results on end-user productivity,
	which is measured as the lines of code needed to express a domain-specific
	program, similarity to the original notation, and how error-reporting
	and debugging are supported in a given implementation. © 2007 Elsevier
	B.V. All rights reserved.},
  affiliation = {University of Maribor, Faculty of Electrical Engineering and Computer
	Science, Smetanova ulica 17, 2000 Maribor, Slovenia; Universidad
	Nacional de La Plata, Facultad de Informática, LIFIA ( 1900 ) La
	Plata Buenos Aires, Argentina},
  author_keywords = {Commercial-Off-The-Shelf; Compiler/interpreter; Compiler/interpreter
	generator; Domain-specific languages; Embedded approach; Extensible
	compiler/interpreter; Preprocessing},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-38849128745&partnerID=40&md5=e4f4b16d1578335791aeb07092fe2c94}
}

@CONFERENCE{Kosar2009675,
  author = {Kosar, T.a , Mernik, M.a , Črepinšek, M.a , Henriques, P.R.b , Da
	Cruz, D.b , Pereira, M.J.V.c , Oliveira, N.b },
  title = {Influence of domain-specific notation to program Understanding},
  year = {2009},
  volume = {4},
  pages = {675-682},
  note = {cited By (since 1996) 1},
  abstract = {Application libraries are the most commonly used implementation approach
	to solve problems in general-purpose languages. Their competitors
	are domain-specific languages, which can provide notation close to
	the problem domain. We carried out an empirical study on comparing
	domain-specific languages and application libraries regarding program
	understanding. In this paper, one case study is presented. Over 3000
	lines of code were studied and more than 86 pages long questionnaires
	were answered by end-users, answering questions on learning, perceiving
	and evolving programs written in domain-specific language as well
	as general-purpose language using application library. In this paper,
	we present comparison results on end-users' correctness and consumed
	time. For domain-specific language and application library same problem
	domain has been used-a well-known open source graph description language,
	DOT. © 2009 IEEE.},
  affiliation = {Faculty of Electrical Engineering and Computer Science, University
	of Maribor, Smetanova 17, 2000 Maribor, Slovenia; Department of Computer
	Science, Campus de Gualtar, University of Minho, 4715-057, Braga,
	Portugal; Polytechnic Institute of Bragança, Campus de Sta. Apolónia,
	Apartado 134 - 5301-857, Bragança, Portugal},
  art_number = {5352767},
  document_type = {Conference Paper},
  journal = {Proceedings of the International Multiconference on Computer Science
	and Information Technology, IMCSIT '09},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-77953896703&partnerID=40&md5=b40cb649826618ed7b2a1b7fbeb230f9}
}

@ARTICLE{Kosar2004393,
  author = {Kosar, T.a , Mernik, M.a , Žumer, V.a , Henriques, P.R.b , Pereira,
	M.J.V.c },
  title = {Software development with grammatical approach},
  journal = {Informatica (Ljubljana)},
  year = {2004},
  volume = {28},
  pages = {393-404},
  number = {4},
  note = {cited By (since 1996) 0},
  abstract = {The paper presents a grammatical approach to software development.
	It supports formal software specification using attribute grammars,
	from which a rapid prototype can be generated, as well as the incremental
	software development. Domain concepts and relationships among them
	have to be identified from a problem statement and represented as
	a context-free grammar. The obtained context-free grammar describes
	the syntax of a domain-specific language whose semantics is the same
	as the functionality of the system under implementation. The semantics
	of this language is then described using attribute grammars from
	which a compiler is automatically generated. The execution of a particular
	program written in that domain-specific language corresponds to the
	execution of a prototype of the system on a particular use case.},
  affiliation = {University of Maribor, Fac. of Elec. Eng. and Comp. Science, Slovenia;
	University of Minho, Department of Computer Science, Portugal; Polytech.
	Inst. of Bragança, Portugal},
  author_keywords = {Attribute grammars; Context-free grammars; Rapid prototyping; Software
	design and modelling; Software development},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-11244354739&partnerID=40&md5=2abea193f1a134a59321147c7445905e}
}

@ARTICLE{Kosar2010247,
  author = {Kosar, T.a , Oliveira, N.b , Mernik, M.a , Pereira, M.J.V.c , Črepinšek,
	M.a , da Cruz, D.b , Henriques, P.R.b },
  title = {Comparing general-purpose and domain-specific languages: An empirical
	study},
  journal = {Computer Science and Information Systems},
  year = {2010},
  volume = {7},
  pages = {247-264},
  number = {2},
  note = {cited By (since 1996) 3},
  abstract = {Many domain-specific languages, that try to bring feasible alternatives
	for existing solutions while simplifying programming work, have come
	up in recent years. Although, these little languages seem to be easy
	to use, there is an open issue whether they bring advantages in comparison
	to the application libraries, which are the most commonly used implementation
	approach. In this work, we present an experiment, which was carried
	out to compare such a domain-specific language with a comparable
	application library. The experiment was conducted with 36 programmers,
	who have answered a questionnaire on both implementation approaches.
	The questionnaire is more than 100 pages long. For a domain-specific
	language and the application library, the same problem domain has
	been used - construction of graphical user interfaces. In terms of
	a domain-specific language, XAML has been used and C# Forms for the
	application library. A cognitive dimension framework has been used
	for a comparison between XAML and C# Forms.},
  affiliation = {University of Maribor, Faculty of Electrical Engineering and Computer
	Science, Smetanova 17, 2000 Maribor, Slovenia; University of Minho
	- Department of Computer Science, Campus de Gualtar, 4715-057, Braga,
	Portugal; Polytechnic Institute of Bragança, Campus de Sta. Apolónia,
	Apartado 134 - 5301-857, Bragança, Portugal},
  author_keywords = {Domain-specific languages; Empirical software engineering; General-purpose
	languages; Program comprehension},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-77953884044&partnerID=40&md5=ee849d8b35b8c49d17ded268d126b2c5}
}

@ARTICLE{Kourie20091,
  author = {Kourie, D.G., Fick, D., Watson, B.W.},
  title = {Virtual machine framework for constructing domain-specific languages},
  journal = {IET Software},
  year = {2009},
  volume = {3},
  pages = {1-13},
  number = {1},
  note = {cited By (since 1996) 0},
  abstract = {An object-oriented framework is proposed for constructing a virtual
	machine (VM) to be used in the context of incrementally and iteratively
	developing a domain-specific language (DSL). The framework is written
	in C. It includes abstract instruction and environment classes. By
	extending these, a concrete layer of classes is obtained whose instances
	define the semantics of a set of instructions, as well as one or
	more execution environment instances that can be manipulated by the
	instructions. The framework provides a generic mechanism for reading
	a set of instructions, executing them sequentially by default but
	branching if necessary, storing or retrieving internal variables,
	and accessing and manipulating the environment as per the instructions.
	In general, each instruction can execute an arbitrary C method as
	specified by the developer. The syntactic form of instructions is
	limited to five possibilities. Using the framework, a range of VMs
	can be generated, each tailored to support a developer-designed target-level
	DSL. Since each such language is built in terms of these five instruction
	formats, these target-level languages share a common syntactic structure.
	The result is a platform to support an incremental iterative language
	design and implementation approach that involves the following three
	phases: determine a set of target-level instructions with semantics
	appropriate to the specific domain; determine source-level language
	instructions whose syntax appeals to the domain specialist and provide
	a simple compiler to map the source to target instructions. The first
	two phases are relatively disjoint and importantly separate syntax
	concerns from semantics concerns. The final phase is quite straightforward.
	Comparative performance results support the use of the framework
	as an alternative to using an interpreter or hardcoded VM for DSL
	development. © 2009 The Institution of Engineering and Technology.},
  affiliation = {University of Pretoria, Espresso Research Group, Department of Computer
	Science, Lynwood Road, Pretoria, South Africa},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-60249088059&partnerID=40&md5=c0fdf6ab2e52a05bc7b0a3ba704f6d20}
}

@ARTICLE{Kovse2004160,
  author = {Kovse, J., Harder, T.},
  title = {MT-Flow - An environment for workflow-supported model transformations
	in MDA},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2004},
  volume = {3084},
  pages = {160-174},
  note = {cited By (since 1996) 0},
  abstract = {Specification of systems in a software product line (product-line
	members) is often supported by domain-specific languages (DSLs) that
	provide powerful language abstractions for selecting the features
	of the desired system. In this paper, we show that efficient composition
	of system specifications (which, in our case, are expressed as models)
	is also possible using (i) a domain-specific workflow model that
	guides the composition and (ii) a set of domain-specific templates
	for model transformations. We illustrate the entire approach on a
	product line for versioning systems, define a metamodel for workflow
	models and postulate a measure for estimating the benefits of the
	proposed approach. © Springer-Verlag 2004.},
  affiliation = {Department of Computer Science, Kaiserslautern University of Technology,
	P.O. Box 3049, D-67653 Kaiserslautern, Germany},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-35048844147&partnerID=40&md5=ec1f7c63cb81c8c1faf1c65095c6305c}
}

@ARTICLE{Kovse2003304,
  author = {Kovse, J., Härder, T.},
  title = {DSL-DIA - An environment for domain-specific languages for database-intensive
	applications},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2003},
  volume = {2817},
  pages = {304-310},
  note = {cited By (since 1996) 0},
  abstract = {This paper presents DSL-DIA, an environment that lets a system-family
	vendor define a metamodel for a custom domain-specific language used
	by customers for specifying properties of family members. Once the
	metamodel is imported in the environment, the environment allows
	the customer a flexible way to program in the domain-specific language
	and translates obtained programs to implementations of family members.
	In our case, family members are always database-intensive applications
	with application logic executed in the database server. © Springer-Verlag
	Berlin Heidelberg 2003.},
  affiliation = {Department of Computer Science, University of Kaiserslautern, P.O.
	Box 3049, D-67653 Kaiserslautern, Germany},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-35248896195&partnerID=40&md5=165e3b168e92de0b22ef775aa3f92938}
}

@ARTICLE{Kovse2004654,
  author = {Kovse, J., Weber, C., Härder, T.},
  title = {Metaprogramming for relational databases},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2004},
  volume = {3288},
  pages = {654-667},
  note = {cited By (since 1996) 1},
  abstract = {For systems that share enough structural and functional commonalities,
	reuse in schema development and data manipulation can be achieved
	by defining problem-oriented anguages. Such languages are often called
	domainspecific, because they introduce powerful abstractions meaningful
	only within the domain of observed systems. In order to use domain-specific
	languages for database applications, a mapping to SQL is required.
	In this paper, we deal with metaprogramming concepts required for
	easy definition of such mappings. Using an example domain-specific
	language, we provide an evaluation of mapping performance. © Springer-Verlag
	004.},
  affiliation = {Department of Computer Science, Kaiserslautern University of Technology,
	P.O. Box 3049, D-67653 Kaiserslautern, Germany},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-33745917786&partnerID=40&md5=d54d260255d62bf0220dd83197f92645}
}

@CONFERENCE{Kowalski2009324,
  author = {Kowalski, M., Wilkosz, K.},
  title = {A domain specific language in dependability analysis},
  year = {2009},
  pages = {324-331},
  note = {cited By (since 1996) 0},
  abstract = {Domain Specific Languages gain increasing popularity as they substantially
	leverage software development by bridging the gap between technical
	and business area. After a domain framework is produced, experts
	gain an effective vehicle for assessing quality and performance of
	a system in the business-specific context. We consider the domain
	to be dependability of Multi-Agent System (MAS), for which a key
	requirement is an efficient verification of a topology model of a
	power system. As a result, we come up with a reliability evaluation
	solution offering a significant rise in the level of Abstraction
	towards MAS utilized for purposes of a power system topology verification.
	By means of the mentioned solution safety engineers are enabled to
	perform analysis while the design is still incomplete. A new DSL
	is developed in XText in order to specify a structure of the system
	together with dependability extensions, which are further translated
	into Dynamic Fault Trees using Model to Model Transformations. The
	Eclipse Ecore becomes a common denominator, in which both metamodels'
	Abstract Syntax Trees are defined. Finally, an expert is offered
	with two ways of defining a model: through abstract and textual concrete
	syntax, both of which are checked for consistency using Object Constraint
	Language.},
  affiliation = {Wroclaw University of Technology},
  art_number = {5261002},
  document_type = {Conference Paper},
  journal = {Proceedings of 2009 4th International Conference on Dependability
	of Computer Systems, DepCos-RELCOMEX 2009},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-70449626054&partnerID=40&md5=99e7d993491d787b4f0947f7a113cb51}
}

@ARTICLE{Krahn2010353,
  author = {Krahn, H., Rumpe, B., Völkel, S.},
  title = {MontiCore: A framework for compositional development of domain specific
	languages},
  journal = {International Journal on Software Tools for Technology Transfer},
  year = {2010},
  volume = {12},
  pages = {353-372},
  number = {5},
  note = {cited By (since 1996) 6},
  abstract = {Domain specific languages (DSLs) are increasingly used today. Coping
	with complex language definitions, evolving them in a structured
	way, and ensuring their error freeness are the main challenges of
	DSL design and implementation. The use of modular language definitions
	and composition operators are therefore inevitable in the independent
	development of language components. In this article, we discuss these
	arising issues by describing a framework for the compositional development
	of textual DSLs and their supporting tools. We use a redundance-free
	definition of a readable concrete syntax and a comprehensible abstract
	syntax as both representations significantly overlap in their structure.
	For enhancing the usability of the abstract syntax, we added concepts
	like associations and inheritance to a grammar-based definition in
	order to build up arbitrary graphs (as known from metamodeling).
	Two modularity concepts, grammar inheritance and embedding, are discussed.
	They permit compositional language definition and thus simplify the
	extension of languages based on already existing ones. We demonstrate
	that compositional engineering of new languages is a useful concept
	when project-individual DSLs with appropriate tool support are defined.
	© 2010 Springer-Verlag.},
  affiliation = {Software Engineering Group, Department of Computer Science 3, RWTH
	Aachen University, Aachen, Germany},
  author_keywords = {Composition; Domain specific language; Grammarware},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-77955230740&partnerID=40&md5=ffa337d780ddaef6a8cf774608b3483b}
}

@ARTICLE{Krahn2007286,
  author = {Krahn, H., Rumpe, B., Völkel, S.},
  title = {Integrated definition of abstract and concrete syntax for textual
	languages},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2007},
  volume = {4735 LNCS},
  pages = {286-300},
  note = {cited By (since 1996) 6},
  abstract = {An understandable concrete syntax and a comprehensible abstract syntax
	are two central aspects of defining a modeling language. Both representations
	of a language significantly overlap in their structure and also information,
	but may also differ in parts of the information. To avoid discrepancies
	and problems while handling the language, concrete and abstract syntax
	need to be consistently defined. This will become an even bigger
	problem, when domain specific languages will become used to a larger
	extent. In this paper we present an extended grammar format that
	avoids redundancy between concrete and abstract syntax by allowing
	an integrated definition of both for textual modeling languages.
	For an amendment of the usability of the abstract syntax it furthermore
	integrates meta-modeling concepts like associations and inheritance
	into a well-understood grammar-based approach. This forms a sound
	foundation for an extensible grammar and therefore language definition.
	© Springer-Verlag Berlin Heidelberg 2007.},
  affiliation = {Institute for Software Systems Engineering, Technische Universität
	Braunschweig, Braunschweig, Germany},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-38049076823&partnerID=40&md5=73cb4b8d0a1f0207c2a002e5a2ea36f0}
}

@CONFERENCE{Kramer2010,
  author = {Kramer, D.a , Clark, T.b , Oussena, S.a },
  title = {MobDSL: A domain specific language for multiple mobile platform deployment},
  year = {2010},
  note = {cited By (since 1996) 0},
  abstract = {There is increasing interest in establishing a presence in the mobile
	application market, with platforms including Apple iPhone, Google
	Android and Microsoft Windows Mobile. Because of the differences
	in platform languages, frameworks, and device hardware, development
	of an application for more than one platform can be a difficult task.
	In this paper we address this problem by the creation of a mobile
	Domain Specific Language (DSL). Domain analysis was carried out using
	two case studies, inferring basic requirements of the language. The
	paper further introduces the language calculus definition and provides
	discussion how it fits the domain analysis, and any issues found
	in our approach. ©2010 IEEE.},
  affiliation = {School of Computing and Technology, Thames Valley University, London,
	W5 5RF, United Kingdom; School of Engineering and Information Sciences,
	Middlesex University, London, NW4 4BT, United Kingdom},
  art_number = {5678062},
  author_keywords = {Domain specific languages; Mobile computing; Platform-independence},
  document_type = {Conference Paper},
  journal = {2010 IEEE International Conference on Networked Embedded Systems
	for Enterprise Applications, NESEA 2010},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-79951497474&partnerID=40&md5=63876caecd25e1c2ca3f79d609230ff8}
}

@CONFERENCE{Krenn2010286,
  author = {Krenn, U., Thonhauser, M., Kreiner, C.},
  title = {ECQL: A query and action language for model-based applications},
  year = {2010},
  pages = {286-290},
  note = {cited By (since 1996) 1},
  abstract = {Modern distributed computer systems with mobile and embedded devices
	as first class citizens are formed from heterogeneous platforms.
	To support this heterogeneity along with adaptation of the system
	an approach for interpretation of domain specific models at runtime
	has been proposed with the concept of Model-Based Software Components
	(MBSC), separating the domain specific functionality from the current
	technical platform. This is achieved by the usage of different sets
	of high-level models. These sets are interpreted by a portable, plugin-extensible
	runtime environment, utilizing several instances of model-based containers
	(MCC) for models and their corresponding data. In this paper the
	design of a domain specific language is presented, enabling the specification
	of accessing and manipulating data entities provided by various MCCs
	used in the runtime architecture of a MBSC. For demonstration purposes
	the application of the various language elements is presented using
	a case study of an exemplary distributed pervasive system running
	in the business domain of logistics. © 2010 IEEE.},
  affiliation = {Institute for Technical Informatics, Graz University of Technology,
	Graz, Austria},
  art_number = {5457760},
  document_type = {Conference Paper},
  journal = {17th IEEE International Conference and Workshops on the Engineering
	of Computer-Based Systems, ECBS 2010},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-77953225600&partnerID=40&md5=ca401490dc4fc79e149967e889788cb7}
}

@ARTICLE{Krishnaswami2011,
  author = {Krishnaswami, N.R., Benton, N.},
  title = {A semantic model for graphical user interfaces},
  journal = {ACM SIGPLAN Notices},
  year = {2011},
  volume = {46},
  pages = {45-57},
  number = {9},
  note = {cited By (since 1996) 0},
  abstract = {We give a denotational model for graphical user interface (GUI) programming
	using the Cartesian closed category of ultrametric spaces. The ultrametric
	structure enforces causality restrictions on reactive systems and
	allows well-founded recursive definitions by a generalization of
	guardedness. We capture the arbitrariness of user input (e.g., a
	user gets to decide the stream of clicks she sends to a program)
	by making use of the fact that the closed subsets of an ultrametric
	space themselves form an ultrametric space, allowing us to interpret
	nondeterminism with a "powerspace" monad. Algebras for the powerspace
	monad yield a model of intuitionistic linear logic, which we exploit
	in the definition of a mixed linear/non-linear domain-specific language
	for writing GUI programs. The non-linear part of the language is
	used for writing reactive stream-processing functions whilst the
	linear sublanguage naturally captures the generativity and usage
	constraints on the various linear objects in GUIs, such as the elements
	of a DOM or scene graph. We have implemented this DSL as an extension
	to OCaml, and give examples demonstrating that programs in this style
	can be short and readable. Copyright © 2011 ACM.},
  affiliation = {Microsoft Research, United States},
  author_keywords = {Denotational semantics; Functional reactive programming; Guarded recursion;
	Linear logic; Ultrametric spaces},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-80053373952&partnerID=40&md5=03e2478b653c0640b853fee04fb8b61c}
}

@CONFERENCE{Krishnaswami201145,
  author = {Krishnaswami, N.R., Benton, N.},
  title = {A semantic model for graphical user interfaces},
  year = {2011},
  pages = {45-57},
  note = {cited By (since 1996) 0},
  abstract = {We give a denotational model for graphical user interface (GUI) programming
	using the Cartesian closed category of ultrametric spaces. The ultrametric
	structure enforces causality restrictions on reactive systems and
	allows well-founded recursive definitions by a generalization of
	guardedness. We capture the arbitrariness of user input (e.g., a
	user gets to decide the stream of clicks she sends to a program)
	by making use of the fact that the closed subsets of an ultrametric
	space themselves form an ultrametric space, allowing us to interpret
	nondeterminism with a "powerspace" monad. Algebras for the powerspace
	monad yield a model of intuitionistic linear logic, which we exploit
	in the definition of a mixed linear/non-linear domain-specific language
	for writing GUI programs. The non-linear part of the language is
	used for writing reactive stream-processing functions whilst the
	linear sublanguage naturally captures the generativity and usage
	constraints on the various linear objects in GUIs, such as the elements
	of a DOM or scene graph. We have implemented this DSL as an extension
	to OCaml, and give examples demonstrating that programs in this style
	can be short and readable. Copyright © 2011 ACM.},
  affiliation = {Microsoft Research, United States},
  author_keywords = {Denotational semantics; Functional reactive programming; Guarded recursion;
	Linear logic; Ultrametric spaces},
  document_type = {Conference Paper},
  journal = {Proceedings of the ACM SIGPLAN International Conference on Functional
	Programming, ICFP},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-80054088312&partnerID=40&md5=41ce7f9cb9a1fe0b346f749745efa250}
}

@CONFERENCE{Krutisch20031,
  author = {Krutisch, R., Meier, P., Wirsing, M.},
  title = {The agent component approach, combining agents, and components},
  year = {2003},
  volume = {2831},
  pages = {1-12},
  note = {cited By (since 1996) 4},
  abstract = {In this paper we introduce a new approach, the so-called AgentComponent
	(AC) approach which combines component and agent technology. A multi
	agent system (MAS) is composed of AC instances, each AC instance
	consists of a knowledge base, storing the beliefs of an AC instance,
	of slots, storing the communication partners of an AC instance, of
	a set of ontologies, that represent domain specific languages for
	certain contexts, and of so-called ProcessComponents (PC) representing
	the behaviours of an AC instance. The AC is a generic component that
	can be reused (instantiated ACs) and parametrized by customizing
	the communication partners (slots), the ontologies and the behaviours
	(PCs) that can be added and removed from any AC instance. Hereby
	we achieve added value for agents and components. Agents can be easily
	composed, customized and reused whereas components get enhanced communication
	and interaction facilities from agents. We present this approach
	in detail, show how to construct a component-based MAS by a simple
	example and present a graphical tool for composing systems of AgentComponents.},
  affiliation = {Ludwig-Maximilians-Univ. Munchen},
  document_type = {Conference Paper},
  journal = {Lecture Notes in Artificial Intelligence (Subseries of Lecture Notes
	in Computer Science)},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-9444227676&partnerID=40&md5=5d84695a6bd2cd1b77bd77f4b9ebccae}
}

@CONFERENCE{Krüger200957,
  author = {Krüger, L.},
  title = {Individual access to IT resources using user context},
  year = {2009},
  pages = {57-60},
  note = {cited By (since 1996) 0},
  abstract = {Concepts of individualization represent an enhancement of existing
	role concepts by containing subjective information demands. Role
	concepts are related to personalization and grant access to IT resources.
	By means of context- and situation-based approaches a concept is
	introduced that provides an individual - as opposed to personalized
	- access to IT resources in heterogeneous system landscapes. The
	first part of the concept is the definition of user context and an
	appropriate UML model. The model includes the user context of a person
	combined with three authorization concepts of SAP R/3, AIX and Solaris.
	By means of these authorization concepts the user context model is
	validated. © 2009 IEEE.},
  affiliation = {VLBA Lab- ITI, Otto-von-Guericke-University, Magdeburg, Germany},
  art_number = {5291018},
  author_keywords = {Authorization; Contextawareness; Domain-specific language; Human factors;
	Individualization},
  document_type = {Conference Paper},
  journal = {2nd International Conference on Advances in Human-Oriented and Personalized
	Mechanisms, Technologies, and Services - CENTRIC 2009},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-74349093704&partnerID=40&md5=20168ffcf72104f1d73eb1a175c1a983}
}

@CONFERENCE{Krüger200933,
  author = {Krüger, L., Grabski, B.},
  title = {Using user context for accessing IT resources},
  year = {2009},
  pages = {33-36},
  note = {cited By (since 1996) 0},
  abstract = {Individualization is an enhancement of existing role concepts by subjective
	information demand. Role concepts, which belong to personalization,
	grant access to IT resources. This paper prepares the ground for
	a context-based approach that provides individual - as opposed to
	personalized - access to IT resources in heteroge-neous system landscapes.
	A central part of such an approach is the definition of user context.
	Here, we provide such a definition, derived from the state of the
	art in this field, along with a UML class model. Our definition of
	user context is validated by relating the UML context model to the
	authorization concepts of SAP R/3, AIX and Solaris. © 2009 ACM.},
  affiliation = {Otto-von-Guericke-University, P.O. Box 4120, 39016 Magdeburg, Germany},
  author_keywords = {Authorization; Context-awareness; Domain-specific language; Human
	Factors; Individualization; Personalization},
  document_type = {Conference Paper},
  journal = {CASTA'09 - Proceedings of the 1st International Workshop on Context-Aware
	Software Technology and Applications},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-77950506587&partnerID=40&md5=1f4041761e728aa5fdb41b7da8c9c732}
}

@ARTICLE{Kubis2011444,
  author = {Kubis, M.},
  title = {An access layer to PolNet - Polish WordNet},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2011},
  volume = {6562 LNAI},
  pages = {444-455},
  note = {cited By (since 1996) 0},
  abstract = {The paper describes an access layer developed in order to provide
	access to PolNet (a lexical database developed for the Polish language).
	The access layer was developed on top of a domain-specific language
	designed to query WordNet-like lexical databases (WQuery). The paper
	presents the overall architecture of the access layer and shows typical
	queries passed by an AI system with NL competence (POLINT-112-SMS)
	to WQuery. The paper discusses the reasons for integrating an ontology
	into an NLP system through a domain-specific query language. © 2011
	Springer-Verlag.},
  affiliation = {Adam Mickiewicz University, Faculty of Mathematics and Computer Science,
	Department of Computer Linguistics and Artificial Intelligence, ul.
	Umultowska 87, 61-614 Poznań, Poland},
  author_keywords = {domain specific language; lexical database; ontology; query language;
	wordnet},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-79953225166&partnerID=40&md5=5a6eecb0b60532960487308ed7b6b77f}
}

@CONFERENCE{Kuhlmann2011108,
  author = {Kuhlmann, M.a , Sohr, K.b , Gogolla, M.a },
  title = {Comprehensive two-level analysis of static and dynamic RBAC constraints
	with UML and OCL},
  year = {2011},
  pages = {108-117},
  note = {cited By (since 1996) 0},
  abstract = {Organizations with stringent security requirements like banks or hospitals
	frequently adopt role-based access control (RBAC) principles to simplify
	their internal permission management. Authorization constraints represent
	a fundamental advanced RBAC concept enabling precise restrictions
	on access rights. Thereby the complexity of the resulting security
	policies increases so that tool support for comfortable creation
	and adequate validation is required. We propose a new approach to
	developing and analyzing RBAC policies using UML for modeling RBAC
	core concepts and OCL to realize authorization constraints. Dynamic
	(i. e., time-dependent) constraints their visual representation in
	UML and their analysis are of special interest. The approach results
	in a domain-specific language for RBAC which is highly configurable
	and extendable with respect to new RBAC concepts and classes of authorization
	constraints and allows the developer to validate RBAC policies in
	an effective way. The approach is supported by a UML and OCL validation
	tool. © 2011 IEEE.},
  affiliation = {Computer Science Department, Database Systems Group, University of
	Bremen, D-28334 Bremen, Germany; University of Bremen, Center for
	Computing Technologies, D-28334 Bremen, Germany},
  art_number = {5992009},
  author_keywords = {Analysis; Modeling; RBAC; Reliability; Security; UML/OCL},
  document_type = {Conference Paper},
  journal = {Proceedings - 2011 5th International Conference on Secure Software
	Integration and Reliability Improvement, SSIRI 2011},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-80052926621&partnerID=40&md5=c633eccfdc525a4e09d57b26016a79e5}
}

@CONFERENCE{Kulesza2004166,
  author = {Kulesza, U., Garcia, A., Lucena, C.},
  title = {An aspect-oriented generative approach},
  year = {2004},
  pages = {166-167},
  note = {cited By (since 1996) 0},
  abstract = {The integration of generative and aspect-oriented techniques is not
	a trivial task. This paper describes our experience in the definition
	of an aspect-oriented generative approach for the context of multi-agent
	systems. Our generative approach is composed of: (i) a domain-specific
	language called Agent-DSL, which allows to model crosscutting and
	non-crosscuting agent features; (ii) an aspect-oriented architecture
	that models a family of software agents; and (iii) a code generator
	that maps abstractions of the Agent-DSL to specific compositions
	of objects and aspects in specific implementations of agent architectures.
	The use of aspect-oriented techniques in the definition of our generative
	approach brought benefits to the modeling and code generation of
	crosscutting features since early design stages.},
  affiliation = {Computer Science Department, PUC-Rio, Brazil},
  author_keywords = {Aspect-oriented software development; Generative programming; Multi-agent
	systems},
  document_type = {Conference Paper},
  journal = {Proceedings of the Conference on Object-Oriented Programming Systems,
	Languages, and Applications, OOPSLA},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-79951731036&partnerID=40&md5=566f2bb9fe59ec0a2544e1ad9f2d6171}
}

@CONFERENCE{Kulkarni2004924,
  author = {Kulkarni, C.a , Brebner, G.a , Schelle, G.b },
  title = {Mapping a domain specific language to a platform FPGA},
  year = {2004},
  pages = {924-927},
  note = {cited By (since 1996) 11},
  abstract = {A domain specific language (DSL) enables designers to rapidly specify
	and implement systems for a particular domain, yielding designs that
	are easy to understand, reason about, re-use and maintain. However,
	there is usually a significant overhead in the required infrastructure
	to map such a DSL on to a programmable logic device. In this paper,
	we present a mapping of an existing DSL for the networking domain
	on to a platform FPGA by embedding the DSL into an existing language
	infrastructure. In particular, we will show that, using few basic
	concepts, we are able to achieve a successful mapping of the DSL
	on to a platform FPGA and create a re-usable structure that also
	makes it easy to extend the DSL. Finally we will present some results
	of mapping the DSL on to a platform FPGA and comment on the resulting
	overhead.},
  affiliation = {Xilinx Inc., San Jose, CA; University of Colorado, Boulder, CO},
  author_keywords = {Domain Specific Language; Network Processing; Platform FPGA},
  document_type = {Conference Paper},
  journal = {Proceedings - Design Automation Conference},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-4444277415&partnerID=40&md5=75f11371b36feca4a8d5d33780bc591a}
}

@CONFERENCE{Kulkarni2007,
  author = {Kulkarni, D., Tripathi, A.},
  title = {Generative programming approach for building pervasive computing
	applications},
  year = {2007},
  note = {cited By (since 1996) 0},
  abstract = {In this paper we present a generative programming approach for building
	context-aware applications. In this approach, a context-aware application
	is programmed using high-level specification constructs provided
	in our programming framework. The runtime environment of the application
	is generated from this specification by a middleware. We demonstrate
	the utility of this approach by presenting an example case-study.
	© 2007 IEEE.},
  affiliation = {Department of Computer Science, University of Minnesota, Twin Cities,
	MN 55455, United States},
  art_number = {4273314},
  document_type = {Conference Paper},
  journal = {Proceedings - ICSE 2007 Workshops: First International Workshop on
	Software Engineering for Pervasive Computing Applications, Systems,
	and Environments, SEPCASE'07},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-38549179984&partnerID=40&md5=10f19fddd04d51b96df6d1b5616561c1}
}

@CONFERENCE{Kulkarni2008181,
  author = {Kulkarni, V., Reddy, S.},
  title = {An abstraction for reusable MDD components Model-based Generation
	of -model-based code generators},
  year = {2008},
  pages = {181-184},
  note = {cited By (since 1996) 7},
  abstract = {We discuss our experience of using model-based techniques to generate
	model-based code generators. The central idea behind model-driven
	development (MDD) is to use suitable models to specify various concerns
	and transform these models to a variety of text artifacts. A business
	product needs to deliver a given business functionality on a wide
	variety of implementation platforms and architectures thus necessitating
	multiple sets of code generators. However, there is a considerable
	commonality across these code generators. In absence of a suitable
	abstraction for capturing this commonality, there is little or no
	reuse across these code generators. We present an abstraction for
	organizing model-base code generators as a hierarchical composition
	of reusable building blocks. A building block is a localized specification
	of a concern in terms of a concern-specific meta model, model to
	model transformation, and model to text transformation. Model-based
	code generation is a 3-step walk over the composition tree wherein
	the first step transforms individual concern-specific models into
	a unified model, the second step transforms the unified model into
	individual concern-specific text artifacts, and the third step composes
	these text artifacts. © 2008 ACM.},
  affiliation = {Tata Consultancy Services, Pune, India},
  author_keywords = {Generative programming; Meta models; Model-driven development; Reuse},
  document_type = {Conference Paper},
  journal = {GPCE'08: Proceedings of the ACM SIGPLAN 7th International Conference
	on Generative Programming and Component Engineering},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-63449105539&partnerID=40&md5=fa4e023bdc51d24d3f93e812785f1bf0}
}

@CONFERENCE{Kurata2006,
  author = {Kurata, G., Mori, S., Nishimura, M.},
  title = {Unsupervised adaptation of a stochastic language model using a Japanese
	raw corpus},
  year = {2006},
  volume = {1},
  pages = {I1037-I1040},
  note = {cited By (since 1996) 1},
  abstract = {The target uses of Large Vocabulary Continuous Speech Recognition
	(LVCSR) systems are spreading. It takes a lot of time to build a
	good LVCSR system specialized for the target domain because experts
	need to manually segment the corpus of the target domain, which is
	a labor-intensive task. In this paper, we propose a new method to
	adapt an LVCSR system to a new domain. In our method, we stochastically
	segment a Japanese raw corpus of the target domain. Then a domain-specific
	Language Model (LM) is built based on this corpus. All of the domain-specific
	words can be added to the lexicon for LVCSR. Most importantly, the
	proposed method is fully automatic. Therefore, we can reduce the
	time for introducing an LVCSR system drastically. In addition, the
	proposed method yielded a comparable or even superior performance
	to use of expensive manual segmentation. © 2006 IEEE.},
  affiliation = {IBM Research, Tokyo Research Laboratory, IBM Japan, Ltd., 1623-14
	Shimotsuruma, Yamato-shi Kanagawa, 242-8502, Japan},
  art_number = {1660201},
  document_type = {Conference Paper},
  journal = {ICASSP, IEEE International Conference on Acoustics, Speech and Signal
	Processing - Proceedings},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-33947634071&partnerID=40&md5=1fb2012db31e02aacd55e4a18526642b}
}

@CONFERENCE{Kurtev2006602,
  author = {Kurtev, I., Bézivin, J., Jouault, F., Valduriez, P.},
  title = {Model-based DSL frameworks},
  year = {2006},
  volume = {2006},
  pages = {602-615},
  note = {cited By (since 1996) 31},
  abstract = {More than five years ago, the OMG proposed the Model Driven Architecture
	(MDA) approach to deal with the separation of platform dependent
	and independent aspects in information systems. Since then, the initial
	idea of MDA evolved and Model Driven Engineering (MDE) is being increasingly
	promoted to handle separation and combination of various kinds of
	concerns in software or data engineering. MDE is more general than
	the set of standards and practices recommended by the OMG's MDA proposal.
	In MDE the concept of model designates not only OMG models but a
	lot of other artifacts like XML documents, Java programs, RDBMS data,
	etc. Today we observe another evolutionary step. A convergence between
	MDE and DSL (Domain Specific Language) engineering is rapidly appearing.
	In the same way as MDE is a generalization of MDA, the DSL engineering
	may be viewed as a generalization of MDE. One of the goals of this
	paper is to explore the potential of this important evolution of
	engineering practices. In order to anchor the discussion on practical
	grounds, we present a set of typical problems that could be solved
	by classical (object-oriented and others), MDE, or DSL-based techniques.
	Solutions to these problems will be based on current platforms (EMF,
	AMMA, GME, etc.). This paper illustrates how powerful model-based
	frameworks, allowing to use and build a variety of DSLs, may help
	to solve complex problems in a more efficient way.},
  affiliation = {ATLAS (INRIA and LINA), University of Nantes, 2, rue de la Houssinière,
	44322, Nantes, France},
  art_number = {1176632},
  author_keywords = {DSL engineering; MDA; Model-driven engineering; Tool-based approaches},
  document_type = {Conference Paper},
  journal = {Proceedings of the Conference on Object-Oriented Programming Systems,
	Languages, and Applications, OOPSLA},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-34248384412&partnerID=40&md5=46ee0350039027d39741f301bcd58642}
}

@ARTICLE{Kutsche2011377,
  author = {Kutsche, R.-D.a , Milanovic, N.b },
  title = {MBSDI 2011 3rd International Workshop on Model-Based Software and
	Data Integration},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2011},
  volume = {6698 LNCS},
  pages = {377-378},
  note = {cited By (since 1996) 0},
  abstract = {... to continuously develop the community of partners from academia
	and industry in the area of model-based software and data integration...
	Our workshop, after the success of MBSDI 2008 (Berlin) and 2009 (Sydney),
	will be the third of its kind, directly addressing collaborative
	development of methodologies and tools for Model-Based Software and
	Data Integration (MBSDI). Our additional focus in the 2011 issue
	of MBSDI will be the emerging field of domain modeling and domain
	ontologies, as an important aid in (semi-) automated understanding
	software and data components and their potentials for integration.
	DSLs and, particularly, Domain Specific Modeling Languages (DSMLs)
	will be a special focus area in MBSDI 2011. © 2011 Springer-Verlag.},
  affiliation = {TU Berlin, Fraunhofer FIRST, Germany; Model Labs. GmbH, Germany},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-79959227502&partnerID=40&md5=a7797fb452f315fa98efbd1ce3f33a71}
}

@CONFERENCE{Kwon2011,
  author = {Kwon, Y.-W., Tilevich, E.},
  title = {A declarative approach to hardening services against QoS vulnerabilities},
  year = {2011},
  note = {cited By (since 1996) 0},
  abstract = {The Quality of Service (QoS) in a distributed service-oriented application
	can be negatively affected by a variety of factors. Network volatility,
	hostile exploits, poor service management, all can prevent a service-oriented
	application from delivering its functionality to the user. This paper
	puts forward a novel approach to improving the reliability, security,
	and availability of service-oriented applications. To counter service
	vulnerabilities, a special service detects vulnerabilities as they
	emerge at runtime, and then hardens the applications by dynamically
	deploying special components. The novelty of our approach lies in
	using a declarative framework to express both vulnerabilities and
	hardening strategies in a domain-specific language, independent of
	the service infrastructure in place. Thus, our approach will make
	it possible to harden service-oriented applications in a disciplined
	and systematic fashion. © 2011 IEEE.},
  affiliation = {Dept. of Computer Science, Virginia Tech., Blacksburg, VA 24060, United
	States},
  art_number = {6049034},
  document_type = {Conference Paper},
  journal = {2011 International Workshop on the Maintenance and Evolution of Service-Oriented
	and Cloud-Based Systems, MESOCA 2011},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-80855164517&partnerID=40&md5=9cf13a25b1d2a9056d0567ea4a390c7e}
}

@ARTICLE{Kühne2010240,
  author = {Kühne, T.a , Mezei, G.b , Syriani, E.c , Vangheluwe, H.c d , Wimmer,
	M.e },
  title = {Explicit transformation modeling},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2010},
  volume = {6002 LNCS},
  pages = {240-255},
  note = {cited By (since 1996) 1},
  abstract = {Despite the pivotal significance of transformations for model-driven
	approaches, there have not been any attempts to explicitly model
	transformation languages yet. This paper presents a novel approach
	for the specification of transformations by modeling model transformation
	languages as domain-specific languages. For each pair of domain,
	the metamodel of the rules are (quasi-)automatically generated to
	create a language tailored to the transformation. Moreover, this
	method is very efficient when the transformation domains are the
	transformation rules themselves, which facilitates the design of
	higher-order transformations. © Springer-Verlag Berlin Heidelberg
	2010.},
  affiliation = {Victoria University of Wellington, New Zealand; Budapest University
	of Technology and Economics, Hungary; McGill University, Canada;
	University of Antwerp, Belgium; Vienna University of Technology,
	Austria},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-78650410131&partnerID=40&md5=64ee2420db24333551f17184a03795b9}
}

@ARTICLE{LabraGayo2001115,
  author = {Labra Gayo, J.E., Luengo Díez, M.C., Cueva Lovelle, J.M., Cernuda
	Del Río, A.},
  title = {LPS: A language prototyping system using modular monadic semantics},
  journal = {Electronic Notes in Theoretical Computer Science},
  year = {2001},
  volume = {44},
  pages = {115-136},
  number = {2},
  note = {cited By (since 1996) 2},
  abstract = {This paper describes LPS, a Language Prototyping System that facilitates
	the modular development of interpreters from semantic building blocks.
	The system is based on the integration of ideas from Modular Monadic
	Semantics and Generic Programming. To define a new programming language,
	the abstract syntax is described as the fixpoint of non-recursive
	pattern functors. For each functor an algebra is defined whose carrier
	is the computational monad obtained from the application of several
	monad transformers to a base monad. The interpreter is automatically
	generated by a catamorphism or, in some special cases, a monadic
	catamorphism. The system has been implemented as a domain-specific
	language embedded in Haskell and we have also implemented an interactive
	framework for language testing. ©2001 Published by Elsevier Science
	B.V.},
  affiliation = {Department of Computer Science, University of Oviedo, C/Calvo Sotelo
	S/N, CP 33007, Oviedo, Spain},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-18944402476&partnerID=40&md5=0105d927f14b0d2e245e85d763f0aaca}
}

@CONFERENCE{Lagarde2007445,
  author = {Lagarde, F., Espinoza, H., Terrier, F., Gérard, S.},
  title = {Improving UML profile design practices by leveraging conceptual domain
	models},
  year = {2007},
  pages = {445-448},
  note = {cited By (since 1996) 7},
  abstract = {The profile extension mechanism has permitted a rapid growth of the
	use of UML as a domain-specific modeling language. However, designing
	profiles typically falls into ad-hoc processes that often rely on
	domain-inappropriate primitives. One of the fundamental reasons is
	that profiles are specified on the same level of abstraction as the
	UML abstract syntax and consequently they narrow down the design
	space to an implementation level. In order to improvethis situation,
	some profile designers start from a "conceptual domain model" that
	states the domain ontology, and only then deal with finding out the
	profile extensions to support it. In spite of this, building truthfulness
	conceptual domain models and maintaining traceable mapping with the
	profile view is a bit of an art. In this paper, we propose to systematize
	the design of UML profiles built-upon conceptual domain models, by
	adopting a minimal setof framing rules. As these rules are defined
	on the basis of regularly occurring design patterns, domain models
	can be afterward checked for self-consistency and interactively transformed
	in stereotypes, tags and constraints. Copyright 2007 ACM.},
  affiliation = {CEA Saclay, DRT/LIST/DTSI/SOL/L-LSP, F-91191, Gif sur Yvette Cedex,
	France},
  author_keywords = {DSML; UML profiles},
  document_type = {Conference Paper},
  journal = {ASE'07 - 2007 ACM/IEEE International Conference on Automated Software
	Engineering},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-56849109724&partnerID=40&md5=b8e4e6914fb18361a106c85566157955}
}

@ARTICLE{Lagarde2008116,
  author = {Lagarde, F.a , Espinoza, H.a , Terrier, F.a , André, C.b , Gérard,
	S.a },
  title = {Leveraging patterns on domain models to improve UML profile definition},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2008},
  volume = {4961 LNCS},
  pages = {116-130},
  note = {cited By (since 1996) 3},
  abstract = {Building a reliable UML profile is a difficult activity that requires
	the use of complex mechanisms -stereotypes and their attributes,
	OCL enforcement- to define a domain-specific modeling language (DSML).
	Despite the ever increasing number of profiles being built in many
	domains, there is a little published literature available to help
	DSML designers. Without a clear design process, most such profiles
	are inaccurate and jeopardize subsequent model transformations or
	model analyses. We believe that a suitable approach to building UML
	based domain specific languages should include systematic transformation
	of domain representations into profiles. This article therefore proposes
	a clearly-defined process geared to helping the designer throughout
	this design activity. Starting from the conceptual domain model,
	we identify a set of design patterns for which we detail several
	profile implementations. We illustrate our approach by creating a
	simplified profile that depicts elements belonging to a real-time
	system domain. The prototype tool supporting our approach is also
	described. © 2008 Springer-Verlag Berlin Heidelberg.},
  affiliation = {CEA, LIST, Gif-sur-Yvette, F-91191, France; I3S Laboratory, BP 121,
	06903 Sophia Antipolis Cédex, France},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-47249160765&partnerID=40&md5=e434f7201c7359f76e877cf239d0a978}
}

@CONFERENCE{Lahcen2009226,
  author = {Lahcen, A.A.a b , Degenne, P.c , Seen, D.L.c , Parigot, D.a },
  title = {Developing a service-oriented component framework for a landscape
	modeling language},
  year = {2009},
  pages = {226-233},
  note = {cited By (since 1996) 0},
  abstract = {With modeling and simulation, it is possible to study how a system
	works before trying to predict how it would behave in a variety of
	situations. However, when modeling landscape processes, issues related
	to space, time and multiple scales need to be addressed. In order
	to investigate these issues, a modeling platform based on a Domain
	Specific Language (DSL) has been developed. One of the main technical
	challenges of this platform is the ability to build applications
	with the capacity to themselves dynamically adapt to their environment.
	In this paper, we present the arguments and motivations behind the
	choice of the Service-Oriented Computing (SOC) approach when implementing
	the execution framework of the DSL. The modeling platform is composed
	of a development environment based on Eclipse IDE, a code generator,
	and an execution framework. The execution framework, which is the
	focus of this paper, must meet the constraints set by dynamic landscapes
	modeling, while capitalizing on the possibilities offered by the
	SOC approach.},
  affiliation = {INRIA, 06902 Sophia Antipolis, France; LRIT Laboratory, Mohammed V
	University, Agdal 10090, Morocco; CIRAD, UMR TETIS, 34398 Montpellier,
	France},
  author_keywords = {DSL; Landscape applications; Landscape modeling; Service orientation;
	Service-oriented component framework},
  document_type = {Conference Paper},
  journal = {Proceedings of the 13th IASTED International Conference on Software
	Engineering and Applications, SEA 2009},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-77954200558&partnerID=40&md5=e94ba7c405da5467ae2523862748f596}
}

@ARTICLE{Laird2010144,
  author = {Laird, P., Barrett, S.},
  title = {Towards dynamic evolution of domain specific languages},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2010},
  volume = {5969 LNCS},
  pages = {144-153},
  note = {cited By (since 1996) 0},
  abstract = {We propose the development of a framework for the variable interpretation
	of Domain Specific Languages (DSL). Domains often contain abstractions,
	the interpretation of which change in conjunction with global changes
	in the domain or specific changes in the context in which the program
	executes. In a scenario where domain assumptions encoded in the DSL
	implementation change, programmers must still work with the existing
	DSL, and therefore take more effort to describe their program, or
	sometimes fail to specify their intent. In such circumstances DSLs
	risk becoming less fit for purpose. We seek to develop an approach
	which makes a DSL less restrictive, maintaining flexibility and adaptability
	to cope with changing or novel contexts without reducing the expressiveness
	of the abstractions used. © 2010 Springer-Verlag.},
  affiliation = {Department of Computer Science, Trinity College, Dublin 2, Ireland},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-77951528551&partnerID=40&md5=c3f64fc63ae1eee832f1643d20c6c1e3}
}

@CONFERENCE{Laird200931,
  author = {Laird, P., Barrett, S.},
  title = {Towards context sensitive domain specific languages},
  year = {2009},
  volume = {385},
  pages = {31-36},
  note = {cited By (since 1996) 0},
  abstract = {We propose the development of a framework for the dy- namic context
	sensitive interpretation of Domain Speci c Languages. Domains often
	contain abstractions, the inter- pretation of which change in conjunction
	with changes in the domain or changes in the context in which the
	program ex- ecutes. In a scenario where domain assumptions encoded
	in the DSL change, programmers must still work with the ex- isting
	DSL, and therefore take more effort to describe their program or
	sometimes fail to specify their intent. In such changing circumstances
	DSLs risk becoming less t for pur- pose. We seek to develop an approach
	which makes a DSL less restrictive, maintaining exibility and adaptability
	to cope with changing or novel contexts without reducing the expressiveness
	of the abstractions used. © Copyright 2009 ACM.},
  affiliation = {Department of Computer Science, Trinity College, Dublin 2, Ireland},
  author_keywords = {Context sensitivity; Domain specific languages; Dynamic adaptation},
  document_type = {Conference Paper},
  journal = {ACM International Conference Proceeding Series},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-70049102197&partnerID=40&md5=8b89799369de617b37509a059f97db21}
}

@CONFERENCE{Laird2009713,
  author = {Laird, P., Dondio, P., Barrett, S.},
  title = {Dynamic domain specific languages for trust models},
  year = {2009},
  pages = {713-718},
  note = {cited By (since 1996) 0},
  abstract = {We propose the development of a framework for the dynamic interpretation
	of Trust models, defined via a Domain Specific Language. A trust
	model usually defines abstractions, the interpretation of which change
	in conjunction with changes in the domain or changes in the context
	in which the program executes. In a scenario where trust model assumptions
	encoded in the DSL change, programmers must still work with the existing
	DSL, and therefore take more effort to describe their program or
	sometimes fail to specify their intent. In such changing circumstances
	a trust model risks becoming less effective and fit for purpose.
	We seek to develop an approach in which a trust model adapts to a
	changing environment by making the underlying DSL less restrictive,
	maintaining flexibility and adaptability to cope with changing or
	novel contexts without reducing the expressiveness of the abstractions
	used. © 2009 IEEE.},
  affiliation = {Department of Computer Science, Trinity College, Dublin 2, Ireland},
  art_number = {5358865},
  author_keywords = {Context sensitivity; Domain specific languages; Dynamic adaptation;
	Trust models},
  document_type = {Conference Paper},
  journal = {Computation World: Future Computing, Service Computation, Adaptive,
	Content, Cognitive, Patterns, ComputationWorld 2009},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-77950971378&partnerID=40&md5=dc0a99cd3fb0bdcc69db35edaf6de36e}
}

@CONFERENCE{Lamb201151,
  author = {Lamb, C.C., Jamkhedkar, P.A., Bohnsack, M.P., Nandina, V., Heileman,
	G.L.},
  title = {A domain specific language for usage management},
  year = {2011},
  pages = {51-62},
  note = {cited By (since 1996) 0},
  abstract = {In this paper we describe the development of a domain specific language
	(DSL) for expressing usage management policies and associating those
	policies with managed artifacts. We begin by framing a model for
	the language, including generalized use cases, a domain model, a
	general supported life-cycle, and specific extension requirements.
	We then develop the language from that model, demonstrating key syntactic
	elements and highlighting the technology behind the language while
	tracing features back to the initial model. We then demonstrate how
	the DSL supports common usage management and DRM-centric environments,
	including creative commons, the extensible rights markup language
	(XrML), and the open digital rights language (ODRL). © 2011 ACM.},
  affiliation = {University of New Mexico, Department of Electrical and Computer Engineering,
	Albuquerque, NM 87131-0001, United States},
  author_keywords = {Access control; DRM; Interoperability; Usage management},
  document_type = {Conference Paper},
  journal = {Proceedings of the ACM Conference on Computer and Communications
	Security},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-81055125678&partnerID=40&md5=8a481b65efd51959251f5136bead37ab}
}

@ARTICLE{Lampe199897,
  author = {Lampe, J.},
  title = {Depot4 - A generator for dynamically extensible translators},
  journal = {Software-Concepts and Tools},
  year = {1998},
  volume = {19},
  pages = {97-108},
  number = {2},
  note = {cited By (since 1996) 2},
  abstract = {Research in compiler-compilers has contributed to facilitating the
	implementation of domain-specific programming languages and syntax-based
	software design. We present a formalism for the description of formal
	translations whose use requires no more than common procedural programming
	skills and an understanding of the EBNF notation. The soundness and
	applicability of the ideas presented have been proved by implementing
	the Depot4 metasystem. Its metalanguage, Ml4, extends EBNF in a symmetrical
	way; i.e., target descriptions utilise features already known from
	syntax definitions. The current implementation is by preprocessing.
	Simple use, flexibility and extensibility have been rated high. Applying
	principles of object-oriented programming, a concise and extensible
	system was built. A flexible access scheme allows the separate replacement
	of modules even during run time, thus enabling dynamic adjustment.
	New ways of application may originate from a more general view of
	source and target languages as well. © 1998 Springer-Verlag.},
  affiliation = {Technical University of Dresden, Department of Mathematics, D-01062
	Dresden, Germany},
  author_keywords = {Domain-specific languages; EBNF; Extensibility; Java; Oberon; Translator
	generator},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-17244380335&partnerID=40&md5=9b2ff26b952cd639005a9a7115e0c109}
}

@ARTICLE{Langer201152,
  author = {Langer, P.a , Wieland, K.b , Wimmer, M.b , Cabot, J.c },
  title = {From UML profiles to EMF profiles and beyond},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2011},
  volume = {6705 LNCS},
  pages = {52-67},
  note = {cited By (since 1996) 0},
  abstract = {Domain-Specific Modeling Languages (DSMLs) are getting more and more
	attention as a key element of Model Driven Engineering. As any other
	software artefact, DSMLs should continuously evolve to adapt to the
	changing needs of the domain they represent. Unfortunately, right
	now evolution of DSMLs is a costly process that requires changing
	its metamodel and re-creating the complete modeling environment.
	In this paper we advocate for the use of EMF Profiles, an adaptation
	of the UML profile concept to DSMLs. Profiles have been a key enabler
	for the success of UML by providing a lightweight language-inherent
	extension mechanism which is expressive enough to cover an important
	subset of adaptation scenarios. We believe a similar concept for
	DSMLs would provide an easier extension mechanism which has been
	so far neglected by current metamodeling tools. Apart from direct
	metamodel profiles, we also propose reusable profile definition mechanisms
	whereby profiles are defined independently of any DSML and, later
	on, coupled with all DSMLs that can benefit from these profiles.
	Our approach has been implemented in a prototype integrated in the
	EMF environment. © 2011 Springer-Verlag Berlin Heidelberg.},
  affiliation = {Johannes Kepler, University Linz, Austria; Vienna University of Technology,
	Austria; INRIA and Ecole des Mines de Nantes, France},
  author_keywords = {language engineering; Language extensions; UML profiles},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-79960175874&partnerID=40&md5=33f883aaa21aa12e691019b92250934e}
}

@ARTICLE{Lapalme200741,
  author = {Lapalme, J.a , Aboulhamid, E.M.a , Nicolescu, G.b , Rousseau, F.c
	},
  title = {Separating modeling and simulation aspects in hardware/software framework-based
	modeling languages},
  journal = {Arabian Journal for Science and Engineering},
  year = {2007},
  volume = {32},
  pages = {41-60},
  number = {2 C},
  note = {cited By (since 1996) 0},
  abstract = {As transistor integration reaches the order of billions, the already
	significant productivity gap which plagues the silicon industry will
	only widen further. Many are working on the problem from different
	angles. Some regard domain-specific modeling languages as a solution.
	Others believe in modeling languages which are based on a library/framework
	approach. Yet others believe in sophisticated proprietary tools.
	None of the current paths seem to be silver bullets. However, object-oriented
	framework-based solutions, such as SystemC, are gaining a great deal
	of momentum and acceptance from the industry. Despite all the efforts
	which have been spent on the development of these types of solutions,
	very few efforts have been spent on the cornerstone task of investigating
	which software design techniques and technologies should be used
	to develop effective framework-based solutions. The main objective
	of this article is to present how modern software engineering technologies
	may be used to create better framework-based modeling solutions.
	These solutions are characterized by a clear separation of concerns
	between modeling and simulation aspects. A novel modeling framework
	called SoCML is presented which possesses the above characteristic.
	SoCML has many benefits such as verification by interception and
	alternative simulation support.},
  affiliation = {Laboratoire LASSO, IR.OUniversité de Montréal, C.P. 6128 , Succ. Centre-Ville,
	Montréal, QC H3C 3J7, Canada; École Polytechnique de Montreal Canada,
	C.P. 6079, succ. Centre-Ville, Montréal, QC H3C 3A7, Canada; TIMA,
	46 av. Felix Viallet, 38031 Grenoble CEDEX, France},
  author_keywords = {C#; C++; Concurrent; Environments; Logic design hardware description
	languages; Modeling methodologies; Programming languages: design
	languages; Simulation; Simulation and modeling: simulation languages;
	Verification; VHDL},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-47649100794&partnerID=40&md5=a56b78acd52cd0b71328bcf9bfc0d488}
}

@ARTICLE{Larsen200945,
  author = {Larsen, K.F.},
  title = {A MuDDy experience-ML bindings to a BDD library},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2009},
  volume = {5658 LNCS},
  pages = {45-57},
  note = {cited By (since 1996) 0},
  abstract = {Binary Decision Diagrams (BDDs) are a data structure used to efficiently
	represent boolean expressions on canonical form. BDDs are often the
	core data structure in model checkers. MuDDy is an ML interface (both
	for Standard ML and Objective Caml) to the BDD package BuDDy that
	is written in C. This combination of an ML interface to a high-performance
	C library is surprisingly fruitful. ML allows you to quickly experiment
	with high-level symbolic algorithms before handing over the grunt
	work to the C library. I show how, with a relatively little effort,
	you can make a domain specific language for concurrent finite state-machines
	embedded in Standard ML and then write various custom model-checking
	algorithms for this domain specific embedded language (DSEL). © IFIP
	International Federation for Information Processing 2009.},
  affiliation = {Department of Computer Science, University of Copenhagen, Njalsgade
	132, Copenhagen S, DK-2300, Denmark},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-69049105474&partnerID=40&md5=97ccfaf80bd65b4bb23c6b3a2464b115}
}

@CONFERENCE{Latry200799,
  author = {Latry, F., Mercadal, J., Consel, C.},
  title = {Staging telephony service creation: A language approach},
  year = {2007},
  pages = {99-110},
  note = {cited By (since 1996) 2},
  abstract = {The open-endedness of telephony platforms is creating expectations
	among users, ranging from end-users to administrators, to create
	services dedicated to their activities. Not only is the population
	of developers heterogeneous, but the technologies underlying modern
	telephony range over a variety of areas such as multimedia, databases,
	web services, and distributed systems. This situation drastically
	widens the expertise required for service creation. This paper proposes
	an approach to coping with the heterogeneity of both the service
	developers and the technologies underlying modern telephony. Our
	approach is based on programming languages. It consists of providing
	a language that is specific to each developer community with respect
	to its expertise (e.g., programming skills) and the target application
	area (e.g., administration). Such languages, called Domain-Specific
	Languages (DSLs), are organized in layers, accounting for abstraction
	levels. Our layered approach to telephony service creation is illustrated
	by two high-level DSLs for end-user service creation, requiring no
	programming skills, and an expressive DSL enabling the development
	of expert-level telephony services. We show that layering DSLs greatly
	facilitates their implementation and verification of telephony-specific
	properties by leveraging on high-level tools. © 2007 ACM.},
  affiliation = {Department of Telecommunications, INRIA, LaBRI, 351, cours de la Libération,
	F-33405 Talence, France},
  document_type = {Conference Paper},
  journal = {Proceedings of the 1st International Conference on Principles, Systems
	and Applications of IP Telecommunications, IPTComm '07},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-77952411033&partnerID=40&md5=387e3d65da31bdb19c6730e42c67cff0}
}

@ARTICLE{Lawall200578,
  author = {Lawall, J.L.a , Duchesne, H.b , Muller, G.b , Le Meur, A.-F.c },
  title = {Bossa Nova: Introducing modularity into the Bossa domain-specific
	language},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2005},
  volume = {3676 LNCS},
  pages = {78-93},
  note = {cited By (since 1996) 1},
  abstract = {Domain-specific languages (DSLs) have been proposed as a solution
	to ease the development of programs within a program family. Sometimes,
	however, experience with the use of a DSL reveals the presence of
	subfamilies within the family targeted by the language. We are then
	faced with the question of how to capture these subfamilies in DSL
	abstractions. A solution should retain features of the original DSL
	to leverage existing expertise and support tools. The Bossa DSL is
	a language targeted towards the development of kernel process scheduling
	policies. We have encountered the issue of program subfamilies in
	using this language to implement an encyclopedic, multi-OS library
	of scheduling policies. In this paper, we propose that introducing
	certain kinds of modularity into the language can furnish abstractions
	appropriate for implementing scheduling policy subfamilies. We present
	the design of our modular language, Bossa Nova, and assess the language
	quantitatively and qualitatively. © Springer-Verlag Berlin Heidelberg
	2005.},
  affiliation = {DIKU, University of Copenhagen, Denmark; OBASCO Group, École des Mines
	de Nantes-INRIA, LINA, France; Jacquard Group, LIFL/INRIA, Université
	des Sciences et Technologies de Lille, France},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-33646127791&partnerID=40&md5=e459a8df1799909bc2576c14ec1f45b1}
}

@ARTICLE{Lawall2004436,
  author = {Lawall, J.L.a , Le Meur, A.-F.L.a c , Muller, G.b },
  title = {On designing a target-independent DSL for safe OS process-scheduling
	components},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2004},
  volume = {3286},
  pages = {436-455},
  note = {cited By (since 1996) 3},
  abstract = {Developing new process-scheduling components for multiple OSes is
	challenging because of the tight interdependence between an OS and
	its scheduler and because of the stringent safety requirements that
	OS code must satisfy. In this context, a domain-specific language
	(DSL), designed by a scheduling expert, can encapsulate scheduling
	expertise and thus facilitate scheduler programming and verification.
	Nevertheless, designing a DSL that is target-independent and provides
	safety guarantees requires expertise not only in scheduling but also
	in the structure of various OSes. To address these issues, we propose
	the introduction of an OS expert into the DSL design process and
	the use of a type system to enable the OS expert to express relevant
	OS properties. This paper instantiates our approach in the context
	of the Bossa process-scheduling framework and describes how the types
	provided by an OS expert are used to ensure that Bossa scheduling
	components are safe. © Springer-Verlag 2004.},
  affiliation = {DIKU, University of Copenhagen, 2100 Copenhagen Ø, Denmark; Ecole
	des Mines de Nantes/INRIA, 44307 Nantes Cedex 3, France; Université
	des Sciences et Technologies de Lille, LIFL, INRIA Project Jacquard,
	59655 Villeneuve d'Ascq, France},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-35048831779&partnerID=40&md5=9bb7d63f10b8b43ad1d9b3ed20dacd38}
}

@CONFERENCE{Lawall200480,
  author = {Lawall, J.L.a , Muller, G.b , Duchesne, H.b },
  title = {Invited application paper: Language design for implementing process
	scheduling hierarchies},
  year = {2004},
  pages = {80-91},
  note = {cited By (since 1996) 2},
  abstract = {Standard operating systems provide only a single fixed scheduler,
	which does not meet all possible application scheduling needs. More
	flexibility can be achieved using a hierarchy of schedulers, allowing
	multiple schedulers to coexist in a single operating system (OS).
	Bossa is a framework for facilitating the implementation and deployment
	of OS process schedulers. In this paper, we describe the features
	of Bossa that enable the creation and management of a scheduling
	hierarchy. These features include a domain-specific language for
	implementing schedulers and a type system for describing requirements
	on scheduler behavior. The use of the domain-specific language eases
	scheduler development and enables scheduler verification. We have
	found that the approach allows programmers, even students who are
	not kernel or scheduling experts, to easily and safely implement
	and deploy schedulers that meet specific application needs.},
  affiliation = {DIKU, University of Copenhagen, 2100 Copenhagen Ø, Denmark; Obasco
	Group, EMN/INRIA, 44307 Nantes Cedex 3, France},
  author_keywords = {Domain-Specific Languages; Operating System extension; Process scheduling;
	Scheduling hierarchies; Verification},
  document_type = {Conference Paper},
  journal = {Proceedings of the ACM SIGPLAN Symposium on Partial Evaluation and
	Semantics-Based Program Manipulation},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-11244280796&partnerID=40&md5=56a16c20a29f20124c00ede0fbb5045d}
}

@CONFERENCE{Lawall20097,
  author = {Lawall, J.L.a , Muller, G.b , Palix, N.a },
  title = {Enforcing the use of API functions in Linux code},
  year = {2009},
  pages = {7-11},
  note = {cited By (since 1996) 3},
  abstract = {In the Linux kernel source tree, header files typically define many
	small functions that have a simple behavior but are critical to ensure
	readability, correctness, and maintainability. We have observed,
	however, that some Linux code does not use these functions systematically.
	In this paper, we propose an approach combining rule-based program
	matching and transformation with generative programming to generate
	rules for finding and fixing code fragments that should use the functions
	defined in header files. We illustrate our approach using an in-depth
	study based on four typical functions defined in the header file
	include/linux/usb.h. Copyright 2009 ACM.},
  affiliation = {DIKU, University of Copenhagen, Denmark; EMN/INRIA-Regal, France},
  author_keywords = {apis; bug-finding; bug-fixing; linux},
  document_type = {Conference Paper},
  journal = {Proceedings of the 8th Workshop on Aspects, Components, and Patterns
	for Infrastructure Software, ACP4IS '09, Co-located with the 8th
	Int. Conf. Aspect-Oriented Software Development, AOSD.09},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-77952272364&partnerID=40&md5=c0509e49eb695ce5f60e7ceea42e48fc}
}

@CONFERENCE{Lawall2007,
  author = {Lawall, J.L.a , Probst, C.W.b , Schultz, U.P.c },
  title = {Issues in holistic system design},
  year = {2007},
  note = {cited By (since 1996) 0},
  abstract = {The coordination of layers in computer and software systems is one
	of the main challenges in designing such systems today. In this paper
	we consider Holistic System Design as a way of integrating requirements
	and facilities of different system layers. We also discuss some of
	the challenges that this kind of system design poses for computer
	science in general as well as programming languages and operating
	systems in particular. Copyright © 2006 ACM.},
  affiliation = {DIKU, University of Copenhagen, Universitetsparken 1, 2100 Copenhagen
	Ø; Technical University of Denmark, Richard Petersens Plads, 2800
	Kongens Lyngby; Maersk Institute, University of Southern Denmark,
	Campusvej 55, 5230 Odense M},
  art_number = {1216007},
  author_keywords = {Adaptive software; Domain-specific languages; Software architecture},
  document_type = {Conference Paper},
  journal = {International Conference on Architectural Support for Programming
	Languages and Operating Systems - ASPLOS},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-34748912288&partnerID=40&md5=605dbec06106a8041f2cdb5551ef0805}
}

@CONFERENCE{Lawall2006,
  author = {Lawall, J.L.a , Probst, C.W.b , Schultz, U.P.c },
  title = {Issues in holistic system design},
  year = {2006},
  note = {cited By (since 1996) 0},
  abstract = {The coordination of layers in computer and software systems is one
	of the main challenges in designing such systems today. In this paper
	we consider Holistic System Design as a way of integrating requirements
	and facilities of different system layers. We also discuss some of
	the challenges that this kind of system design poses for computer
	science in general as well as programming languages and operating
	systems in particular. Copyright © 2006 ACM.},
  affiliation = {DIKU, University of Copenhagen, Universitetsparken 1, 2100 Copenhagen
	Ø, Denmark; IMM, Technical University of Denmark, Richard Petersens
	Plads, 2800 Kongens Lyngby, Denmark; Maersk Institute, University
	of Southern Denmark, Campusvej 55, 5230 Odense M, Denmark},
  art_number = {1216007},
  author_keywords = {adaptive software; domain-specific languages; software architecture},
  document_type = {Conference Paper},
  journal = {International Conference on Architectural Support for Programming
	Languages and Operating Systems - ASPLOS},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-77953992828&partnerID=40&md5=b6a4af603d1a196bc4c9c43682e2d3a8}
}

@ARTICLE{LeNoir201185,
  author = {Le Noir, J.a , Delande, O.a , Exertier, D.b , Da Silva, M.A.A.c ,
	Blanc, X.d },
  title = {Operation based model representation: Experiences on inconsistency
	detection},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2011},
  volume = {6698 LNCS},
  pages = {85-96},
  note = {cited By (since 1996) 0},
  abstract = {Keeping the consistency between design models is paramount in complex
	contexts. It turns out that the underlying Model Representation Strategy
	has an impact on the inconsistency detection activity. The Operation
	Based strategy represents models as the sequence of atomic editing
	actions that lead to its current state. Claims have been made about
	gains in time and space complexity and in versatility by using this
	kind of representation when compared to the traditional object based
	one. However, this hypothesis has never been tested in an industrial
	context before. In this paper, we detail our experience evaluating
	an Operation Based consistency engine (Praxis) when compared with
	a legacy system based on EMF. We evaluated a set of industrial models
	under inconsistency rules written in both Java (for EMF) and PraxisRules
	(the DSL - Domain Specific Language - for describing inconsistency
	rules in Praxis). Our results partially confirm the gains claimed
	by the Operation Based engines. © 2011 Springer-Verlag.},
  affiliation = {Thales Research and Technology, France; Thales Corporate Services,
	France; LIP6, UPMC Paris Universitas, France; LABRI, Université de
	Bordeaux 1, France},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-79959258986&partnerID=40&md5=5e29117e0ae3796ee2c5f9ccb1cad73c}
}

@CONFERENCE{Leclercq2007209,
  author = {Leclercq, M.a , Özcan, A.E.a , Quéma, V.b , Stefani, J.-B.c },
  title = {Supporting heterogeneous architecture descriptions in an extensible
	toolset},
  year = {2007},
  pages = {209-218},
  note = {cited By (since 1996) 9},
  abstract = {Many architecture description languages (ADLs) have been proposed
	to model, analyze, configure, and deploy complex software systems.
	To face this diversity, extensible ADLs (or ADL interchange formats)
	have been proposed. These ADLs provide linguistic support for integrating
	various architectural aspects within the same description. Nevertheless,
	they do not support extensibility at the tool level, i.e. they do
	not provide an extensible toolset for processing ADL descriptions.
	In this paper, we present an extensible toolset for easing the development
	of architecture-based software systems. This toolset is not bound
	to a specific ADL, but rather uses a grammar description mechanism
	to accept various input languages, e.g. ADLs, Interface Definition
	Languages (IDLs), Domain Specific Languages (DSLs). Moreover, it
	can easily be extended to implement many different features, such
	as behavioral analysis, code generation, deployment, etc. Its extensibility
	is obtained by designing its core functionalities using fine-grained
	components that implement flexible design patterns. Experiments are
	presented to illustrate both the functionalities implemented by the
	toolset and the way it can be extended. © 2007 IEEE.},
  affiliation = {STMicroelectronics, Grenoble, France; CNRS, Grenoble, France; INRIA,
	Grenoble, France},
  art_number = {4222583},
  document_type = {Conference Paper},
  journal = {Proceedings - International Conference on Software Engineering},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-34548809142&partnerID=40&md5=bbd82a37227fa9b5a55867fc9321fd26}
}

@ARTICLE{Ledeczi200382,
  author = {Ledeczi, A., Davis, J., Neema, S., Agrawal, A.},
  title = {Modeling Methodology for Integrated Simulation of Embedded Systems},
  journal = {ACM Transactions on Modeling and Computer Simulation},
  year = {2003},
  volume = {13},
  pages = {82-103},
  number = {1},
  note = {cited By (since 1996) 19},
  abstract = {Developing a single embedded application involves a multitude of different
	development tools including several different simulators. Most tools
	use different abstractions, have their own formalisms to represent
	the system under development, utilize different input and output
	data formats, and have their own semantics. A unified environment
	that allows capturing the system in one place and one that drives
	all necessary simulators and analysis tools from this shared representation
	needs a common representation technology that must support several
	different abstractions and formalisms seamlessly. Describing the
	individual formalisms by metamodels and carefully composing them
	is the underlying technology behind MILAN, a Model-based Integrated
	Simulation Framework. MILAN is an extensible framework that supports
	multigranular simulation of embedded systems by seamlessly integrating
	existing simulators into a unified environment. Formal metamodels
	and explicit constraints define the domain-specific modeling language
	developed for MILAN that combines hierarchical, heterogeneous, parametric
	dataflow representation with strong data typing. Multiple modeling
	aspects separate orthogonal concepts. The language also allows the
	representation of the design space of the application, not just a
	point solution. Nonfunctional requirements are captured as formal,
	application-specific constraints. MILAN has integrated tool support
	for design-space exploration and pruning. The models are used to
	automatically configure the integrated functional simulators, high-level
	performance and power estimators, cycle-accurate performance simulators,
	and power-aware simulators. Simulation results are used to automatically
	update the system models. The article focuses on the modeling methodology
	and briefly describes how the integrated models are utilized in the
	framework.},
  affiliation = {Inst. for Software Intgd. Systems, Vanderbilt University, Station
	B, Nashville, TN 37235},
  author_keywords = {Domain specific languages; Metamodeling; Model integrated computing;
	Modeling; Simulation; Simulation integration},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-0344462466&partnerID=40&md5=16028172170915178e34f2c7453cdfac}
}

@ARTICLE{Lee201142,
  author = {Lee, H.a , Brown, K.J.a , Sujeeth, A.K.a , Chafi, H.a , Rompf, T.b
	, Odersky, M.b , Olukotun, K.a },
  title = {Implementing domain-specific languages for heterogeneous parallel
	computing},
  journal = {IEEE Micro},
  year = {2011},
  volume = {31},
  pages = {42-52},
  number = {5},
  note = {cited By (since 1996) 0},
  abstract = {Domain-specific languages offer a solution to the performance and
	the productivity issues in heterogeneous computing systems. The Delite
	compiler framework simplifies the process of building embedded parallel
	DSLs. DSL developers can implement domain-specific operations by
	extending the DSL framework, which provides static optimizations
	and code generation for heterogeneous hardware. The Delite runtime
	automatically schedules and executes DSL operations on heterogeneous
	hardware. © 2011 IEEE.},
  affiliation = {Gates Building, Stanford University, Stanford, CA 94305, United States;
	École Polytechnique Fédérale de Lausanne, Switzerland},
  art_number = {5963629},
  author_keywords = {CPU; domain-specific languages; GPU; heterogeneous computing; parallel
	programming},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-80054848811&partnerID=40&md5=631d6eebf58cfa50ddd3c5beedfe82d4}
}

@ARTICLE{Lee2006231,
  author = {Lee, J.-S.a , Chae, H.S.b },
  title = {Domain-specific language approach to modelling UI architecture of
	mobile telephony systems},
  journal = {IEE Proceedings: Software},
  year = {2006},
  volume = {153},
  pages = {231-240},
  number = {6},
  note = {cited By (since 1996) 2},
  abstract = {Although there has been a considerable increase in the use of embedded
	software including mobile telephony applications, the development
	of embedded software has not proved so manageable as compared with
	conventional software. From the experience of working with mobile
	telephony systems for over three years, it is the author's belief
	that the huge amount of variance in application logics, not the diversity
	of hardware platforms, is the major obstacle to the development of
	embedded software. A domain specific language (DSL) for modelling
	the user interface (UI) architecture of embedded software, especially
	focusing on telephony applications is proposed. With the proposed
	DSL, developers can describe the UI architecture of applications
	by the fundamental domain concepts at a higher level of abstraction.
	The proposed DSL is based on the concept of scene. A scene is proposed
	as a unit of UI in the UI architecture and UI-related behaviours
	are associated with scenes. The result of a pilot project conducted
	in a major company dedicated to developing mobile telephony applications
	is also described. © The Institution of Engineering and Technology
	2006.},
  affiliation = {Software and Solution Center, LG Electronics, GS Gangnam Tower, 679
	Yeoksam-dong, Gangnam-gu, Seoul 135-985, South Korea; Department
	of Computer Science and Engineering, Pusan National University, Busan
	609-735, South Korea},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-33846159505&partnerID=40&md5=5d34c9d8dcefab5d2be95971ea4bc83c}
}

@ARTICLE{Leff2007,
  author = {Leff, A., Rayfield, J.T.},
  title = {WebRB: Evaluating a visual domain-specific language for building
	relational web-applications},
  journal = {ACM SIGPLAN Notices},
  year = {2007},
  volume = {42},
  pages = {281-300},
  number = {10},
  note = {cited By (since 1996) 0},
  abstract = {Many web-applications can be characterized as "relational". In this
	paper we introduce and evaluate WebRB, avisual domain-specific language
	for building such applications. WebRB addresses the limitations of
	the conventional "imperative-embedding" approach typically used to
	build relational web-applications. We describe the WebRB language,
	present extended examples of its use, and discuss the WebRB visual
	editor, libraries, and runtime. We then evaluate WebRB by comparing
	it to alternative approaches, and demonstrate its effectiveness in
	building relational web-applications. Copyright © 2007 ACM.},
  affiliation = {IBM T.J. Watson Research Center},
  author_keywords = {Data-flow languagesR; Relational web-applications; Visual programming
	languages; Web relational blocks; Web-application development; Webrb},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-67650035143&partnerID=40&md5=20a48a1f7d67a15829c65448d5b9d00e}
}

@CONFERENCE{Leff2007281,
  author = {Leff, A., Rayfield, J.T.},
  title = {WebRB: Evaluating a visual domain-specific language for building
	relational Web-applications},
  year = {2007},
  pages = {281-300},
  note = {cited By (since 1996) 1},
  abstract = {Many web-applications can be characterized as "relational". In this
	paper we introduce and evaluate WebRB, a visual domain-specific language
	for building such applications. WebRB addresses the limitations of
	the conventional "imperative-embedding" approach typically used to
	build relational web-applications. We describe the WebRB language,
	present extended examples of its use, and discuss the WebRB visual
	editor, libraries, and runtime. We then evaluate WebRB by comparing
	it to alternative approaches, and demonstrate its effectiveness in
	building relational webapplications. Copyright © 2007 ACM.},
  affiliation = {IBM T.J. Watson Research Center},
  author_keywords = {Data-flow languagesR; Relational web-applications; Visual program-
	Ming languages; Web relational blocks; Web-application development;
	Webrb},
  document_type = {Conference Paper},
  journal = {Proceedings of the Conference on Object-Oriented Programming Systems,
	Languages, and Applications, OOPSLA},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-42149083818&partnerID=40&md5=d4089fc5c4a965201166b40a3a22f25c}
}

@ARTICLE{Leijen2000109,
  author = {Leijen, D., Meijer, E.},
  title = {Domain specific embedded compilers},
  journal = {SIGPLAN Notices (ACM Special Interest Group on Programming Languages)},
  year = {2000},
  volume = {35},
  pages = {109-122},
  number = {1},
  note = {cited By (since 1996) 5},
  abstract = {Domain-specific embedded languages (DSELs) expressed in higher-order,
	typed (HOT) languages provide a composable framework for domain-specific
	abstractions. Such a framework is of greater utility than a collection
	of stand-alone domain-specific languages. Usually, embedded domain
	specific languages are build on top of a set of domain specific primitive
	functions that are ultimately implemented using some form of foreign
	function call. We sketch a general design pattern for embedding client-server
	style services into Haskell using a domain specific embedded compiler
	for the server's source language. In particular we apply this idea
	to implement Haskell/DB, a domain specific embdedded compiler that
	dynamically generates of SQL queries from monad comprehensions, which
	are then executed on an arbitrary ODBC database server. © 2000 ACM.},
  affiliation = {University of Utrecht, Department of Computer Science, PO Box 80.089,
	3508 TB Utrecht, Netherlands},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-0342664664&partnerID=40&md5=aa8461dc5a4aaca12336e9f4a73209aa}
}

@CONFERENCE{Leijen2009,
  author = {Leijen, D., Schulte, W., Burckhardt, S.},
  title = {The design of a task parallel library},
  year = {2009},
  pages = {227-241},
  note = {cited By (since 1996) 18},
  abstract = {The Task Parallel Library (TPL) is a library for .NET that makes it
	easy to take advantage of potential parallelism in a program. The
	library relies heavily on generics and delegate expressions to provide
	custom control structures expressing structured parallelism such
	as map-reduce in user programs. The library implementation is built
	around the notion of a task as a finite CPU-bound computation. To
	capture the ubiquitous apply-to-all pattern the library also introduces
	the novel concept of a replicable task. Tasks and replicable tasks
	are assigned to threads using work stealing techniques, but unlike
	traditional implementations based on the THE protocol, the library
	uses a novel data structure called a 'duplicating queue'. A surprising
	feature of duplicating queues is that they have sequentially inconsistent
	behavior on architectures with weak memory models, but capture this
	non-determinism in a benign way by sometimes duplicating elements.
	TPL ships as part of the Microsoft Parallel Extensions for the .NET
	framework 4.0, and forms the foundation of Parallel LINQ queries
	(however, note that the productized TPL library may differ in significant
	ways from the basic design described in this article). Copyright
	© 2009 ACM.},
  affiliation = {Microsoft Research},
  author_keywords = {Domain specific languages; Duplicating queue; Parallelism; Work stealing},
  document_type = {Conference Paper},
  journal = {Proceedings of the Conference on Object-Oriented Programming Systems,
	Languages, and Applications, OOPSLA},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-72249096886&partnerID=40&md5=cb238d51c61f22f59eac516f7756fac6}
}

@ARTICLE{Leijen2009227,
  author = {Leijen, D., Schulte, W., Burckhardt, S.},
  title = {The design of a task parallel library},
  journal = {ACM SIGPLAN Notices},
  year = {2009},
  volume = {44},
  pages = {227-241},
  number = {10},
  note = {cited By (since 1996) 4},
  abstract = {The Task Parallel Library (TPL) is a library for .NET that makes it
	easy to take advantage of potential parallelism in a program. The
	library relies heavily on generics and delegate expressions to provide
	custom control structures expressing structured parallelism such
	as map-reduce in user programs. The library implementation is built
	around the notion of a task as a finite CPU-bound computation. To
	capture the ubiquitous apply-to-all pattern the library also introduces
	the novel concept of a replicable task. Tasks and replicable tasks
	are assigned to threads using work stealing techniques, but unlike
	traditional implementations based on the THE protocol, the library
	uses a novel data structure called a 'duplicating queue'. A surprising
	feature of duplicating queues is that they have sequentially inconsistent
	behavior on architectures with weak memory models, but capture this
	non-determinism in a benign way by sometimes duplicating elements.
	TPL ships as part of the Microsoft Parallel Extensions for the .NET
	framework 4.0, and forms the foundation of Parallel LINQ queries
	(however, note that the productized TPL library may differ in significant
	ways from the basic design described in this article). © 2009 ACM.},
  affiliation = {Microsoft Research},
  author_keywords = {Domain specific languages; Parallelism; Work stealing},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-70350660787&partnerID=40&md5=dd85df3231323315aa33f9bd736e1c69}
}

@CONFERENCE{Lejdfors20061610,
  author = {Lejdfors, C., Ohlsson, L.},
  title = {Implementing an embedded GPU language by combining translation and
	generation},
  year = {2006},
  volume = {2},
  pages = {1610-1614},
  note = {cited By (since 1996) 3},
  abstract = {Dynamic languages typically allow programs to be written at a very
	high level of abstraction. But their dynamic nature makes it very
	hard to compile such languages, meaning that a price has to be paid
	in terms of performance. However under certain restricted conditions
	compilation is possible. In this paper we describe how a domain specific
	language for image processing in Python can be compiled for execution
	on high speed graphics processing units. Previous work on similar
	problems have used either translative or generative compilation methods,
	each of which has its limitations. We propose a strategy which combine
	these two methods thereby achieving the benefits of both. Copyright
	2006 ACM.},
  affiliation = {Department of Computer Science, Lund University, Lund, Sweden},
  author_keywords = {Compilation; Dynamic languages; Generative techniques; GPU; Image
	processing},
  document_type = {Conference Paper},
  journal = {Proceedings of the ACM Symposium on Applied Computing},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-33751050638&partnerID=40&md5=d82e5f95bb39f12dfb5868b91ad05985}
}

@ARTICLE{Lemieux201129,
  author = {Lemieux, V.a , Limonad, L.b },
  title = {What 'good' looks like: Understanding records ontologically in the
	context of the global financial crisis},
  journal = {Journal of Information Science},
  year = {2011},
  volume = {37},
  pages = {29-39},
  number = {1},
  note = {cited By (since 1996) 0},
  abstract = {This paper explores the internal components (semantics) of financial
	electronic records. The authors adopt a view of records as representations
	of perceptions about a specific domain that belong to classes of
	representations at the centre of which are archetypal 'good' records
	(records that most faithfully represent their domains). The paper
	proposes a static modelling language that illustrates how the ontological
	concepts of Bunge and Searle can be integrated to achieve a richer
	grammatical explanatory tool for use in modelling the internal structure
	of archetypal records in the context of domains of financial crisis
	and contagion such as the failure of Lehman Brothers. © The Author(s),
	2011.},
  affiliation = {School of Library, Archival and Information Studies, University of
	British Columbia, Vancouver, Canada; Sauder School of Business, University
	of British Columbia, Vancouver, Canada},
  author_keywords = {Bunge; conceptual modelling; domain-specific language; failure of
	Lehman Brothers; global financial crisis; information systems; ontology;
	records; Searle; semantics; social ontology},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-79551628835&partnerID=40&md5=ba46be1cea18eba70bf44900b0fb3873}
}

@ARTICLE{Lepper201115,
  author = {Lepper, M.a , Trancón Y Widemann, B.b },
  title = {Optimization of visitor performance by reflection-based analysis},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2011},
  volume = {6707 LNCS},
  pages = {15-30},
  note = {cited By (since 1996) 0},
  abstract = {Visitors are a well-known and powerful design pattern for processing
	regular data structures and for combining declarative and imperative
	coding styles. The authors' umod model generator creates Java data
	models from a concise and algebraic notation. It is primarily used
	to model intermediate representations of computer languages. The
	user defines visitor code by extending skeleton classes, which are
	generated according to traversal annotations in the model. Since
	the generated code on its own executes the pure traversal and no
	semantic side-effects, traversals are redundant unless some user-overridden
	method is eventually invoked. We present a reflection-based control
	flow analysis to detect this situation and prune the traversal transparently.
	With a well-stratified model, this may lead to substantial increase
	in performance. © 2011 Springer-Verlag.},
  affiliation = {Semantics GmbH, Berlin, Germany; Universität Bayreuth, Germany},
  author_keywords = {Control Flow Analysis; Generative Programming; Reflection; Visitor
	Pattern},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-79960229997&partnerID=40&md5=fc5f1b99dd5e270431307c7efa14c0b5}
}

@CONFERENCE{Lerner2003,
  author = {Lerner, S., Millstein, T., Chambers, C.},
  title = {Automatically proving the correctness of compiler optimizations},
  year = {2003},
  pages = {220-231},
  note = {cited By (since 1996) 27},
  abstract = {We describe a technique for automatically proving compiler optimizations
	sound, meaning that their transformations are always semantics-preserving.
	We first present a domain-specific language, called Cobalt, for implementing
	optimizations as guarded rewrite rules. Cobalt optimizations operate
	over a C-like intermediate representation including unstructured
	control flow, pointers to local variables and dynamically allocated
	memory, and recursive procedures. Then we describe a technique for
	automatically proving the soundness of Cobalt optimizations. Our
	technique requires an automatic theorem prover to discharge a small
	set of simple, optimization-specific proof obligations for each optimization.
	We have written a variety of forward and backward intraprocedural
	dataflow optimizations in Cobalt, including constant propagation
	and folding, branch folding, full and partial redundancy elimination,
	full and partial dead assignment elimination, and simple forms of
	points-to analysis. We implemented our soundness-checking strategy
	using the Simplify automatic theorem prover, and we have used this
	implementation to automatically prove our optimizations correct.
	Our checker found many subtle bugs during the course of developing
	our optimizations. We also implemented an execution engine for Cobalt
	optimizations as part of the Whirlwind compiler infrastructure.},
  affiliation = {Department of Computer Science, University of Washington, Seattle,
	WA, United States},
  author_keywords = {Automated correctness proofs; Compiler optimization},
  document_type = {Conference Paper},
  journal = {Proceedings of the ACM SIGPLAN Conference on Programming Language
	Design and Implementation (PLDI)},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-0038039859&partnerID=40&md5=49db1aaea27c4e9b9c907afc5aa15f57}
}

@ARTICLE{Lerner2003220,
  author = {Lerner, S., Millstein, T., Chambers, C.},
  title = {Automatically proving the correctness of compiler optimizations},
  journal = {ACM SIGPLAN Notices},
  year = {2003},
  volume = {38},
  pages = {220-231},
  number = {5},
  note = {cited By (since 1996) 12},
  abstract = {We describe a technique for automatically proving compiler optimizations
	sound, meaning that their transformations are always semantics-preserving.
	We first present a domain-specific language, called Cobalt, for implementing
	optimizations as guarded rewrite rules. Cobalt optimizations operate
	over a C-like intermediate representation including unstructured
	control flow, pointers to local variables and dynamically allocated
	memory, and recursive procedures. Then we describe a technique for
	automatically proving the soundness of Cobalt optimizations. Our
	technique requires an automatic theorem prover to discharge a small
	set of simple, optimization-specific proof obligations for each optimization.
	We have written a variety of forward and backward intraprocedural
	dataflow optimizations in Cobalt, including constant propagation
	and folding, branch folding, full and partial redundancy elimination,
	full and partial dead assignment elimination, and simple forms of
	points-to analysis. We implemented our soundness-checking strategy
	using the Simplify automatic theorem prover, and we have used this
	implementation to automatically prove our optimizations correct.
	Our checker found many subtle bugs during the course of developing
	our optimizations. We also implemented an execution engine for Cobalt
	optimizations as part of the Whirlwind compiler infrastructure.},
  affiliation = {Dept. of Computer Science and Eng., University of Washington, Seattle,
	WA, United States},
  author_keywords = {Automated correctness proofs; Compiler optimization},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-1442264309&partnerID=40&md5=06a5e916a3381114d48b2979a78c42ce}
}

@ARTICLE{Lerner20055,
  author = {Lerner, S.a , Millstein, T.b , Chambers, C.a },
  title = {Cobalt: A Language for Writing Provably-Sound Compiler Optimizations},
  journal = {Electronic Notes in Theoretical Computer Science},
  year = {2005},
  volume = {132},
  pages = {5-17},
  note = {cited By (since 1996) 0},
  abstract = {We overview the current status and future directions of the Cobalt
	project. Cobalt is a domain-specific language for implementing compiler
	optimizations as guarded rewrite rules. Cobalt optimizations operate
	over a C-like intermediate representation including unstructured
	control flow, pointers to local variables and dynamically allocated
	memory, and recursive procedures. The design of Cobalt engenders
	a natural inductive strategy for proving the soundness of optimizations.
	This strategy is fully automated by requiring an automatic theorem
	prover to discharge a small set of simple proof obligations for each
	optimization. We have written a variety of forward and backward intraprocedural
	dataflow optimizations in Cobalt, including constant propagation
	and folding, branch folding, full and partial redundancy elimination,
	full and partial dead assignment elimination, and simple forms of
	points-to analysis. The implementation of our soundness-checking
	strategy employs the Simplify automatic theorem prover, and we have
	used this implementation to automatically prove the above optimizations
	correct. An execution engine for Cobalt optimizations is implemented
	as part of the Whirlwind compiler infrastructure. © 2005 Elsevier
	B.V. All rights reserved.},
  affiliation = {Department of Computer Science and Engineering, University of Washington,
	Seattle, WA, United States; Computer Science Department, University
	of California, Los Angeles, Los Angeles, CA, United States},
  author_keywords = {Automated correctness proofs; Compiler optimization},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-18544382513&partnerID=40&md5=c9ef72a44cd4ec7a85828d17bbd7b661}
}

@ARTICLE{Leroux2006555,
  author = {Leroux, D.a , Nally, M.b , Hussey, K.a },
  title = {Rational software architect: A tool for domain-specific modeling},
  journal = {IBM Systems Journal},
  year = {2006},
  volume = {45},
  pages = {555-568},
  number = {3},
  note = {cited By (since 1996) 4},
  abstract = {Rational Software Architect (RSA), the latest generation Rational®
	modeling tool, is based on Eclipse™ Modeling Framework (EMF) technology.
	RSA offers all the important features of the previous generation
	of Rational modeling tools, while supporting a much wider range of
	model formats. RSA diagrams can be used in editing and displaying
	models derived from any EMF-based metamodel. The combination of RSA
	and EMF provides a powerful capability for integrating domain-specific
	languages (DSLs) with UML® in a single toolset. This paper describes
	how RSA and EMF provide these capabilities and explores some of the
	ways that IBM is currently exploiting them. © 2006 IBM.},
  affiliation = {IBM Software Group, Rational, 770 Palladium Drive, Ottawa, ON K2V
	1C8, Canada; IBM Software Group, Department of Rational, 1090 Katella
	St., Laguna Beach, CA 92651, United States},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-33748314575&partnerID=40&md5=3f2c9c6fddf3c9db224edbdda8a75446}
}

@CONFERENCE{Lesniewski-Laas2007432,
  author = {Lesniewski-Laas, C., Ford, B., Strauss, J., Morris, R., Kaashoek,
	M.F.},
  title = {Alpaca: Extensible authorization for distributed services},
  year = {2007},
  pages = {432-444},
  note = {cited By (since 1996) 10},
  abstract = {Traditional Public Key Infrastructures (PKI) have not lived up to
	their promise because there are too many ways to define PKIs, too
	many cryptographic primitives to build them with, and too many administrative
	domains with incompatible roots of trust. Alpaca is an authentication
	and authorization framework that embraces PKI diversity by enabling
	one PKI to "plug in" another PKI's credentials and cryptographic
	algorithms, allowing users of the latter to authenticate themselves
	to services using the former using their existing, unmodified certificates.
	Alpaca builds on Proof-Carrying Authorization (PCA), expressing a
	credential as an explicit proof of a logical claim. Alpaca generalizes
	PCA to express not only delegation policies but also the cryptographic
	primitives, credential formats, and namespace structures needed to
	use foreign credentials directly. To achieve this goal, Alpaca introduces
	a method of creating and naming new principals which behave according
	to arbitrary rules, a modular approach to logical axioms, and a domain-specific
	language specialized for reasoning about authentication. We have
	implemented Alpaca as a Python module that assists applications in
	generating proofs (e.g., in a client requesting access to a resource),
	and in verifying those proofs via a compact 800-line TCB (e.g., in
	a server providing that resource). We present examples demonstrating
	Alpaca's extensibility in scenarios involving inter-organization
	PKI interoperability and secure remote PKI upgrade. Copyright 2007
	ACM.},
  affiliation = {MIT, CSAIL, Cambridge, MA, United States},
  author_keywords = {Authorization; Cryptography; Logic; Security; Theorem-proving},
  document_type = {Conference Paper},
  journal = {Proceedings of the ACM Conference on Computer and Communications
	Security},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-77952364800&partnerID=40&md5=da836dac731c29a9dca964006c384068}
}

@ARTICLE{Levendovszky2009830,
  author = {Levendovszky, T., Mészáros, T.},
  title = {Tooling the dynamic behavior models of graphical DSLs},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2009},
  volume = {5611 LNCS},
  pages = {830-839},
  number = {PART 2},
  note = {cited By (since 1996) 0},
  abstract = {Domain-specific modeling is a powerful technique to describe complex
	systems in a precise but still understandable way. Rapid creation
	of graphical Domain-Specific Languages (DSLs) has been focused for
	many years. Research efforts have proven that metamodeling is a promising
	way of defining the abstract syntax of the language. It is also clear
	that DSLs can be developed to describe the concrete syntax and the
	dynamic behavior. Previous research has contributed a set of graphical
	DSLs to model the behavior ("animation" ) of arbitrary graphical
	DSLs. This paper contributes practical techniques to simplify our
	message handling method, automate the integration process, and show
	where domain-specific model patterns can help to accelerate the simulation
	modeling process. © 2009 Springer Berlin Heidelberg.},
  affiliation = {Department of Automation and Applied Informatics, Budapest University
	of Technology and Economics, Goldmann György tér 3, H-1111 Budapest,
	Hungary},
  author_keywords = {Domain-Specific Modeling Languages; Metamodeling; Simulation},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-70350279312&partnerID=40&md5=a44f36287475de20248905b73b26ad9d}
}

@ARTICLE{Levendovszky2009501,
  author = {Levendovszky, T.a b , Lengyel, L.a , Mészáros, T.a },
  title = {Supporting domain-specific model patterns with metamodeling},
  journal = {Software and Systems Modeling},
  year = {2009},
  volume = {8},
  pages = {501-520},
  number = {4},
  note = {cited By (since 1996) 2},
  abstract = {Metamodeling is a widely applied technique in the field of graphical
	languages to create highly configurable modeling environments. These
	environments support the rapid development of domain-specific modeling
	languages (DSMLs). Design patterns are efficient solutions for recurring
	problems. With the proliferation of DSMLs, there is a need for domain-specific
	design patterns to offer solutions to problems recurring in different
	domains. The aim of this paper is to provide theoretical and practical
	foundations to support domain-specific model patterns in metamodeling
	environments. In order to support the treatment of premature model
	parts, we weaken the instantiation relationship. We provide constructs
	relaxing the instantiation rules, and we show that these constructs
	are appropriate and sufficient to express patterns. We provide the
	necessary modifications in metamodeling tools for supporting patterns.
	With the contributed results, a well-founded domain-specific model
	pattern support can be realized in metamodeling tools. © Springer-Verlag
	2009.},
  affiliation = {Budapest University of Technology and Economics, Budapest, Hungary;
	Institute for Software Integrated Systems, Vanderbilt University,
	Nashville, TN, United States},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-69249244310&partnerID=40&md5=096f1a792b5fdac5fe0dafeba06672b9}
}

@CONFERENCE{Li2008495,
  author = {Li, F., Li, D., Wan, J., Huang, X.},
  title = {Towards a component-based model integration approach for embedded
	computer control system},
  year = {2008},
  volume = {1},
  pages = {495-499},
  note = {cited By (since 1996) 0},
  abstract = {A component-based model integration approach for the embedded computer
	control system(ECS) development is proposed in this paper. The three-layer
	architecture for modeling, verification as well as implementation
	is described. Model strategies such as multi-aspect & multi-view
	description method, DSML(Domain Specific Modeling Language) & FML(Formal
	Modeling Language) description method as well as hierarchical component
	based modeling method are put forward. The focus of our approach
	is on creating an integrated embedded computer control system development
	environment for design, verification as well as implementation. ©
	2008 IEEE.},
  affiliation = {College of Mechanical and Automobile Engineering, South China University
	of Technology, Guangzhou, Guangdong Province, 510641, China},
  art_number = {4724700},
  document_type = {Conference Paper},
  journal = {Proceedings - 2008 International Conference on Computational Intelligence
	and Security, CIS 2008},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-60349091516&partnerID=40&md5=0c4f306f874ab798a11096b0a7980504}
}

@CONFERENCE{Li2010286,
  author = {Li, F., Sehic, S., Dustdar, S.},
  title = {COPAL: An adaptive approach to context provisioning},
  year = {2010},
  pages = {286-293},
  note = {cited By (since 1996) 1},
  abstract = {Context-aware services need to acquire context information from heterogeneous
	context sources. The diversity of service requirements posts challenges
	on context provisioning systems as well as their programming models.
	This paper proposes COPAL (COntext Provisioning for ALI) - an adaptive
	approach to context provisioning. COPAL is at first a runtime middleware,
	which provides loose-coupling between context and its processing.
	The component architecture of COPAL ensures that new context processing
	functions can be added dynamically. A set of context processing patterns
	are proposed to customize context attributes and compose context
	provisioning schemes. The COPAL components and models are reflected
	in a Domain Specific Language (DSL), which can further reduce the
	development efforts of context provisioning using automatic code
	generation. A motivating scenario is used throughout the paper to
	illustrate COPAL approach. © 2010 IEEE.},
  affiliation = {Distributed Systems Group (DSG), Information Systems Institute, Vienna
	University of Technology, Argentinierstrasse 8/184-1, A -1040 Wien,
	Austria},
  art_number = {5645051},
  document_type = {Conference Paper},
  journal = {2010 IEEE 6th International Conference on Wireless and Mobile Computing,
	Networking and Communications, WiMob'2010},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-78650728648&partnerID=40&md5=e07d5eb33d60910213b7bbfb1fdf7bbe}
}

@CONFERENCE{Liao2010689,
  author = {Liao, H., Jiang, J., Zhang, Y.},
  title = {A study of automatic code generation},
  year = {2010},
  pages = {689-691},
  note = {cited By (since 1996) 0},
  abstract = {Automatic code generation is the study of generative programming in
	the sense that the source code is generated automatically. In this
	paper, an approach based on component techniques that can produce
	in a systematic way correct, compatible and efficient database structures
	and manipulation function modules from abstract models is proposed.
	In contrast to some conventional software engineering methods, this
	approach has certain merits of improving software quality and shortening
	the software development cycle. © 2010 IEEE.},
  affiliation = {School of Computer Science, Southwest Petroleum University, Chengdu,
	Sichuan 610500, China},
  art_number = {5709179},
  author_keywords = {Automatic code generation; Component techniques},
  document_type = {Conference Paper},
  journal = {Proceedings - 2010 International Conference on Computational and
	Information Sciences, ICCIS 2010},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-79952376281&partnerID=40&md5=0b3f43e3076af6b92453e79bf73939b3}
}

@CONFERENCE{Liegl2009123,
  author = {Liegl, P., Mayrhofer, D.},
  title = {A domain specific language for UN/CEFACT's core components},
  year = {2009},
  number = {PART 2},
  pages = {123-131},
  note = {cited By (since 1996) 0},
  abstract = {In order to overcome the heterogeneities of different business document
	standards the United Nations Center for Trade Facilitation and Electronic
	Business (UN/CEFACT) has released the Core Components Technical Specification
	(CCTS). Core components are reusable building blocks for assembling
	business documents in an implementation neutral manner. However,
	core components are standardized without considering a specific implementation
	format and thus no tool integration is possible. Currently a syntax
	specific solution for core components, based on the Unified Modeling
	Language (UML), is provided with the UML Profile for Core Components
	(UPCC). In this paper we circumvent the complex UML meta model and
	provide a dedicated core component modeling environment based on
	a Domain Specific Language (DSL). Thereby, core component models
	are assembled on a conceptual level. In a next step the conceptual
	document model is used for the generation of domain specific artifacts.
	Our DSL based solution provides in situ validation of conceptual
	core component models and the flexible generation of deployment artifacts
	such as XML Schema definitions, used for the definition of interfaces
	in a service oriented environment. © 2009 IEEE.},
  affiliation = {Vienna University of Technology, Favoritenstrasse 9-11/188, A-1040
	Vienna, Austria},
  art_number = {5305976},
  document_type = {Conference Paper},
  journal = {SERVICES 2009 - 5th 2009 World Congress on Services},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-72449171048&partnerID=40&md5=0d9d7f39d95d3a8e411e17a7382e76b6}
}

@CONFERENCE{Liew200547,
  author = {Liew, P.a , Kontogiannis, K.a , Tong, T.b },
  title = {A framework for business model driven development},
  year = {2005},
  pages = {47-54},
  note = {cited By (since 1996) 0},
  abstract = {Typically, large companies in an effort to increase efficiency specify
	business processes using workflow languages, while software designers
	specify the systems that implement these processes with the use of
	languages like UML. This separation of domain expertise allows for
	software engineers from each individual area to work more efficiently
	using domain specific languages and tools. However, models in these
	two domains evolve independently and inconsistencies may occur when
	two models become unsynchronized due to constant revision or evolution
	of processes and design artifacts. In this paper, we present a set
	of transformations to automatically generate a specific set of UML
	artifacts from the business process specifications. In particular,
	we examine and investigate a preliminary framework for the necessary
	annotations that need be applied to a Business Process Model so that
	the generation of UML use cases, activity diagrams, collaboration
	diagrams and deployment diagrams could be feasible. The objective
	of this work is to be able to generate rich Platform Independent
	UML models that can be used for automating the generation of design
	artifacts and source code by using a Model Driven Architecture approach.
	By doing so, we aim to decrease software design time, reduce maintenance
	costs and better support system evolution. © 2004 IEEE.},
  affiliation = {Dept. of Electrical and Computer Engineering, University of Waterloo,
	200 University Ave. West, Waterloo, ON N2L3G1, Canada; IBM Canada,
	IBM Toronto Laboratory, 8200 Warden Avenue, Markham, ON L6G 1C7,
	Canada},
  art_number = {1613370},
  document_type = {Conference Paper},
  journal = {STEP 2004 Proceedings - The 12th International Workshop on Software
	Technology and Engineering Practice},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-46249093366&partnerID=40&md5=b57aab8c08ad4728e8d2189e965a3288}
}

@ARTICLE{Lin2007299,
  author = {Lin, C.-K., Black, A.P.},
  title = {DirectFlow: A domain-specific language for information-flow systems},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2007},
  volume = {4609 LNCS},
  pages = {299-322},
  note = {cited By (since 1996) 3},
  abstract = {Programs that process streams of information are commonly built by
	assembling reusable information-flow components. In some systems
	the components must be chosen from a pre-defined set of primitives;
	in others the programmer can create new custom components using a
	general-purpose programming language. Neither approach is ideal:
	restricting programmers to a set of primitive components limits the
	expressivity of the system, while allowing programmers to define
	new components in a general-purpose language makes it difficult or
	impossible to reason about the composite system. We advocate defining
	information-flow components in a domain-specific language (DSL) that
	enables us to infer the properties of the components and of the composed
	system; this provides us with a good compromise between analysability
	and expressivity. This paper presents DirectFlow, which comprises
	a DSL, a compiler and a runtime system. The language allows programmers
	to define objects that implement information-flow components without
	specifying how messages are sent and received. The compiler generates
	Java classes by inferring the message sends and methods, while the
	run-time library constructs information-flow networks by composition
	of DSL-defined components with standard components. © Springer-Verlag
	Berlin Heidelberg 2007.},
  affiliation = {Department of Computer Science, Portland State University},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-38149129499&partnerID=40&md5=ebdc6811418d569b16f359d8aace7b60}
}

@ARTICLE{Lin2007349,
  author = {Lin, Y.a , Gray, J.a c , Jouault, F.a b },
  title = {DSMDiff: A differentiation tool for domain-specific models},
  journal = {European Journal of Information Systems},
  year = {2007},
  volume = {16},
  pages = {349-361},
  number = {4},
  note = {cited By (since 1996) 18},
  abstract = {Model differentiation techniques, which provide the capability to
	identify mappings and differences between models, are essential to
	many model development and management practices. There has been initial
	research toward model differentiation applied to Unified Modeling
	Language (UML) diagrams, but differentiation of domain-specific models
	has not been explored deeply in the modeling community. Traditional
	modeling practice using the UML relies on a single fixed general-purpose
	language (i.e., all UML diagrams conform to a single metamodel).
	In contrast, Domain-Specific Modeling (DSM) is an emerging model-driven
	paradigm in which multiple metamodels are used to define various
	modeling languages that represent the key concepts and abstractions
	for particular domains. Therefore, domain-specific models may conform
	to various metamodels, which requires model differentiation algorithms
	be metamodel-independent and able to apply to multiple domain-specific
	modeling languages. This paper presents metamodel-independent algorithms
	and associated tools for detecting mappings and differences between
	domain-specific models, with facilities for graphical visualization
	of the detected differences. © 2007 Operational Research Society
	Ltd. All rights reserved.},
  affiliation = {Department of Computer and Information Sciences, University of Alabama
	at Birmingham, Birmingham, United States; ATLAS Group (INRIA and
	LINA), University of Nantes, France; Department of Computer and Information
	Sciences, University of Alabama at Birmingham, Birmingham, AL 35294-1170,
	United States},
  author_keywords = {Domain-specific modeling; Model comparison; Model-driven engineering},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-35548974276&partnerID=40&md5=b74884bd7c9ef866c3ca8f65eb1f8392}
}

@ARTICLE{Lincke2009236,
  author = {Lincke, D.a , Jansson, P.b , Zalewski, M.b , Ionescu, C.a },
  title = {Generic libraries in c++ with concepts from high-level domain descriptions
	in haskell a domain-specific library for computational vulnerability
	assessment},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2009},
  volume = {5658 LNCS},
  pages = {236-261},
  note = {cited By (since 1996) 0},
  abstract = {A class of closely related problems, a problem domain, can often be
	described by a domain-specific language, which consists of algorithms
	and combinators useful for solving that particular class of problems.
	Such a language can be of two kinds: it can form a new language or
	it can be embedded as a sublanguage in an existing one. We describe
	an embedded DSL in the form of a library which extends a general
	purpose language. Our domain is that of vulnerability assessment
	in the context of climate change, formally described at the Potsdam
	Institute for Climate Impact Research. The domain is described using
	Haskell, yielding a domain specific sublanguage of Haskell that can
	be used for prototyping of implementations. In this paper we present
	a generic C++ library that implements a domain-specific language
	for vulnerability assessment, based on the formal Haskell description.
	The library rests upon and implements only a few notions, most importantly,
	that of a monadic system, a crucial part in the vulnerability assessment
	formalisation. We describe the Haskell description of monadic systems
	and we show our mapping of the description to generic C++ components.
	Our library heavily relies on concepts, a C++ feature supporting
	generic programming: a conceptual framework forms the domain-specific
	type system of our library. By using functions, parametrised types
	and concepts from our conceptual framework, we represent the combinators
	and algorithms of the domain. Furthermore, we discuss what makes
	our library a domain specific language and how our domain-specific
	library scheme can be used for other domains (concerning language
	design, software design, and implementation techniques). © IFIP International
	Federation for Information Processing 2009.},
  affiliation = {Potsdam Institute for Climate Impact Research, Potsdam, Germany; Chalmers
	University of Technology, University of Gothenburg, Gothenburg, Sweden},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-69049097161&partnerID=40&md5=cdd741f05ba5561397e3cd357e3791b8}
}

@CONFERENCE{Lindeman2011127,
  author = {Lindeman, R.T., Kats, L.C.L., Visser, E.},
  title = {Declaratively defining domain-specific language debuggers},
  year = {2011},
  pages = {127-136},
  note = {cited By (since 1996) 0},
  abstract = {Tool support is vital to the effectiveness of domain-specific languages.
	With language workbenches, domain-specific languages and their tool
	support can be generated from a combined, high-level specification.
	This paper shows how such a specification can be extended to describe
	a debugger for a language. To realize this, we introduce a meta-language
	for coordinating the debugger that abstracts over the complexity
	of writing a debugger by hand. We describe the implementation of
	a language-parametric infrastructure for debuggers that can be instantiated
	based on this specification. The approach is implemented in the Spoofax
	language workbench and validated through realistic case studies with
	the Stratego transformation language and the WebDSL web programming
	language. Copyright © 2011 ACM.},
  affiliation = {Delft University of Technology, Netherlands},
  author_keywords = {Debugging; Domain-specific language; Language workbench; Spoofax},
  document_type = {Conference Paper},
  journal = {GPCE'11 - Proceedings of the 10th International Conference on Generative
	Programming and Component Engineering},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-81455131789&partnerID=40&md5=d9d802e30501dc4066f70508b1465c12}
}

@CONFERENCE{Ling1998345,
  author = {Ling, Gary Shu},
  title = {Frob - functional robotics},
  year = {1998},
  pages = {345},
  note = {cited By (since 1996) 0},
  abstract = {Frob or functional robotics is a domain-specific language embedded
	in Haskell to control robotic systems. It promotes a style of programming
	largely independent of the underlying hardware. Frob is based on
	the core of Fran, a reactive system for computer animation.},
  affiliation = {Yale Computer Science Dep},
  document_type = {Article},
  journal = {Proceedings of the ACM SIGPLAN International Conference on Functional
	Programming, ICFP},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-0031611720&partnerID=40&md5=a88c15a80e1f385de76edf25b3ea9d87}
}

@CONFERENCE{Ling2009460,
  author = {Ling, H.a , Zhou, X.a , Zheng, Y.b },
  title = {Design and implementation of DSL via category theoretic computations},
  year = {2009},
  pages = {460-466},
  note = {cited By (since 1996) 0},
  abstract = {Domain specific languages provide appropriate built-in abstractions
	and notations in a particular problem domain, and have been suggested
	as means for developing highly adaptable software systems. The paper
	presents a theory-based framework to support domain-specific design
	and implementation. Focusing concern on reasoning about interactive
	relationships among software models and objects at different levels
	of abstraction and granularity, our framework provides a unified
	categorial environment for intra-model composition and inter-model
	refinement of specifications via category theoretic computations,
	and therefore enables a high-level of reusability and dynamic adaptability.
	© 2009 IEEE.},
  affiliation = {School of Management and Engineering, Nanjing Univ., Nanjing Jiangsu
	210093, China; Institute of Software, CAS, Beijing 100080, China},
  art_number = {5392879},
  document_type = {Conference Paper},
  journal = {4th International Conference on Frontier of Computer Science and
	Technology, FCST 2009},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-77949867568&partnerID=40&md5=71765bbc97e50e19189ed9e8830b8b1c}
}

@CONFERENCE{Linsey2008145,
  author = {Linsey, J.S.a , Clauss, E.a , Wood, K.L.a , Laux, J.P.b , Markman,
	A.B.b },
  title = {Increasing innovation: A trilogy of experiments towards a design-by-analogy
	method},
  year = {2008},
  volume = {3 PART A},
  pages = {145-159},
  note = {cited By (since 1996) 0},
  abstract = {Design by analogy is a noted approach for conceptual design. This
	paper seeks to develop a robust design-by-analogy method. This endeavor
	is sought through a series of three experiments focusing on understanding
	the influence of representation on the design-by-analogy process.
	The first two experiments evaluate the effects of analogous product
	description-presented in either domain-general or domainspecific
	language-on a designer's ability to later use the product to solve
	a novel design problem. Six different design problems with corresponding
	analogous products are evaluated. The third experiment in the series
	uses a factorial design to explore the effects of the representation
	(domain specific or general sentinel descriptions) for both the design
	problem and the analogous product on the designer's ability to develop
	solutions to novel design problems. Results show that a more general
	representation of the analogous products facilitates later use for
	a novel design problem. The highest rates of success occur when design
	problems are presented in domain specific representations and the
	analogous product is in a domain general representation. Other insights
	for the development of design by analogy methods and tools are also
	discussed. Copyright © 2007 by ASME.},
  affiliation = {Manufacturing and Design Research Laboratory, Department of Mechanical
	Engineering, University of Texas, Austin, TX, United States; Similarity
	and Cognition Lab., Department of Psychology, University of Texas,
	Austin, TX, United States},
  document_type = {Conference Paper},
  journal = {2007 Proceedings of the ASME International Design Engineering Technical
	Conferences and Computers and Information in Engineering Conference,
	DETC2007},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-44849126935&partnerID=40&md5=83ed8a1e107c209c0c0236f7c0e6d772}
}

@CONFERENCE{Lisboa200953,
  author = {Lisboa, E.a b , Silva, L.a , Chaves, I.a , Lima, T.a , Barros, E.a
	},
  title = {A design flow based on a domain specific language to concurrent development
	of device drivers and device controller simulation models},
  year = {2009},
  volume = {320},
  pages = {53-60},
  note = {cited By (since 1996) 0},
  abstract = {Nowadays, embedded Systems must communicate with different peripheral
	devices. The communication structure is implemented by a combined
	solution of hardware and software. The device controller is the hardware
	that implements, in general, complex communication protocols. On
	the other hand, the device driver provides transparent access to
	the functionalities of the device and depends on the architecture
	of the device controller. So, the design of the communication structure
	demands great effort, considerable development time and is very susceptible
	to errors. To minimize these issues, this paper presents an approach
	to the concurrent development of device controller simulation models
	and of the respective device drivers. Also a domain specific language,
	called DevC, is proposed to describe device controller features in
	a high level of abstraction. In this paper a brief introduction to
	this language is presented. From the specifications described in
	DevC, controller models and device drivers are synthesized. Both
	the device controller and the driver are first validated using a
	hardware virtual platform to reduce simulation time, and then they
	are validated on real hardware. Some controllers, such as a serial,
	as well as a text and graphic lcd, have been developed to validate
	the approach proposed. © 2009 by EDAA.},
  affiliation = {Center of Informatics, Federal University of Pernambuco, Recife-PE,
	Brazil; Federal Institute of Education, Science and Technology of
	Sergipe, Aracaju-SE, Brazil},
  document_type = {Conference Paper},
  journal = {ACM International Conference Proceeding Series},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-77951281521&partnerID=40&md5=9219f28a3513a8109c31ed0428eeb966}
}

@CONFERENCE{Liu2009,
  author = {Liu, H., Cheng, E., Hudak, P.},
  title = {Causal commutative arrows and their optimization},
  year = {2009},
  pages = {35-46},
  note = {cited By (since 1996) 3},
  abstract = {Arrows are a popular form of abstract computation. Being more general
	than monads, they are more broadly applicable, and in particular
	are a good abstraction for signal processing and dataflow computations.
	Most notably, arrows form the basis for a domain specific language
	called Yampa, which has been used in a variety of concrete applications,
	including animation, robotics, sound synthesis, control systems,
	and graphical user interfaces. Our primary interest is in better
	understanding the class of abstract computations captured by Yampa.
	Unfortunately, arrows are not concrete enough to do this with precision.
	To remedy this situation we introduce the concept of commutative
	arrows that capture a kind of non-interference property of concurrent
	computations. We also add an init operator, and identify a crucial
	law that captures the causal nature of arrow effects. We call the
	resulting computational model causal commutative arrows. To study
	this class of computations in more detail, we define an extension
	to the simply typed lambda calculus called causal commutative arrows
	(CCA), and study its properties. Our key contribution is the identification
	of a normal form for CCA called causal commutative normal form (CCNF).
	By defining a normalization procedure we have developed an optimization
	strategy that yields dramatic improvements in performance over conventional
	implementations of arrows.We have implemented this technique in Haskell,
	and conducted benchmarks that validate the effectiveness of our approach.
	When combined with stream fusion, the overall methodology can result
	in speed-ups of greater than two orders of magnitude. Copyright ©
	2009 ACM.},
  affiliation = {Department of Computer Science, Yale University},
  author_keywords = {Arrows; Dataflow language; Functional programming; Functional reactive
	programming; Program optimization; Stream processing},
  document_type = {Conference Paper},
  journal = {Proceedings of the ACM SIGPLAN International Conference on Functional
	Programming, ICFP},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-70450191605&partnerID=40&md5=1271572d40ed4d1966529676477a6427}
}

@ARTICLE{Liu200935,
  author = {Liu, H., Cheng, E., Hudak, P.},
  title = {Causal commutative arrows and their optimization},
  journal = {ACM SIGPLAN Notices},
  year = {2009},
  volume = {44},
  pages = {35-46},
  number = {9},
  note = {cited By (since 1996) 0},
  abstract = {Arrows are a popular form of abstract computation. Being more general
	than monads, they are more broadly applicable, and in particular
	are a good abstraction for signal processing and dataflow computations.
	Most notably, arrows form the basis for a domain specific language
	called Yampa, which has been used in a variety of concrete applications,
	including animation, robotics, sound synthesis, control systems,
	and graphical user interfaces. Our primary interest is in better
	understanding the class of abstract computations captured by Yampa.
	Unfortunately, arrows are not concrete enough to do this with precision.
	To remedy this situation we introduce the concept of commutative
	arrows that capture a kind of non-interference property of concurrent
	computations. We also add an init operator, and identify a crucial
	law that captures the causal nature of arrow effects. We call the
	resulting computational model causal commutative arrows. To study
	this class of computations in more detail, we define an extension
	to the simply typed lambda calculus called causal commutative arrows
	(CCA), and study its properties. Our key contribution is the identification
	of a normal form for CCA called causal commutative normal form (CCNF).
	By defining a normalization procedure we have developed an optimization
	strategy that yields dramatic improvements in performance over conventional
	implementations of arrows.We have implemented this technique in Haskell,
	and conducted benchmarks that validate the effectiveness of our approach.
	When combined with stream fusion, the overall methodology can result
	in speed-ups of greater than two orders of magnitude. © 2009 ACM.},
  affiliation = {Department of Computer Science, Yale University},
  author_keywords = {Arrows; Dataflow language; Functional programming; Functional reactiveprogramming;
	Programoptimization; Stream processing},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-70350437962&partnerID=40&md5=4fc273cc580ccb0c0689cf53e69d7271}
}

@ARTICLE{Liu200513,
  author = {Liu, J.},
  title = {Feature interactions and software derivatives},
  journal = {Journal of Object Technology},
  year = {2005},
  volume = {4},
  pages = {13-19},
  number = {3},
  note = {cited By (since 1996) 0},
  abstract = {Feature Oriented Programming (FOP) merges the studies of feature modularity,
	generative programming, and compositional programming. We advance
	FOP by proposing the concept of software derivatives, which represent
	feature interactions. We apply the theory of software derivatives
	to refactoring legacy Java applications into FOP designs. © JOT,
	2005.},
  affiliation = {Department of Computer Sciences, University of Texas, Austin, United
	States},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-22944461737&partnerID=40&md5=8f4a3bd68388278f65f46a3e7c2aeb5a}
}

@CONFERENCE{Liu2010279,
  author = {Liu, Q.a , Bryant, B.R.a , Mernik, M.b },
  title = {Metamodel recovery from multi-tiered domains using extended MARS},
  year = {2010},
  pages = {279-288},
  note = {cited By (since 1996) 2},
  abstract = {With the rapid development of model-driven engineering (MDE), domain-specific
	modeling has become a widely used software development technique.
	In MDE, metamodels represent a schema definition of the syntax and
	static semantics to which an instance model conforms (i.e., a model
	conforms to its metamodel in a similar manner to how a program conforms
	to a grammar). However, in order to address new feature requests
	of the domain and language, the metamodel often undergoes frequent
	evolution that may result in the inability of users to load and view
	previous model instances. MARS is a metamodel recovery system to
	address the problems of metamodel evolution. This paper presents
	our extensions to MARS to infer models for multi-tiered domains.
	A new XSLT translator has been developed to generate a domain-specific
	language (DSL) called MRL (model representation language) for the
	XML representation of domain instances. The metamodel inference engine
	has been revised to translate the MRL back into a metamodel. © 2010
	IEEE.},
  affiliation = {Department of Computer and Information Sciences, University of Alabama
	at Birmingham, Birmingham, AL, United States; Institute of Computer
	Science, University of Maribor, Maribor, Slovenia},
  art_number = {5676270},
  author_keywords = {Domain-specific modeling; Grammar inference; Metamodel; Model-driven
	engineering},
  document_type = {Conference Paper},
  journal = {Proceedings - International Computer Software and Applications Conference},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-78751697130&partnerID=40&md5=b97692417fa9b4320f56ad181cd87b58}
}

@CONFERENCE{Liu20102491,
  author = {Liu, S.-H.a , Cardenas, A.a , Xiong, X.a , Mernik, M.b , Bryant,
	B.R.c , Gray, J.c },
  title = {Can domain-specific languages be implemented by service-oriented
	architecture?},
  year = {2010},
  pages = {2491-2492},
  note = {cited By (since 1996) 0},
  abstract = {Although there have been many benefits of Domain-Specific Languages
	(DSLs) reported from both academia and industry, the need to evolve
	a DSL definition in the presence of limited tool support results
	in several challenges that increase DSL development cost and constrain
	DSL adoption opportunities. As a new approach to address such limitations,
	this paper introduces a Service-Oriented Architecture (SOA) technique
	to implement an existing imperative DSL. The approach utilizes WSDL
	to perform lexical analysis and assist with syntax analysis. The
	paper also explores how WS-BPEL can be used to define a DSL grammar.
	Web services have potential to define the semantics of a DSL. The
	advantages that SOA offers in DSL implementation are realized through
	SOA's characteristics of interoperability, loose coupling, and technology-neutral
	implementation. © 2010 ACM.},
  affiliation = {Department of Computer Science, California State University, Fresno,
	CA, United States; Faculty of Electrical Engineering and Computer
	Science, University of Maribor, Slovenia; Department of Computer
	and Information Sciences, University of Alabama, Birmingham, AL,
	United States},
  author_keywords = {domain-specific languages; service-oriented architecture},
  document_type = {Conference Paper},
  journal = {Proceedings of the ACM Symposium on Applied Computing},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-77954729876&partnerID=40&md5=fab986463c62373c1cba8041683fcae8}
}

@CONFERENCE{Liu2010535,
  author = {Liu, S.-H.a , Cardenas, A.a , Xiong, X.a , Mernik, M.b , Bryant,
	B.R.c , Gray, J.d },
  title = {A SOA approach for domain-specific language implementation},
  year = {2010},
  pages = {535-542},
  note = {cited By (since 1996) 0},
  abstract = {Although there have been many benefits of Domain-Specific Languages
	(DSLs) reported from both academia and industry, implementation of
	DSLs continue to face challenges with respect to frequent evolution
	of both syntax and semantics. Techniques for implementing DSLs also
	lack interoperable capabilities among base languages and limited
	tool support. Such challenges result in increasing DSL development
	cost and constrain DSL adoption opportunities. This paper introduces
	a Service-Oriented Architecture (SOA) approach to address such problems.
	The approach utilizes WSDL to perform lexical and syntax analysis.
	Web services are used to define the semantics of a DSL, and WS-BPEL
	is then used to specify a DSL program. We present two case studies
	representing different DSL categories to show the feasibility of
	SOA-based DSL implementation. The case studies demonstrate the potential
	for easing the burden of DSL evolution and offering interoperability
	and tool support. Improved modularization and removal of tokenization/parsing
	are two additional advantages. Discussion and comparison among interpreter-based,
	model-driven and SOA-based DSL implementations are provided, which
	may raise more research interests in this area. © 2010 IEEE.},
  affiliation = {California State University, Fresno, United States; University of
	Maribor, Slovenia; University of Alabama at Birmingham, United States;
	University of Alabama, United States},
  art_number = {5575476},
  document_type = {Conference Paper},
  journal = {Proceedings - 2010 6th World Congress on Services, Services-1 2010},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-78049324407&partnerID=40&md5=e2f5a711a9e242d23ec1990fb53c9ed1}
}

@ARTICLE{Liu200647,
  author = {Liu, T.a b , Li, X.-F.c , Liu, L.c , Wu, C.a , Ju, R.d },
  title = {Optimizing packet accesses for a domain specific language on network
	processors},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2006},
  volume = {4339 LNCS},
  pages = {47-61},
  note = {cited By (since 1996) 0},
  abstract = {Programming network processors remains a challenging task since their
	birth until recently when high-level programming environments for
	them are emerging. By employing domain specific languages for packet
	processing, the new environments try to hide hardware details from
	the programmers and enhance both the programmability of the systems
	and the portability of the applications. A frequent issue for the
	new environments to be widely adopted is their relatively low achievable
	performance compared to low-level, hand-tuned programming. In this
	paper we present two techniques, Packet Access Combining (PAC) and
	Compiler-Generated Packet Caching (CGPC), to optimize packet accesses,
	which are shown as the performance bottleneck in such new environments
	for packet processing applications. PAC merges multiple packet accesses
	into a single wider access; CGPC implements an automatic packet data
	caching mechanism without a hardware cache. Both techniques focus
	on reducing long memory latency and expensive memory traffic, and
	they also reduce instruction counts significantly. We have implemented
	the proposed techniques in a high level programming environment for
	network processor named Shangri-La. Our evaluation with standard
	NPF benchmarks shows that for the evaluated applications the two
	techniques can reduce the memory traffic by 90% and improve the packet
	throughput by 5.8 times, on average. © 2006 Springer-Verlag Berlin
	Heidelberg.},
  affiliation = {Institute of Computing Technology, Chinese Academy of Sciences, Beijing,
	China; Graduate School, Chinese Academy of Sciences, Beijing, China;
	Intel China Research Center Ltd., Beijing, China; Microprocessor
	Technology Labs., Intel Corporation, Santa Clara, CA, United States},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-43949143524&partnerID=40&md5=13e0e7862e58f2f081d41d13a3b859fa}
}

@CONFERENCE{Lochmann20091,
  author = {Lochmann, H.a , Hessellund, A.b },
  title = {An integrated view on modeling with multiple domain-specific languages},
  year = {2009},
  pages = {1-10},
  note = {cited By (since 1996) 0},
  abstract = {The use of domain-specific languages (DSLs) has been shown to raise
	the level of abstraction, increase productivity and ease maintenance
	and evolution in software development. Development of and tooling
	for a single DSL is well-studied, but surprisingly little is known
	about the interplay of different DSLs in a single system. Multiple
	DSLs are required when moving from toy examples to real enterprise
	applications. Method and tool support is needed if multiple DSL development
	is to succeed. In this paper, we propose a novel method for development
	with multiple DSLs which fills this gap. The method specifically
	tackles the problem of overlapping concerns between different DSLs.
	It has three steps: 1) Identification, 2) Specification, and 3) Application.
	We explain these steps using a suite of prototype tools and documented
	case studies.},
  affiliation = {SAP Research CEC Dresden, Chemnitzer Str. 48, 01187, Dresden, Germany;
	IT University of Copenhagen, Rued Langgaards Vej 7, 2300, København,
	Denmark},
  document_type = {Conference Paper},
  journal = {Proceedings of the IASTED International Conference on Software Engineering,
	SE 2009},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-74549195796&partnerID=40&md5=c172d6d507fce20572f6f1cff04ee488}
}

@ARTICLE{Lohmann200455,
  author = {Lohmann, D., Blaschke, G., Spinczyk, O.},
  title = {Generic advice: On the combination of AOP with generative programming
	in AspectC++},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2004},
  volume = {3286},
  pages = {55-74},
  note = {cited By (since 1996) 12},
  abstract = {Besides object-orientation, generic types or templates and aspect-oriented
	programming (AOP) gain increasing popularity as they provide additional
	dimensions of decomposition. Most modern programming languages like
	Ada, Eiffel, and C++ already have built-in support for templates.
	For Java and C# similar extensions will be available in the near
	future. Even though promising, the combination of aspects with generic
	and generative programming is still a widely unexplored field. This
	paper presents our extensions to the AspectC++ language, an aspect-oriented
	C++ derivate. By these extensions aspects can now affect generic
	code and exploit the potentials of generic code and template metaprogramming
	in their implementations. This allows aspects to inject template
	metaprograms transparently into the component code. A case study
	demonstrates that this feature enables the development of highly
	expressive and efficient generic aspect implementations in AspectC++.
	A discussion whether these concepts are applicable in the context
	of other aspect-oriented language extensions like AspectJ rounds
	up our contribution. © Springer-Verlag 2004.},
  affiliation = {Friedrich-Alexander-University Erlangen-Nuremberg, Germany},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-35048829285&partnerID=40&md5=3ad761949a0ff3eb37ae578f46d620c2}
}

@ARTICLE{Lohmann2008241,
  author = {Lohmann, W.a , Riedewald, G.a , Wachsmuth, G.b },
  title = {Aspect-oriented Prolog in a language processing context},
  journal = {IET Software},
  year = {2008},
  volume = {2},
  pages = {241-259},
  number = {3},
  note = {cited By (since 1996) 0},
  abstract = {Language processors can be derived from logic grammars. That several
	concerns in the processor such as parsing, several kinds of analysis
	or transformations, can be specified as aspects of the logic grammar
	is demonstred. For that purpose, the authors bring the concepts of
	aspect-oriented programming to Prolog in a systematic way, based
	on established Prolog technology. The authors illustrate that typical
	Prolog programming techniques can be described as generic aspects
	and provided in a library to support reusable concerns. A domain-specific
	language (DSL) is developed to improve readability of aspect-oriented
	specifications. © 2008 The Institution of Engineering and Technology.},
  affiliation = {Universität Rostock, Rostock D-18051, Germany; Humboldt Universität,
	Berlin D-12489, Germany},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-45849114006&partnerID=40&md5=ac57228744b940037c954c34a0951852}
}

@CONFERENCE{Loiret2009375,
  author = {Loiret, F.a , Plšek, A.a , Merle, P.a , Seinturier, L.a , Malohlava,
	M.b },
  title = {Constructing domain-specific component frameworks through architecture
	refinement},
  year = {2009},
  pages = {375-382},
  note = {cited By (since 1996) 0},
  abstract = {Recently, a plethora of domain-specific component frameworks (DSCF)
	emerges. Although the current trend emphasizes generative programming
	methods as cornerstones of software development, they are commonly
	applied in a costly, ad-hoc fashion. However, we believe that DSCFs
	share the same subset of concepts and patterns. In this paper we
	propose two contributions to DSCF development. First, we propose
	DomainComponents - a high-level abstraction to capture semantics
	of domain concepts provided by containers, and we identify patterns
	facilitating their implementation. Second, we develop a generic framework
	that automatically generates implementation of DomainComponents semantics,
	thus addressing domain-specific services with one unified approach.
	To evaluate benefits of our approach we have conducted several case
	studies that span different domain-specific challenges. © 2009 IEEE.},
  affiliation = {INRIA-Lille, Project ADAM, USTL-LIFL CNRS UMR 8022, France; Distributed
	Systems Research Group, Charles University, Prague, Czech Republic},
  art_number = {5349839},
  author_keywords = {Component framework; Component model, domain-specific concerns; Generative
	programming},
  document_type = {Conference Paper},
  journal = {Conference Proceedings of the EUROMICRO},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-74549186519&partnerID=40&md5=a1860afb5a3703e33378e924927b2091}
}

@CONFERENCE{Loiret201161,
  author = {Loiret, F.a , Rouvoy, R.b , Seinturier, L.b , Merle, P.b },
  title = {Software engineering of component-based systems-of-systems: A reference
	framework},
  year = {2011},
  pages = {61-65},
  note = {cited By (since 1996) 0},
  abstract = {Systems-of-Systems (SoS) are complex infrastructures, which are characterized
	by a wide diversity of technologies and requirements imposed by the
	domain(s) they target. In this context, the software engineering
	community has been focusing on assisting the developers by providing
	them domain-specific languages, component-based software engineering
	frameworks and tools to leverage on the design and the development
	of such systems. However, the adoption of such approaches often prevents
	developers from combining several domains, which is a strong requirement
	in the context of SoS. Furthermore, only little attention has been
	paid to the definition of a modular toolset and an extensible runtime
	infrastructure for deploying and executing SoS. In this paper, we
	therefore propose a reference framework to leverage on the software
	engineering of SoS. Our reference framework has been validated on
	the development of two platforms, namely Hulotte and FraSCAti, to
	demonstrate that the resulting complexity is isolated in the core
	toolset, while the development of domain-specific extensions is leveraged
	and simplified by clearly identified abstractions. © 2011 ACM.},
  affiliation = {KTH (Royal Institute of Technology), Stockholm, Sweden; INRIA Lille
	- Nord Europe, Project-team ADAM, Univ. Lille 1 - LIFL CNRS UMR 8022,
	Villeneuve d'Ascq, France},
  author_keywords = {domain-specific component framework; systems-of-systems},
  document_type = {Conference Paper},
  journal = {CompArch'11 - Proceedings of the 2011 Federated Events on Component-Based
	Software Engineering and Software Architecture - CBSE'11},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-79960540095&partnerID=40&md5=0ebf43690ba193443e238e569c53f8c6}
}

@CONFERENCE{Lolong2011,
  author = {Lolong, S., Kistijantoro, A.I.},
  title = {Domain specific language (DSL) development for desktop-based database
	application generator},
  year = {2011},
  note = {cited By (since 1996) 0},
  abstract = {Application Generator (AG) can help save time of software development.
	Some AG has its own DSL (Domain Specific Language) to direct the
	generated application outcome. In this research, we developed a DSL
	using the syntax notation text with simple structure that can assist
	AG in the process of generating source code for desktop-based database
	application using Java. DSL development is applying the methodology
	of DSL development from Czarnecki. The development for AG involves
	three areas of knowledge, i.e. domain engineering, DSL, and AG (compiler).
	Domain engineering is required to understand the target application
	domain to be generated, i.e. MySQL database and Java programming
	language with Swing UI. The DSL is developed in five phases, i.e.
	decision-making, analysis, design, implementation, and development.
	The AG itself is developed in Java platform. The DSL and AG developed
	in this research has shown that the DSL can help programmer to develop
	Java desktop-based database applications by utilizing DSL to map
	MySQL database into Java Swing UI, and employ AG to generate applications
	directly from DSL source. It is expected that further development
	of this research is to support more flexible application development.
	© 2011 IEEE.},
  affiliation = {STEI, Bandung Institute of Technology, Bandung, Indonesia},
  art_number = {6021604},
  author_keywords = {Application Generator; Desktop Base Database Application; Domain Specific
	Language; DSL},
  document_type = {Conference Paper},
  journal = {Proceedings of the 2011 International Conference on Electrical Engineering
	and Informatics, ICEEI 2011},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-80054033613&partnerID=40&md5=e848c99a9f8d86025b3211f03a368580}
}

@ARTICLE{Lorenz2011167,
  author = {Lorenz, D.H., Rosenan, B.},
  title = {Code reuse with language oriented programming},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2011},
  volume = {6727 LNCS},
  pages = {167-182},
  note = {cited By (since 1996) 0},
  abstract = {There is a gap between our ability to reuse high-level concepts in
	software design and our ability to reuse the code implementing them.
	Language Oriented Programming (LOP) is a software development paradigm
	that aims to close this gap, through extensive use of Domain Specific
	Languages (DSLs). With LOP, the high-level reusable concepts become
	reusable DSL constructs, and their translation into code level concepts
	is done in the DSL implementation. Particular products are implemented
	using DSL code, thus reusing only high-level concepts. In this paper
	we provide a comparison between two implementation approaches for
	LOP: (a),using external DSLs with a projectional language workbench
	(MPS); and (b),using internal DSLs with an LOP language (Cedalion).
	To demonstrate how reuse is achieved in each approach, we present
	a small case study, where LOP is used to build a Software Product
	Line (SPL) of calculator software. © 2011 Springer-Verlag.},
  affiliation = {Open University of Israel, 1 University Rd., Raanana 43107, Israel},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-79959648051&partnerID=40&md5=7c09ff34064448eafae9d8d27e73caa2}
}

@CONFERENCE{Lorenz2011199,
  author = {Lorenz, D.H., Rosenan, B.},
  title = {A case study of language oriented programming with Cedalion- Extended
	abstract},
  year = {2011},
  pages = {199-200},
  note = {cited By (since 1996) 0},
  abstract = {Cedalion is an LOP language designed for hosting internal DSLs while
	providing projectional editing. We present a case study where Cedalion
	was used to help colleagues in the field of Biology design a DNA
	microarray for a protein-binding assay.},
  affiliation = {Open University of Israel, 1 University Rd., Raanana 43107, Israel},
  author_keywords = {Domain-specific languages (DSLs); Language workbenches; Language-oriented
	programming (LOP)},
  document_type = {Conference Paper},
  journal = {SPLASH'11 Compilation - Proceedings of OOPSLA'11, Onward! 2011, GPCE'11,
	DLS'11, and SPLASH'11 Companion},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-81355139701&partnerID=40&md5=c1be094a7cf9f4c6e94f5f7199198d75}
}

@CONFERENCE{Lorenz201129,
  author = {Lorenz, D.H., Rosenan, B.},
  title = {Cedalion 101: "I want my DSL now"},
  year = {2011},
  pages = {29-30},
  note = {cited By (since 1996) 0},
  abstract = {Cedalion is a research LOP language designed for hosting internal
	DSLs but with the look-and-feel of external DSLs. Cedalion demonstrates
	a novel approach that combines extensible logic programming with
	projectional editing. We shall demonstrate the ease of realizing
	a small, yet non-trivial, highly expressive DSL in Cedalion.},
  affiliation = {Open University of Israel, 1 University Rd., Raanana 43107, Israel},
  author_keywords = {Domain-specific languages (DSLs); Language workbenches; Language-oriented
	programming (LOP)},
  document_type = {Conference Paper},
  journal = {SPLASH'11 Compilation - Proceedings of OOPSLA'11, Onward! 2011, GPCE'11,
	DLS'11, and SPLASH'11 Companion},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-81355123394&partnerID=40&md5=1410817030d56343796fbab9a959971b}
}

@CONFERENCE{Lorenz2011733,
  author = {Lorenz, D.H., Rosenan, B.},
  title = {Cedalion: A language for language oriented programming},
  year = {2011},
  pages = {733-752},
  note = {cited By (since 1996) 0},
  abstract = {Language Oriented Programming (LOP) is a paradigm that puts domain
	specific programming languages (DSLs) at the center of the software
	development process. Currently, there are three main approaches to
	LOP: (1) the use of internal DSLs, implemented as libraries in a
	given host language; (2) the use of external DSLs, implemented as
	interpreters or compilers in an external language; and (3) the use
	of language workbenches, which are integrated development environments
	(IDEs) for defining and using external DSLs. In this paper, we contribute:
	(4) a novel language-oriented approach to LOP for defining and using
	internal DSLs. While language workbenches adapt internal DSL features
	to overcome some of the limitations of external DSLs, our approach
	adapts language workbench features to overcome some of the limitations
	of internal DSLs. We introduce Cedalion, an LOP host language for
	internal DSLs, featuring static validation and projectional editing.
	To validate our approach we present a case study in which Cedalion
	was used by biologists in designing a DNA microarray for molecular
	Biology research. Copyright is held by the author / owner(s).},
  affiliation = {Open University of Israel, 1 University Rd, Raanana 43107, Israel},
  author_keywords = {Domain-specific languages (DSL); Language workbenches; Language-oriented
	programming (LOP); Logic programming},
  document_type = {Conference Paper},
  journal = {Proceedings of the Conference on Object-Oriented Programming Systems,
	Languages, and Applications, OOPSLA},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-81455154889&partnerID=40&md5=e115226a026d303a615c06a05216d8ef}
}

@ARTICLE{Lortal2011401,
  author = {Lortal, G.a , Dhouib, S.b , Gérard, S.b },
  title = {Integrating ontological domain knowledge into a robotic DSL},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2011},
  volume = {6627 LNCS},
  pages = {401-414},
  note = {cited By (since 1996) 0},
  abstract = {Coming from the Artificial Intelligence (AI) and Semantic Web (SW)
	circles, ontologies are used mainly to represent domains. The Model
	Driven Engineering (MDE) field gave birth to Domain Specific Languages
	to represent a particular technical domain. Abstracting from their
	uses, we consider as many others researchers that ontologies and
	models are closer than their original fields could get to think.
	Furthermore, their building or development are facing the same problems.
	They are costly and need experts' interviews in order to grasp specific
	knowledge and structure it. Likewise, ontologies and DSL can benefit
	from each other domains in reusing construction methodologies and
	even reusing knowledge modelled in another format. In this paper
	we first present the ontologies and DSL definition we use and some
	methodologies of development enabling the reuse of knowledge (as
	alignment, fusion). We then present how we propose to reuse the knowledge
	of a robotic ontology to develop robotic DSLs within the PROTEUS
	project in order to inject ready-made domain information to the DSL.
	© 2011 Springer-Verlag Berlin Heidelberg.},
  affiliation = {Decision Technologies and Mathematics Lab., Thales Research and Technology,
	Campus Polytechnique, 1, avenue Augustin Fresnel, 91767 Palaiseau
	cedex, France; CEA LIST, Laboratoire d'Ingenierie Dirigee Par les
	Modeles Pour les Systemes Embarques, Point Courrier 94, Gif-sur-Yvette
	F-91191, France},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-79957629715&partnerID=40&md5=ce41d03ccc1aa25cbfdda1078816c545}
}

@ARTICLE{Losilla2007179,
  author = {Losilla, F., Vicente-Chicote, C., Álvarez, B., Iborra, A., Sánchez,
	P.},
  title = {Wireless sensor network application development: An architecture-centric
	MDE approach},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2007},
  volume = {4758 LNCS},
  pages = {179-194},
  note = {cited By (since 1996) 8},
  abstract = {Nowadays, Wireless Sensor Networks (WSN) are a very promising research
	field since they find application in many different areas. Current
	proposals for WSN system development are mainly focused on implementation
	issues and they rarely rely on a Software Engineering methodology
	which supports their entire development life-cycle. The Model-Driven
	Engineering (MDE) approach can contribute to solve this problem by
	allowing designers to model their systems at different abstraction
	levels, providing them with automatic model transformations to incrementally
	refine abstract models into more concrete ones. In this vein, this
	paper presents a MDE approach to WSN application development. Three
	levels of abstraction have been defined which allow designers to
	build: (1) domain-specific models, (2) component-based architecture
	descriptions, and (3) platform-specific models. Automatic model transformations
	between these three abstraction levels have been designed and, in
	order to demonstrate the viability of the proposal, a real WSN application
	has been developed using the implemented tools. © Springer-Verlag
	Berlin Heidelberg 2007.},
  affiliation = {División de Sistemas e Ingeniería Electrónica (DSIE), Universidad
	Politécnica de Cartagena, 30202 Cartagena, Spain},
  author_keywords = {Component-based software architecture; Domain specific languages;
	Eclipse platform; Model-driven engineering; Wireless sensor networks},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-38149003822&partnerID=40&md5=01b6e5ac109b709d866b5393453002fa}
}

@ARTICLE{Louridas200716,
  author = {Louridas, P.},
  title = {Declarative GUI programming in Microsoft Windows},
  journal = {IEEE Software},
  year = {2007},
  volume = {24},
  pages = {16-19},
  number = {4},
  note = {cited By (since 1996) 4},
  abstract = {A domain-specific language for building user interfaces offers a transparent
	way for programmers to specify interface elements. Microsoft's Extensible
	Application Markup Language is an XML dialect for this purpose. However,
	XAML isn't the only choice for programmers who wish to try a declarative
	approach, and some options are even open source. © 2007 IEEE.},
  affiliation = {Greek Research and Technology Network, Software Engineering and Security
	Research Group, Athens University of Economics and Business, Athens,
	Greece},
  author_keywords = {Domain-specific languages; Extensible Application Markup Language;
	Graphical user interfaces; GUIs; XAML},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-34547124840&partnerID=40&md5=d1062f648463102df6cb49d8df86595d}
}

@CONFERENCE{Lu200572,
  author = {Lu, Q.a , Gao, X.a , Krishnamoorthy, S.a , Baumgartner, G.b , Ramanujam,
	J.c , Sadayappan, P.a },
  title = {Empirical performance-model driven data layout optimization},
  year = {2005},
  volume = {3602},
  pages = {72-86},
  note = {cited By (since 1996) 0},
  abstract = {Empirical optimizers like ATLAS have been very effective in optimizing
	computational kernels in libraries. The best choice of parameters
	such as tile size and degree of loop unrolling is determined by executing
	different versions of the computation. In contrast, optimizing compilers
	use a model-driven approach to program transformation. While the
	model-driven approach of optimizing compilers is generally orders
	of magnitude faster than ATLAS-like library generators, its effectiveness
	can be limited by the accuracy of the performance models used. In
	this paper, we describe an approach where a class of computations
	is modeled in terms of constituent operations that are empirically
	measured, thereby allowing modeling of the overall execution time.
	The performance model with empirically determined cost components
	is used to perform data layout optimization in the context of the
	Tensor Contraction Engine, a compiler for a high-level domain-specific
	language for expressing computational models in quantum chemistry.
	The effectiveness of the approach is demonstrated through experimental
	measurements on some representative computations from quantum chemistry.
	© Springer-Verlag Berlin Heidelberg 2005.},
  affiliation = {Department of Computer Science and Engineering, Ohio State University,
	Columbus, OH 43210, United States; Department of Computer Science,
	Louisiana State University, Baton Rouge, LA 70803, United States;
	Department of Electrical and Computer Engineering, Louisiana State
	University, Baton Rouge, LA 70803, United States},
  document_type = {Conference Paper},
  journal = {Lecture Notes in Computer Science},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-26444500461&partnerID=40&md5=9026987cc78562a3b660c9d4a54484c9}
}

@CONFERENCE{Lucrédio2010100,
  author = {Lucrédio, D.a , Fortes, R.P.M.b , Almeida, E.S.c , Meira, S.L.d },
  title = {Designing domain architectures for Model-Driven Engineering},
  year = {2010},
  pages = {100-109},
  note = {cited By (since 1996) 0},
  abstract = {Model-Driven Engineering (MDE) can leverage domain engineering by
	offering support to complex variability and automatic implementation.
	However, little attention is given to the process of designing a
	domain architecture that is well suited to MDE techniques such as
	domain-specific languages and software transformations. A domain-specific
	software architecture is normally developed based on a few selected
	and important requirements, called architectural drivers. This paper
	presents three types of architectural drivers that can be used to
	build a software architecture that can take full advantage of the
	benefits of MDE. It also presents some patterns that can be used
	to help in the architectural design. An evaluation is also presented,
	showing that, when used together in a model-driven domain engineering
	project, these drivers and patterns can lead to some benefits in
	terms of reusability and complexity, but that in some cases there
	are drawbacks that need to be considered in a trade-off analysis.
	© 2010 IEEE.},
  affiliation = {Computing Department, Federal University of São Carlos, São Carlos
	- SP, Brazil; Institute of Mathematical and Computing Sciences, University
	of São Paulo, São Carlos - SP, Brazil; Computing Science Department,
	Federal University of Bahia, Salvador - BA, Brazil; Recife Center
	for Advanced Studies and Systems, Recife, PE, Brazil},
  art_number = {5631928},
  author_keywords = {Architectural drivers; Code generation; Domain engineering; Domain-specific
	languages; Model-Driven Engineering; Patterns},
  document_type = {Conference Paper},
  journal = {Proceedings - 4th Brazilian Symposium on Software Components, Architectures
	and Reuse, SBCARS 2010},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-79952087220&partnerID=40&md5=bcc0442191d412fdd24dc5c1eefbf5d9}
}

@ARTICLE{Ludwig2011270,
  author = {Ludwig, M.a , Farcet, N.a , Babau, J.-P.b , Champeau, J.c },
  title = {Integrating design and runtime variability support into a system
	ADL},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2011},
  volume = {6698 LNCS},
  pages = {270-281},
  note = {cited By (since 1996) 0},
  abstract = {As the complexity of modern large systems or System of Systems increases,
	it becomes challenging to capture their whole dimension and to identify
	their key aspects. Architecture models provide a legible description
	of the system, and help describing its properties in a representation
	shared and understood by most stakeholders. In our case, we intend
	to evaluate system architectures through model execution. Since evolutionary
	design and configuration are key challenges of such systems, variability
	needs a way to be expressed in architecture models. Variability can
	be solved either at design time (derive a system from the family),
	or at runtime (reconfigure the system). This paper presents our experience
	in integrating variability aspects in a system architecture description
	Domain-Specific Language. © 2011 Springer-Verlag.},
  affiliation = {Thales Communications, 148 boulevard de Valmy, 92704 Colombes Cedex,
	France; LISyC, UBO, UEB, 20 avenue Le Gorgeu, 29200 Brest, France;
	LISyC, ENSTA Bretagne, 2 rue François Verny, 29200 Brest, France},
  author_keywords = {architecture modelling; Systems of Systems; variability},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-79959220782&partnerID=40&md5=a16a74f8591280c8713a7dbc4913d09f}
}

@CONFERENCE{Lukman2010a,
  author = {Lukman, T.a , Godena, G.a , Gray, J.b , Strmčnik, S.a },
  title = {Model-driven engineering of industrial process control applications},
  year = {2010},
  note = {cited By (since 1996) 0},
  abstract = {Software is an important part of industrial process control systems.
	However, the state-of-the-practice for developing industrial process
	control software still has several key challenges that need to be
	addressed (e.g., migration to platforms of different vendors, lack
	of automation). This paper introduces a model-driven engineering
	approach to the development of industrial process control software,
	which is based on the ProcGraph domain-specific modeling language.
	The paper discusses and offers solutions to several of the development
	challenges that have not been addressed by existing techniques in
	the process controls domain. The contributions of the paper are a
	model-driven engineering approach for the industrial process control
	domain and a supporting tool infrastructure. The approach is demonstrated
	by a case study focused on the development of a control system for
	a TiO2 (titanium dioxide) pigment production subprocess. ©2010 IEEE.},
  affiliation = {Jožef Stefan Institute, Department of Systems and Control, Jamova
	39, 1000 Ljubljana, Slovenia; University of Alabama, Department of
	Computer Science, Tuscaloosa, AL 35487-0290, United States},
  art_number = {5641224},
  document_type = {Conference Paper},
  journal = {Proceedings of the 15th IEEE International Conference on Emerging
	Technologies and Factory Automation, ETFA 2010},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-78650533238&partnerID=40&md5=cc9a611496eaeb72ffb1e5f61c51d7d7}
}

@CONFERENCE{Lukman2010,
  author = {Lukman, T.a , Mernik, M.b , Demirezen, Z.c , Bryant, B.c , Gray,
	J.d },
  title = {Automatic generation of model traversals from metamodel definitions},
  year = {2010},
  note = {cited By (since 1996) 0},
  abstract = {Developing software from models is a growing practice and there exist
	many model-based tools (e.g., model editors, model interpreters)
	for supporting model-driven engineering. Even though these tools
	facilitate the automation of software engineering tasks and activities,
	such tools are typically engineered manually. In this paper, a simple
	technique is described that enables automatic generation of model
	traversais. Semantic rules can be inserted into a traversal algorithm
	to provide meaning to the modeling language. The combination of automated
	traversal generation with attached semantic rules can generate a
	model interpreter that can translate a model into some other representation.
	Copyright © 2010 ACM.},
  affiliation = {Jožef Stefan Institute, Jamova 39, 1000 Ljubljana, Slovenia; University
	of Marlbor, Smetanova 17, 2000 Marlbor, Slovenia; University of Alabama
	at Birmingham, Dept. of Computer and Information Sciences, Birmingham,
	AL 35294-1170, United States; University of Alabama, Department of
	Computer Science, Tuscaloosa, AL 35487-0290, United States},
  art_number = {78},
  author_keywords = {Attribute grammars; Domain-Specific languages; Metamodeling; Semantics},
  document_type = {Conference Paper},
  journal = {Proceedings of the Annual Southeast Conference},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-79951836227&partnerID=40&md5=ec2be414164400cd97ee0a6dc20f46be}
}

@ARTICLE{Luković2010359,
  author = {Luković, I.a , Popović, A.b , Mostić, J.a , Ristić, S.a },
  title = {A tool for modeling form type check constraints and complex functionalities
	of business applications},
  journal = {Computer Science and Information Systems},
  year = {2010},
  volume = {7},
  pages = {359-386},
  number = {2},
  note = {cited By (since 1996) 0},
  abstract = {IIS*Case is a software tool that provides information system modeling
	and prototypes generation. At the level of platform independent model
	specifications, IIS*Case provides conceptual modeling of database
	schemas that include specifications of various database constraints,
	such as domain, not null, key and unique constraints, as well as
	various kinds of inclusion dependencies. It also provides conceptual
	modeling of business applications. In the paper, we present new concepts
	and a tool embedded into IIS*Case, that is aimed at supporting specification
	of check constraints. We present a domain specific language for specifying
	check constraints and a tool that enables visually oriented design
	and parsing check constraints. Also, we present concepts and a tool
	that is aimed at supporting specification of complex (i.e. nonstandard)
	functionalities of business applications. It is provided visually
	oriented and platform independent specification of business application
	functions.},
  affiliation = {University of Novi Sad, Faculty of Technical Sciences, Trg D. Obradovića
	6, 21000 Novi Sad, Serbia; University of Montenegro, Faculty of Science,
	Džordža Vašingtona bb, 81000 Podgorica, Montenegro},
  author_keywords = {Check constraint specification; Function specification; Information
	system design; Platform independent models and model driven software
	development},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-77953900002&partnerID=40&md5=0d843c9c97361039fb29f5a053bac128}
}

@CONFERENCE{Luković2009683,
  author = {Luković, I.a , Popović, A.b , Mostić, J.a , Ristić, S.a },
  title = {A tool for modeling form type check constraints},
  year = {2009},
  volume = {4},
  pages = {683-690},
  note = {cited By (since 1996) 0},
  abstract = {IIS*Case is a software tool that provides information system modeling
	and generating executable application prototypes. At the level of
	platform independent model specifications, IIS*Case provides conceptual
	modeling of database schemas that include specifications of various
	database constraints, such as domain, not null, key and unique constraints,
	as well as various kinds of inclusion dependencies. In the paper,
	we present new concepts and a tool embedded into IIS*Case, that are
	aimed to support specification of check constraints. We present a
	domain specific language for specifying check constraints and a tool
	that enables visually oriented design and parsing check constraints.
	© 2009 IEEE.},
  affiliation = {Faculty of Technical Sciences, University of Novi Sad, Trg D. Obradovica
	6, 21000 Novi Sad, Serbia; Faculty of Science, University of Montenegro,
	Džordža Vašingtona bb, 81000 Podgorica, Montenegro},
  art_number = {5352764},
  document_type = {Conference Paper},
  journal = {Proceedings of the International Multiconference on Computer Science
	and Information Technology, IMCSIT '09},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-78649740929&partnerID=40&md5=2bf3f01f8e12c4bcd730ea243f92a2da}
}

@ARTICLE{Luković2011379,
  author = {Luković, I.a , Pereira, M.J.V.b , Oliveira, N.c , da Cruz, D.c ,
	Henriques, P.R.c },
  title = {A DSL for PIM specifications: Design and attribute grammar based
	implementation},
  journal = {Computer Science and Information Systems},
  year = {2011},
  volume = {8},
  pages = {379-403},
  number = {2},
  note = {cited By (since 1996) 0},
  abstract = {IIS*Case is a model driven software tool that provides information
	system modeling and prototype generation. It comprises visual and
	repository based tools for creating various platform independent
	model (PIM) specifications that are latter transformed into the other,
	platform specific specifications, and finally to executable programs.
	Apart from having PIMs stored as repository definitions, we need
	to have their equivalent representation in the form of a domain specific
	language. One of the main reasons for this is to allow for checking
	the formal correctness of PIMs being created. In the paper, we present
	such a meta-language, named IIS*CDesLang. IIS*CDesLang is specified
	by an attribute grammar (AG), created under a visual programming
	environment for AG specifications, named VisualLISA.},
  affiliation = {University of Novi Sad, Faculty of Technical Sciences, Trg D. Obradovića
	6, 21000 Novi Sad, Serbia; Polytechnic Institute of Bragança, Escola
	Superior de Tecnologia e Gestão, Campus de Santa Apolónia-Apartado
	1134, 5301-857 Bragança, Portugal; Universisty of Minho, Department
	of Computer Science, Campus de Gualtar, 4710-057 Braga, Portugal},
  author_keywords = {Attribute grammars; Domain specific languages; Domain specific modelling;
	Information system modeling; Model-driven approaches},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-80755172307&partnerID=40&md5=9a0fede3c65b401f5765bfa46e7b9095}
}

@ARTICLE{LunaRobles2011297,
  author = {Luna Robles, E.a b , Rossi, G.c , Garrigós, I.d },
  title = {WebSpec: A visual language for specifying interaction and navigation
	requirements in web applications},
  journal = {Requirements Engineering},
  year = {2011},
  volume = {16},
  pages = {297-321},
  number = {4},
  note = {cited By (since 1996) 0},
  abstract = {Web application development is a complex and time-consuming process
	that involves different stakeholders (ranging from customers to developers);
	these applications have some unique characteristics like navigational
	access to information, sophisticated interaction features, etc. However,
	there have been few proposals to represent those requirements that
	are specific to Web applications. Consequently, validation of requirements
	(e. g., in acceptance tests) is usually informal and as a result
	troublesome. To overcome these problems, we present WebSpec, a domain-specific
	language for specifying the most relevant and characteristic requirements
	of Web applications: those involving interaction and navigation.
	We describe WebSpec diagrams, discussing their abstraction and expressive
	power. With a simple though realistic example, we show how we have
	used WebSpec in the context of an agile Web development approach
	discussing several issues such as automatic test generation, management
	of changes in requirements, and improving the understanding of the
	diagrams through application simulation. © 2011 Springer-Verlag London
	Limited.},
  affiliation = {LIFIA, Facultad de Informática, UNLP, La Plata, Argentina; CICPBA,
	Buenos Aires, Argentina; Conicet, La Plata, Argentina; Lucentia Research
	Group, DLSI, University of Alicante, Alicante, Spain},
  author_keywords = {Code generation; Interaction; Simulation; Testing; Web requirements},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-80355133393&partnerID=40&md5=5c6d57ed91d21ee177a80a8c06321f05}
}

@ARTICLE{Lung2010672,
  author = {Lung, C.-H., Rajeswaran, P., Sivadas, S., Sivabalasingam, T.},
  title = {Experience of building an architecture-based generator using GenVoca
	for distributed systems},
  journal = {Science of Computer Programming},
  year = {2010},
  volume = {75},
  pages = {672-688},
  number = {8},
  note = {cited By (since 1996) 0},
  abstract = {Selecting the architecture that meets the requirements, both functional
	and non-functional, is a challenging task, especially at the early
	stage when more uncertainties exist. Architectural prototyping is
	a useful approach in supporting the evaluation of alternative architectures
	and balancing different architectural qualities. Generative programming
	has gained increasing attention, but it mostly deals with lower-level
	artifacts; hence, it usually supports lower degrees of software automation.
	This paper proposes an architecture-centric generative approach in
	facilitating architectural prototyping and evaluation. We also present
	our empirical experience in raising the level of abstraction to the
	architecture layer for distributed and concurrent systems using GenVoca.
	GenVoca is a generative programming approach that is used here to
	support the generation or instantiation of a particular architectural
	pattern in distributed computing based on user's selection. As a
	result, it can support rapid architectural prototyping and evaluation
	of both functional and non-functional requirements and encourage
	greater degrees of software automation and reuse. Lessons learned
	from the empirical study are also reported and could be applied to
	other areas. © 2009 Elsevier B.V. All rights reserved.},
  affiliation = {Department of Systems and Computer Engineering, Carleton University,
	Ottawa, ON, Canada},
  author_keywords = {Distributed systems; Generative programming; GenVoca; Prototyping;
	Software architecture; Software patterns},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-77955275049&partnerID=40&md5=fda07565e80c7de68a69a913249d0244}
}

@ARTICLE{Luong2010536,
  author = {Luong, T.N., Etcheverry, P., Nodenot, T., Marquesuzaà, C., Lopistéguy,
	P.},
  title = {End-user visual design of web-based interactive applications making
	use of geographical information: The WINDMash approach},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2010},
  volume = {6383 LNCS},
  pages = {536-541},
  note = {cited By (since 1996) 0},
  abstract = {Visual instructional design languages currently provide notations
	for representing the intermediate and final results of a knowledge
	engineering process. This paper reports on a visual framework (called
	WIND - Web INteraction Design) that focuses on both designers' creativity
	and model executability. It only addresses Active Reading Learning
	Scenarios making use of localized documents (travel stories, travel
	guides). Our research challenge is to enable the teachers to design
	by themselves interaction scenarios for such a domain, avoiding any
	programmer intervention. The WIND framework provides a conceptual
	model and its associated Application Programming Interface (API).
	The WIND interaction scenarios are encoded as XML documents which
	are automatically transformed into code thanks to the provided API,
	thus providing designers with a real application that they can immediately
	assess and modify (prototyping techniques). The WIND conceptual model
	only provides designers with an abstract syntax and a semantics.
	Users of such a Domain Specific Language (DSL) need a concrete syntax.
	Our choice is to produce a Web-Based Mashup Environment providing
	designers with visual functionality. © 2010 Springer-Verlag Berlin
	Heidelberg.},
  affiliation = {IUT de Bayonne - Pays Basque, LIUPPA-T2I, 2 Allée du Parc Montaury,
	Anglet 64600, France},
  author_keywords = {Applications of TEL in the Domain of Geography; Interaction Design;
	Semantic Web; Technologies for Personalisation and Adaptation; Visual
	Instructional Design Languages},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-78049389868&partnerID=40&md5=6a7494f28b3d4cfa41c611902857e68d}
}

@ARTICLE{Lussenburg2010346,
  author = {Lussenburg, V.a , Van Der Storm, T.b c , Vinju, J.b c , Warmer, J.a
	},
  title = {Mod4J: A qualitative case study of model-driven software development},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2010},
  volume = {6395 LNCS},
  pages = {346-360},
  number = {PART 2},
  note = {cited By (since 1996) 0},
  abstract = {Model-driven software development (MDSD) has been on the rise over
	the past few years and is becoming more and more mature. However,
	evaluation in real-life industrial context is still scarce. In this
	paper, we present a case-study evaluating the applicability of a
	state-of-the-art MDSD tool, modJ, a suite of domain specific languages
	(DSLs) for developing administrative enterprise applications. modJ
	was used to partially rebuild an industrially representative application.
	This implementation was then compared to a base implementation based
	on elicited success criteria. Our evaluation leads to a number of
	recommendations to improve mod4J. We conclude that having extension
	points for hand-written code is a good feature for a model driven
	software development environment. © 2010 Springer-Verlag.},
  affiliation = {Ordina, Netherlands; Centrum Wiskunde and Informatica, Netherlands;
	Universiteit Van Amsterdam, Netherlands},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-78349284851&partnerID=40&md5=c7b57f207da4a783f287ee8969204168}
}

@ARTICLE{Lämmel2007208,
  author = {Lämmel, R.},
  title = {Google's MapReduce programming model - Revisited},
  journal = {Science of Computer Programming},
  year = {2007},
  volume = {68},
  pages = {208-237},
  number = {3},
  note = {cited By (since 1996) 24},
  abstract = {Google's MapReduce programming model serves for processing large data
	sets in a massively parallel manner. We deliver the first rigorous
	description of the model including its advancement as Google's domain-specific
	language Sawzall. To this end, we reverse-engineer the seminal papers
	on MapReduce and Sawzall, and we capture our findings as an executable
	specification. We also identify and resolve some obscurities in the
	informal presentation given in the seminal papers. We use typed functional
	programming (specifically Haskell) as a tool for design recovery
	and executable specification. Our development comprises three components:
	(i) the basic program skeleton that underlies MapReduce computations;
	(ii) the opportunities for parallelism in executing MapReduce computations;
	(iii) the fundamental characteristics of Sawzall's aggregators as
	an advancement of the MapReduce approach. Our development does not
	formalize the more implementational aspects of an actual, distributed
	execution of MapReduce computations. © 2007 Elsevier B.V. All rights
	reserved.},
  affiliation = {Data Programmability Team, Microsoft Corp., Redmond, WA, United States},
  author_keywords = {Data processing; Distributed programming; Executable specification;
	Haskell; List homomorphism; Map; MapReduce; Parallel programming;
	Reduce; Sawzall; Software design; Typed functional programming},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-34548493644&partnerID=40&md5=dc0372b3c79d9e512d090f1182e4c12f}
}

@CONFERENCE{Lämmel2010104,
  author = {Lämmel, R., Pek, E.},
  title = {Vivisection of a non-executable, domain-specific language: Understanding
	(the usage of) the P3P language},
  year = {2010},
  pages = {104-113},
  note = {cited By (since 1996) 0},
  abstract = {P3P is the policy language with which websites declare the intended
	use of data that is collected about users of the site. We have systematically
	collected P3P-based privacy policies from websites listed in the
	Google directory, and analysed the resulting corpus with regard to
	different levels of validity, size or complexity metrics, different
	cloning levels, coverage of language constructs, and the use of the
	language's extension mechanism. In this manner, we have found interesting
	characteristics of P3P in the wild. For instance, cloning is exceptionally
	common in this domain, and encountered language extensions exceed
	the base language in terms of grammar complexity. Overall, this effort
	helps understanding the de-facto usage of the nonexecutable, domain-specific
	language P3P. Some elements of our methodology may be useful for
	other software languages as well. © 2010 IEEE.},
  affiliation = {Software Languages Team and ADAPT Lab., Universität Koblenz, Landau,
	Germany},
  art_number = {5521756},
  document_type = {Conference Paper},
  journal = {IEEE International Conference on Program Comprehension},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-77956146105&partnerID=40&md5=6f6784a1ba2cfdc8e78a158442eae9f8}
}

@ARTICLE{Lédeczi2001,
  author = {Lédeczi, A., Bakay, A., Maróti, M., Völgyesi, P., Nordstrom, G.,
	Sprinkle, J., Karsai, G.},
  title = {Composing domain-specific design environments},
  journal = {Computer},
  year = {2001},
  volume = {34},
  pages = {44-51+24},
  number = {11},
  note = {cited By (since 1996) 187},
  abstract = {Domain-specific integrated development environments can help capture
	specifications in the form of domain models. These tools support
	the design process by automating analysis and simulating essential
	system behavior. In addition, they can automatically generate, configure,
	and integrate target application components. The high cost of developing
	domain-specific, integrated modeling, analysis, and application-generation
	environments prevents their penetration into narrower engineering
	fields that have limited user bases. Model-integrated computing (MIC),
	an approach to model-based engineering that helps compose domain-specific
	design environments rapidly and cost effectively, is particularly
	relevant for specialized computer-based systems domains-perhaps even
	single projects. The authors describe how MIC provides a way to compose
	such environments cost effectively and rapidly by using a metalevel
	architecture to specify the domain-specific modeling language and
	integrity constraints. They also discuss the toolset that implements
	MIC and describe a practical application in which using the technology
	in a tool environment for the process industry led to significant
	reductions in development and maintenance costs.},
  affiliation = {Inst. for Software Integrated Syst., Vanderbilt University, Nashville,
	TN, United States},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-0035500228&partnerID=40&md5=9607942abbf85d7977552610bf989bc0}
}

@ARTICLE{López-Sanz201057,
  author = {López-Sanz, M., Cuesta, C.E., Marcos, E.},
  title = {Formalizing high-level service-oriented architectural models using
	a dynamic ADL},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2010},
  volume = {6428 LNCS},
  pages = {57-66},
  note = {cited By (since 1996) 0},
  abstract = {Despite the well-known advantages of applying the MDA approach, particularly
	when applied to the development of SOA-based systems, there are still
	some gaps in the process that need to be filled. Specifically, when
	modelling the system at the PIM level, we have an architectural description
	at a high level of abstraction, as it must only comprise technologically
	independent models. But this architecture cannot be directly validated,
	as we must transform it into a PSM version before being able to execute
	it. In order to solve this issue, we propose to formalize the architectural
	model using Domain Specific Language, an ADL which supports the description
	of dynamic, adaptive and evolvable architectures, such as SOA itself.
	Our choice, π-ADL, allows for the definition of executable versions
	of the architecture; and therefore providing this specification implies
	having a prototype of the system at the PIM level. This appears as
	a perfect way of getting an executable yet completely technology
	neutral version of the architecture. We illustrate this by discussing
	a real-world case study, in which a service-oriented messaging system
	is modelled at the PIM level and then specified using its π-ADL counterpart;
	the result can then be used to validate the architecture at the right
	abstraction level. © 2010 Springer-Verlag Berlin Heidelberg.},
  affiliation = {Kybele Research Group, Rey Juan Carlos University, Mostoles, Madrid
	28933, Spain},
  author_keywords = {π-ADL; Model-Driven Architecture; PIM-level modelling; Service-Oriented
	Architecture},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-78649493783&partnerID=40&md5=7cbff42b44c94823f7bed226cf6956f5}
}

@ARTICLE{Lúcio2011239,
  author = {Lúcio, L.a , Vieira, E.b , Weißleder, S.c },
  title = {MoDeVVa 2010 workshop summary},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2011},
  volume = {6627 LNCS},
  pages = {239-243},
  note = {cited By (since 1996) 0},
  abstract = {The MoDeVVa workshop series is focused on Model-Driven Engineering,
	Verification, and Validation. Models are purposeful abstractions.
	They are used to support the focus on the important aspects and to
	make complex systems easy to understand. Beyond their use as documentation,
	models can also be used for automatic transformation or code generation.
	For this, a formal foundation of models with fixed semantics is necessary.
	One typical application is the automatic generation of large parts
	of system source code. The automation can result in a decrease of
	system engineering costs. Thus, the usage of models, model transformations,
	and code generation is becoming more and more important for industrial
	applications. As one of the most important representatives for the
	application of models, Model-Driven Engineering (MDE) is a development
	methodology that is based on models, meta models, and model transformations.
	There is already a lot of tool support for models, (domain-specific)
	modeling languages, model transformations, and code generation. The
	constant pace at which scientific and industrial development of MDE-related
	techniques moves forward shows that MDE is quickly changing and that
	new approaches and corresponding issues arise frequently. Most important,
	there is a crucial need for verification and validation (V&V) techniques
	in the context of MDE. Likewise, V&V is very important in many domains
	(e.g., automotive or avionics) and the use of MDE techniques in the
	context of V&V is an interesting topic. One prominent representative
	of this approach is model-based testing (MBT). © 2011 Springer-Verlag
	Berlin Heidelberg.},
  affiliation = {University of Luxembourg, Luxembourg; Alcatel-Lucent, France; Fraunhofer
	FIRST, Germany},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-79957636754&partnerID=40&md5=17714a1ff465c07583dabd043f98763b}
}

@ARTICLE{Mader2011113,
  author = {Mader, R.a b , Armengaud, E.a c , Leitner, A.b , Kreiner, C.b , Bourrouilh,
	Q.a , Grießnig, G.a b , Steger, C.b , Weiß, R.b },
  title = {Computer-aided PHA, FTA and FMEA for automotive embedded systems},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2011},
  volume = {6894 LNCS},
  pages = {113-127},
  note = {cited By (since 1996) 0},
  abstract = {The shift of the automotive industry towards powertrain electrification
	introduces new automotive sensors, actuators and functions that lead
	to an increasing complexity of automotive embedded systems. The safety-criticality
	of these systems demands the application of analysis techniques such
	as PHA (Preliminary Hazard Analysis), FTA (Fault Tree Analysis) and
	FMEA (Failure Modes and Effects Analysis) in the development process.
	The early application of PHA allows to identify and classify hazards
	and to define top-level safety requirements. Building on this, the
	application of FTA and FMEA supports the verification of a system
	architecture defining an embedded system together with connected
	sensors and controlled actuators. This work presents a modeling framework
	with automated analysis and synthesis capabilities that supports
	a safety engineering workflow using the domain-specific language
	EAST-ADL. The contribution of this work is (1) the definition of
	properties that indicate the correct application of the workflow
	using the language. The properties and a model integrating the work
	products of the workflow are used for the automated detection of
	errors (property checker) and the automated suggestion and application
	of corrective measures (model corrector). Furthermore, (2) fault
	trees and a FMEA table can be automatically synthesized from the
	same model. The applicability of this computer-aided and tightly
	integrated approach is evaluated using the case study of a hybrid
	electric vehicle development. © 2011 Springer-Verlag.},
  affiliation = {AVL List GmbH, Austria; Institute for Technical Informatics, Graz
	University of Technology, Austria; Virtual Vehicle Competence Center
	(ViF), Austria},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-80053016464&partnerID=40&md5=f69ec524213d1f0ad9f7051939f47321}
}

@CONFERENCE{Mader2011169,
  author = {Mader, R.a b , Grießnig, G.a b , Leitner, A.b , Kreiner, C.b , Bourrouilh,
	Q.a , Armengaud, E.c , Steger, C.b , Weiß, R.b },
  title = {A computer-aided approach to preliminary hazard analysis for automotive
	embedded systems},
  year = {2011},
  pages = {169-178},
  note = {cited By (since 1996) 1},
  abstract = {Powertrain electrification of automobiles leads to a higher number
	of sensors, actuators and control functions, which in turn increases
	the complexity of automotive embedded systems. The safety-criticality
	of the system requires the application of Preliminary Hazard Analysis
	early in the development process. This is a necessary first step
	for the development of an automotive embedded system that is acceptably
	safe. Goal of this activity is the identification and classification
	of hazards and the definition of top level safety requirements that
	are the basis for designing a safety-critical embedded system that
	is able to control or mitigate the identified hazards. A computer-aided
	framework to support Preliminary Hazard Analysis for automotive embedded
	systems is presented in this work. The contribution consists of (1)
	an enhancement for Preliminary Hazard Analysis to the domain-specific
	language EAST-ADL, as well as (2) the identification of properties
	that indicate the correct application of Preliminary Hazard Analysis
	using the language. These properties and an analysis model reflecting
	the results of the Preliminary Hazard Analysis are used for the automated
	detection of an erroneously applied Preliminary Hazard Analysis (property
	checker) and the automated suggestion and application of corrective
	measures (model corrector). The applicability of the approach is
	evaluated by the case study of hybrid electric vehicle development.
	© 2011 IEEE.},
  affiliation = {AVL List GmbH, Austria; Institute for Technical Informatics, Graz
	University of Technology, Austria; Virtual Vehicle Competence Center,
	Austria},
  art_number = {5934817},
  author_keywords = {Automotive embedded system; Functional safety; ISO 26262; Preliminary
	hazard analysis; Safety goal},
  document_type = {Conference Paper},
  journal = {Proceedings - 18th IEEE International Conference and Workshops on
	Engineering of Computer-Based Systems, ECBS 2011},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-80051981496&partnerID=40&md5=90d3f2b253ed5491e36840aefc564e4f}
}

@CONFERENCE{Madhavapeddy2007101,
  author = {Madhavapeddy, A.a b , Ho, A.a c , Deegan, T.a b , Scott, D.b , Sohan,
	R.a },
  title = {Melange: Creating a "functional" internet},
  year = {2007},
  pages = {101-114},
  note = {cited By (since 1996) 6},
  abstract = {Most implementations of critical Internet protocols are written in
	type-unsafe languages such as C or C++ and are regularly vulnerable
	to serious security and reliability problems. Type-safe languages
	eliminate many errors but are not used to due to the perceived performance
	overheads. We combine two techniques to eliminate this performance
	penalty in a practical fashion: strong static typing and generative
	meta-programming. Static typing eliminates run-time type information
	by checking safety at compile-time and minimises dynamic checks.
	Meta-programming uses a single specification to abstract the low-level
	code required to transmit and receive packets. Our domain-specific
	language, MPL, describes Internet packet protocols and compiles into
	fast, zero-copy code for both parsing and creating these packets.
	MPL is designed for implementing quirky Internet protocols ranging
	from the low-level: Ethernet, IPv4, ICMP and TCP; to the complex
	application-level: SSH, DNS and BGP; and even file-system protocols
	such as 9P. We report on fully-featured SSH and DNS servers constructed
	using MPL and our OCaml framework Melange, and measure greater throughput,
	lower latency, better flexibility and more succinct source code than
	their C equivalents OpenSSH and BIND. Our quantitative analysis shows
	that the benefits of MPL-generated code overcomes the additional
	overheads of automatic garbage collection and dynamic bounds checking.
	Qualitatively, the flexibility of our approach shows that dramatic
	optimisations are easily possible. Copyright 2007 ACM.},
  affiliation = {Computer Laboratory, University of Cambridge; XenSource Inc.; Arastra
	Inc.},
  document_type = {Conference Paper},
  journal = {Operating Systems Review (ACM)},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-34548011724&partnerID=40&md5=9f8684fffb2848bc2f0f3ebeecda1f50}
}

@ARTICLE{Madl200659,
  author = {Madl, G., Dutt, N.},
  title = {Domain-specific modeling of power aware distributed real-time embedded
	systems},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2006},
  volume = {4017 LNCS},
  pages = {59-68},
  note = {cited By (since 1996) 0},
  abstract = {This paper provides two contributions to the research on applying
	domain-specific modeling languages to distributed real-time embedded
	(DRE) systems. First, we present the ALDERIS platform-independent
	visual language for component-based system development. Second, we
	demonstrate the use of the ALDERIS language on a helicopter autopilot
	DRE design. The ALDERIS language is based on the concept of platform-based
	design, and explicitly captures asynchronous event-driven component
	interactions as well as the underlying platform for the computation.
	Unlike most modeling languages, ALDERIS has formally defined semantics
	providing a way for the formal verification of dense real-time properties
	and energy consumption. © Springer-Verlag Berlin Heidelberg 2006.},
  affiliation = {Center for Embedded Computer Systems, University of California, Irvine,
	CA 92697, United States},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-33746772060&partnerID=40&md5=7e41de0838d265ae8276be42730023e9}
}

@ARTICLE{Madl2009241,
  author = {Madl, G.a , Pasricha, S.b , Dutt, N.a , Abdelwahed, S.c },
  title = {Cross-abstraction functional verification and performance analysis
	of chip multiprocessor designs},
  journal = {IEEE Transactions on Industrial Informatics},
  year = {2009},
  volume = {5},
  pages = {241-256},
  number = {3},
  note = {cited By (since 1996) 1},
  abstract = {This paper introduces the cross-abstraction real-time analysis (Carta)
	framework for the model-based functional verification and performance
	estimation of chip multiprocessors (CMPs) utilizing bus matrix (crossbar
	switch) interconnection networks. We argue that the inherent complexity
	in CMP designs requires the synergistic use of various models of
	computation to efficiently manage the tradeoffs between accuracy
	and complexity. Our approach builds on domain-specific modeling languages
	(DSMLs) driving an open-source tool-chain that provides a cross-abstraction
	bridge between the finite-state machine (FSM), discrete-event (DE),
	and timed automata (TA) models of computation, and utilizes multiple
	model checkers to analyze formal properties at the cycle-accurate
	and transaction-level abstractions. The cross-abstraction analysis
	exploits accuracy for functional verification, and achieves significant
	speedups for performance estimation with marginal accuracy loss.
	We demonstrate results on an industrial strength networking CMP design
	utilizing a bus matrix interconnection network. To the best of our
	knowledge, the Carta framework is the first model-based tool-chain
	that utilizes multiple abstractions and model checkers for the comprehensive
	and formal functional verification, performance estimation, and real-time
	verification of bus matrix-based CMP designs. © 2006 IEEE.},
  affiliation = {Department of Computer Science, University of California, Irvine,
	CA 92617, United States; Department of Electrical and Computer Engineering,
	Colorado State University, Forth Collins, CO 80523, United States;
	Department of Electrical and Computer Engineering, Mississippi State
	University, Starkville, MS 39762, United States},
  art_number = {5175490},
  author_keywords = {Bus matrix interconnect; Chip multiprocessor (CMP); Model checking;
	Performance analysis; Real-time},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-69249210879&partnerID=40&md5=8f1854cc16dda46b72557358b85521a6}
}

@CONFERENCE{Maeda2010296,
  author = {Maeda, K.},
  title = {A Scala-based domain specific language for structured data representation},
  year = {2010},
  volume = {2},
  pages = {296-299},
  note = {cited By (since 1996) 0},
  abstract = {This paper describes Sibon, a new representation written in a text-based
	data format using Scala syntax. The design principle of Sibon is
	good readability and simplicity of structured data representation.
	An important feature of Sibon is an executable representation. Once
	Sibon-related definitions are loaded, the representation can be executed
	corresponding to the definitions. A program generator was developed
	to create Scala and Java programs from Sibon definitions. In the
	author's experience, productivity was improved in the design and
	implementation of programs that manipulate structured data.},
  affiliation = {Department of Business Administration and Information Science, Chubu
	University, 1200 Matsumoto, Kasugai, Aichi, Japan},
  author_keywords = {Data representation; Domain specific languages; Java; Scala; Structured
	data},
  document_type = {Conference Paper},
  journal = {ICSOFT 2010 - Proceedings of the 5th International Conference on
	Software and Data Technologies},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-78751560951&partnerID=40&md5=c9c24385926035b3e6008d42f372aa93}
}

@CONFERENCE{Maeda2008675,
  author = {Maeda, K.},
  title = {Experience of a ruby-syntax representation for structured data},
  year = {2008},
  pages = {675-680},
  note = {cited By (since 1996) 0},
  abstract = {This paper describes Ribbon (Ruby Instructions Becoming Basic Object
	Notation), a new representation written in a text-based data format
	using Ruby syntax. The design principles of Ribbon are high readability
	and simplicity of structured data representation. An important feature
	of Ribbon is an executable representation. Once Ribbon-related definitions
	are loaded into a Ruby interpreter, the representation can be executed
	corresponding to the definitions. Java programs are expected to read/write
	Java objects from/to persistent storage-media, or to traverse the
	structured data. A program generator was developed to create Ruby
	and Java programs from Ribbon definitions. In the author's experience,
	productivity was improved in the design and implementation of programs
	that manipulate structured data.},
  affiliation = {Department of Business Administration and Information Scienece, Chubu
	University, 1200 Matsumoto, Kasugai, Aichi 487-8501, Japan},
  author_keywords = {Data representation; Domain specific languages; Java; Ruby; Structured
	data},
  document_type = {Conference Paper},
  journal = {Proceedings of the 2008 International Conference on Software Engineering
	Research and Practice, SERP 2008},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-62749132325&partnerID=40&md5=c79e595052f9c1b17408ffc0d9ab18e2}
}

@ARTICLE{Maeda2008853,
  author = {Maeda, K.},
  title = {Structured data representation using Ruby syntax},
  journal = {WSEAS Transactions on Information Science and Applications},
  year = {2008},
  volume = {5},
  pages = {853-858},
  number = {5},
  note = {cited By (since 1996) 0},
  abstract = {This paper describes Ribbon (Ruby Instructions Becoming Basic Object
	Notation), a new representation written in a text-based data format
	using Ruby syntax. The design principle of Ribbon is good readability
	and simplicity of structured data representation. An important feature
	of Ribbon is an executable representation. Once Ribbon-related definitions
	are loaded into a Ruby interpreter, the representation can be executed
	corresponding to the definitions. Java programs are expected to read/write
	Java objects to persistent storage-media, or to traverse the structured
	data. A program generator was developed to create Ruby and Java programs
	from Ribbon definitions. In the author's experience, productivity
	was improved in the design and implementation of programs that manipulate
	structured data.},
  affiliation = {Department of Business Administration and Information Science, Chubu
	University, 1200 Matsumoto, Kasugai, Aichi, Japan},
  author_keywords = {Data representation; Domain specific languages; Java; Ruby; Structured
	data},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-48849088023&partnerID=40&md5=c4b496229b180bad11df997dfe9e3664}
}

@ARTICLE{Magdalenic2009397,
  author = {Magdalenic, I.a , Radosevic, D.a , Skocir, Z.b },
  title = {Dynamic Generation of Web Services for Data Retrieval Using Ontology},
  journal = {Informatica},
  year = {2009},
  volume = {20},
  pages = {397-416},
  number = {3},
  note = {cited By (since 1996) 4},
  abstract = {Semantic Web is envisioned as semantic description of data and services
	enabling unambiguous computerized interpretation. Thanks to semantic
	description, computers can perform demanding tasks such as automation
	of discovery and access to heterogeneous data sources. Although this
	is possible with the existing technologies, combination of web services
	technology, ontologies and generative programming methods makes this
	simpler and more efficient. This paper presents the model for dynamic
	generation of web services for data retrieval from heterogeneous
	data sources using ontologies. Emphasis is on dynamic generation
	of web services customized to a particular user based on the request
	defined by ontology. The paper also describes a prototype of the
	model implementation. Some advantages of our approach over other
	approaches are also provided. © 2009 Institute of Mathematics and
	Informatics, Vilnius.},
  affiliation = {Faculty of Organization and Informatics, University of Zagreb, Pavlinska
	2, HR-42000 Varazdin, Croatia; Faculty of Electrical Engineering
	and Computing, University of Zagreb, Unska 3, HR-10000 Zagreb, Croatia},
  author_keywords = {Data retrieval; Generative programming; Ontology; Web services},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-70349835987&partnerID=40&md5=651c041d0b423441db40060caab993e3}
}

@ARTICLE{Magklaras2006361,
  author = {Magklaras, G.B.a , Furnell, S.M.a , Brooke, P.J.b },
  title = {Towards an insider threat prediction specification language},
  journal = {Information Management and Computer Security},
  year = {2006},
  volume = {14},
  pages = {361-381},
  number = {4},
  note = {cited By (since 1996) 3},
  abstract = {Purpose - This paper presents the process of constructing a language
	tailored to describing insider threat incidents, for the purposes
	of mitigating threats originating from legitimate users in an IT
	infrastructure. Design/methodology/approach - Various information
	security surveys indicate that misuse by legitimate (insider) users
	has serious implications for the health of IT environments. A brief
	discussion of survey data and insider threat concepts is followed
	by an overviewof existing research efforts to mitigate this particular
	problem. None of the existing insider threat mitigation frameworks
	provide facilities for systematically describing the elements of
	misuse incidents, and thus all threat mitigation frameworks could
	benefit from the existence of a domain specific language for describing
	legitimate user actions. Findings - The paper presents a language
	development methodology which centres upon ways to abstract the insider
	threat domain and approaches to encode the abstracted information
	into language semantics. The language construction methodology is
	based upon observed information security survey trends and the study
	of existing insider threat and intrusion specification frameworks.
	Originality/value - This paper summarizes the picture of the insider
	threat in IT infrastructures and provides a useful reference for
	insider threat modeling researchers by indicating ways to abstract
	insider threats.},
  affiliation = {Network Research Group, School of Computing, Communications and Electronics,
	University of Plymouth, Plymouth, United Kingdom; School of Computing,
	University of Teesside, Middlesbrough, United Kingdom},
  author_keywords = {Data security; Information systems},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-33746645281&partnerID=40&md5=2820309c58fd88952ebc538fc335bf11}
}

@CONFERENCE{Mahoney200815,
  author = {Mahoney, W., Sousan, W.},
  title = {IDEA: A new intrusion detection data source},
  year = {2008},
  pages = {15-19},
  note = {cited By (since 1996) 0},
  abstract = {In the context of computer systems, an intrusion is generally considered
	to be a harmful endeavor to prevent others from legitimate use of
	that system, to obtain data which is not normally available to the
	intruder, or to plant data or disrupt data already existent on the
	machines. Traditionally intrusion detection has relied on two data
	sources: various log flies which record user's activity, and network
	traffic which contains potential threats. This research presents
	a system which we call IDEA; the Intrusion DEtection Automata system.
	We utilize a third source of data for intrusion detection in the
	form of an instrumented process. Open source software is recompiled
	using a modified compiler we have created, and the resulting executable
	program generates the data as it runs. An external monitoring facility
	then checks the behavior of the program against known good execution
	paths. These paths are specified either using a domain specific language
	and hand-written rules, or by running the software in a learning
	mode and capturing the normal behavior for later comparison. © 2008
	IEEE.},
  affiliation = {Peter Kiewit Institute, University of Nebraska at Omaha, 6001 Dodge
	Street, Omaha, NE 68182-0500, United States},
  art_number = {4511526},
  document_type = {Conference Paper},
  journal = {Proceedings of the 2nd International Conference on Information Security
	and Assurance, ISA 2008},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-51349162115&partnerID=40&md5=8422bb3eb5529602d7bf29f95b8816c9}
}

@ARTICLE{Mahoney2007151,
  author = {Mahoney, W., Sousan, W.},
  title = {Instrumentation of open-source software for intrusion detection},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2007},
  volume = {4839 LNCS},
  pages = {151-163},
  note = {cited By (since 1996) 0},
  abstract = {A significant number of cyber assaults and intrusion attempts are
	made against open source software written in C, C++, or Java. Detecting
	all flaws in a large system is still a daunting, unrealistic task.
	The information assurance area known as "intrusion detection" (ID)
	senses unauthorized access attempts by monitoring key pieces of system
	data. There is a desire to at least detect intrusion attempts in
	order to stop them while in progress, or repair the damage at a later
	date. Most ID systems examine system log files, or monitor network
	traffic. This research presents a new approach to generating records
	for intrusion detection by means of instrumentation. Open source
	code such as a web server can be compiled and the execution path
	of the server can be observed externally in near real-time. This
	method thus creates a new data source for ID which can be incorporated
	into a discovery system. © Springer-Verlag Berlin Heidelberg 2007.},
  affiliation = {University of Nebraska at Omaha, 282F PKI 6001 Dodge Street, Omaha
	Nebraska 68182-0500, United States},
  author_keywords = {Domain specific language; Instrumentation; Intrusion detection},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-38549106437&partnerID=40&md5=d3aaeb68e2198a9ab04d8f5829056f67}
}

@CONFERENCE{Maier2008224,
  author = {Maier, S., Volk, D.},
  title = {Facilitating language-oriented game development by the help of language
	workbenches},
  year = {2008},
  pages = {224-227},
  note = {cited By (since 1996) 0},
  abstract = {In recent years, a strong tendency towards language-oriented engineering
	became visible within game development projects. This approach is
	typically based on data-driven game engines and scripting languages
	resp. editing tools alike and already provided a great deal of overall
	productivity improvements. However, in its current form, potential
	benefits are not able to fully unfold yet.This is due to a mostly
	manual tool development process, which provokes substantial costs
	and lacks flexibility - especially during prototyping phases of development.
	Language workbenches seem to be a viable solution to this problem
	as they promise the ability of (visual) language (re-)generation
	by introducing a meta-level of development. This paper picks up that
	idea and evaluates its application in the area of game development.
	In this particular case, we discuss first findings of an ongoing
	case study, covering the development of level editors for several
	classic games, which have been built by the help of a language workbench.
	Copyright 2008 ACM.},
  affiliation = {Institute for Software Technology, Universitaet der Bundeswehr Muenchen,
	85577 Neubiberg, Germany},
  author_keywords = {(Visual) domain-specific languages; Game development; Game prototyping;
	Language workbenches; Model-driven development; Software factories},
  document_type = {Conference Paper},
  journal = {ACM Future Play 2008 International Academic Conference on the Future
	of Game Design and Technology, Future Play: Research, Play, Share},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-70349333145&partnerID=40&md5=f8ca4321e2e1e6b888d062ba35c915bf}
}

@CONFERENCE{Mainland200773,
  author = {Mainland, G.},
  title = {Why it's nice to be quoted: Quasiquoting for haskell},
  year = {2007},
  pages = {73-82},
  note = {cited By (since 1996) 11},
  abstract = {Quasiquoting allows programmers to use domain specific syntax to construct
	program fragments. By providing concrete syntax for complex data
	types, programs become easier to read, easier to write, and easier
	to reason about and maintain. Haskell is an excellent host language
	for embedded domain specific languages, and quasiquoting ideally
	complements the language features that make Haskell perform so well
	in this area. Unfortunately, until now no Haskell compiler has provided
	support for quasiquoting. We present an implementation in GHC and
	demonstrate that by leveraging existing compiler capabilities, building
	a full quasiquoter requires little more work than writing a parser.
	Furthermore, we provide a compile-time guarantee that all quasiquoted
	data is type-correct. Copyright © 2007 ACM.},
  affiliation = {Harvard School of Engineering and Applied Sciences},
  author_keywords = {Meta programming; Quasiquoting},
  document_type = {Conference Paper},
  journal = {Haskell'07: Proceedings of the ACM SIGPLAN 2007 Haskell Workshop},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-38849106746&partnerID=40&md5=d2496e685a4d3f13d434f63e583b5121}
}

@CONFERENCE{Mainland2008,
  author = {Mainland, G., Morrisett, G., Welsh, M.},
  title = {Flask: Staged functional programming for sensor networks},
  year = {2008},
  pages = {335-345},
  note = {cited By (since 1996) 8},
  abstract = {Severely resource-constrained devices present a confounding challenge
	to the functional programmer: we are used to having powerful abstraction
	facilities at our fingertips, but how can we make use of these tools
	on a device with an 8- or 16-bit CPU and at most tens of kilobytes
	of RAM? Motivated by this challenge, we have developed Flask, a domain
	specific language embedded in Haskell that brings the power of functional
	programming to sensor networks, collections of highly resource-constrained
	devices. Flask consists of a staging mechanism, that cleanly separates
	node-level code from the meta-language used to generate node-level
	code fragments; syntactic support for embedding standard sensor network
	code; a restricted subset of Haskell that runs on sensor networks
	and constrains program space and time consumption; a higher-level
	"data stream" combinator library for quickly constructing sensor
	network programs; and an extensible runtime that provides commonly-used
	services. We demonstrate Flask through several small code examples
	as well as a compiler that generates node-level code to execute a
	network-wide query specified in a SQL-like language. We show how
	using Flask ensures constraints on space and time behavior. Through
	microbenchmarks and measurements on physical hardware, we demonstrate
	that Flask produces programs that are efficient in terms of CPU and
	memory usage and that can run effectively on existing sensor network
	hardware. Copyright © 2008 ACM.},
  affiliation = {Harvard School of Engineering and Applied Sciences},
  author_keywords = {Meta programming},
  document_type = {Conference Paper},
  journal = {Proceedings of the ACM SIGPLAN International Conference on Functional
	Programming, ICFP},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-59249083339&partnerID=40&md5=49e37095fb9f5e5c8f75fdda9d18d8c9}
}

@ARTICLE{Mainland2008335,
  author = {Mainland, G., Morrisett, G., Welsh, M.},
  title = {Flask: Staged functional programming for sensor P},
  journal = {ACM SIGPLAN Notices},
  year = {2008},
  volume = {43},
  pages = {335-345},
  number = {9},
  note = {cited By (since 1996) 2},
  abstract = {Severely resource-constrained devices present a confounding challenge
	to the functional programmer: we are used to having powerful abstraction
	facilities at our fingertips, but how can we make use of these tools
	on a device with an 8- or 16-bit CPU and at most tens of kilobytes
	of RAM? Motivated by this challenge, we have developed Flask, a domain
	specific language embedded in Haskell that brings the power of functional
	programming to sensor networks, collections of highly resource-constrained
	devices. Flask consists of a staging mechanism that cleanly separates
	node-level code from the meta-language used to generate node-level
	code fragments; syntactic support for embedding standard sensor network
	code; a restricted subset of Haskell that runs on sensor networks
	and constrains program space and time consumption; a higher-level
	"data stream" combinator library for quickly constructing sensor
	network programs; and an extensible runtime that provides commonly-used
	services. We demonstrate Flask through several small code examples
	as well as a compiler that generates node-level code to execute a
	network-wide query specified in a SQL-like language. We show how
	using Flask ensures constraints on space and time behavior. Through
	microbenchmarks and measurements on physical hardware, we demonstrate
	that Flask produces programs that are efficient in terms of CPU and
	memory usage and that can run effectively on existing sensor network
	hardware. Copyright © 2008 ACM.},
  affiliation = {Harvard School of Engineering and Applied Sciences},
  author_keywords = {Meta Programming},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-67650088256&partnerID=40&md5=e8d90a9adc1eb2727cf5799e8e69a7bc}
}

@ARTICLE{Mali2011108,
  author = {Mali, Y., Van Wyk, E.},
  title = {Building extensible specifications and implementations of promela
	with AbleP},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2011},
  volume = {6823 LNCS},
  pages = {108-125},
  note = {cited By (since 1996) 0},
  abstract = {This paper describes how new language features can be seamlessly added
	to an extensible specification of Promela to provide new (domain-specific)
	notations and analyses to the engineer. This is accomplished using
	ableP, an extensible specification and implementation of Promela,
	the modeling language used by the spin model checker. Language extensions
	described here include an enhanced select-statement, a convenient
	tabular notation for boolean expressions, a notion of discrete time,
	and extended type checking. ableP and the extensions are developed
	using the Silver attribute grammar system and the Copper parser and
	scanner generator. These tools support the modular development and
	composition of language extensions so that independently developed
	extensions can be imported into ableP by an engineer with little
	knowledge of language design and implementation issues. © 2011 Springer-Verlag.},
  affiliation = {Department of Computer Science and Engineering, University of Minnesota,
	Minneapolis, MN 55455, United States},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-79960414854&partnerID=40&md5=352a6bf6d3b7ec2e2acd28f7f3061606}
}

@CONFERENCE{Mandelbaum2007,
  author = {Mandelbaum, Y.a , Fisher, K.b , Walker, D.a , Fernandez, M.b , Gleyzer,
	A.a },
  title = {PADS/ML: A functional data description language},
  year = {2007},
  pages = {77-83},
  note = {cited By (since 1996) 1},
  abstract = {Massive amounts of useful data are stored and processed in ad hoc
	formats for which common tools like parsers, printers, query engines
	and format converters are not readily available. In this paper, we
	explain the design and implementation of PADS/ML , a new language
	and system that facilitates the generation of data processing tools
	for ad hoc formats. The PADS/ML design includes features such as
	dependent, polymorphic and recursive datatypes, which allow programmers
	to describe the syntax and semantics of ad hoc data in a concise,
	easy-to-read notation. The PADS/ML implementation compiles these
	descriptions into ml structures and functors that include types for
	parsed data, functions for parsing and printing, and auxiliary support
	for user-specified, format-dependent and format-independent tool
	generation. Copyright © 2007 ACM.},
  affiliation = {Princeton University; AT and T Labs Research},
  author_keywords = {Data description languages; Dependent types; Domain-specific languages;
	Functional programming; ML; Modules; Parsing; Printing},
  document_type = {Conference Paper},
  journal = {Conference Record of the Annual ACM Symposium on Principles of Programming
	Languages},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-34548253441&partnerID=40&md5=a2f8adfe33b9a9a04f37c42aed4def0d}
}

@ARTICLE{Mandelbaum200777,
  author = {Mandelbaum, Y.a , Fisher, K.b , Walker, D.a , Fernandez, M.b , Gleyzer,
	A.a },
  title = {PADS/ML: A functional data description language},
  journal = {ACM SIGPLAN Notices},
  year = {2007},
  volume = {42},
  pages = {77-83},
  number = {1},
  note = {cited By (since 1996) 3},
  abstract = {Massive amounts of useful data are stored and processed in ad hoc
	formats for which common tools like parsers, printers, query engines
	and format converters are not readily available. In this paper, we
	explain the design and implementation of PADS/ML, a new language
	and system that facilitates the generation of data processing tools
	for ad hoc formats. The PADS/ML design includes features such as
	dependent, polymorphic and recursive datatypes, which allow programmers
	to describe the syntax and semantics of ad hoc data in a concise,
	easy-to-read notation. The PADS/ML implementation compiles these
	descriptions into ML structures and functors that include types for
	parsed data, functions for parsing and printing, and auxiliary support
	for user-specified, format-dependent and format-independent tool
	generation. Copyright © 2007 ACM.},
  affiliation = {Princeton University, United States; AT and T Labs Research, United
	States},
  author_keywords = {Data description languages; Dependent types; Domain-specific languages;
	Functional programming; ML; Modules; Parsing; Printing},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-33846528587&partnerID=40&md5=52674d07f10ce7650eb06cfcb06ccc79}
}

@CONFERENCE{Manjunatha2010496,
  author = {Manjunatha, A., Ranabahu, A., Sheth, A., Thirunarayan, K.},
  title = {Power of clouds in your pocket: An efficient approach for cloud mobile
	hybrid application development},
  year = {2010},
  pages = {496-503},
  note = {cited By (since 1996) 1},
  abstract = {The advancements in computing have resulted in a boom of cheap, ubiquitous,
	connected mobile devices as well as seemingly unlimited, utility
	style, pay as you go computing resources, commonly referred to as
	Cloud computing. However, taking full advantage of this mobile and
	cloud computing landscape, especially for the data intensive domains
	has been hampered by the many heterogeneities that exist in the mobile
	space as well as the Cloud space. Our research focuses on exploiting
	the capabilities of the mobile and cloud landscape by defining a
	new class of applications called cloud mobile hybrid (CMH) applications
	and a Domain Specific Language (DSL) based methodology to develop
	these applications. We define Cloud-mobile hybrid as a collective
	application that has a Cloud based back-end and a mobile device front-end.
	Using a single DSL script, our toolkit is capable of generating a
	variety of CMH applications. These applications are composed of multiple
	combinations of native Cloud and mobile applications. Our approach
	not only reduces the learning curve but also shields developers from
	the complexities of the target platforms. We provide a detailed description
	of our language and present the results obtained using our prototype
	generator implementation. We also present a list of extensions that
	will enhance the various aspects of this platform. © 2010 IEEE.},
  affiliation = {Ohio Center of Excellence in Knowledge-Enabled Computing (Kno.e.sis),
	Wright State University, Dayton, OH 45435, United States},
  art_number = {5708492},
  document_type = {Conference Paper},
  journal = {Proceedings - 2nd IEEE International Conference on Cloud Computing
	Technology and Science, CloudCom 2010},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-79952422062&partnerID=40&md5=23d5fc2a229f4cfdf15a2c561bff7f88}
}

@CONFERENCE{Mara201165,
  author = {Mara, L., Honorato, G., Dantas, F., Garcia, A., Lucena, C.},
  title = {Hist-inspect: A tool for history-sensitive detection of code smells},
  year = {2011},
  pages = {65},
  note = {cited By (since 1996) 0},
  abstract = {Hist-Inspect is a tool that allows the specification and evaluation
	of different configurations for detection strategies by means of
	a domain-specific language. The tool enables to easily adjust thresholds
	and combination of software metrics as well as compare the performance
	of conventional and history-sensitive detection strategies. The tool
	also provides a diverse set of views, including graphical representation
	of module evolution measures. These views enable the code reviewer
	to reason about the stability of individual modules, the growth or
	decline of a particular structural property (e.g. coupling or cohesion),
	without the burden of recovering all the values for each version
	under analysis.},
  affiliation = {Informatics Department, Pontifical Catholic University of Rio de Janeiro
	(PUC-Rio), Rio de Janeiro - RJ, Brazil},
  author_keywords = {Detection strategy; Metrics},
  document_type = {Conference Paper},
  journal = {Proceedings of the 10th International Conference on Aspect-Oriented
	Software Development Companion, AOSD.11},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-79955151863&partnerID=40&md5=8f265a2b7d2e3787ef147a6b923ca37e}
}

@ARTICLE{Maraninchi2003219,
  author = {Maraninchi, F.a b , Rémond, Y.c },
  title = {Mode-automata: A new domain-specific construct for the development
	of safe critical systems},
  journal = {Science of Computer Programming},
  year = {2003},
  volume = {46},
  pages = {219-254},
  number = {3},
  note = {cited By (since 1996) 41},
  abstract = {Over the past ten years, the family of synchronous languages (Special
	Section of the Proc. IEEE 79 (9) (1991)) has been very successful
	in offering domain-specific, formally defined languages and programming
	environments for safety-critical systems. Among them, Lustre is well-suited
	for the development of regulation systems, which are first designed
	by control engineers, and can then be programmed as block-diagrams.
	Automatic generation of C code provides the embedded software. The
	success of Lustre showed that it is a good idea to offer domain-specific
	languages and constructs to reduce the gap between the first design
	of a system (for instance a control law) and the program written
	for it. When the structure of the first design has to be encoded
	into the available constructs of a general-purpose programming language,
	the interesting information is likely to be lost somewhere on the
	way from the original design to the actual implementation. This may
	have consequences on the efficiency of the code produced, or even
	on the correctness of the design. Working with the systems Lustre
	is well-suited for, we observed that they are often specified informally
	using the notion of running modes. However, there seemed to exist
	no language in which the mode-structure of a complex system could
	be expressed directly. Following the approach of domain-specific
	languages, we proposed to extend Lustre with a new construct, called
	mode-automaton, devoted to the description of these running modes
	of regulation systems. In this paper, we define the language of mode-automata
	and its semantics, give some ideas on the compilation process, illustrate
	the approach with the example of the production cell, and comment
	on the benefits of the approach, in general. © 2002 Elsevier Science
	B.V. All rights reserved.},
  affiliation = {VERIMAG-Centre Equation, 2 Avenue de Vignate, F38610 Gieres, France;
	Institut National Polytechnique De Grenoble (INPG), VERIMAG, France;
	Université Joseph Fourier Grenoble (UJF), VERIMAG, France},
  author_keywords = {Case-study; Language design and implementation; Production cell; Real-time
	systems; Regulation systems; Running-modes; Safety-critical},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-0037332776&partnerID=40&md5=f42aa826bb400677606a31aa1ab33a55}
}

@CONFERENCE{Marcondes20091447,
  author = {Marcondes, F.S.a , Tasinaffo, P.M.a , Fernandes, D.D.a , Vega, I.S.b
	, Montini, D.Á.a , Dias, L.A.V.a },
  title = {Systematic and formal approach to got a domain specific language},
  year = {2009},
  pages = {1447-1450},
  note = {cited By (since 1996) 1},
  abstract = {This paper presents a systematic approach applied over State Machine
	(since it is a wide know model and easy to be used to formal specification)
	to improve the domain analysis procedure, besides been out of scope
	of this paper, this approach can also helps to improve the enterprise's
	business process as well. The motivation which leads to the this
	paper is how to got a Domain Specific Language (DSL) that is completely
	correspondent to a Domain Analysis sharing both the same business
	rules. This is a very important property to be achieved since a DSL
	must be used to help the codding procedure in a specific domain,
	so, it must be a direct relation over them and this relation is explored
	in this paper. It has a briefly discussion over the need for formalization
	procedures concluding that too much formalization can be a problem
	and lack of it can also be, so, formal transformations can be performed
	at mark point (as baselines or any other mark that can be defined)
	bringing important contributions to the rigor of the model improving
	it. © 2009 IEEE.},
  affiliation = {Instituto Tecnológico de Aeronáutica - ITA, Brazil; Pontifícia Universidade
	Católica de São Paulo - PUC-SP, Brazil},
  art_number = {5070830},
  author_keywords = {Domain analysis; Domain specific language; Formal methods; State machines},
  document_type = {Conference Paper},
  journal = {ITNG 2009 - 6th International Conference on Information Technology:
	New Generations},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-77951122190&partnerID=40&md5=9cc1cd30c73aad33f5b37ac275b86447}
}

@ARTICLE{Marinilli200530,
  author = {Marinilli, M., Micarelli, A.},
  title = {Generative programming driven by user models},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2005},
  volume = {3538 LNAI},
  pages = {30-39},
  note = {cited By (since 1996) 0},
  abstract = {This paper discusses the automatic generation of programs by adapting
	the construction process to the user currently interacting with the
	program. A class of such systems is investigated where such generation
	process is continuously repeated making the program design and implementation
	evolve according to user behaviour. By leveraging on existing technologies
	(software generation facilities, modelling languages, specific and
	general standard meta-models) an experimental proof of concept system
	that is able to generate itself while interacting with the user is
	introduced and tested. The findings are discussed and a general organization
	for this class of adaptive systems is briefly proposed and compared
	with existing literature. © Springer-Verlag Berlin Heidelberg 2005.},
  affiliation = {Dipartimento di Informatica e Automazione, Laboratorio di Intelligenza
	Artificiale, Università Roma Tre, via della Vasca Navale 79, 00184
	Rome, Italy},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-26944486845&partnerID=40&md5=2a9ce17620684b92efff61ac12b7acbe}
}

@CONFERENCE{Markall20101815,
  author = {Markall, G.R.a , Ham, D.A.b c , Kelly, P.H.J.a },
  title = {Towards generating optimised finite element solvers for GPUs from
	high-level specifications},
  year = {2010},
  volume = {1},
  number = {1},
  pages = {1815-1823},
  note = {cited By (since 1996) 0},
  abstract = {We argue that producing maintainable high-performance implementations
	of finite element methods for multiple targets requires that they
	are written using a high-level domain-specific language. We make
	the case for using one such language, the Unified Form Language (UFL),
	by discussing how it allows the generation of high-performance code
	from maintainable sources. We support this case by showing that optimal
	implementations of a finite element solver written for a Graphics
	Processing Unit and a multicore CPU require the use of different
	algorithms and data formats that are embodied by the UFL representation.
	Finally we describe a prototype compiler that generates low-level
	code from high-level specifications, and outline how the high-level
	UFL representation can be lowered to facilitate optimisation using
	existing techniques prior to code generation.},
  affiliation = {Department of Computing, Imperial College London, United Kingdom;
	Department of Earth Science and Engineering, Imperial College London,
	United Kingdom; Grantham Institute for Climate Change, Imperial College
	London, United Kingdom},
  author_keywords = {Finite element method; GPU},
  document_type = {Conference Paper},
  journal = {Procedia Computer Science},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-78650283968&partnerID=40&md5=125376236c5bf9eb72ff31361d2d6da9}
}

@ARTICLE{Marpons200718,
  author = {Marpons, G.a , Mariño, J.a , Carro, M.a , Herranz, Á.a , Moreno-Navarro,
	J.J.a b , Fredlund, L.-Å.a },
  title = {Automatic coding rule conformance checking using logic programming},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2007},
  volume = {4902 LNCS},
  pages = {18-34},
  note = {cited By (since 1996) 0},
  abstract = {An extended practice in the realm of Software Engineering and programming
	in industry is the application of coding rules. Coding rules are
	customarily used to constrain the use (or abuse) of certain programming
	language constructions. However, these rules are usually written
	using natural language, which is intrinsically ambiguous and which
	may complicate their use and hinder their automatic enforcement.
	This paper presents some early work aiming at defining a framework
	to formalise and check for coding rule conformance using logic programming.
	We show how a certain class of rules - structural rules - can be
	reformulated as logic programs, which provides both a framework for
	formal specification and also for automatic conformance checking
	using a Prolog engine. Some examples of rules belonging to actual,
	third-party coding rule sets are discussed, along with the corresponding
	Prolog code. Experimental data regarding the practicality and impact
	of their application to real-life software projects is presented
	and discussed. © Springer-Verlag Berlin Heidelberg 2008.},
  affiliation = {Universidad Politécnica de Madrid; IMDEA Software},
  author_keywords = {Coding rule checking; Declarative domain-specific languages and applications;
	Logic programming; Programming environments},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-38549085407&partnerID=40&md5=f5ea907f25b411bb7826508c48f1328e}
}

@ARTICLE{Marques200847,
  author = {Marques, E., Veiga, L., Ferreira, P.},
  title = {Transparent mobile middleware integration for java and .NET Development
	environments},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2008},
  volume = {5168 LNCS},
  pages = {47-57},
  note = {cited By (since 1996) 0},
  abstract = {Developing a distributed application for mobile resource constrained
	devices is a difficult and error-prone task that requires awareness
	of several system-level details (e.g., fault-tolerance, ...). Several
	mobile middleware solutions addressing these issues have been proposed.
	However, they rely on either significant changes in application structure,
	extensions to the programming language syntax and semantics, domain
	specific languages, cumbersome development tools, or a combination
	of the above. The main disadvantages of these approaches are lack
	of transparency and reduced portability. In this paper we describe
	our work on enabling transparent integration between applications
	and middleware without changing application structure, extending
	the programming language or otherwise reducing portability. We used
	the OBIWAN middleware but our solutions are general. To achieve this
	goal we employ program analysis and transformation techniques for
	extending application code with hooks for calling middleware services.
	Application code extension is performed automatically at compile-time
	by a code extension tool integrated with the development environment
	tool set. We describe the implementation of our .NET and Java prototypes
	and discuss evaluation results. © 2008 Springer-Verlag Berlin Heidelberg.},
  affiliation = {Distributed Systems Group, INESC-ID/Technical Univ. of Lisbon, Rua
	Alves Redol N. 9, Lisbon 1000-029, Portugal},
  author_keywords = {Aspect-oriented programming; Distributed mobile applications; Fault-tolerance;
	Incremental object replication; Integrated development environment;
	Program transformation; Transparent middleware integration},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-51849111541&partnerID=40&md5=40f745e664ad7fbccdec8bb33f2f8bfe}
}

@CONFERENCE{Marquet2007,
  author = {Marquet, K., Grimaud, G.},
  title = {A DSL approach tor object memory management ot small devices},
  year = {2007},
  note = {cited By (since 1996) 0},
  abstract = {Small devices have a specific hardware configuration. In particular,
	they usually include several types of memories (typically ROM, internal
	and external RAM, ROM, Flash memory) different in quantities and
	properties. We propose an object memory management where the placement
	of an object in a given generation is based on different properties.
	This approach is supported by a domain specific language allowing
	to write powerful and flexible placement policies. These placement
	policies completely describe the placement, in the different memories,
	of the objects handled by the virtual machine.Copyright © 2007 ACM.},
  affiliation = {LIFL, CNRS UMR 8022 - IRCICA, CNRS FR3024 INRIA Future, POPS Research
	Group, Univ. Lille 1, France},
  art_number = {4},
  document_type = {Conference Paper},
  journal = {Proceedings of the 4th Workshop on Programming Languages and Operating
	Systems, PLOS 2007},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-57349142958&partnerID=40&md5=8bb3277eb09a14598a61304ae8951a0e}
}

@CONFERENCE{Marquet2007155,
  author = {Marquet, K., Grimaud, G.},
  title = {A DSL approach for object memory management of small devices},
  year = {2007},
  volume = {272},
  pages = {155-164},
  note = {cited By (since 1996) 0},
  abstract = {Small devices have a specific hardware configuration. In particular,
	they usually include several types of memories (typically ROM, internal
	and external RAM, Flash memory) different in quantities and properties.
	We propose an object memory management where the placement of an
	object in a given generation is based on different properties. This
	approach is supported by a domain specific language allowing to write
	powerful and flexible placement policies. These placement policies
	completely describe the placement, in the different memories, of
	the objects handled by the virtual machine. Copyright 2007 ACM.},
  affiliation = {LIFL, CNRS UMR 8022 - IRCICA, Univ. de Lille 1},
  document_type = {Conference Paper},
  journal = {ACM International Conference Proceeding Series},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-41149088832&partnerID=40&md5=fb17c38f5f040fc677384e46656bf84f}
}

@ARTICLE{Martinho2010396,
  author = {Martinho, R.a d , Varajão, J.b , Domingos, D.c e },
  title = {Using the semantic web to define a language for modelling controlled
	flexibility in software processes},
  journal = {IET Software},
  year = {2010},
  volume = {4},
  pages = {396-406},
  number = {6},
  note = {cited By (since 1996) 1},
  abstract = {Software processes and corresponding models are dynamic entities that
	must evolve to cope with changes occurred in the enacting process,
	the software development organisation, the market and the methodologies
	used to produce software. However, in the everyday practice, software
	team members do not want total flexibility. They rather prefer to
	learn about and follow previously defined controlled flexibility,
	that is, advices on which, where, how and by whom process models
	and related instances can change/adapt. Process engineers can express
	these advices within a process model with a domain-specific language
	(DSL), which complements the core process modelling language with
	additional controlled flexibility information. Then, software team
	members can browse and learn on this information in process models
	and instances, and be guided when performing changes. In this study,
	the authors propose the use of the semantic web and associated ontology-based
	technologies to develop and evolve their controlled flexibility DSL
	for software processes. They use an ontology-based format to define
	the controlled flexibility-related concepts, descriptions and axioms
	that specify the formal semantics of their DSL. In addition, the
	authors provide concrete mappings between these ontology concepts
	and a unified modelling language class-based DSL metamodel and describe
	how it supports changes made in the ontology. © 2010 The Institution
	of Engineering and Technology.},
  affiliation = {School of Technology and Management, Polytechnic Institute of Leiria
	Campus, 2, Morro Do Lena, Alto do Vieiro, 2411-901 Leiria, Portugal;
	Department of Engineering, University of Trás-os-Montes e Alto Douro,
	5001-801 Vila Real, Portugal; Department of Informatics, Faculty
	of Sciences, University of Lisboa, Piso 3, Campo Grande, 1749-016
	Lisboa, Portugal; Department of Informatics, LaSIGE - Large-Scale
	Informatics Systems Laboratory, University of Lisboa, Piso 3, Campo
	Grande, 1749-016 Lisboa, Portugal; CAlg - Centro ALGORITMI Universidade
	do Minho, Campus Azurém, 4800 Guimarães, Portugal},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-78751555721&partnerID=40&md5=5977f2d1a384da44ab153bbfef5a6910}
}

@ARTICLE{Martínez-Ortiz2009725,
  author = {Martínez-Ortiz, I., Sierra, J.-L., Fernández-Manjón, B.},
  title = {Language-Driven, technology-Enhanced instructional systems design},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2009},
  volume = {5794 LNCS},
  pages = {725-731},
  note = {cited By (since 1996) 0},
  abstract = {In this paper we propose to extend the ADDIE (Analysis - Design -
	Development - Implementation - Evaluation) process for Instructional
	Systems Design (ISD) with a new linguistic layer. This layer allows
	developers to provide instructors with domain-specific languages
	to support and guide them through ISD. Instructors use the toolsets
	associated with these languages to produce technology-enhanced learning
	systems more effectively. We also describe how to put these ideas
	into practice by adopting modern model-driven software development
	processes together with the language engineering principles. This
	language engineering approach has been applied to <e-LD>, a highly
	flexible and extensible authoring tool for IMS Learning Design Units
	of Learning. © 2009 Springer Berlin Heidelberg.},
  affiliation = {Fac. Informática., Universidad Complutense de Madrid, C/ Prof. José
	García Santesmases s/n, 28040 Madrid, Spain},
  author_keywords = {<e-LD>; ADDIE; IMS Learning Design; Software Language Engineering;
	Technology-Enhanced Instructional Systems Design},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-70450211329&partnerID=40&md5=d6eb752b2e493015ff178499975677eb}
}

@ARTICLE{Martínez-Ortiz20091092,
  author = {Martínez-Ortiz, I., Sierra, J.-L., Fernández-Manjón, B., Fernández-Valmayor,
	A.},
  title = {Language engineering techniques for the development of e-learning
	applications},
  journal = {Journal of Network and Computer Applications},
  year = {2009},
  volume = {32},
  pages = {1092-1105},
  number = {5},
  note = {cited By (since 1996) 1},
  abstract = {In this paper we propose the use of language engineering techniques
	to improve and systematize the development of e-learning applications.
	E-learning specifications usually rely on domain-specific languages
	that describe different aspects of such final e-learning applications.
	This fact makes it natural to adopt well-established language engineering
	principles during the construction of these applications. These principles
	promote the specification of the structure and the runtime behavior
	of the domain-specific languages as the central part of the development
	process. This specification can be used to drive different activities:
	rapid prototyping, provision of authoring notations and tools, automatic
	model checking of properties, importation/exportation from/to standards,
	and deployment of running applications. This language engineering
	concept also promotes active collaboration between instructors (the
	users of the languages) and developers (the designers and implementers)
	throughout the development process. In this paper we describe this
	language-driven approach to the construction of e-learning applications
	and we illustrate all its aspects using a learning flow sequencing
	language as a case study. © 2009 Elsevier Ltd. All rights reserved.},
  affiliation = {Dpto. Ingeniería del Software, Inteligencia Artificial. Fac. Informática,
	Universidad Complutense de Madrid, C/ Profesor Jose Garcia Santesmases,
	s/n, 28040 Madrid, Spain},
  author_keywords = {Authoring; Domain-specific languages; E-learning applications; Language
	engineering; Model checking; Rapid prototyping},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-67649550043&partnerID=40&md5=d00f9a388152ccff071e6b7a49477e69}
}

@ARTICLE{Mathe200954,
  author = {Mathe, J.L.a , Martin, J.B.b , Miller, P.c , Ledeczi, A.a , Weavind,
	L.M.b , Nadas, A.a , Miller, A.b , Maron, D.J.c , Sztipanovits, J.a
	},
  title = {A model-integrated, guideline-driven, clinical decision-support system},
  journal = {IEEE Software},
  year = {2009},
  volume = {26},
  pages = {54-61},
  number = {4},
  note = {cited By (since 1996) 2},
  abstract = {Using evidence-based guidelines to standardize the care of patients
	with complex medical problems is a difficult challenge. In acute
	care settings, such as intensive care units, the inherent problems
	of stabilizing and improving vital patient parameters is complicated
	by the division of responsibilities among different healthcare team
	members. Computerized support for implementing such guidelines has
	tremendous potential. The use of model-integrated techniques for
	specifying and implementing guidelines as coordinated asynchronous
	processes is a promising new methodology for providing advanced clinical
	decision support. Combined with visual dashboards, which show the
	status of the implemented guidelines, a new approach to computer-supported
	care is possible. The Vanderbilt Medical Center is applying these
	techniques to the management of sepsis. © 2009 IEEE.},
  affiliation = {Institute for Software Integrated Systems, Vanderbilt University,
	Nashville, TN, United States; Vanderbilt Medical Center, Nashville,
	TN, United States; Vanderbilt HealthTech Laboratory, Nashville, TN,
	United States},
  author_keywords = {Data mining; Design languages; Domain-specific modeling languages;
	Guidelines; Laboratories; Medical diagnostic imaging; Medical information
	systems; Medical services; Microwave integrated circuits; modeling.;
	Protocols},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-67650457674&partnerID=40&md5=ab70441d33f35127f4e29204ded327ec}
}

@ARTICLE{Matlage2011150,
  author = {Matlage, K., Gill, A.},
  title = {Every animation should have a beginning, a middle, and an end: A
	case study of using a functor-based animation language},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2011},
  volume = {6546 LNCS},
  pages = {150-165},
  note = {cited By (since 1996) 0},
  abstract = {Animations are sequences of still images chained together to tell
	a story. Every story should have a beginning, a middle, and an end.
	We argue that this advice leads to a simple and useful idiom for
	creating an animation Domain Specific Language (DSL). We introduce
	our animation DSL, and show how it captures the concept of beginning,
	middle, and end inside a Haskell applicative functor we call Active.
	We have an implementation of our DSL inside the image generation
	accelerator, ChalkBoard, and we use our DSL on an extended example,
	animating a visual demonstration of the Pythagorean Theorem. © 2011
	Springer-Verlag.},
  affiliation = {Information Technology and Telecommunication Center, Department of
	Electrical Engineering and Computer Science, University of Kansas,
	2335 Irving Hill Road, Lawrence, KS 66045, United States},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-80052792232&partnerID=40&md5=5fa2a010acc5fc51f6ef175a4a237c64}
}

@ARTICLE{Matlage201055,
  author = {Matlage, K., Gill, A.},
  title = {ChalkBoard: Mapping functions to polygons},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2010},
  volume = {6041 LNCS},
  pages = {55-71},
  note = {cited By (since 1996) 2},
  abstract = {ChalkBoard is a domain specific language for describing images. The
	ChalkBoard language is uncompromisingly functional and encourages
	the use of modern functional idioms. ChalkBoard uses off-the-shelf
	graphics cards to speed up rendering of functional descriptions.
	In this paper, we describe the design of the core ChalkBoard language,
	and the architecture of our static image generation accelerator.
	© 2010 Springer-Verlag.},
  affiliation = {Information Technology and Telecommunication Center, Department of
	Electrical Engineering and Computer Science, University of Kansas,
	2335 Irving Hill Road, Lawrence, KS 66045, United States},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-78649933394&partnerID=40&md5=f7d5e2a0982d941bb6ab32f3b67f2296}
}

@CONFERENCE{Matsui201169,
  author = {Matsui, A.A.M., Aida, H.},
  title = {Advanced client-service compatibility assessment via analysis of
	references to service-side FSMs},
  year = {2011},
  pages = {69-77},
  note = {cited By (since 1996) 0},
  abstract = {In a service oriented environment, service contracts play an important
	role to provide interoperation between clients and services. As contracts
	are the de facto insulation layer between clients and services, we
	argue that contracts should not only present specifications of method
	formats, but also pre and post-conditions that could provide more
	sophisticated client-service interactions. We have proposed that
	service contracts should contain specifications of service-side finite
	state machines (FSM). The immediate benefits of pre and post-conditions
	in distributed services are less defensive source codes in both sides,
	and avoidance to execute remote service with invalid parameters,
	which translates into rationalization of resources. But we argue
	that FSMs can also be used to provide client-service synchronization
	and advanced compatibility assessment, if the client source code
	is specially prepared to support these features. In other words,
	if the client source code contains constructs that are specific to
	deal with distributed services that follow this format. In this paper,
	we provide a framework for such extensions and present details about
	our implementation. © 2011 IEEE.},
  affiliation = {Department of Electrical Engineering and Information Systems, University
	of Tokyo, Tokyo, Japan},
  art_number = {6014007},
  author_keywords = {compatibility; domain-specific language; formal verification; service-side
	FSM; SOA},
  document_type = {Conference Paper},
  journal = {2011 IEEE 3rd International Conference on Communication Software
	and Networks, ICCSN 2011},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-80053157736&partnerID=40&md5=362f9118d65bfa8a23bbd5b10c6ec7ba}
}

@ARTICLE{Matthews200847,
  author = {Matthews, J., Findler, R.B.},
  title = {An operational semantics for Scheme},
  journal = {Journal of Functional Programming},
  year = {2008},
  volume = {18},
  pages = {47-86},
  number = {1},
  note = {cited By (since 1996) 2},
  abstract = {This paper presents an operational semantics for the core of Scheme.
	Our specification improves over the denotational semantics from the
	Revised5 Report on Scheme specification in four ways. First, it covers
	a larger part of the language, specifically eval, quote, dynamic-wind,
	and the top level. Second, it models multiple values in a way that
	does not require changes to unrelated parts of the language. Third,
	it provides a faithful model of Scheme's undefined order of evaluation.
	Finally, we have implemented our specification in PLT Redex, a domain-specific
	language for writing operational semantics. The implementation allows
	others to experiment with our specification and allows us to build
	a specification test suite, which improves our confidence that our
	system is a faithful model of Scheme. In addition to a specification
	of Scheme, this paper contributes three novel modeling techniques
	for Felleisen Hieb-style rewriting semantics. All three techniques
	are applicable to a wider range of problems than modeling Scheme,
	and they combine seamlessly in our model, suggesting that they would
	scale to complete models of other languages.},
  affiliation = {University of Chicago},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-36749083420&partnerID=40&md5=c8559c0921f675b4e8bb8b4dc69484cb}
}

@ARTICLE{Matthews2004301,
  author = {Matthews, J.a , Findler, R.B.a , Flatt, M.b , Felleisen, M.c },
  title = {A visual environment for developing context-sensitive term rewriting
	systems},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2004},
  volume = {3091},
  pages = {301-311},
  note = {cited By (since 1996) 1},
  abstract = {Over the past decade, researchers have found context-sensitive term-rewriting
	semantics to be powerful and expressive tools for modeling programming
	languages, particularly in establishing type soundness proofs. Unfortunately,
	developing such semantics is an error-prone activity. To address
	that problem, we have designed PLT Redex, an embedded domain-specific
	language that helps users interactively create and debug context-sensitive
	term-rewriting systems. We introduce the tool with a series of examples
	and discuss our experience using it in courses and developing an
	operational semantics for R5RS Scheme. © Springer-Verlag 2004.},
  affiliation = {University of Chicago; University of Utah; Northeastern University},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-35048881084&partnerID=40&md5=6417ceaea1982d8d3ee46b1b8051067f}
}

@CONFERENCE{Matthews199890,
  author = {Matthews, John, Cook, Byron, Launchbury, John},
  title = {Microprocessor specification in hawk},
  year = {1998},
  pages = {90-101},
  note = {cited By (since 1996) 15},
  abstract = {Modern microprocessors require an immense investment of time and effort
	to create and verify, from the high-level architectural design downwards.
	We are exploring ways to increase the productivity of design engineers
	by creating a domain-specific language for specifying and simulating
	processor architectures. We believe that the structuring principles
	used in modern functional programming languages, such as static typing,
	parametric polymorphism, first-class functions, and lazy evaluation
	provide a good formalism for such a domain-specific language, and
	have made initial progress by creating a library on top of the functional
	language Haskell. We have specified the integer subset of an out-of-order,
	superscalar DLX microprocessor, with register-renaming, a reorder
	buffer, a global reservation station, multiple execution units, and
	speculative branch execution. Two key abstractions of this library
	are the signal abstract data type (ADT), which models the simulation
	history of a wire, and the transaction ADT, which models the state
	of an entire instruction as it travels through the microprocessor.},
  document_type = {Conference Paper},
  journal = {Proceedings of the IEEE International Conference on Computer Languages},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-0031621809&partnerID=40&md5=c40936ea0ff8ac7084886f76745df70c}
}

@ARTICLE{Matthey200350,
  author = {Matthey, T.a , Ko, A.b , Izaguirre, J.A.b },
  title = {PROTOMOL: A molecular dynamics research framework for algorithmic
	development},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2003},
  volume = {2659},
  pages = {50-59},
  note = {cited By (since 1996) 0},
  abstract = {This paper describes the design and evaluation of PROTOMOL, a high
	performance object-oriented software framework for molecular dynamics
	(MD). The main objective of the framework is to provide an efficient
	implementation that is extensible and allows the prototyping of novel
	algorithms. This is achieved through a combination of generic and
	object-oriented programming techniques and a domain specific language.
	The program reuses design patterns without sacrificing performance.
	Parallelization using MPI is allowed in an incremental fashion. To
	show the flexibility of the design, several fast electrostatics (N-body)
	methods have been implemented and tested in PROTOMOL. In particular,
	we show that an script O sign(N) multi-grid method for N-body problems
	is faster than particle-mesh Ewald (PME) for N &gt; 8,000. The method
	works in periodic and non-periodic boundary conditions. Good parallel
	efficiency of the multi-grid method is demonstrated on an IBM p690
	Regatta Turbo with up to 20 processors for systems with N = 102,
	104 and 106. Binaries and source code are available free of charge
	at http://www.nd.edu/∼lcls/protomol. © Springer-Verlag Berlin Heidelberg
	2003.},
  affiliation = {Department of Informatics, University of Bergen, 5020 Bergen, Norway;
	Department of Computer Science and Engineering, University of Notre
	Dame, Notre Dame, IN 46556-0309, United States},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-35248855935&partnerID=40&md5=d8a5db7d3b8b67c4264c329b7a8fe146}
}

@CONFERENCE{Maurmaier2009244,
  author = {Maurmaier, M., Göhner, P.},
  title = {Model-driven development in industrial automation: Automating the
	development of industrial automation systems using model transformations},
  year = {2009},
  volume = {2 RA},
  pages = {244-249},
  note = {cited By (since 1996) 0},
  abstract = {The complexity of modern automation systems is growing steadily. In
	software engineering, model-driven development proved that it contributes
	significantly to cope with this complexity in development, while
	increasing efficiency and the quality of the development results.
	However, hardware-software dependencies, different types of requirements
	that must be considered in development and the large number of modeling
	languages are specific challenges for a model-driven approach in
	automation technology. In this paper a concept of model-driven system
	development is presented that takes into account these challenges,
	and thus provides the possibility to leverage model-driven development
	in industrial automation technology.},
  affiliation = {Institute of Industrial Automation and Software Engineering, Universität
	Stuttgart, Pfaffenwaldring 47, 70550 Stuttgart, Germany},
  author_keywords = {Domain-specific modeling language; Industrial automation systems;
	MDE; Model transformation; Model-driven development},
  document_type = {Conference Paper},
  journal = {ICINCO 2009 - 6th International Conference on Informatics in Control,
	Automation and Robotics, Proceedings},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-74549142440&partnerID=40&md5=f6f0f23bcf1784ad73f92ba12481ccf8}
}

@CONFERENCE{Maximilien2007438,
  author = {Maximilien, E.M.},
  title = {A partial solution to the Semantic Web Services Challenge problem
	using Swashup : The ruby on rails services mashup approach},
  year = {2007},
  volume = {SAIC},
  pages = {438-446},
  note = {cited By (since 1996) 0},
  abstract = {The Swashup approach to the Semantic Web Services Challenge is primarily
	a software engineering approach. In particular, our approach heavily
	leverages the Ruby language, it's Rails framework, and the ability
	to define languages within the language or domain-specific languages
	(DSL5). We start by modeling the RosettaNet Pip3A4 messages in such
	a way that the messages' XSD types directly map to Ruby classes annotated
	using a DSL. Secondly, we use Ruby to define process mediations that
	make use of the data elements as plain Ruby objects. Finally, we
	take advantage of the Rails framework to access SOAP services and
	to define network endpoints. We demonstrate the effectiveness of
	our approach by showing how our solution to the level one of first
	mediation problem is achieved with a small amount of code. We also
	provide a brief comparison of our approach's main aspects with the
	other challenge's entries: WSMO/WSMX, WebML, and jABC.},
  affiliation = {IBM Almaden Research Center, 650 Harry Road, San Jose, CA, United
	States},
  author_keywords = {B2B integration; Semantic web services; Service composition; Service
	mashups; Software engineering; Web 2.0; Web services},
  document_type = {Conference Paper},
  journal = {ICEIS 2007 - 9th International Conference on Enterprise Information
	Systems, Proceedings},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-67650233985&partnerID=40&md5=1a7fbd6846d4044fc69c53b9263d6585}
}

@ARTICLE{Maximilien200832,
  author = {Maximilien, E.M.a , Ranabahu, A.b , Gomadam, K.b },
  title = {An online platform for web APIs and service mashups},
  journal = {IEEE Internet Computing},
  year = {2008},
  volume = {12},
  pages = {32-43},
  number = {5},
  note = {cited By (since 1996) 31},
  abstract = {On the newly programmable Web, mashups are flourishing. Designers
	create mashups by combining components of existing Web sites and
	applications. Although rapid mashup proliferation offers many opportunities,
	a lack of standarization and compatibility offers considerable challenges.
	IBM Sharable Code is an online service platform for developing and
	sharing situational Web 2.0 applications and mashups. The platform
	is based on an innovative domain-specific language that streamlines
	and standardizes the development and deployment of applications consuming
	and exposing Web APIs. Parts of the DSL and the resulting applications
	and mashups can be shared and reused by members of the IBM Sharable
	Code community. In this article, the authors offer an overview of
	the platform's architecture and the DSL language at its core. © 2008
	IEEE.},
  affiliation = {IBM Almaden Research Center, San Jose, CA, United States; Wright State
	University, Kno.e.sis Center, Dayton, OH, United States},
  author_keywords = {Availability; Communities; Domain-specific languages; DSL; Engines;
	Feeds; Mashups; Rails; Ruby on rails; Service mashups; User interfaces;
	Web 2.0},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-52249119913&partnerID=40&md5=ddeddc404152bf48763940e6dc29dd1b}
}

@ARTICLE{Maximilien200713,
  author = {Maximilien, E.M.a , Wilkinson, H.b , Desai, N.c , Tai, S.a },
  title = {A domain-specific language for Web APIs and services mashups},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2007},
  volume = {4749 LNCS},
  pages = {13-26},
  note = {cited By (since 1996) 9},
  abstract = {Distributed programming has shifted from private networks to the public
	Internet and from using private and controlled services to increasingly
	using publicly available heterogeneous Web services (e.g., REST,
	SOAP, RSS, and Atom). This move enables the creation of innovative
	end-user-oriented composed services with user interfaces. These services
	mashups are typically point solutions to specific (specialized) problems;
	however, what is missing is a programming model that facilitates
	and accelerates creation and deployment of mashups of diverse services.
	In this paper we describe a domain-specific language that unifies
	the most common service models and facilitates service composition
	and integration into end-user-oriented Web applications. We demonstrate
	our approach with an implementation that leverages the Ruby on Rails
	framework. © Springer-Verlag Berlin Heidelberg 2007.},
  affiliation = {IBM Research; Universidad de Buenos Aires; N.C. State University},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-38349004890&partnerID=40&md5=2be2c451e699a0c779bd70ee8abb527c}
}

@CONFERENCE{Mayer2008203,
  author = {Mayer, P.a , Schroeder, A.a , Koch, N.a b },
  title = {MDD4SOA: Model-driven service orchestration},
  year = {2008},
  pages = {203-212},
  note = {cited By (since 1996) 18},
  abstract = {Service-Oriented Architectures (SOAs) have become an important cornerstone
	of the development of enterprise-scale software applications. Although
	a range of domain-specific languages and standards are available
	for dealing with such architectures, model-driven approaches starting
	from models written in an established modelling language like UML
	and including the ability for model transformation (in particular,
	for code generation) are still in their infancy. In this paper, we
	show (1) how our UML-based domain-specific language for working with
	SOA artefacts, UML4SOA, can be used for modelling service orchestrations,
	and (2) how to exploit so-designed models in the MDD4SOA approach
	to generate code in multiple languages, among them BPEL and WSDL,
	Java, and the formal language Jolie. We use a case study for illustrating
	this approach. Our main contributions are an easy-to-use, conservative
	extension to the UML2 for modelling service orchestrations on a high
	level of abstraction, and a fully automated, model-driven approach
	for transforming these orchestrations down to code. © 2008 IEEE.},
  affiliation = {Institute for Informatics, Ludwig-Maximilians-Universität München,
	Oettingenstr. 67, 80538 München, Germany; Cirquent GmbH, Arabellastr.
	17, 81925 München, Germany},
  art_number = {4634771},
  document_type = {Conference Paper},
  journal = {Proceedings - 12th IEEE International Enterprise Distributed Object
	Computing Conference, EDOC 2008},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-56649123486&partnerID=40&md5=d1b6ddfb15564792020b65754731378f}
}

@CONFERENCE{McFarlin2007,
  author = {McFarlin, D., Chauhan, A.},
  title = {Library function selection in compiling octave},
  year = {2007},
  note = {cited By (since 1996) 0},
  abstract = {One way to address the continuing performance problem of high-level
	domain-specific languages, such as Octave or MATLAB, is to compile
	them to a relatively lower level language for which good compilers
	are available. As a first step in this direction, specializing the
	high-level operations in the source, based on operand types, leads
	to significant gains. However, simple translation of the high-level
	operations to the underlying libraries can often miss important opportunities
	to improve performance. This paper presents a global algorithm to
	select functions from a target library, utilizing the semantics of
	the operations as well as the platform-specific performance characteristics
	of the library. Making use of the library properties, the simple
	and easy-to-implement selection algorithm is able to achieve as much
	as three times performance improvement for certain linear algebra
	kernels, over a straight mapping of operations, which are compiled
	to the vendor-tuned BLAS. © 2007 IEEE.},
  affiliation = {Department of Computer Science, Indiana University, Bloomington, IN
	47405, United States},
  art_number = {4228373},
  document_type = {Conference Paper},
  journal = {Proceedings - 21st International Parallel and Distributed Processing
	Symposium, IPDPS 2007; Abstracts and CD-ROM},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-34548791377&partnerID=40&md5=e86ff8d1bc8b4552903566e556144dfe}
}

@CONFERENCE{McFarlin2009,
  author = {McFarlin, D.S., Franchetti, F., Püuschel, M., Moura, J.M.F.},
  title = {High performance synthetic aperture radar image formation on commodity
	multicore architectures},
  year = {2009},
  volume = {7337},
  note = {cited By (since 1996) 2},
  abstract = {Synthetic Aperture Radar (SAR) image processing platforms have to
	process increasingly large datasets under and hard real-time deadlines.
	Upgrading these platforms is expensive. An attractive solution to
	this problem is to couple high performance, general-purpose Commercial-Off-The-Shelf
	(COTS) architectures such as IBM's Cell BE and Intel's Core with
	software implementations of SAR algorithms. While this approach provides
	great flexibility, achieving the requisite performance is difficult
	and time-consuming. The reason is the highly parallel nature and
	general complexity of modern COTS microarchitectures. To achieve
	the best performance, developers have to interweave of various complex
	optimizations including multithreading, the use of SIMD vector extensions,
	and careful tuning to the memory hierarchy. In this paper, we demonstrate
	the computer generation of high performance code for SAR implementations
	on Intel's multicore platforms based on the Spiral framework and
	system. The key is to express SAR and its building blocks in Spiral's
	formal domain-specific language to enable automatic vectorization,
	parallelization, and memory hierarchy tuning through rewriting at
	a high abstraction level and automatic exploration of choices. We
	show that Spiral produces code for the latest Intel quadcore platforms
	that surpasses competing hand-tuned implementations on the Cell Blade,
	an architecture with twice as many cores and three times the memory
	bandwidth. Specifically, we show an average performance of 39 Gigaflops/sec
	for 16-Megapixel and 100-Megapixel SAR images with runtimes of 0.56
	and 3.76 seconds respectively. © 2009 SPIE.},
  affiliation = {Electrical and Computer Engineering Carnegie Mellon University},
  art_number = {733708},
  author_keywords = {Multithreading; Parallel processing; Program generation; SIMD vectorization;
	Synthetic aperture radar},
  document_type = {Conference Paper},
  journal = {Proceedings of SPIE - The International Society for Optical Engineering},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-69749094679&partnerID=40&md5=bfdb24b6285b2d765dc6764a4b7e34e1}
}

@ARTICLE{McGinnis2011190,
  author = {McGinnis, L., Huang, E., Kwon, K.S., Ustun, V.},
  title = {Ontologies and simulation: A practical approach},
  journal = {Journal of Simulation},
  year = {2011},
  volume = {5},
  pages = {190-201},
  number = {3},
  note = {cited By (since 1996) 0},
  abstract = {The challenges in cost-effectively deploying simulation technology
	are well known. Two major challenges are creating an appropriate
	conceptual model and translating that conceptual model correctly
	into a computational model. Ontologies have been widely discussed
	as one mechanism for capturing modelling knowledge in a reusable
	form, making it effectively available in the conceptual and computational
	modelling phases. In this paper, we show how ontologies can be effectively
	deployed in simulation using recent innovations from systems engineering
	and software engineering. We use OMG SysML to create an ontology
	implementation referred to as a domain-specific language, or DSL,
	for a class of simulation applications; the DSL is used to create
	a specific (conceptual) user model for a problem in the domain. We
	then use model transformation to automate the translation to a computational
	simulation model. Two proof-of-concept implementations are described,
	one using a legacy simulation language, and another using an object-oriented
	simulation language. © 2011 Operational Research Society Ltd. All
	rights reserved.},
  affiliation = {Keck Virtual Factory Lab, Georgia Institute of Technology, Atlanta,
	GA, United States},
  author_keywords = {domain-specific language; formal language; model transformation; ontology},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-80052236761&partnerID=40&md5=c0db3bed727735720ce15c145e0825db}
}

@ARTICLE{McGregor200489,
  author = {McGregor, J.D.},
  title = {Product production},
  journal = {Journal of Object Technology},
  year = {2004},
  volume = {3},
  pages = {89-98},
  number = {10},
  note = {cited By (since 1996) 2},
  abstract = {The primary goal of a software development organization is to develop
	successful products. Choosing the appropriate production techniques
	can have strategic implications for the organization. In this month's
	issue of Strategic Software Engineering I will explore how to organize
	to establish an explicit product production capability. This capability
	can be the basis for entering new markets or gaining advantage in
	your current market.},
  affiliation = {Clemson University, Luminary Software LLC, United States},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-11244258374&partnerID=40&md5=33d01cf744adab8cbf54afba33e29e45}
}

@ARTICLE{McIntosh2007224,
  author = {McIntosh, A.C.S., Cushing, J.B., Nadkarni, N.M., Zeman, L.},
  title = {Database design for ecologists: Composing core entities with observations},
  journal = {Ecological Informatics},
  year = {2007},
  volume = {2},
  pages = {224-236},
  number = {3 SPEC. ISS.},
  note = {cited By (since 1996) 7},
  abstract = {The ecoinformatics community recognizes that ecological synthesis
	across studies, space, and time will require new informatics tools
	and infrastructure. Recent advances have been encouraging, but many
	problems still face ecologists who manage their own datasets, prepare
	data for archiving, and search data stores for synthetic research.
	In this paper, we describe how work by the Canopy Database Project
	(CDP) might enable use of database technology by field ecologists:
	increasing the quality of database design, improving data validation,
	and providing structural and semantic metadata - all of which might
	improve the quality of data archives and thereby help drive ecological
	synthesis. The CDP has experimented with conceptual components for
	database design, templates, to address information technology issues
	facing ecologists. Templates represent forest structures and observational
	measurements on these structures. Using our software, researchers
	select templates to represent their study's data and can generate
	normalized relational databases. Information hidden in those databases
	is used by ancillary tools, including data intake forms and simple
	data validation, data visualization, and metadata export. The primary
	question we address in this paper is, which templates are the right
	templates. We argue for defining simple templates (with relatively
	few attributes) that describe the domain's major entities, and for
	coupling those with focused and flexible observation templates. We
	present a conceptual model for the observation data type, and show
	how we have implemented the model as an observation entity in the
	DataBank database designer and generator. We show how our visualization
	tool CanopyView exploits metadata made explicit by DataBank to help
	scientists with analysis and synthesis. We conclude by presenting
	future plans for tools to conduct statistical calculations common
	to forest ecology and to enhance data mining with DataBank databases.
	DataBank could be extended to another domain by replacing our forest-ecology-specific
	templates with those for the new domain. This work extends the basic
	computer science idea of abstract data types and user-defined types
	to ecology-specific database design tools for individual users, and
	applies to ecoinformatics the software engineering innovations of
	domain-specific languages, software patterns, components, refactoring,
	and end-user programming. © 2007 Elsevier B.V. All rights reserved.},
  affiliation = {The Evergreen State College, 2700 Evergreen Pkwy NW, Olympia, WA 98505,
	United States},
  author_keywords = {Data visualization; Database design; Domain-specific conceptual structures;
	Ecoinformatics; End-user programming; Forest canopy; Semantic data
	integration},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-35348892669&partnerID=40&md5=8d04f7ce8f36741da40f391f0b064d1c}
}

@ARTICLE{McRitchie200498,
  author = {McRitchie, I., Brown, T.J., Spence, I.T.A.},
  title = {Managing component variability within embedded software product lines
	via transformational code generation},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2004},
  volume = {3014},
  pages = {98-110},
  note = {cited By (since 1996) 0},
  abstract = {This paper presents a transformative code generation technique for
	the static optimization and customization of embedded software. The
	approach supports the development of product families by separating
	core functionality from variable facets. The implementation technique
	utilizes generative programming techniques in order to minimize runtime
	memory requirements and maximize performance within an embedded environment.
	© Springer-Verlag Berlin Heidelberg 2004.},
  affiliation = {School of Computer Science, Queen's University of Belfast, Belfast,
	United Kingdom},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-35048893341&partnerID=40&md5=0fc0a3aa33dbca260697a14694309b3d}
}

@CONFERENCE{Mehnert2009,
  author = {Mehnert, H., Bogk, A.},
  title = {A domain-specific language for manipulation of binary data in dylan},
  year = {2009},
  note = {cited By (since 1996) 0},
  abstract = {We present a domain specific language for manipulation of binary data,
	or structured byte sequences, as they appear in everyday applications
	such as networking or graphics file manipulation. Our DSL is implemented
	as an extension of the Dylan language, making use of the macro facility.
	Dylan macros, unlike Common Lisp macros, are implemented as pattern
	matches and substitutions on the parse tree, and we will show the
	strengths and limits of this approach for the given problem.},
  art_number = {22},
  document_type = {Conference Paper},
  journal = {Proceedings of the 2007 International Lisp Conference, ILC '07},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-70450184461&partnerID=40&md5=c0a55e6595f21de20b696b6daf8ec333}
}

@CONFERENCE{Meier2011339,
  author = {Meier, P.a , Kounev, S.a , Koziolek, H.b },
  title = {Automated transformation of component-based software architecture
	models to queueing petri nets},
  year = {2011},
  pages = {339-348},
  note = {cited By (since 1996) 0},
  abstract = {Performance predictions early in the software development process
	can help to detect problems before resources have been spent on implementation.
	The Palladio Component Model (PCM) is an example of a mature domain-specific
	modeling language for component-based systems enabling performance
	predictions at design time. PCM provides several alternative model
	solution methods based on analytical and simulation techniques. However,
	existing solution methods suffer from scalability issues and provide
	limited flexibility in trading-off between results accuracy and analysis
	overhead. Queueing Petri Nets (QPNs) are a general-purpose modeling
	formalism, at a lower level of abstraction, for which efficient and
	mature simulation-based solution techniques are available. This paper
	contributes a formal mapping from PCM to QPN models, implemented
	by means of an automated model-to-model transformation as part of
	a new PCM solution method based on simulation of QPNs. The limitations
	of the mapping and the accuracy and overhead of the new solution
	method compared to existing methods are evaluated in detail in the
	context of five case studies of different size and complexity. The
	new solution method proved to provide good accuracy with solution
	overhead up to 20 times lower compared to PCM's reference solver.
	© 2011 IEEE.},
  affiliation = {Karlsruhe Institute of Technology (KIT), 76131 Karlsruhe, Germany;
	Industrial Software Systems, ABB Corporate Research, 68526 Ladenburg,
	Germany},
  art_number = {6005378},
  author_keywords = {model-to-model transformation; non-functional system properties; performance
	prediction; software architecture models},
  document_type = {Conference Paper},
  journal = {IEEE International Workshop on Modeling, Analysis, and Simulation
	of Computer and Telecommunication Systems - Proceedings},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-80053006440&partnerID=40&md5=30750eeef28a1be2ed0d91cb452643dc}
}

@ARTICLE{Mellor199727,
  author = {Mellor, Stephen J., Johnson, Ralph},
  title = {Why explore object methods, patterns, and architectures?},
  journal = {IEEE Software},
  year = {1997},
  volume = {14},
  pages = {27-29},
  number = {1},
  note = {cited By (since 1996) 5},
  abstract = {Objects, patterns, and architectures each holds the promise of solving
	chronic software development problems. However, each camp advocates
	quite different means for achieving that solution. Resolving the
	conflicting views requires a re-examination of core assumptions.},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-0030832379&partnerID=40&md5=d0e8cea635d3083c2585655e98df284c}
}

@CONFERENCE{Mendonca200813,
  author = {Mendonca, M.a , Wasowski, A.b , Czarnecki, K.a , Cowan, D.a },
  title = {Efficient compilation techniques for large scale feature models},
  year = {2008},
  pages = {13-21},
  note = {cited By (since 1996) 15},
  abstract = {Feature modeling is used in generative programming and software product-line
	engineering to capture the common and variable properties of programs
	within an application domain. The translation of feature models to
	propositional logics enabled the use of reasoning systems, such as
	BDD engines, for the analysis and transformation of such models and
	interactive configurations. Unfortunately, the size of a BDD structure
	is highly sensitive to the variable ordering used in its construction
	and an inappropriately chosen ordering may prevent the translation
	of a feature model into a BDD representation of a tractable size.
	Finding an optimal order is NP-hard and has for long been addressed
	by using heuristics. We review existing general heuristics and heuristics
	from the hardware circuits domain and experimentally show that they
	are not effective in reducing the size of BDDs produced from feature
	models. Based on that analysis we introduce two new heuristics for
	compiling feature models to BDDs. We demonstrate the effectiveness
	of these heuristics using publicly available and automatically generated
	models. Our results are directly applicable in construction of feature
	modeling tools.© 2008 ACM.},
  affiliation = {University of Waterloo; IT University of Copenhagen},
  author_keywords = {Configuration; Feature modeling; Formal verification; Model-driven
	development; Software-product lines},
  document_type = {Conference Paper},
  journal = {GPCE'08: Proceedings of the ACM SIGPLAN 7th International Conference
	on Generative Programming and Component Engineering},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-78650760937&partnerID=40&md5=aef38df7c98f0cdbd12bdcba7dc5b2c4}
}

@CONFERENCE{Menezes2010395,
  author = {Menezes, A.L., Cirilo, C.E., De Moraes, J.L.C., De Souza, W.L., Do
	Prado, A.F.},
  title = {Using archetypes and Domain Specific Languages on development of
	ubiquitous applications to pervasive healthcare},
  year = {2010},
  pages = {395-400},
  note = {cited By (since 1996) 0},
  abstract = {Pervasive healthcare focuses on the use of new technologies, tools,
	and services, in order to help patients to play a more active role
	in the treatment of their diseases. Since pervasive healthcare environments
	demand a huge amount of information exchange, the use of technologies
	like Health Level Seven (HL7) and archetypes has been proposed to
	provide interoperability between applications for these environments.
	However, the complexity of such technologies difficults their full
	adoption as well as the migration from centralized healthcare environments
	into pervasive ones. Aiming at collaborating to bridge this gap,
	this paper proposes an approach to integrate archetypes into HL7
	v3 messages for the development of pervasive healthcare applications.
	The approach suggests the use of Domain Specific Languages (DSLs),
	which simplify the HL7 messages modeling and allow to automate most
	of the messages schema codification. © 2010 IEEE.},
  affiliation = {Computer Department (CD), Federal University of São Carlos (UFSCar),
	Postal Box 676, 13565-905 - São Carlos - SP, Brazil},
  art_number = {6042677},
  document_type = {Conference Paper},
  journal = {Proceedings - IEEE Symposium on Computer-Based Medical Systems},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-80055099915&partnerID=40&md5=2112bdec09d81760cbf41ee9828b10d9}
}

@CONFERENCE{Menotti2009457,
  author = {Menotti, R.a , Cardoso, J.M.P.b , Fernandes, M.M.c , Marques, E.d
	},
  title = {Automatic generation of FPGA hardware accelerators using a domain
	specific language},
  year = {2009},
  pages = {457-461},
  note = {cited By (since 1996) 1},
  abstract = {This paper describes an alternative approach to direct mapping loops
	described in high-level languages onto FPGAs. Different from other
	approaches, this technique does not inherit from software pipelining
	techniques. The control is distributed over operations, thus a finite
	state machine is not necessary to control the order of operations,
	allowing efficient hardware implementations. The specification of
	a hardware block is done by means of LALP, a domain specific language
	specially designed to help the application of the techniques. While
	the language syntax resembles C, it contains certain constructs that
	allow programmer interventions to enforce or relax data dependences
	as needed, and so optimize the performance of the generated hardware
	blocks. ©2009 IEEE.},
  affiliation = {Coordenação de Informática, Universidade Tecnológica Federal do Paraná,
	Campo Mourão, Brazil; Faculdade de Engenharia, Universidade do Porto,
	Porto, Portugal; Departamento de Computação, Universidade Federal
	de São Carlos, São Carlos, Brazil; Inst. Ciências Matemáticas e Computação,
	Universidade de São Paulo, São Carlos, Brazil},
  art_number = {5272485},
  document_type = {Conference Paper},
  journal = {FPL 09: 19th International Conference on Field Programmable Logic
	and Applications},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-70450078793&partnerID=40&md5=bfc289d40182e06eb6145267cec98ecd}
}

@CONFERENCE{Menzel2010243,
  author = {Menzel, M., Warschofsky, R., Meinel, C.},
  title = {A pattern-driven generation of security policies for Service-oriented
	Architectures},
  year = {2010},
  pages = {243-250},
  note = {cited By (since 1996) 3},
  abstract = {Service-oriented Architectures support the provision, discovery, and
	usage of services in different application contexts. The Web Service
	specifications provide a technical foundation to implement this paradigm.
	Moreover, mechanisms are provided to face the new security challenges
	raised by SOA. To enable the seamless usage of services, security
	requirements can be expressed as security policies (e.g. WS-Policy
	and WSSecurityPolicy) that enable the negotiation of these requirements
	between clients and services. However, the codification of security
	policies is a difficult and error-prone task due to the complexity
	of the Web Service specifications. In this paper, we introduce our
	model-driven approach that facilitates the transformation of architecture
	models annotated with simple security intentions to security policies.
	This transformation is driven by security configuration patterns
	that provide expert knowledge on Web Service security. Therefore,
	we will introduce a formalised pattern structure and a domain-specific
	language to specify these patterns. © 2010 IEEE.},
  affiliation = {Hasso-Plattner-Institute, Prof.-Dr.-Helmert Str. 2-3, 14482 Potsdam,
	Germany},
  art_number = {5552780},
  document_type = {Conference Paper},
  journal = {ICWS 2010 - 2010 IEEE 8th International Conference on Web Services},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-77957265737&partnerID=40&md5=369dc174439bf8f4bf1763c17129baa5}
}

@CONFERENCE{Mercadal2010,
  author = {Mercadal, J.a b , Enard, Q.a d , Consel, C.a b c , Loriant, N.a },
  title = {A domain-specific approach to architecturing error handling in pervasive
	computing},
  year = {2010},
  pages = {47-61},
  note = {cited By (since 1996) 0},
  abstract = {The challenging nature of error handling constantly escalates as a
	growing number of environments consists of networked devices and
	software components. In these environments, errors cover a uniquely
	large spectrum of situations related to each layer ranging from hardware
	to distributed platforms, to software components. Handling errors
	becomes a daunting task for programmers, whose outcome is unpredictable.
	Scaling up error handling requires to raise the level of abstraction
	beyond the code level and the try-catch construct, approaching error
	handling at the software architecture level. We propose a novel approach
	that relies on an Architecture Description Language (ADL), which
	is extended with error-handling declarations. To further raise the
	level of abstraction, our approach revolves around a domain-specific
	architectural pattern commonly used in pervasive computing. Error
	handling is decomposed into components dedicated to platform-wide,
	error-recovery strategies. At the application level, descriptions
	of functional components include declarations dedicated to error
	handling. We have implemented a compiler for an ADL extended with
	error-handling declarations. It produces customized programming frameworks
	that drive and support the programming of error handling. Our approach
	has been validated with a variety of applications for building automation.
	© 2010 ACM.},
  affiliation = {INRIA, Bordeaux, France; LaBRI, Bordeaux, France; ENSEIRB, Bordeaux,
	France; Thales, Bordeaux, France},
  author_keywords = {Architecture description languages; Domain-specific languages; Exception;
	Pervasive computing},
  document_type = {Conference Paper},
  journal = {Proceedings of the Conference on Object-Oriented Programming Systems,
	Languages, and Applications, OOPSLA},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-78650123844&partnerID=40&md5=2af36390675e838cdba7172bf4980bb8}
}

@ARTICLE{Mercadal201047,
  author = {Mercadal, J.a b , Enard, Q.a d , Consel, C.a b c , Loriant, N.a },
  title = {A domain-specific approach to architecturing error handling in pervasive
	computing},
  journal = {ACM SIGPLAN Notices},
  year = {2010},
  volume = {45},
  pages = {47-61},
  number = {10},
  note = {cited By (since 1996) 0},
  abstract = {The challenging nature of error handling constantly escalates as a
	growing number of environments consists of networked devices and
	software components. In these environments, errors cover a uniquely
	large spectrum of situations related to each layer ranging from hardware
	to distributed platforms, to software components. Handling errors
	becomes a daunting task for programmers, whose outcome is unpredictable.
	Scaling up error handling requires to raise the level of abstraction
	beyond the code level and the try-catch construct, approaching error
	handling at the software architecture level. We propose a novel approach
	that relies on an Architecture Description Language (ADL), which
	is extended with error-handling declarations. To further raise the
	level of abstraction, our approach revolves around a domain-specific
	architectural pattern commonly used in pervasive computing. Error
	handling is decomposed into components dedicated to platform-wide,
	error-recovery strategies. At the application level, descriptions
	of functional components include declarations dedicated to error
	handling. We have implemented a compiler for an ADL extended with
	error-handling declarations. It produces customized programming frameworks
	that drive and support the programming of error handling. Our approach
	has been validated with a variety of applications for building automation.
	Copyright © 2010 ACM.},
  affiliation = {INRIA, Bordeaux, France; LaBRI, Bordeaux, France; ENSEIRB, Bordeaux,
	France; Thales, Bordeaux, France},
  author_keywords = {Architecture description languages; Domain-specific languages; Exception;
	Pervasive computing},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-79551708696&partnerID=40&md5=fd19d7db9cf6e109b4fcf946ceb858a0}
}

@CONFERENCE{Mercadal2008149,
  author = {Mercadal, J.a , Palix, N.a , Consel, C.a , Lawall, J.L.b },
  title = {Pantaxou: A domain-specific language for developing safe coordination
	services},
  year = {2008},
  pages = {149-159},
  note = {cited By (since 1996) 3},
  abstract = {Coordinating entities in a networked environment has always been a
	significant challenge for software developers. In recent years, however,
	it has become even more difficult, because devices have increasingly
	rich capabilities, combining an ever larger range of technologies
	(networking, multimedia, sensors, etc.). To address this challenge,
	we propose a language-based approach to covering the life-cycle of
	applications coordinating networked entities. Our approach covers
	the characterization of the networked environment, the specification
	of coordination applications, the verification of a networked environment
	and its deployment. It is carried out in practice by a domain-specific
	language, named Pantaxou. This paper presents the domain-specific
	language Pantaxou, dedicated to the development of applications for
	networked heterogeneous entities. Pantaxou has been used to specify
	a number of coordination scenarios in areas ranging from home automation
	to telecommunications. The language semantics has been formally defined
	and a compiler has been developed. The compiler verifies the coherence
	of a coordination scenario and generates coordination code in Java.
	© 2008 ACM.},
  affiliation = {INRIA / LaBRI, Talence, France; DIKU, University of Copenhagen, Copenhagen,
	Denmark},
  author_keywords = {Architecture description languages; Coordination languages; Distributed
	systems; Domain-specific languages; Safety},
  document_type = {Conference Paper},
  journal = {GPCE'08: Proceedings of the ACM SIGPLAN 7th International Conference
	on Generative Programming and Component Engineering},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-63449110270&partnerID=40&md5=86addff89f9f423c8f84d9e536f64c25}
}

@CONFERENCE{Merkle2010139,
  author = {Merkle, B.},
  title = {Textual modeling tools: Overview and comparison of Language Workbenches},
  year = {2010},
  pages = {139-148},
  note = {cited By (since 1996) 0},
  abstract = {Domain Specific Languages (DSL) attract more and more users as they
	are specialized and optimized for a certain problem area. Currently
	the number of new emerging Programming Languages is significant [1]
	but GPL (General Purpose Languages) do often not fit the specific
	need of the end-user. DSL are one way to solve this problem. DSLs
	can be divided into different independent dimensions: e.g. internal
	vs. external or textual vs. graphical or tabular. In this paper we
	focus on textual syntaxes as they have several advantages like easy
	information exchange via e.g. mail, integration into existing tools
	like diff, merge and version control and most important the fast
	editing style supported by the "usual" IDE support like code completion,
	error markers, intentions and quick fixes. While Fowler described
	the initial vision of Language Workbenches [2], several mature Textual
	Language Workbenches have emerged in recent years. In this paper
	we will compare them with a consistent example and look at pros and
	cons. © 2010 ACM.},
  affiliation = {SICK AG, Research and Development Software Engineering, Erwin-Sick-Str.1,
	79183 Waldkirch, Germany},
  author_keywords = {Domain-specific languages; EMFText; Language Workbenches; MPS; TCS;
	TEF; Textual modeling; Xtext},
  document_type = {Conference Paper},
  journal = {Proceedings of the ACM International Conference Companion on Object
	Oriented Programming Systems Languages and Applications Companion,
	SPLASH '10},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-78650155890&partnerID=40&md5=178b6997fff474e6cac10969e4b046d2}
}

@CONFERENCE{Mernik2001291,
  author = {Mernik, M., Žumer, V.},
  title = {Domain-specific languages for software engineering},
  year = {2001},
  pages = {291},
  note = {cited By (since 1996) 0},
  document_type = {Conference Paper},
  journal = {Proceedings of the Hawaii International Conference on System Sciences},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-0034975176&partnerID=40&md5=5f4613df2e7615176c5b4745e3eb9e49}
}

@ARTICLE{Mernik2005316,
  author = {Mernik, M.a d , Heering, J.b e , Sloane, A.M.c f },
  title = {When and how to develop domain-specific languages},
  journal = {ACM Computing Surveys},
  year = {2005},
  volume = {37},
  pages = {316-344},
  number = {4},
  note = {cited By (since 1996) 232},
  abstract = {Domain-specific languages (DSLs) are languages tailored to a specific
	application domain. They offer substantial gains in expressiveness
	and ease of use compared with general-purpose programming languages
	in their domain of application. DSL development is hard, requiring
	both domain knowledge and language development expertise. Few people
	have both. Not surprisingly, the decision to develop a DSL is often
	postponed indefinitely, if considered at all, and most DSLs never
	get beyond the application library stage. Although many articles
	have been written on the development of particular DSLs, there is
	very limited literature on DSL development methodologies and many
	questions remain regarding when and how to develop a DSL. To aid
	the DSL developer, we identify patterns in the decision, analysis,
	design, and implementation phases of DSL development. Our patterns
	improve and extend earlier work on DSL design patterns. We also discuss
	domain analysis tools and language development systems that may help
	to speed up DSL development. Finally, we present a number of open
	problems. © 2005 ACM.},
  affiliation = {University of Maribor; CWI; Macquarie University; Faculty of Electrical
	Engineering and Computer Science, University of Maribor, Smetanova
	17, 2000 Maribor, Slovenia; Department of Software Engineering, CWI,
	Kruislaan 413, 1098 SJ Amsterdam, Netherlands; Department of Computing,
	Macquarie University, Sydney, NSW 2109, Australia},
  author_keywords = {Application language; Domain analysis; Domain-specific language; Language
	development system},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-33745167684&partnerID=40&md5=53727d1bbb35e7c120cf107586ab7d6d}
}

@CONFERENCE{Mernik20031063,
  author = {Mernik, M.a , Gerlič, G.a , Žumer, V.a , Bryant, B.R.b },
  title = {Can a parser be generated from examples?},
  year = {2003},
  pages = {1063-1067},
  note = {cited By (since 1996) 14},
  abstract = {One of the open problems in the area of domain-specific languages
	is how to make domain-specific language development easier for domain
	experts not versed in a programming language design. Possible approaches
	are to build a domain-specific language from parameterized building
	blocks or by language (grammar) induction. This paper uses an evolutionary
	approach to grammar induction. Grammar-specific genetic operators
	for crossover and mutation are proposed to achieve this task. Suitability
	of the approach is shown by small experiments where underlying grammars
	are successfully genetically obtained and parsers are than automatically
	generated.},
  affiliation = {University of Maribor, Fac. of Elec. Eng./Computer Science, Smetanova
	17, 2000 Maribor, Slovenia; Department of Computer Sciences, University
	of Alabama at Birmingham, Birmingham, AL 35294-1170, United States},
  author_keywords = {Evolutionary algorithm; Grammar induction; Parser generation},
  document_type = {Conference Paper},
  journal = {Proceedings of the ACM Symposium on Applied Computing},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-0037634757&partnerID=40&md5=cfcbf2ee53f9ebd2ed74a26ff0d33f9a}
}

@CONFERENCE{Mernik2009,
  author = {Mernik, M.a , Hrnčič, D.a , Bryant, B.R.b , Sprague, A.P.b , Gray,
	J.b , Liu, Q.b , Javed, F.b },
  title = {Grammar inference algorithms and applications in software engineering},
  year = {2009},
  note = {cited By (since 1996) 0},
  abstract = {Many problems exist whose solutions take the form of patterns that
	may be expressed using grammars (e.g., speech recognition, text processing,
	genetic sequencing). Construction of these grammars is usually carried
	out by computer scientists working with domain experts. In the case
	when there is a lack of domain experts, grammar inference can be
	applied. In this paper, two grammar inference algorithms are briefly
	described and their application to software engineering is presented.
	©2009 IEEE.},
  affiliation = {Faculty of Electrical Engineering and Computer Science, University
	of Maribor, Maribor, Slovenia; Department of Computer and Information
	Sciences, University of Alabama at Birmingham, Birmingham, AL, United
	States},
  art_number = {5348441},
  author_keywords = {Domain-specific language; Grammar learning; Memetic algorithm; Metamodeling},
  document_type = {Conference Paper},
  journal = {ICAT 2009 - 2009 22nd International Symposium on Information, Communication
	and Automation Technologies},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-74549219954&partnerID=40&md5=8ba03ec176f43b89e98c14401ee2810e}
}

@ARTICLE{Meyers20111223,
  author = {Meyers, B.a , Vangheluwe, H.a b },
  title = {A framework for evolution of modelling languages},
  journal = {Science of Computer Programming},
  year = {2011},
  volume = {76},
  pages = {1223-1246},
  number = {12},
  note = {cited By (since 1996) 0},
  abstract = {In model-driven engineering, evolution is inevitable over the course
	of the complete life cycle of complex software-intensive systems
	and more importantly of entire product families. Not only instance
	models, but also entire modelling languages are subject to change.
	This is in particular true for domain-specific languages, whose language
	constructs are tightly coupled to an application domain. The most
	popular approach to evolution in the modelling domain is a manual
	process, with tedious and error-prone migration of artefacts such
	as instance models as a result. This paper provides a taxonomy for
	evolution of modelling languages and discusses the different evolution
	scenarios for various kinds of modelling artefacts, such as instance
	models, meta-models, and transformation models. Subsequently, the
	consequences of evolution and the required remedial actions are decomposed
	into primitive scenarios such that all possible evolutions can be
	covered exhaustively. These primitives are then used in a high-level
	framework for the evolution of modelling languages. We suggest that
	our structured approach enables the design of (semi-)automatic modelling
	language evolution solutions. © 2010 Elsevier B.V. All rights reserved.},
  affiliation = {Modelling, Simulation and Design Lab (MSDL), University of Antwerp,
	Middelheimlaan 1, B-2020 Antwerp, Belgium; Modelling, Simulation
	and Design Lab (MSDL), McGill University, 3480 University Street,
	Montral, QC H3A 2A7, Canada},
  author_keywords = {Evolution; Language engineering; Model transformation; Model-driven
	engineering; Modelling languages},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-79958834491&partnerID=40&md5=03a73b40e8cec47e2f383d507c0837a7}
}

@CONFERENCE{Mezini2005342,
  author = {Mezini, M., Ostermann, K.},
  title = {A comparison of program generation with aspect-oriented programming},
  year = {2005},
  volume = {3566},
  pages = {342-354},
  note = {cited By (since 1996) 3},
  abstract = {Program generation and transformation techniques have gained considerable
	attention in the context of domain-specific languages (DSLs) and
	model-driven architecture (MDA). In this paper we compare domain-specific
	program generators with general-purpose aspect-oriented languages.
	We argue that program generation techniques have severe disadvantages
	with respect to composability, scalability, under-standability, and
	other important software engineering issues. Finally, we advocate
	general-purpose aspect-oriented languages as an alternative for the
	implementation of domain-specific languages. © Springer-Verlag Berlin
	Heidelberg 2005.},
  affiliation = {Darmstadt University of Technology, Germany},
  document_type = {Conference Paper},
  journal = {Lecture Notes in Computer Science},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-26444442435&partnerID=40&md5=2c79213ab0ba4eff4f9eee8857d3aec6}
}

@ARTICLE{Michel2009865,
  author = {Michel, O.a , Spicher, A.a , Giavitto, J.-L.b },
  title = {Rule-based programming for integrative biological modeling : AAApplication
	to the modeling of thλe phage genetic switch},
  journal = {Natural Computing},
  year = {2009},
  volume = {8},
  pages = {865-889},
  number = {4},
  note = {cited By (since 1996) 1},
  abstract = {Systems biology aims at integrating processes at various time and
	spatial scales into a single and coherent formal description to allow
	computer modeling. In this context, we focus on rule-based modeling
	and its integration in the domain-specific language MGS . Through
	the notions of topological collections and transformations, MGS allows
	the modeling of biological processes at various levels of description.
	We validate our approach through the description of various models
	of the genetic switch of the λ phage, from a very simple biochemical
	description of the process to an individual-based model on a Delaunay
	graph topology. This approach is a first step into providing the
	requirements for the emerging field of spatial systems biology which
	integrates spatial properties into systems biology. © 2008 Springer
	Science+Business Media B.V.},
  affiliation = {LACL - EA 4213, Faculté des Sciences et Technologie, Université de
	Paris 12, 61 avenue du Général de Gaulle, Creteil Cedex 94010, France;
	IBISC Lab., FRE 3190 CNRS, Université d'Évry and Genopole, 523 place
	des terrasses de l'agora, Evry 91000, France},
  author_keywords = {Domain-specific languages; Rule-based modeling; Spatial systems biology},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-76849092686&partnerID=40&md5=711134ab90ca3ebc818aa3a9ade35339}
}

@ARTICLE{Michels2011153,
  author = {Michels, S., Plasmeijer, R., Achten, P.},
  title = {iTask as a new paradigm for building GUI applications},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2011},
  volume = {6647 LNCS},
  pages = {153-168},
  note = {cited By (since 1996) 0},
  abstract = {The iTask system is a combinator library written in Clean offering
	a declarative, domain-specific language for defining workflows. From
	a declarative specification, a complete multi-user, web-enabled,
	workflow management system (WFMS) is generated. In the iTask paradigm,
	a workflow is a definition in which interactive elements are defined
	by editors on model values (abstracting from concrete GUI implementation
	details). The order of their appearance is calculated dynamically
	using combinator functions (abstracting from concrete synchronisation
	details). Defining interactive elements and the order of their appearance
	are also major concerns when programming GUI applications. For this
	reason, the iTask paradigm is potentially suited to program GUI applications
	as well. However, the iTask system was designed for a different application
	domain and lacks a number of key features to make it suited for programming
	GUI applications. In this paper, we identify these key features and
	show how they can be added to the iTask system in an orthogonal way,
	thus creating a new paradigm for programming GUI applications. ©
	2011 Springer-Verlag.},
  affiliation = {Institute for Computing and Information Sciences, Radboud University
	Nijmegen, P.O. Box 9010, Nijmegen 6500 GL, Netherlands},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-80054118440&partnerID=40&md5=2904d887cc7e5ef9b9551b4dce7180b5}
}

@ARTICLE{Middelkoop2011105,
  author = {Middelkoop, A., Dijkstra, A., Swierstra, S.D.},
  title = {Dependently typed attribute grammars},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2011},
  volume = {6647 LNCS},
  pages = {105-120},
  note = {cited By (since 1996) 0},
  abstract = {Attribute Grammars (AGs) are a domain-specific language for functional
	and composable descriptions of tree traversals. Given such a description,
	it is not immediately clear how to state and prove properties of
	AGs formally. To meet this challenge, we apply dependent types to
	AGs. In a dependently typed AG, the type of an attribute may refer
	to values of attributes. The type of an attribute is an invariant,
	the value of an attribute a proof for that invariant. Additionally,
	when an AG is cycle-free, the composition of the attributes is logically
	consistent. We present a lightweight approach using a preprocessor
	in combination with the dependently typed language Agda. © 2011 Springer-Verlag.},
  affiliation = {Universiteit Utrecht, Netherlands},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-80054096413&partnerID=40&md5=22bfa0d916720a3f2b0b0dcddc17dc93}
}

@ARTICLE{Miksa201099,
  author = {Miksa, K., Sabina, P., Kasztelnik, M.},
  title = {Combining ontologies with domain specific languages: A case study
	from network configuration software},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2010},
  volume = {6325 LNCS},
  pages = {99-118},
  note = {cited By (since 1996) 1},
  abstract = {One of the important aspects of Model-Driven Engineering (MDE) is
	to consider application-domain variability, which leads to creation
	of Domain Specific Languages (DSL). As with DSLs models are concise,
	easy to understand and maintain, this approach greatly increases
	the productivity and software quality. Usually, the DSLs in MDE are
	described with a metamodel and a concrete syntax definition. The
	models expressed in the DSL are linguistic instantiations of the
	language concepts found in the metamodel. However, for some of the
	application domains it's not enough to consider the linguistic dimension
	of the instantiation. The problem arises when the domain itself contains
	the aspect of typing. This leads to another view on instantiation,
	called ontological instantiation . Since both aspects are present
	simultaneously, we refer to the combined approach with the term "two-dimensional
	metamodelling". In the following, we will exemplify the problem with
	a case study based on a real challenge found in the domain of network
	management. The solution we propose benefits from ontology technology
	which is applied to enforce the semantics of ontological instantiation.
	Our approach presents significant differences comparing to the existing
	2D metamodelling solution, although the motivations are similar.
	Thus, we consider our work as a case study of applying ontology enabled
	software engineering in the area of DSL engineering, rather than
	a new metamodelling technology or an application of existing 2D metamodelling
	architecture. The article is a result of joint work of the MOST project
	partners, applied within the case study provided by Comarch. © 2010
	Springer-Verlag.},
  affiliation = {Comarch SA, Al. Jana Pawla II 39A, Krakow, Poland},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-78649881345&partnerID=40&md5=cc67a228760830d42b43a4f4959a9329}
}

@ARTICLE{Miksa2010329,
  author = {Miksa, K.a , Kasztelnik, M.a , Sabina, P.a , Walter, T.b },
  title = {Towards semantic modeling of network physical devices},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2010},
  volume = {6002 LNCS},
  pages = {329-343},
  note = {cited By (since 1996) 1},
  abstract = {One of the challenges faced by network management systems is the increasing
	need for consistent management of physical network equipment. We
	propose a solution where equipment is modelled using a dedicated
	Domain Specific Language (DSL) enriched with the power of logic-based
	reasoning services. This enables us to define a rich layer of semantics
	on top of the structural description of the devices. This way, the
	configuration related constraints are expressed declaratively, in
	a platform independent manner, and are managed in an integrated way
	with the structural model. The information kept in the model can
	then be used on runtime to give guidance to the system user. © Springer-Verlag
	Berlin Heidelberg 2010.},
  affiliation = {Comarch SA, Al. Jana Pawla II 39A, Krakow, Poland; ISWeb - Information
	Systems and Semantic Web, Institute for Computer Science, University
	of Koblenz-Landau, Universitätsstrasse 1, Koblenz 56070, Germany},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-78649806018&partnerID=40&md5=f22c73f5994bb175f48e40d13189c36c}
}

@ARTICLE{Miles1998593,
  author = {Miles, W.S.a , Johnson, L.F.b },
  title = {Implementing generalized operator overloading},
  journal = {Software - Practice and Experience},
  year = {1998},
  volume = {28},
  pages = {593-610},
  number = {6},
  note = {cited By (since 1996) 0},
  abstract = {This paper presents a practical method of adding problem-specific
	notation to an established computer language. Our idea is to use
	unrestricted operator overloading as a tool to map the problem domain
	notation directly into an existing programming language. Our method
	introduces new operator symbols and function names into a host language
	by overloading existing usage. We extend the host programming language
	syntax to an augmented language which is mapped to the host language
	by a programmable preprocessor. The preprocessor uses a programmer-modifiable
	symbolic language grammar to translate an augmented program into
	a standard program. This process gives a natural extension to any
	computer language without modifying the host language. Direct use
	of problem notation can improve program legibility and code comprehension
	within the problem domain. The preprocessor provides a useful research
	tool for exploring language issues without the need to write a compiler
	for a new language. It can also be used to provide a domain specific
	language for a programming group at lower cost than new language
	development. This paper presents several working examples which illustrate
	our work. We redefine many of the standard C operators to alleviate
	some of the more common programming errors, thus creating a 'cleaner'
	C. As a more esoteric example, we encode a subset of APL vector operators
	as an algebraic extension to the C language. A curious application
	of our method shows its success in an arbitrary problem domain by
	compiling and executing poetry. Our final example introduces standard
	symbolic logic notation into C for tautology verification. © 1998
	John Wiley & Sons, Ltd.},
  affiliation = {WSM Information Systems Inc., 192 Woodlawn Lane, New Maryland, NB
	E3C 1J6, Canada; Information Metrics Institute, University of New
	Brunswick, P.O. Box 4400, Fredericton, NB E3B 5A3, Canada},
  author_keywords = {Language design; Notation; Operator overloading; Preprocessor; Problem
	domains},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-0032072118&partnerID=40&md5=e43fa5db7bebd09af8f4b66535c8ab32}
}

@CONFERENCE{Miller2009269,
  author = {Miller, A., Kumar, B., Singhal, A.},
  title = {Photon: A domain-specific language for testing converged applications},
  year = {2009},
  volume = {2},
  pages = {269-274},
  note = {cited By (since 1996) 0},
  abstract = {Automated testing of converged applications can be complex, as it
	is rare for a single testing tool to provide a single solution for
	all access points which a given application supports. As such, testing
	teams often create customized testing frameworks, which integrate
	several different testing tools, and a myriad of programming languages
	and scripting tools. When an application's unique set of access points
	changes, or a new testing tool comes to market which offers a competitive
	advantage over existing test tools, the cost of updating these customized
	frameworks can be difficult to justify. This paper provides a solution
	to this problem by introducing "Photonese," a domainspecific language
	which testers can use to compose automation scripts which are independent
	of the test tool used for automation. In this way, the tester creates
	reusable testing assets in a framework which is reusable across multiple
	projects. © 2009 IEEE.},
  affiliation = {Verizon Communications},
  art_number = {5254116},
  document_type = {Conference Paper},
  journal = {Proceedings - International Computer Software and Applications Conference},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-70449628409&partnerID=40&md5=e8850da2a605de4d9a92035125fcf28e}
}

@CONFERENCE{Miller2010741,
  author = {Miller, J.A., Han, J., Hybinette, M.},
  title = {Using domain specific language for modeling and simulation: Scalation
	as a case study},
  year = {2010},
  pages = {741-752},
  note = {cited By (since 1996) 0},
  abstract = {Progress in programming paradigms and languages has over time influenced
	the way that simulation programs are written. Modern object-oriented,
	functional programming languages are expressive enough to define
	embedded Domain Specific Languages (DSLs). The Scala programming
	language is used to implement ScalaTion that supports several popular
	simulation modeling paradigms. As a case study, ScalaTion is used
	to consider how language features of object-oriented, functional
	programming languages and Scala in particular can be used to write
	simulation programs that are clear, concise and intuitive to simulation
	modelers. The dichotomy between "model specification" and "simulation
	program" is also considered both historically and in light of the
	potential narrowing of the gap afforded by embedded DSLs. ©2010 IEEE.},
  affiliation = {Department of Computer Science, University of Georgia, Athens, GA
	30602, United States},
  art_number = {5679113},
  document_type = {Conference Paper},
  journal = {Proceedings - Winter Simulation Conference},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-79951640392&partnerID=40&md5=38e540c649d8f5e158393c509cfef953}
}

@CONFERENCE{Millsteln200328,
  author = {Millsteln, T.},
  title = {Static Reasoning about Programs and Queries},
  year = {2003},
  pages = {28-34},
  note = {cited By (since 1996) 0},
  abstract = {In this paper, I survey three projects that are loosely related by
	the aim to statically understand important properties of a computation.
	First I describe an extension to mainstream programming languages
	that solves some common expressiveness limitations while preserving
	the ability to perform static typechecking modularly. Second I describe
	a notion of query containment that is appropriate for data integration
	systems and investigate the complexity of the problem. Finally I
	describe a domain-specific language for writing compiler optimizations
	and a strategy for automatically proving the correctness of optimizations
	written in this language. These three projects explore themes that
	are prevalent in the work of Paris Kanellakis, including object orientation,
	type theory, database theory, and declarative languages. I was first
	exposed to many of these topics through my interaction with Paris.},
  affiliation = {Dept. of Comp. Sci. and Engineering, University of Washington, Seattle,
	WA, United States},
  author_keywords = {Compiler correctness; Data integration; Modular typechecking; Multimethods;
	Query containment},
  document_type = {Conference Paper},
  journal = {Principles of Computing and Knowledge: Paris C. Kanellakis Memorial
	Workshop},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-0141894803&partnerID=40&md5=56df3a25f331c93ae1949ce66d141fc0}
}

@ARTICLE{Mitchell20101,
  author = {Mitchell, N.},
  title = {Deriving a relationship from a single example},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2010},
  volume = {5812 LNCS},
  pages = {1-24},
  note = {cited By (since 1996) 0},
  abstract = {Given an appropriate domain specific language (DSL), it is possible
	to describe the relationship between Haskell data types and many
	generic functions, typically type-class instances. While describing
	the relationship is possible, it is not always an easy task. There
	is an alternative - simply give one example output for a carefully
	chosen input, and have the relationship derived. When deriving a
	relationship from only one example, it is important that the derived
	relationship is the intended one. We identify general restrictions
	on the DSL, and on the provided example, to ensure a level of predictability.
	We then apply these restrictions in practice, to derive the relationship
	between Haskell data types and generic functions. We have used our
	scheme in the Derive tool, where over 60% of type classes are derived
	from a single example. © 2010 Springer-Verlag.},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-77951999910&partnerID=40&md5=72b654bfada9728412d66894b88da0b1}
}

@CONFERENCE{Mizera-Pietraszko2009423,
  author = {Mizera-Pietraszko, J.},
  title = {Interactive document retrieval from multilingual digital repositories},
  year = {2009},
  pages = {423-428},
  note = {cited By (since 1996) 0},
  abstract = {On the contrary to multilingual information retrieval systems, digital
	libraries usually do not provide any support for query translation.
	This paper presents a study aimed at exploring the role of the translation
	component in a digital library system designed for multilingual access
	to resources. Thus, we propose a user-oriented approach to one-word
	query formulation aimed at browsing English and French document collections
	of digital libraries. In particular, the focus is on comparison of
	bilingual to monolingual harvesting of digital collections. We explore
	some multilingual repositories based on OPAC (Online Public Catalogue)
	systems by utilization of metadata-based search. The evaluation of
	the digital library systems selected relies on usability criteria.
	In addition, the search results are grouped into categories according
	to the language pair phenomena. A diversity of the library contents
	oriented towards domain specific network communities is also regarded
	as a relevance factor at the query formulation stage. ©2009 IEEE.},
  affiliation = {Institute of Informatics, Wroclaw University of Technology},
  art_number = {5273836},
  document_type = {Conference Paper},
  journal = {2nd International Conference on the Applications of Digital Information
	and Web Technologies, ICADIWT 2009},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-71449083806&partnerID=40&md5=3bb27c2b3d6cc85f86b0313b3f964f55}
}

@CONFERENCE{Mogensen20091910,
  author = {Mogensen, T.Æ.},
  title = {Troll, a language for specifying dice-rolls},
  year = {2009},
  pages = {1910-1915},
  note = {cited By (since 1996) 0},
  abstract = {Dice are used in many games, and often in fairly complex ways that
	make it difficult to unambiguously describe the dice-roll mechanism
	in plain language. Many role-playing games, such as Dungeons & Dragons,
	use a formalised notation for some instances of dice-rolls. This
	notation, once explained, make dice-roll descriptions concise and
	unambiguous. Furthermore, the notation has been used in automated
	tools for pseudo-random dice-rolling (typically used when playing
	over the Internet). This notation is, however, fairly limited in
	the types of dice-rolls it can describe, so most games still use
	natural language to describe rolls. Even Dungeons & Dragons use formal
	notation only for some of the dice-roll methods used in the game.
	Hence, a more complete notation is in this paper proposed, and a
	tool for pseudo-random rolls and (nearly) exact probability calculations
	is described. The notation is called "Troll", combining the initial
	of the Danish word for dice ("terninger") with the English word "roll".
	It is a development of the language Roll described in an earlier
	paper. The present paper describes the most important features of
	Troll and its implementation. Copyright 2009 ACM.},
  affiliation = {DIKU, University of Copenhagen, Universitetsparken 1, DK-2100 Copenhagen
	O, Denmark},
  author_keywords = {Dice; Domain-specific languages; Probability},
  document_type = {Conference Paper},
  journal = {Proceedings of the ACM Symposium on Applied Computing},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-72949091434&partnerID=40&md5=52e4e92e1f20f310140dd7df683edd69}
}

@CONFERENCE{Moha2007527,
  author = {Moha, N., Guéhéneuc, Y.-G.},
  title = {DECOR: A tool for the detection of design defects},
  year = {2007},
  pages = {527-528},
  note = {cited By (since 1996) 0},
  abstract = {Software engineers often need to identify design defects, recurring
	design problems that hinder the development process, to improve and
	assess the quality of their systems. However, this is difficult because
	of the lack of specifications and tools. We propose Decor, a method
	to specify design defects systematically and to generate automatically
	detection algorithms. With this method, software engineers analyse
	and specify design defects at a high-level of abstraction using a
	unified vocabulary and dedicated language for generating detection
	algorithms.},
  affiliation = {Ptidej Team - GEODES, Dept. of Informatics and Operations Research,
	University of Montreal, QC, Canada},
  author_keywords = {algorithm generation; antipatterns; code smells; design defects; detection;
	domain-specific language; java},
  document_type = {Conference Paper},
  journal = {ASE'07 - 2007 ACM/IEEE International Conference on Automated Software
	Engineering},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-77954012613&partnerID=40&md5=e73f2aa4956899131a92be7cb29744c6}
}

@ARTICLE{Moha2010345,
  author = {Moha, N.a b d , Guéhéneuc, Y.G.c , Le Meur, A.F.b , Duchien, L.b
	, Tiberghien, A.b },
  title = {From a domain analysis to the specification and detection of code
	and design smells},
  journal = {Formal Aspects of Computing},
  year = {2010},
  volume = {22},
  pages = {345-361},
  number = {3-4},
  note = {cited By (since 1996) 1},
  abstract = {Code and design smells are recurring design problems in software systems
	that must be identified to avoid their possible negative consequences
	on development and maintenance. Consequently, several smell detection
	approaches and tools have been proposed in the literature. However,
	so far, they allow the detection of predefined smells but the detection
	of new smells or smells adapted to the context of the analysed systems
	is possible only by implementing new detection algorithms manually.
	Moreover, previous approaches do not explain the transition from
	specifications of smells to their detection. Finally, the validation
	of the existing approaches and tools has been limited on few proprietary
	systems and on a reduced number of smells. In this paper, we introduce
	an approach to automate the generation of detection algorithms from
	specifications written using a domain-specific language. This language
	is defined from a thorough domain analysis. It allows the specification
	of smells using high-level domain-related abstractions. It allows
	the adaptation of the specifications of smells to the context of
	the analysed systems.We specify 10 smells, generate automatically
	their detection algorithms using templates, and validate the algorithms
	in terms of precision and recall on Xerces v2.7.0 and GanttProject
	v1.10.2, two open-source object-oriented systems.We also compare
	the detection results with those of a previous approach, iPlasma.
	BCS © 2010.},
  affiliation = {GEODES, DIRO, Université de Montréal, Montreal, QC, Canada; INRIA
	Lille Nord Europe, LIFL CNRS UMR 8022, Université des Sciences et
	Technologies de Lille, Villeneuve-d', Ascq cedex, France; DGIGL,
	École Polytechnique de Montréal, Montreal, QC, Canada; IRISA, INRIA
	Rennes-Bretagne Atlantique, Campus de Beaulieu, 35042 Rennes cedex,
	France},
  author_keywords = {Algorithm generation; Antipatterns; Code smells; Design smells; Detection;
	Domain-specific language; Java},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-77954089392&partnerID=40&md5=53373f5274ae16441fc17fcb71543bad}
}

@ARTICLE{Moha2008276,
  author = {Moha, N.a b , Guéhéneuc, Y.-G.a , Le Meur, A.-F.b , Duchien, L.b
	},
  title = {A domain analysis to specify design defects and generate detection
	algorithms},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2008},
  volume = {4961 LNCS},
  pages = {276-291},
  note = {cited By (since 1996) 1},
  abstract = {Quality experts often need to identify in software systems design
	defects, which are recurring design problems, that hinder development
	and maintenance. Consequently, several defect detection approaches
	and tools have been proposed in the literature. However, we are not
	aware of any approach that defines and reifies the process of generating
	detection algorithms from the existing textual descriptions of defects.
	In this paper, we introduce an approach to automate the generation
	of detection algorithms from specifications written using a domain-specific
	language. The domain-specific is defined from a thorough domain analysis.
	We specify several design defects, generate automatically detection
	algorithms using templates, and validate the generated detection
	algorithms in terms of precision and recall on Xerces v2.7.0, an
	open-source object-oriented system. © 2008 Springer-Verlag Berlin
	Heidelberg.},
  affiliation = {Ptidej Team - GEODES, DIRO, University of Montreal, QC, Canada; Adam
	Team - INRIA Futurs, LIFL, Université des Sciences et Technologies
	de Lille, France},
  author_keywords = {Algorithm generation; Antipatterns; Code smells; Design defects; Detection;
	Domain-specific language; Java},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-47249115803&partnerID=40&md5=3e94657a05bff3b86d870dce4e136470}
}

@ARTICLE{Moha201020,
  author = {Moha, N.a , Guéhéneuc, Y.-G.b , Duchien, L.c , Le Meur, A.-F.c },
  title = {DECOR: A method for the specification and detection of code and design
	smells},
  journal = {IEEE Transactions on Software Engineering},
  year = {2010},
  volume = {36},
  pages = {20-36},
  number = {1},
  note = {cited By (since 1996) 11},
  abstract = {Code and design smells are poor solutions to recurring implementation
	and design problems. They may hinder the evolution of a system by
	making it hard for software engineers to carry out changes. We propose
	three contributions to the research field related to code and design
	smells: 1) Decor, a method that embodies and defines all the steps
	necessary for the specification and detection of code and design
	smells, 2) Detex, a detection technique that instantiates this method,
	and 3) an empirical validation in terms of precision and recall of
	Detex. The originality of Detex stems from the ability for software
	engineers to specify smells at a high level of abstraction using
	a consistent vocabulary and domain-specific language for automatically
	generating detection algorithms. Using Detex, we specify four well-known
	design smells: the antipatterns Blob, Functional Decomposition, Spaghetti
	Code, and Swiss Army Knife, and their 15 underlying code smells,
	and we automatically generate their detection algorithms. We apply
	and validate the detection algorithms in terms of precision and recall
	on Xerces v2.7.0, and discuss the precision of these algorithms on
	11 open-source systems. © 2010 IEEE.},
  affiliation = {Triskell Team, IRISA-Université de Rennes 1, INRIA Rennes-Bretagne
	Atlantique Campus de Beaulieu, 35042 Rennes cedex, France; Département
	de Génie Informatique et Génie Logiciel, Ecole Polytechnique de Montréal,
	succursale Centre-Ville, Montréal, QC, H3C 3A7, Canada; INRIA, Lille-Nord
	Europe, Parc Scientifique de la Haute Borne 40, avenue Halley-Bat,
	59650 Villeneuve d'Ascq, France},
  art_number = {5196681},
  author_keywords = {Antipatterns; Code smells; Design smells; Detection; Java.; Metamodeling;
	Specification},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-76749149064&partnerID=40&md5=e4d1410d58677020f4a707549fdc032e}
}

@ARTICLE{Mohagheghi2010212,
  author = {Mohagheghi, P., Haugen, Ø.},
  title = {Evaluating domain-specific modelling solutions},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2010},
  volume = {6413 LNCS},
  pages = {212-221},
  note = {cited By (since 1996) 0},
  abstract = {This paper presents criteria and evaluation methods for evaluating
	domain-specific modelling (DSM) solutions based on analysing state
	of the art and experiences of developing and evaluating DSM solutions
	in research projects. The state-of-the-art analysis returned several
	requirements regarding the quality of domain-specific modelling languages
	and tools developed based on them that are classified based on the
	identified stakeholders. The stakeholders are those who develop and
	those who use a DSM solution, the intended domain and purposes with
	developing a DSM solution as defined by domain experts, software
	engineering concerns, integration with other languages or tools,
	and the quality of artefacts to be modelled or generated. Both quantitative
	and qualitative approaches may be applied for evaluating DSM solutions
	based on the development stage and requirements. There is a clear
	need for a process that supports evaluating the quality of DSM solutions
	and this research contributes to the definition of such process.
	© 2010 Springer-Verlag.},
  affiliation = {SINTEF, Forskningsveien 1, Oslo, Norway},
  author_keywords = {assessment; case study; domain-specific language; modelling; quality},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-78649967008&partnerID=40&md5=0909f186f84beb5e5e6d31aa63c17d8e}
}

@ARTICLE{Moisan20101,
  author = {Moisan, S.},
  title = {Generating knowledge-based system generators: A software engineering
	approach},
  journal = {International Journal of Intelligent Information Technologies},
  year = {2010},
  volume = {6},
  pages = {1-17},
  number = {1},
  note = {cited By (since 1996) 2},
  abstract = {This article investigates software engineering techniques for designing
	and reengineering knowledge-based system generators, focusing on
	inference engines and domain specific languages. Indeed, software
	development of knowledge-based systems is a difficult task. We choose
	a software engineering approach to favor code reuse,evolution, and
	maintenance. We propose a software platform named Lama to design
	the different elements necessary to produce a knowledge-based system.
	This platform offers software toolkits (mainly component frameworks)
	to build interfaces, inference engines, and expert languages. We
	have used the platform to build several KBS generators for various
	tasks (planning, classification, model calibration) in different
	domains. The approach appears well fitted to knowledge-based system
	generators; it allows developers a significant gain in time, as well
	as it improves software readability and safeness. Copyright © 2010,
	IGI Global.},
  affiliation = {INRIA, France},
  author_keywords = {Component frameworks; Generators of knowledge-based systems; Reuse;
	Software engineering},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-75749112069&partnerID=40&md5=bd1146b9e39b131fac72f9f4c66b6d71}
}

@ARTICLE{Monperrus2008505,
  author = {Monperrus, M.a b , Jézéquel, J.-M.b , Champeau, J.a , Hoeltzener,
	B.a },
  title = {A model-driven measurement approach},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2008},
  volume = {5301 LNCS},
  pages = {505-519},
  note = {cited By (since 1996) 0},
  abstract = {Companies using domain specific languages in a model-driven development
	process need to measure their models. However, developing and maintaining
	a measurement software for each domain specific modeling language
	is costly. Our contribution is a model-driven measurement approach.
	This measurement approach is model-driven from two viewpoints: 1)
	it measures models of a model-driven development process; 2) it uses
	models as unique and consistent metric specifications, w.r.t a metric
	specification metamodel. This declarative specification of metrics
	is then used to generate a fully fledged implementation. The benefit
	from applying the approach is evaluated by two applications. They
	indicate that this approach reduces the domain-specific measurement
	software development cost. © 2008 Springer-Verlag Berlin Heidelberg.},
  affiliation = {ENSIETA, Brest, France; INRIA, University of Rennes, France},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-56649106309&partnerID=40&md5=7b3538fc0b1114e3378519f39d8367c9}
}

@ARTICLE{Monperrus2011537,
  author = {Monperrus, M.a , Jézéquel, J.-M.b c , Baudry, B.c , Champeau, J.d
	, Hoeltzener, B.d },
  title = {Model-driven generative development of measurement software},
  journal = {Software and Systems Modeling},
  year = {2011},
  volume = {10},
  pages = {537-552},
  number = {4},
  note = {cited By (since 1996) 0},
  abstract = {Metrics offer a practical approach to evaluate properties of domain-specific
	models. However, it is costly to develop and maintain measurement
	software for each domain-specific modeling language. In this paper,
	we present a model-driven and generative approach to measuring models.
	The approach is completely domain-independent and operationalized
	through a prototype that synthesizes a measurement infrastructure
	for a domain-specific modeling language. This model-driven measurement
	approach is model-driven from two viewpoints: (1) it measures models
	of a domain-specific modeling language; (2) it uses models as unique
	and consistent metric specifications, with respect to a metric specification
	metamodel which captures all the necessary concepts for model-driven
	specifications of metrics. The benefit from applying the approach
	is evaluated by four case studies. They indicate that this approach
	significantly eases the measurement activities of model-driven development
	processes. © 2010 Springer-Verlag.},
  affiliation = {Technische Uniersität Darmstadt, Darmstadt, Germany; University of
	Rennes, Rennes, France; INRIA, Rennes, France; ENSIETA, Brest, France},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-80053130296&partnerID=40&md5=fc6bea360f0a4e00cfedd5eadc7cfb4c}
}

@CONFERENCE{Montini20101304,
  author = {Montini, D.Á.a , Fernandes, D.D.a , Marcondes, F.S.a , Tasinaffo,
	P.M.a , Vega, I.S.b , Dias, L.A.V.a },
  title = {Formal approach use to choose a software manufactoring cell's SDLC},
  year = {2010},
  pages = {1304-1305},
  note = {cited By (since 1996) 0},
  abstract = {This paper shows how to use state machines and systematic approaches
	to software modeling to help modeler to improve, verify and validate
	a Domain Analysis and also refine and improve enterprise business
	processes. The main objective of this approach is how to systematic
	got a DSL from a Domain Analysis which can be used code system respecting,
	all business rules without complex definitions or documents. Many
	problems of Computer Software Systems (CSS) are derived from a lack
	of its behavior specification in order to solve that problem, but
	even with a well defined system behavior, many business rules are
	not properly treated since formalization becomes on the design phase.
	This paper shows an approach on how to systematically refine domain
	analysis to consider all business rules. It considers a state machine
	which represent all aspects of the domain choice. The state machines
	use is based on user friendliness and formality. © 2010 IEEE.},
  affiliation = {Brazilian Aeronautics Institute of Tecnology - ITA, Brazil; Pontifícia
	Universidade Católica de São Paulo - PUC-SP, Brazil},
  art_number = {5501573},
  author_keywords = {Domain analysis; Domain specific language; Formal methods and state
	machines},
  document_type = {Conference Paper},
  journal = {ITNG2010 - 7th International Conference on Information Technology:
	New Generations},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-77955287846&partnerID=40&md5=7fd316749edc7d0ac1b44028f32c7881}
}

@ARTICLE{Mora2011201,
  author = {Mora, B.a , García, F.b , Ruiz, F.b , Piattini, M.b },
  title = {Graphical versus textual software measurement modelling: An empirical
	study},
  journal = {Software Quality Journal},
  year = {2011},
  volume = {19},
  pages = {201-233},
  number = {1},
  note = {cited By (since 1996) 0},
  abstract = {Model-driven Engineering (MDE) has attained great importance in both
	the Software Engineering industry and the research community, where
	it is now widely used to provide a suitable approach with which to
	improve productivity when developing software artefacts. In this
	scenario, measurement models (software artefacts) have become a fundamental
	point in improvement of productivity, where MDE and Software Measurement
	can reap mutual benefits. MDE principles and techniques can be used
	in software measurement to build more automatic and generic solutions,
	and to achieve this, it is fundamental to be able to develop software
	measurement models. To facilitate this task, a domain-specific language
	named "Software Measurement Modelling Language" (SMML) has been developed.
	This paper tackles the question of whether the use of SMML can assist
	in the definition of software measurement models. An empirical study
	was conducted, with the aim of verifying whether SMML makes it easier
	to construct measurement models which are more usable and maintainable
	as regards textual notation. The results show that models which do
	not use the language are more difficult-in terms of effort, correctness
	and efficiency-to understand and modify than those represented with
	SMML. Additional feedback was also obtained, to verify the suitability
	of the graphical representation of each symbol (element or relationship)
	of SMML. © 2010 Springer Science+Business Media, LLC.},
  affiliation = {Indra Software Labs, Information Technology Company, Ciudad Real,
	Spain; ALARCOS Research Group, Department of Information Technologies
	and Systems, University of Castilla-La Mancha, Paseo de la Universidad,
	4, 13071 Ciudad Real, Spain},
  author_keywords = {DSL; Empirical validation; Software measurement},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-78751641318&partnerID=40&md5=70a21fedba9f85ccc1f9df8e8f9438f8}
}

@CONFERENCE{Moreno200629,
  author = {Moreno, G.A.},
  title = {Creating custom containers with generative techniques},
  year = {2006},
  pages = {29-38},
  note = {cited By (since 1996) 6},
  abstract = {Component containers are a key part of mainstream component technologies,
	and play an important role in separating non-functional concerns
	from the core component logic. This paper addresses two different
	aspects of containers. First, it shows how generative programming
	techniques, using AspectC++ and meta-programming, can be used to
	generate stubs and skeletons without the need for special compilers
	or interface description languages. Second, the paper describes an
	approach to create custom containers by composing different non-functional
	features. Unlike component technologies such as EJB, which only support
	a predefined set of container types, this approach allows different
	combinations of non-functional features to be composed in a container
	to meet the application needs. Copyright © 2006 ACM.},
  affiliation = {Software Engineering Institute, Carnegie Mellon University},
  author_keywords = {Aspect-oriented programming; AspectC++; Component; Container; Generative
	programming; Meta-programming; Non-functional concern},
  document_type = {Conference Paper},
  journal = {Proceedings of the 5th International Conference on Generative Programming
	and Component Engineering, GPCE'06},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-34547426872&partnerID=40&md5=06088466ebf0631daef3910825301dc5}
}

@ARTICLE{Moreno200767,
  author = {Moreno, N.a , Fraternali, P.b , Vallecillo, A.a },
  title = {WebML modelling in UML},
  journal = {IET Software},
  year = {2007},
  volume = {1},
  pages = {67-80},
  number = {3},
  note = {cited By (since 1996) 9},
  abstract = {In recent years, we have witnessed how the Web Engineering community
	has started using the standard unified modelling language (UML) notation,
	techniques and supporting tools for modelling Web systems, which
	has led to the adaptation to UML of several existing modelling languages,
	notations and development processes. This interest for being MOF
	and UML-compliant arises from the increasing need to interoperate
	with other notations and tools, and to exchange data and models,
	thus facilitating reuse. WebML, like any other domain-specific language,
	allows one to express in a precise and natural way the concepts and
	mechanisms of its domain of reference. However, it cannot fully interoperate
	with other notations, nor be integrated with other model-based tools.
	As a solution to these requirements, a UML 2.0 profile for WebML
	which allows WebML models to be used in conjunction with other notations
	and modelling tools has been described. The paper also evaluates
	UML 2.0 as a platform for Web modelling and identifies some key requirements
	for making this version of the standard more usable. © The Institution
	of Engineering and Technology 2007.},
  affiliation = {Department of Lenguajes y Ciencias de la Computación, University of
	Málaga, Spain; Dipartimento di Elettronica e Informazione, Politecnico
	di Milano, Milano, Italy},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-34250770028&partnerID=40&md5=aeeb985ac3be68f8bde2617ff7815ccf}
}

@CONFERENCE{Moreno2006,
  author = {Moreno, N.a , Fraternalli, P.b , Vallecillo, A.a },
  title = {A UML 2.0 profile for WebML modeling},
  year = {2006},
  volume = {155},
  note = {cited By (since 1996) 1},
  abstract = {In recent years, we have witnessed how the Web Engineering community
	considers the use of standard UML notation, techniques and supporting
	tools for modeling Web systems, including the adaptation of their
	own modeling languages, representation diagrams and development processes
	to UML. This interest for being MOF and UML-compliant arises from
	the increasing need to be able to interoperate with other notations
	and tools, and to exchange data and models, thus facilitating and
	improving reuse. WebML, like any other Domain Specific Language (DSL),
	allows to express in a precise and natural way the concepts and mechanisms
	of its domain of reference. However, it cannot fully interoperate
	with other notations, nor can it be integrated with other tools.
	As a solution to these requirements, in this paper we describe a
	UML 2.0 profile for WebML which allows WebML models to be used in
	conjunction with other notations and modeling tools.},
  affiliation = {Dept. Lenguajes y Ciencias de la Computacion, University of Malaga,
	Malaga, Spain; Dipartimento di Elettronica e Informazione, Politecnico
	di Milano, Milano, Italy},
  art_number = {1149998},
  author_keywords = {Metamodels; UML; UML profiles; WebML},
  document_type = {Conference Paper},
  journal = {ACM International Conference Proceeding Series},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-34547296377&partnerID=40&md5=a90506999b39bf80f6584282be5b0e4d}
}

@ARTICLE{Moreno-Ger2009564,
  author = {Moreno-Ger, P., Fuentes-Fernández, R., Sierra-Rodríguez, J.-L., Fernández-Manjón,
	B.},
  title = {Model-checking for adventure videogames},
  journal = {Information and Software Technology},
  year = {2009},
  volume = {51},
  pages = {564-580},
  number = {3},
  note = {cited By (since 1996) 1},
  abstract = {This paper describes a model-checking approach for adventure games
	focusing on 〈e-Adventure〉, a platform for the development of adaptive
	educational adventure videogames. In 〈e-Adventure〉, games are described
	using a domain-specific language oriented to game writers. By defining
	a translation from this language to suitable state-based models,
	it is possible to automatically extract a verification model for
	each 〈e-Adventure〉 game. In addition, temporal properties to be verified
	are described using an extensible assertion language, which can be
	tailored to each specific application scenario. When the framework
	determines that some of these properties do not hold, it generates
	an animation of a counterexample. This approach facilitates the collaboration
	of multidisciplinary teams of experts during the verification of
	the integrity of the game scripts, exchanging hours of manual verification
	for semi-automatic verification processes that also facilitate the
	diagnosis of the conditions that may potentially break the games.
	© 2008 Elsevier B.V. All rights reserved.},
  affiliation = {Dpto. Ingeniería del Software e Inteligencia Artificial, Facultad
	de Informática, Universidad Complutense de Madrid, 28040 Madrid,
	Spain},
  author_keywords = {Adventure games; Domain-specific languages; Model-checking; Temporal
	properties; Verification of games},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-57849090002&partnerID=40&md5=089c98936da5b6a96cae42b18a837b54}
}

@ARTICLE{Moreno-Ger2006153,
  author = {Moreno-Ger, P.a , Martínez-Ortiz, I.b , Sierra, J.L.a , Fernández-Manjón,
	B.a },
  title = {Language-driven development of videogames: The 〈e-game〉 experience},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2006},
  volume = {4161 LNCS},
  pages = {153-164},
  note = {cited By (since 1996) 0},
  abstract = {In this paper we describe a language-driven approach to the development
	of videogames. In our approach the development process starts with
	the design of a suitable domain-specific language for building games,
	along with an abstract syntax for the language and its operational
	semantics. Next an engine supporting the language is built. Finally
	games are built using the customized language and they are executed
	using the engine. This approach is exemplified with the 〈e-Game〉
	project, which delivers the design of a language and the construction
	of an engine for the documental development of graphical adventure
	videogames with educational purposes. © IFIP International Federation
	for Information Processing 2006.},
  affiliation = {Fac. Informática, Universidad Complutense, 28040, Madrid, Spain; Centro
	de Estudios Superiores Felipe II., 28300, Aranjuez, Spain},
  author_keywords = {Adventure games; Development process; Document-oriented approach;
	Edutainment; Game engine; Languagedriven approach; Storyboard markup
	language; Videogames},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-33750065388&partnerID=40&md5=f8353c730298523cab5fc2dfd4d92069}
}

@CONFERENCE{Morgan200763,
  author = {Morgan, C., De Volder, K., Wohlstadter, E.},
  title = {A static aspect language for checking design rules},
  year = {2007},
  volume = {208},
  pages = {63-72},
  note = {cited By (since 1996) 1},
  abstract = {Design rules express constraints on the behavior and structure of
	a program. These rules can help ensure that a program follows a set
	of established practices, and avoids certain classes of errors.Design
	rules often crosscut program structure and enforcing them is emerging
	as an important application domain for Aspect Oriented Programming.
	For many interesting design rules, current general purpose AOP languages
	lack the expressiveness to characterize them statically and enforce
	them at compile time.We have developed a domain specific language
	called Program Description Logic (PDL). PDL allows succinct declarative
	definitions of programmatic structures which correspond to design
	rule violations. PDL is based on a fully static and expressive pointcut
	language. PDL pointcuts allow characterizing a wide range of design
	rules without sacrificing static verification.We evaluate PDL by
	comparing it to FxCop, an industrial strength tool for checking design
	rules. Copyright 2007 ACM.},
  affiliation = {University of British Columbia},
  author_keywords = {Aspect-oriented programming; Design rule},
  document_type = {Conference Paper},
  journal = {ACM International Conference Proceeding Series},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-34548288988&partnerID=40&md5=bb08fe06ce58fccb3053c8ec4789730c}
}

@CONFERENCE{Morihata2008,
  author = {Morihata, A., Matsuzaki, K., Takeichi, M.},
  title = {Write it recursively: A generic framework for optimal path queries},
  year = {2008},
  pages = {169-178},
  note = {cited By (since 1996) 1},
  abstract = {Optimal path queries are queries to obtain an optimal path specified
	by a given criterion of optimality. There have been many studies
	to give efficient algorithms for classes of optimal path problem.
	In this paper, we propose a generic framework for optimal path queries.
	We offer a domain-specific language to describe optimal path queries,
	together with an algorithm to find an optimal path specified in our
	language. One of the most distinct features of our framework is the
	use of recursive functions to specify queries. Recursive functions
	reinforce expressiveness of our language so that we can describe
	many problems including known ones; thus, we need not learn existing
	results. Moreover, we can derive an efficient querying algorithm
	from the description of a query written in recursive functions. Our
	algorithm is a generalization of existing algorithms, and answers
	a query in O(n log n) time on a graph of O(n) size. We also explain
	our implementation of an optimal path querying system, and report
	some experimental results. Copyright © 2008 ACM.},
  affiliation = {Graduate School of Information Science and Technology, University
	of Tokyo, Japan},
  author_keywords = {Finite state automaton; Optimal path query; Program transformation;
	Recursive function},
  document_type = {Conference Paper},
  journal = {Proceedings of the ACM SIGPLAN International Conference on Functional
	Programming, ICFP},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-59249100209&partnerID=40&md5=f85ad5a775107ce14cf5108d80d9722d}
}

@ARTICLE{Morihata2008169,
  author = {Morihata, A., Matsuzaki, K., Takeichi, M.},
  title = {Write it recursively: A generic framework for optimal path queries},
  journal = {ACM SIGPLAN Notices},
  year = {2008},
  volume = {43},
  pages = {169-178},
  number = {9},
  note = {cited By (since 1996) 0},
  abstract = {Optimal path queries are queries to obtain an optimal path specified
	by a given criterion of optimality. There have been many studies
	to give efficient algorithms for classes of optimal path problem.
	In this paper, we propose a generic framework for optimal path queries.
	We offer a domain-specific language to describe optimal path queries,
	together with an algorithm to find an optimal path specified in our
	language. One of the most distinct features of our framework is the
	use of recursive functions to specify queries. Recursive functions
	reinforce expressiveness of our language so that we can describe
	many problems including known ones; thus, we need not learn existing
	results. Moreover, we can derive an efficient querying algorithm
	from the description of a query written in recursive functions. Our
	algorithm is a generalization of existing algorithms, and answers
	a query in O(n log n) timeonagraphof O(n) size. We also explain our
	implementation of an optimal path querying system, and report some
	experimental results. Copyright © 2008 ACM.},
  affiliation = {Graduate School of Information Science and Technology, University
	of Tokyo, Japan},
  author_keywords = {Finite state automaton; Optimal path query; Program transformation;
	Recursive function},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-67650088260&partnerID=40&md5=b4a1ca55aa861dcae52089e39c33ace3}
}

@ARTICLE{Morin2009690,
  author = {Morin, B.a , Perrouin, G.b , Lahire, P.c , Barais, O.a d , Vanwormhoudt,
	G.e , Jézéquel, J.-M.a d },
  title = {Weaving variability into domain metamodels},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2009},
  volume = {5795 LNCS},
  pages = {690-705},
  note = {cited By (since 1996) 5},
  abstract = {Domain-Specific Modeling Languages (DSMLs) describe the concepts of
	a particular domain and their relationships, in a metamodel. From
	a given DSML, it is possible to describe a wide range of different
	models. These models often share a common base and vary on some parts.
	Current approaches tend to distinguish the variability language from
	the DSMLs themselves, implying greater learning curve for DSMLs stakeholders
	and a significant overhead in product line engineering of DSMLs.
	We propose to consider variability as an independent aspect to be
	woven into the DSML to introduce variability capabilities. In particular
	we detail how variability is woven and how to perform product line
	derivation. We validate our approach through the weaving of variability
	into two very different metamodels: Ecore and SmartAdapter, our Aspect-Oriented
	modeling weaver, thus adding flexibility in the weaving process itself.
	These results emphasize how new abilities of the language can be
	provided by this means. © 2009 Springer Berlin Heidelberg.},
  affiliation = {INRIA, Centre Rennes - Bretagne Atlantique, Equipe Triskell, F-35042
	Rennes Cedex, France; LASSY, University of Luxembourg, L-1359 Luxembourg-Kirchberg,
	Luxembourg; I3S Nice-Sophia Antipolis, Equipe Rainbow, F-06903 Sophia-Antipolis
	Cedex, Guadeloupe; IRISA, Université de Rennes1, Equipe Triskell,
	F-35042 Rennes Cedex, France; Institut Telecom, LIFL, Université
	de Lille 1, F-59655 Villeneuve d'Ascq Cedex, France},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-77249123516&partnerID=40&md5=d3439cc75ade80366f7dd5fff6c6ce3d}
}

@ARTICLE{Moss200547,
  author = {Moss, A., Muller, H.},
  title = {Efficient code generation for a domain specific language},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2005},
  volume = {3676 LNCS},
  pages = {47-62},
  note = {cited By (since 1996) 0},
  abstract = {We present a domain-specific-language (DSL) for writing instances
	of a class of filter programs. The values in the language are symbolic
	and independent of a concrete precision. Efficient code generation
	is required to fit the program onto a target device limited in both
	memory and processing power. We construct an interpreter for the
	DSL in a language specific to the device which contains the semantics
	of the target instruction set embedded within a declarative meta-language.
	The compiler is automatically generated from the interpreter through
	specialisation. This extension of the instruction set allows the
	construction of an interpreter for the DSL that is both simple and
	clear. In particular it allows us to declare static representations
	of the symbolic values, and have the specialisation of the code produce
	operate upon these values in the instruction set of the target device.
	© Springer-Verlag Berlin Heidelberg 2005.},
  affiliation = {Department of Computer Science, University of Bristol},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-33646130844&partnerID=40&md5=b77b5d9cf6d5f4e81b41e9cf7d527f32}
}

@CONFERENCE{Moss200931,
  author = {Moss, A., Page, D.},
  title = {Program interpolation},
  year = {2009},
  pages = {31-40},
  note = {cited By (since 1996) 0},
  abstract = {Program interpolation is a new type of transformation that given an
	input program written in a specially constructed Domain Specific
	Language(DSL), produces a family of functionally equivalent instruction
	sequences as output. Each sequence is an "interpolation" between
	the control-flows of implementation strategies supplied in the input
	program. The purpose of the transformation is to expose behavioural
	differences (e.g. performance) within the sequences, and thus allow
	automated optimisation with respect to architectural trade-offs that
	are difficult to quantify and model. We present results from a prototype
	compiler that demonstrate a 63% speedup in the domain of multi-precision
	integer arithmetic. © 2009 ACM.},
  affiliation = {University of Bristol},
  author_keywords = {Dynamic feedback; Program interpolation; Program optimization},
  document_type = {Conference Paper},
  journal = {Proceedings of the 2009 ACM SIGPLAN Symposium on Partial Evaluation
	and Program Manipulation, PEPM'09},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-67650697494&partnerID=40&md5=684f7e96848ac69e82c219a6b59ec96a}
}

@CONFERENCE{Motal2009150,
  author = {Motal, T., Zapletal, M., Werthner, H.},
  title = {The business choreography language (BCL) - A domain-specific language
	for global choreographies},
  year = {2009},
  number = {PART 2},
  pages = {150-159},
  note = {cited By (since 1996) 0},
  abstract = {UN/CEFACT's Modeling Methodology (UMM) is a modeling approach for
	describing the choreography of B2B processes. UMM is developed by
	the United Nations Center for Trade Facilitation and Electronic Business
	(UN/CEFACT) and currently defined as a UML profile. Thereby, it constrains
	the UML for the specific needs of B2B. As we learned, using UML as
	the underlying notation for UMM results in several shortcomings.
	Furthermore, some workarounds are required to fit the concepts of
	UMM to the UML meta model. Thus, in this paper we examine an alternative
	notation for UMM following the concepts of a domain-specific language
	(DSL). The contribution of this paper is twofold: (i) we identify
	general concepts for modeling global choreographies by taking UMM
	as a starting point. (ii) We introduce the Business Choreography
	Language (BCL), a domain-specific language designed to efficiently
	support the prior identified concepts. The concepts of the BCL are
	exemplified by an implementation using the Microsoft DSL Tools for
	Visual Studio. In fact, the BCL is an approach tailored to support
	the specific needs of global B2B choreographies. © 2009 IEEE.},
  affiliation = {Vienna University of Technology, Favoritenstrasse 9-11/188, A-1040
	Vienna, Austria},
  art_number = {5305975},
  document_type = {Conference Paper},
  journal = {SERVICES 2009 - 5th 2009 World Congress on Services},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-72449168436&partnerID=40&md5=c49c2587352e7f9fbb4cfd9f5ecf406c}
}

@ARTICLE{Mount2009293,
  author = {Mount, S., Hammoudeh, M., Wilson, S., Newman, R.},
  title = {CSP as a domain-specific language embedded in python and jython},
  journal = {Concurrent Systems Engineering Series},
  year = {2009},
  volume = {67},
  pages = {293-309},
  note = {cited By (since 1996) 0},
  abstract = {Recently, much discussion has taken place within the Python programming
	community on how best to support concurrent programming. This paper
	describes a new Python library, python-csp, which implements synchronous,
	message-passing concurrency based on Hoare's Communicating Sequential
	Processes. Although other CSP libraries have been written for Python,
	python-csp has a number of novel features. The library is implemented
	both as an object hierarchy and as a domain-specific language, meaning
	that programmers can compose processes and guards using infix operators,
	similar to the original CSP syntax. The language design is intended
	to be idiomatic Python and is therefore quite different to other
	CSP libraries. python-csp targets the CPython interpreter and has
	variants which reify CSP process as Python threads and operating
	system processes. An equivalent library targets the Jython interpreter,
	where CSP processes are reified as Java threads. jython-csp also
	has Java wrappers which allow the library to be used from pure Java
	programs. We describe these aspects of python-csp, together with
	performance benchmarks and a formal analysis of channel synchronisation
	and choice, using the model checker SPIN. Copyright © 2009 The authors
	and IOS Press.},
  affiliation = {School of Computing and I.T., University of Wolverhampton, Wulfruna
	St., Wolverhampton, WV1 1SB, United Kingdom},
  author_keywords = {CSP; Domain-specific languages; Dynamic languages; Python},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-78649577039&partnerID=40&md5=017dc4ebdf649df2680d6ba68b4276b8}
}

@ARTICLE{Muller2003370,
  author = {Muller, G.a , Lawall, J.L.b , Thibault, S.c , Jensen, R.E.V.a },
  title = {A domain-specific language approach to programmable networks},
  journal = {IEEE Transactions on Systems, Man and Cybernetics Part C: Applications
	and Reviews},
  year = {2003},
  volume = {33},
  pages = {370-381},
  number = {3},
  note = {cited By (since 1996) 1},
  abstract = {Active networks present significant safety, security, and efficiency
	challenges. Domain-specific languages, i.e., languages providing
	only constructs relevant to a particular domain, provide a solution
	that balances these constraints. Safety and security can be ensured
	using verification techniques that exploit the restricted nature
	of such languages. Strategies have been developed for the compilation
	of domain-specific languages that provide both portability and efficiency.
	This paper presents a synthesis of work on the PLAN-P domain-specific
	language for programmable routers. We present the language design,
	representative experiments that have been carried out using the language,
	and new compilation strategies. End-to-end performance is typically
	comparable to that of hand-coded C implementations.},
  affiliation = {Ecole des Mines de Nantes, 44307 Nantes, France; University of Copenhagen,
	2100 Copenhagen, Denmark; Green Mountain Computing Syst., Inc., Richmond,
	VA 23200, United States},
  author_keywords = {High-level languages; Networks; Program compilers; Routing},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-0242365679&partnerID=40&md5=f35d5221a97cf6f170c588a0a7319a0c}
}

@ARTICLE{Muller2005264,
  author = {Muller, P.-A., Fleurey, F., Jean-Marc, J.},
  title = {Weaving executability into object-oriented meta-languages},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2005},
  volume = {3713 LNCS},
  pages = {264-278},
  note = {cited By (since 1996) 47},
  abstract = {Nowadays, object-oriented meta-languages such as MOF (Meta-Object
	Facility) are increasingly used to specify domain-specific languages
	in the model-driven engineering community. However, these meta-languages
	focus on structural specifications and have no built-in support for
	specifications of operational semantics. In this paper we explore
	the idea of using aspect-oriented modeling to add precise action
	specifications with static type checking and genericity at the meta
	level, and examine related issues and possible solutions. We believe
	that such a combination would bring significant benefits to the community,
	such as the specification, simulation and testing of operational
	semantics of metamodels. We present requirements for such statically-typed
	meta-languages and rationales for the aforementioned benefits. ©
	Springer-Verlag Berlin Heidelberg 2005.},
  affiliation = {IRISA / INRIA Rennes, Campus Universitaire de Beaulieu, Avenue du
	General Leclerc, 35042 RENNES Cedex, France},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-33646181776&partnerID=40&md5=e2372f690b90dbb43af6eaca069ed26e}
}

@CONFERENCE{Mulo201062,
  author = {Mulo, E., Zdun, U., Dustdar, S.},
  title = {An event view model and DSL for engineering an event-based SOA monitoring
	infrastructure},
  year = {2010},
  pages = {62-72},
  note = {cited By (since 1996) 0},
  abstract = {An event-based solution that uses events to convey information to
	a monitoring tool is well suited to implementing a non-intrusive
	monitoring infrastructure. This enables an SOA system's stakeholders
	to observe the system aspects of interest to them. However, implementation
	of SOA today, let alone the monitoring infrastructure, is a complex
	task due to the heterogeneous environment consisting of multiple
	technologies, platforms and components. We propose an approach for
	implementing such an event-based SOA monitoring infrastructure, that
	introduces a dedicated event view model and an eventing domain-specific
	language in a model-driven framework. The event view model captures
	SOA artifacts and links them with the event domain, while the eventing
	domain-specific language enables a system developer to specify instances
	of the event view model. With our model-driven approach, most of
	the runtime monitoring infrastructure is generated. These two ingredients
	(view model and domain-specific language) focus implementation efforts
	on the concern of eventing, thereby helping to manage complexity.
	We apply and evaluate our approach in the context of a case study.
	© 2010 ACM.},
  affiliation = {Distributed Systems Group, Institute of Information Systems, Vienna
	University of Technology, Vienna, Austria},
  author_keywords = {domain-specific language; event-based; model-driven software development;
	monitoring; service-oriented architecture},
  document_type = {Conference Paper},
  journal = {Proceedings of the 4th ACM International Conference on Distributed
	Event-Based Systems, DEBS 2010},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-77955793012&partnerID=40&md5=841587bfbb1041b9c6b0893eeba86c90}
}

@CONFERENCE{Munnelly2008757,
  author = {Munnelly, J., Clarke, S.},
  title = {A domain-specific language for ubiquitous healthcare},
  year = {2008},
  volume = {2},
  pages = {757-762},
  note = {cited By (since 1996) 0},
  abstract = {The development of ubiquitous healthcare applications has proved to
	be significantly more complex than traditional healthcare applications.
	In software engineering research, there are two approaches of interest
	to us for handling the kind of complexcity that emerges. The first
	is the use of domain-specific languages, which abstracts the low
	level domain knowledge required when using general-purpose programming
	languages into more expressive domain-specific constructs. The second
	is advanced modularity techniques, such as aspect-oriented programming,
	that provide for modularization of concerns that complicate code
	by cutting across a broad code base and tangling with other concerns.
	In this paper, we identify a set of ubiquitous healthcare concerns
	that complicate their software development. We use advanced modularity
	techniques to provide good separation of these concerns and encapsulate
	their behaviour within a new domain-specific language, ALPH that
	provides the application developer with a high level of abstraction.
	The result is a means to develop ubiquitous healthcare applications
	more easily and in a more timely fashion, while improving software
	quality by increasing modularity in the code.© 2008 IEEE.},
  affiliation = {Trinity College, Dublin},
  art_number = {4783710},
  author_keywords = {Domain specific languages; Programming languages; Ubiquitous healthcare},
  document_type = {Conference Paper},
  journal = {2008 3rd International Conference on Pervasive Computing and Applications,
	ICPCA08},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-64049097912&partnerID=40&md5=a836863f55d123191326fe94a84da571}
}

@CONFERENCE{Munnelly2007,
  author = {Munnelly, J., Clarke, S.},
  title = {ALPH: A domain-specific language for crosscutting pervasive healthcare
	concerns},
  year = {2007},
  note = {cited By (since 1996) 0},
  abstract = {Pervasive healthcare is an advancing discipline that applies ubiquitous
	computing features to applications deployed in the healthcare domain.
	In these applications, ubiquitous computing concerns and health informatics
	concerns are entwined with base functionality resulting in significant,
	complex crosscutting code. Domainspecific languages (DSLs) can reduce
	development effort by providing higher level programming abstractions
	for domain-specific functionality. We introduce ALPH (Aspect Language
	for Pervasive Healthcare); a DSL that provides domain-specific constructs
	for tasks and entities within the pervasive healthcare domain. The
	DSL is translated into an aspect language and the crosscutting behaviour
	is weaved. We describe an example implementation to illustrate the
	level of abstraction that can be achieved using domain-specific constructs.
	Copyright © 2007 ACM.},
  affiliation = {Distributed Systems Group, Trinity College Dublin},
  art_number = {4},
  author_keywords = {ALPH; Aspect-oriented programming; Domain-specific languages; Pervasive
	healthcare},
  document_type = {Conference Paper},
  journal = {DSAL'07: Second Workshop on Domain-Specific Aspect Languages},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-35448985788&partnerID=40&md5=991109edf6d34f302509816a4659a169}
}

@ARTICLE{Musat201048,
  author = {Musat, D.a , Castaño, V.a b , Calvo-Manzano, J.A.a , Garbajosa, J.a
	},
  title = {MATURE: A model driven based tool to automatically generate a language
	that supports CMMI process areas specification},
  journal = {Communications in Computer and Information Science},
  year = {2010},
  volume = {99 CCIS},
  pages = {48-59},
  note = {cited By (since 1996) 0},
  abstract = {Many companies have achieved a higher quality in their processes by
	using CMMI. Process definition may be efficiently supported by software
	tools. A higher automation level will make process improvement and
	assessment activities easier to be adapted to customer needs. At
	present, automation of CMMI is based on tools that support practice
	definition in a textual way. These tools are often enhanced spreadsheets.
	In this paper, following the Model Driven Development paradigm (MDD),
	a tool that supports automatic generation of a language that can
	be used to specify process areas practices is presented. The generation
	is performed from a metamodel that represents CMMI. This tool, differently
	from others available, can be customized according to user needs.
	Guidelines to specify the CMMI metamodel are also provided. The paper
	also shows how this approach can support other assessment methods.
	© 2010 Springer-Verlag Berlin Heidelberg.},
  affiliation = {Technical University of Madrid (UPM), Madrid, Spain; International
	Center for Numerical Methods in Engineering (CIMNE), Spain},
  author_keywords = {Capability Maturity Model Integration (CMMI); Domain Specific Language
	(DSL); Domain Specific Model (DSM); Model Driven Architecture (MDA);
	Model Driven Development (MDD); Spice ISO/IEC 15504},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-77957565866&partnerID=40&md5=87c4208a4649379fdc3d0a14f4160d32}
}

@CONFERENCE{Muscar2011380,
  author = {Muscar, A., Bǎdicǎ, C.},
  title = {A functional approach to agent development: Research agenda},
  year = {2011},
  pages = {380-385},
  note = {cited By (since 1996) 0},
  abstract = {A vast array of solutions for developing multiagent systems has been
	proposed over the past decades. While every solution has its strong
	points, a trade-off has to be made between expressivity and generality.
	It is our opinion that by embedding an agent development language
	in a general purpose functional language we can obtain a solution
	that can address this gap. In this paper we present our approach
	on developing a complete solution for implementing multi-agent systems.
	We motivate our claims about embedded domain specific languages by
	means of an example. We also expand on the future directions of our
	research regarding workflow-oriented coordination and organizational
	aspects in multi-agent systems. © 2011 IEEE.},
  affiliation = {Software Engineering Department, University of Craiova, Romania},
  art_number = {6032268},
  author_keywords = {MAS; Multiagent systems; Programming languages; Software; Software
	agents},
  document_type = {Conference Paper},
  journal = {Proceedings - International Computer Software and Applications Conference},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-80054996712&partnerID=40&md5=05d84a2914d3cf7b745acc9fb8e44de0}
}

@CONFERENCE{Muñoz2005342,
  author = {Muñoz, J., Pelechano, V.},
  title = {Building a Software Factory for pervasive systems development},
  year = {2005},
  volume = {3520},
  pages = {342-356},
  note = {cited By (since 1996) 4},
  abstract = {The rise of the number and complexity of pervasive systems is a fact.
	Pervasive systems developers need advanced development methods in
	order to build better systems in an easy way. Software Factories
	and the Model Driven Architecture (MDA) are two important trends
	in the software engineering field. This paper applies the guidelines
	and strategies described by these proposals in order to build a methodological
	approach for pervasive systems development. Software Factories are
	based on the definition of software families supported by frameworks.
	Individual systems requirements are specified by means of domain
	specific languages. Following this strategy, our approach defines
	a framework and a domain specific language for pervasive systems.
	We use the MDA guidelines to support the development of our domain
	specific language and the automatic generation of the specific source
	code of a particular system. The approach presented in this paper
	raises the abstraction level in the development of pervasive systems
	and provides high reusable assets to reduce the effort in the development
	projects. © Springer-Verlag Berlin Heidelberg 2005.},
  affiliation = {Departamento de Sistemas Informáticos y Computación, Universidad Politécnica
	de Valencia, Camí de Vera s/n, E-46022, Spain},
  document_type = {Conference Paper},
  journal = {Lecture Notes in Computer Science},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-25144456434&partnerID=40&md5=a891fa0c5c9af7948003e7d88c60036a}
}

@CONFERENCE{Mäkelä2010509,
  author = {Mäkelä, J.-M., Leppänen, V.},
  title = {SMASim: A cycle-accurate scalable multi-core architecture simulator},
  year = {2010},
  volume = {1},
  pages = {509-514},
  note = {cited By (since 1996) 0},
  abstract = {The computer industry has tried to mitigate the problem of achieving
	computationally more efficient hardware on three fronts: increasing
	the execution speed by increasing the operating frequency, decreasing
	the amount of required time to issue a single instruction by enhancing
	instruction level parallelism (ILP), and increasing the "computational
	volume" by adding more computational units. Developing complete physical
	architectures or even experimental FPGA prototypes has turned out
	to be expensive and to require relatively great amount of resources.
	Software archtitecture simulators are seen as an efficient way of
	lowering these costs. SMASim is a software based simulator, motivated
	by an experimental moving threads architecture that attempts to lower
	the costs of rapidly designing new architectures. It is based on
	a general purpose, cycle-accurate event-driven message passing framework
	between the described hardware architecture elements. Its relatively
	simple cost model captures the essential properties of many hardware
	designs. The simulator's design allows easy monitoring of the system
	and provides execution performance comparable to other cycle-accurate
	hardware simulators. The focus on SMASim has been to speed up declaring
	new target architectures with expressive domain specific notations
	and to decrease the amount of design errors with the static type
	checker of the implementation language. As a result, the implementation
	supports modular architecture descriptions on various granularity
	levels. A graphical user interface is provided to simplify the task
	of modifying parameters of a simulated system and to provide interactive
	feedback.},
  affiliation = {University of Turku, Department of Information Technology, Joukahaisenkatu
	3-5 B, 20520 Turku, Finland},
  author_keywords = {Cycle-accurate; Domain specific language; Multi-core; Simulator},
  document_type = {Conference Paper},
  journal = {WCE 2010 - World Congress on Engineering 2010},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-79959855206&partnerID=40&md5=4dd54de0f90ab16879ffea5759f58084}
}

@ARTICLE{Mérillon2001121,
  author = {Mérillon, F., Muller, G.},
  title = {Dealing with hardware in embedded software: A general framework based
	on the devil language},
  journal = {SIGPLAN Notices (ACM Special Interest Group on Programming Languages)},
  year = {2001},
  volume = {36},
  pages = {121-127},
  number = {8},
  note = {cited By (since 1996) 3},
  abstract = {Writing code that talks to hardware is a crucial part of any embedded
	project. Both productivity and quality are needed, but some flaws
	in the traditional development process make these requirements difficult
	to meet. We have recently introduced a new approach of dealing with
	hardware, based on the Devil language. Devil allows to write a high-level,
	formal definition of the programming interface of a peripheral circuit.
	A compiler automatically checks the consistency of a Devil specification,
	from which it generates the low-level, hardware-operating code. In
	our original framework, the generated code is dependent of the host
	architecture (CPU, buses, and bridges). Consequently, any variation
	in the hardware environment requires a specific tuning of the compiler.
	Considering the variability of embedded architectures, this is a
	serious drawback. In addition, this prevents from mixing different
	buses in the same circuit interface. In this paper, we remove those
	limitations by improving our framework in two ways. (i) We propose
	a better isolation between the Devil compiler and the host architecture.
	(ii) We introduce Trident, a language extension aimed at mapping
	one or several buses to each peripheral circuit. Copyright ACM 2001.},
  affiliation = {Compose Group, IRISA/LaBRI},
  author_keywords = {B.4[Hardware]: Input/Output and Data communications; D.3[Software]:
	Programming Languages; Design; Device Drivers; Domain-Specific Languages;
	Embedded Systems; Languages},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-17244372012&partnerID=40&md5=d7925939292d63d0753e7a93a60b34d1}
}

@CONFERENCE{Mészáros2008309,
  author = {Mészáros, T., Mezei, G., Levendovszky, T.},
  title = {A flexible, declarative Presentation Framework for Domain-Specific
	Modeling},
  year = {2008},
  pages = {309-312},
  note = {cited By (since 1996) 2},
  abstract = {Domain-Specific Modeling has gained increasing popularity in software
	modeling. Domain-Specific Modeling Languages can simplify the design
	and the implementation of systems in various domains. Consequent
	domain specific visualization helps to understand the models for
	domain specialists. However, the efficiency of domain-specific modeling
	is often determined by the limited capabilities - i.e. the lack of
	interactive design elements, low customization facilities - of the
	editor applications. This paper introduces the Presentation Framework
	of Visual Modeling and Transformation System, the framework provides
	a flexible environment for model visualization and provides a declarative
	solution for appearance description as well. Copyright 20048 ACM.},
  affiliation = {Budapest University of Technology and Economics, Goldman György tér
	3., 1111 Budapest, Hungary},
  author_keywords = {Domain-Specific Modeling; Metamodeling; Model visualization; Modeling
	framework; Software modeling},
  document_type = {Conference Paper},
  journal = {Proceedings of the Workshop on Advanced Visual Interfaces AVI},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-57349175131&partnerID=40&md5=0c1dac8faffdc028242e9c5b0f1f55e6}
}

@ARTICLE{Møller200517,
  author = {Møller, A., Schwartzbach, M.I.},
  title = {The design space of type checkers for XML transformation languages},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2005},
  volume = {3363 LNCS},
  pages = {17-36},
  note = {cited By (since 1996) 9},
  abstract = {We survey work on statically type checking XML transformations, covering
	a wide range of notations and ambitions. The concept of type may
	vary from idealizations of DTD to full-blown XML Schema or even more
	expressive formalisms. The notion of transformation may vary from
	clean and simple transductions to domain-specific languages or integration
	of XML in general-purpose programming languages. Type annotations
	can be either explicit or implicit, and type checking ranges from
	exact decidability to pragmatic approximations. We characterize and
	evaluate existing tools in this design space, including a recent
	result of the authors providing practical type checking of full unannotated
	XSLT 1.0 stylesheets given general DTDs that describe the input and
	output languages. © 2005 Springer-Verlag.},
  affiliation = {BRICS, University of Aarhus, Denmark},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-77049092342&partnerID=40&md5=ea5ae8979baa02fda0eee38126586801}
}

@CONFERENCE{Mühlbach20119,
  author = {Mühlbach, S.a , Koch, A.b },
  title = {A novel network platform for secure and efficient malware collection
	based on reconfigurable hardware logic},
  year = {2011},
  pages = {9-14},
  note = {cited By (since 1996) 0},
  abstract = {With the growing diversity of malware, researchers must be able to
	quickly collect many representative samples for study. This can be
	done, e.g., by using honeypots. As an alternative to software-based
	honeypots, we propose a singlechip honeypot appliance that is entirely
	hardware-based and thus significantly more resilient against compromising
	attacks. Additionally, it can easily keep up with network speeds
	of 10+ Gb/s and emulate thousands of vulnerable hosts. As base technology,
	we employ reconfigurable hardware devices whose functionality is
	not fixed by the manufacturing process. We present improvements to
	the platform, aiming to simplify management and updates. To this
	end, we introduce the domain-specific language VEDL, which can be
	used to describe the honeypot behavior in a highlevel manner by security
	experts not proficient in hardware design. © 2011 WorldCIS.},
  affiliation = {Secure Things Group, Center for Advanced Security Research Darmstadt
	(CASED), Germany; Embedded Systems and Applications Group, Dept.
	of Computer Science, Technische Universität Darmstadt, Germany},
  art_number = {5749873},
  document_type = {Conference Paper},
  journal = {World Congress on Internet Security, WorldCIS-2011},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-79955920754&partnerID=40&md5=cfc9faf239155cde042b39fccb8e1d66}
}

@ARTICLE{Müller2009165,
  author = {Müller, C., Ruiz-Cortés, A., Fernández, P.},
  title = {Temporal-awareness in SLAs: Why should we be concerned?},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2009},
  volume = {4907 LNCS},
  pages = {165-173},
  note = {cited By (since 1996) 1},
  abstract = {Traditionally, Service Level Agreements have been decomposed in two
	sets of properties: functionals (what) and non-functionals (how).
	However, in our opinion, there has been a third key element that
	has had a minor attention from academy: temporal awareness (when).
	We believe temporality is a main concern that should be addressed
	in realistic scenarios. In doing so, this position paper discuss
	our experience in extending the specification WS-Agreement with a
	temporal Domain Specific Language; importantly, main aim of the paper
	is to provoke a debate about the importance of temporality in SLAs.
	© 2009 Springer Berlin Heidelberg.},
  affiliation = {Dpto. Lenguajes y Sistemas Informáticos ETS. Ingeniería Informática,
	Universidad de Sevilla (Spain - España), Sevilla 41012, Spain},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-60349117611&partnerID=40&md5=cc75d955175774eb79301a32958b913c}
}

@ARTICLE{Naixiao199753,
  author = {Naixiao, Z.a , Hongjun, Z.b , Zongyan, Q.a },
  title = {Garment: A Mechanism for Abstraction and Encapsulation of Languages},
  journal = {SIGPLAN Notices (ACM Special Interest Group on Programming Languages)},
  year = {1997},
  volume = {32},
  pages = {53-60},
  number = {6},
  note = {cited By (since 1996) 1},
  abstract = {Domain-specific languages are closely related to interface languages
	of domain-oriented software. Thus, the specifications of such software
	can be abstracted to specifications of language systems, and implementation
	of such software can be abstracted to implementation of the language
	systems. As a unified model to support software development and research,
	a mechanism named Garment for abstracting and encapsulating languages
	is proposed. Garment provides a unified framework for defining languages
	(syntax and semantics) and describing relations between languages
	(which are classified as inheritance, shielding and extension). Finally,
	an experimental environment, which supports software development
	with Garment, is introduced briefly.},
  affiliation = {Dept. of Information Sciences, School of Math. Sciences, Peking University,
	Beijing 100871, China; Dept. of Comp. Sci. and Technology, Peking
	University, Beijing 100871, China},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-0007928570&partnerID=40&md5=bb537917b8888f278904a331b98d2a21}
}

@CONFERENCE{Nakatsuka2010137,
  author = {Nakatsuka, M.a , Yasunaga, S.a , Kuwabara, K.b },
  title = {Extending a multilingual chat application: Towards collaborative
	language resource building},
  year = {2010},
  pages = {137-142},
  note = {cited By (since 1996) 0},
  abstract = {We are developing a multilingual chat application to help children
	in Japanese schools whose native language is not Japanese communicate
	with teachers and support staff. Our multilingual chat application
	utilizes machine translation to allow communication in their native
	languages. Since special words or expressions are used in school
	settings, a machine translation service often produces inadequate
	translations. To cope with such problems, Language Grid provides
	a machine translation service that utilizes specialized domain specific
	dictionaries to improve translation quality. However, constructing
	such dictionaries is not easy. In this paper, we present a system
	that helps users expand the dictionaries using morphological analysis
	in the chat application itself. In addition, we present other extensions
	to the system to further support multilingual communication and build
	language resources. © 2010 IEEE.},
  affiliation = {Graduate School of Science and Engineering, Ritsumeikan University,
	1-1-1 Noji-Higashi, Kusatsu-shi, Shiga-ken 525-8577, Japan; College
	of Information Science and Engineering, Ritsumeikan University, 1-1-1
	Noji-Higashi, Kusatsu-shi, Shiga-ken 525-8577, Japan},
  art_number = {5599751},
  document_type = {Conference Paper},
  journal = {Proceedings of the 9th IEEE International Conference on Cognitive
	Informatics, ICCI 2010},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-78649887120&partnerID=40&md5=9e0b0b180c9ea8a6c6b04a0e6a7aa2ed}
}

@ARTICLE{Narayanan2009706,
  author = {Narayanan, A., Levendovszky, T., Balasubramanian, D., Karsai, G.},
  title = {Automatic domain model migration to manage metamodel evolution},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2009},
  volume = {5795 LNCS},
  pages = {706-711},
  note = {cited By (since 1996) 5},
  abstract = {Metamodel evolution is a significant problem in domain specific software
	development for several reasons. Domain-specific modeling languages
	(DSMLs) are likely to evolve much more frequently than programming
	languages and commonly used software formalisms, often resulting
	in a large number of valuable instance models that are no longer
	compliant with the metamodel. In this paper, we present the Model
	Change Language (MCL), aimed at satisfying these requirements. ©
	2009 Springer Berlin Heidelberg.},
  affiliation = {Vanderbilt University, Nashville, TN 37235, United States},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-77249101471&partnerID=40&md5=28813d01f7af8d36061c135ee08709a0}
}

@CONFERENCE{Naumowicz2009369,
  author = {Naumowicz, T.a , Schröter, B.b , Schiller, J.a },
  title = {Poster abstract: Prototyping a software factory for wireless sensor
	networks},
  year = {2009},
  pages = {369-370},
  note = {cited By (since 1996) 2},
  abstract = {Wireless sensor networks (WSNs) are often advertised with high sensing
	accuracy, long lifetime, and easy deployment. However, they are still
	not widely used in environmental research due to of poor tool support
	and high complexity. A wider use of WSNs in field science would enable
	researchers to address scientific questions that are infeasible today.
	To address this issue, we designed and prototyped a Software Factory
	for WSNs that hides the complexity of software development for embedded
	systems. It exposes a visual domain-specific modeling language and
	supports code generation for resource constrained devices. The proposed
	Software Factory simplifies the integration of domain experts into
	the development process, making WSNs more attractive as a tool for
	researchers from outside of the computer science field. This could
	lead to a wider adoption of WSNs in field sciences.},
  affiliation = {Freie Universität Berlin, Institute of Computer Science, Takustr.
	9, 14195 Berlin, Germany; Microsoft Research, 7 JJ Thomson Ave, CB3
	0FB Cambridge, United Kingdom},
  author_keywords = {Domain-specific languages; Software factory; Wireless sensor networks},
  document_type = {Conference Paper},
  journal = {Proceedings of the 7th ACM Conference on Embedded Networked Sensor
	Systems, SenSys 2009},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-74549197058&partnerID=40&md5=850fa897f49b9864ad4e8bf822016760}
}

@ARTICLE{Navarro-Pérez20073,
  author = {Navarro-Pérez, J.A., Voronkov, A.},
  title = {Encodings of problems in effectively propositional logic},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2007},
  volume = {4501 LNCS},
  pages = {3},
  note = {cited By (since 1996) 0},
  abstract = {Solving various combinatorial problems by their translation to the
	propositional satisfiability problem has become commonly accepted.
	By optimising such translations and using efficient SAT solvers one
	can often solve hard problems in various domains, such as formal
	verification and planning. This approach to solving combinatorial
	problems is usually implemented by a translation procedure turning
	a formal description of the problem written in a domain-specific
	language L (for example, SMV for model checking problems [3] or STRIPS
	[2] for planning problems) into a SAT problem. Such translation procedures
	share the following common features: 1. They contain many isomorphic
	or nearly isomorphic subsets of clauses obtained by the translation
	of the same expression of L. 2. The size of the resulting SAT problem
	is dominated by these copies. In this talk the second author will
	present encodings able to specify some combinatorial problems, namely
	LTL bounded model checking [1] and planning within the Bernays-Schönfinkel
	fragment of first-order logic. This fragment, which also corresponds
	to the category of effectively propositional problems (EPR) of the
	CASC system competitions [4], allows a natural and succinct representation
	of both the transition systems corresponding to the problems and
	the property that one wants to verify, while avoiding the problem
	of creating isomorphic copies. Our technique provides a rich collection
	of benchmarks with close links to real-life applications for the
	automated reasoning community and may boost development of new translation
	techniques and solvers for effectively propositional problems. ©
	Springer-Verlag Berlin Heidelberg 2007.},
  affiliation = {University of Manchester, School of Computer Science},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-38049162220&partnerID=40&md5=25fa73075cc72debf68469d4ca8a6906}
}

@CONFERENCE{Naylor200737,
  author = {Naylor, M.a , Axelsson, E.b , Runciman, C.a },
  title = {A functional-logic library for wired},
  year = {2007},
  pages = {37-48},
  note = {cited By (since 1996) 3},
  abstract = {We develop a Haskell library for functional-logic programming, motivated
	by the implementation of Wired, a relational embedded domain-specific
	language for describing and analysing digital circuits at the VLSI-layout
	level. Compared to a previous library for logic programming by Claessen
	and Ljunglöf, we support residuation, easier creation of logical
	data types, and pattern matching. We discuss other applications of
	our library, including test-data generation, and various extensions,
	including lazy narrowing. Copyright © 2007 ACM.},
  affiliation = {University of York; Chalmers University},
  author_keywords = {Design; Languages},
  document_type = {Conference Paper},
  journal = {Haskell'07: Proceedings of the ACM SIGPLAN 2007 Haskell Workshop},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-38849178660&partnerID=40&md5=2c977e77bb6f7d10622f8b9b0b8549cf}
}

@ARTICLE{Nebeling2010471,
  author = {Nebeling, M., Grossniklaus, M., Leone, S., Norrie, M.C.},
  title = {Domain-specific language for context-aware web applications},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2010},
  volume = {6488 LNCS},
  pages = {471-479},
  note = {cited By (since 1996) 1},
  abstract = {Context-awareness is a requirement in many modern web applications.
	While most model-driven web engineering approaches have been extended
	with support for adaptivity, state-of-the-art development platforms
	generally provide only limited means for the specification of adaptation
	and often completely lack a notion of context. We propose a domain-specific
	language for context-aware web applications that builds on a simple
	context model and powerful context matching expressions. © 2010 Springer-Verlag
	Berlin Heidelberg.},
  affiliation = {Institute of Information Systems, ETH Zurich, CH-8092 Zurich, Switzerland},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-78751529803&partnerID=40&md5=a0c05ac875612bbe3f28224549dd4321}
}

@ARTICLE{Newton2008131,
  author = {Newton, R.R.a , Craig, M.B.a , Girod, L.D.a , Madden, S.R.a , Morrisett,
	J.G.b },
  title = {Design and evaluation of a compiler for embedded stream programs},
  journal = {ACM SIGPLAN Notices},
  year = {2008},
  volume = {43},
  pages = {131-140},
  number = {7},
  note = {cited By (since 1996) 0},
  abstract = {Applications that combine live data streams with embedded, parallel,
	and distributed processing are becoming more commonplace. WaveScript
	is a domain-specific language that brings high-level, type-safe,
	garbage-collected programming to these domains. This is made possible
	by three primary implementation techniques, each of which leverages
	characteristics of the streaming domain. First, we employ a novel
	evaluation strategy that uses a combination of interpretation and
	reification to partially evaluate programs into stream dataflow graphs.
	Second, we use profile-driven compilation to enable many optimizations
	that are normally only available in the synchronous (rather than
	asynchronous) dataflow domain. Finally, we incorporate an extensible
	system for rewrite rules to capture algebraic properties in specific
	domains (such as signal processing). We have used our language to
	build and deploy a sensornetwork for the acoustic localization of
	wild animals, in particular, the Yellow-Bellied marmot. We evaluate
	WaveScript's performance on this application, showing that it yields
	good performance on both embedded and desktop-class machines, including
	distributed execution and substantial parallel speedups. Our language
	allowed us to implement the application rapidly, while outperforming
	a previous C implementation by over 35%, using fewer than half the
	lines of code. We evaluate the contribution of our optimizations
	to this success. Copyright © 2008 ACM.},
  affiliation = {MITCSAIL; Harvard University},
  author_keywords = {Sensor networks; Streamprocessing language},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-67650071018&partnerID=40&md5=b2d39db7fe12ac53c8346dcbee109fc1}
}

@ARTICLE{Nešković2011284,
  author = {Nešković, S., Paunović, O., Babarogić, S.},
  title = {Using protocols and domain specific languages to achieve compliance
	of administrative processes with legislation},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2011},
  volume = {6866 LNCS},
  pages = {284-298},
  note = {cited By (since 1996) 0},
  abstract = {The paper deals with the problem of achieving formal compliance of
	administrative process with corresponding legislation. The presented
	approach is based on an explicit introduction of protocol models
	specifying general rules and behavior extracted from legislation
	that regulates a set of administrative processes. Identified protocols
	are then transformed into a domain specific business modeling language
	used for specification of choreography and orchestration models of
	the regulated administrative processes. Compliance of these models
	with legislation is based on a formal approach which treats protocol
	model as the definition of a state machine and choreography models
	as a system which generates events to the state machine. Compliance
	is achieved if the sequence of events generated by all possible valid
	execution paths in the choreography is accepted by the defined state
	machine. © 2011 Springer-Verlag Berlin Heidelberg.},
  affiliation = {University of Belgrade, Faculty of Organizational Sciences, Branislav
	Lazarević Laboratory for Information Systems, Jove Ilića 154, 11000
	Belgrade, Serbia},
  author_keywords = {Administrative processes; Business protocols; Compliance with legislation;
	Domain specific languages; Model transformations; UML Profiles},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-80052343070&partnerID=40&md5=3613e2cd99e82ad406bb33f3eac38ee4}
}

@CONFERENCE{Nguyen2010710,
  author = {Nguyen, V.C., Qafmolla, X.},
  title = {On instance-model querying and meta-model transformation},
  year = {2010},
  pages = {710-715},
  note = {cited By (since 1996) 0},
  abstract = {In today's market environment, change is an integral part of all projects.
	As such, its proper management is a crucial task when it comes to
	reducing both time and cost of development. The classical modeling
	approach can improve the situation up to a proper extent but it is
	not enough, because the process is usually variable and complex.
	Therefore it is necessary to introduce different level of abstractions
	for modeling. Each of these levels should serve at a certain phase
	for a certain purpose in the process. In the early stages several
	elements are grouped together and aggregated at the higher level,
	in an abstract model. Throughout time, granularity becomes smaller
	while understanding of the concepts becomes clearer and clearer and
	we need to see already working prototypes. In this situation, the
	approaches on instance- and meta-modeling techniques promise to bring
	productivity and efficiency to the process. This paper outlines practices
	from both approaches. We introduce the approach of using Object Constraint
	Language (OCL) with a Domain Specific Language (DSL) for instance-level
	model querying, illustrating this method with some examples. We analyze
	OCL from the broad perspective discussing its advantages and pointing
	out some its limitations. Moving to a higher level of abstraction,
	we also present the usage of Kermeta - an extension to the meta-data
	language with an action language for specifying semantics and behavior
	of meta-models. We show how Kermeta provides the possibility of automated
	meta-model transformations.},
  affiliation = {Department of Computer Science and Engineering, Software Engineering
	Research Group, Czech Technical University in Prague, Karlovo náměstí
	13, 121 35 Prague 2, Czech Republic},
  author_keywords = {Domain specific languages; Instance-model; Kermeta; Meta-model; Model
	driven development; OCL},
  document_type = {Conference Paper},
  journal = {Proceedings of the International MultiConference of Engineers and
	Computer Scientists 2010, IMECS 2010},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-79952365623&partnerID=40&md5=75d6b8b0da4b1274627c8de160fed6f1}
}

@CONFERENCE{Niazi2009393,
  author = {Niazi, M.F.a , Latif, K.a , Tenhunen, H.a , Seceleanu, T.b },
  title = {A DSL for the SegBus platform},
  year = {2009},
  pages = {393-398},
  note = {cited By (since 1996) 2},
  abstract = {The paper presents a Domain Specific Language (DSL) for a multi-core
	segmented bus platform, SegBus. The DSL, based on a UML profile,
	consists of graphical platform elements in the form of stereotypes
	with the necessary tagged values to depict platform aspects at high
	level of abstraction. Customizations are applied to each stereotyped
	element in the form of user-defined rules to restrict relationship
	between platform elements. The Object Constraint Language (OCL) is
	employed to introduce constraints, in order to impose structural
	requirements between platform elements, for which we introduce mechanisms
	to validate them. We present a simplified example of a H.264 video
	encoder application where the DSL is used to specify and validate
	application and platform model in a unified representation manner.
	©2009 IEEE.},
  affiliation = {Department of Information Technology, University of Turku, Finland;
	ABB Corporate Research, Västerås, Sweden},
  art_number = {5398012},
  document_type = {Conference Paper},
  journal = {Proceedings - IEEE International SOC Conference, SOCC 2009},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-77949639769&partnerID=40&md5=1d3331ef8d858b956abec295ca721835}
}

@CONFERENCE{Niazi2010199,
  author = {Niazi, M.F.a , Seceleanu, T.b , Tenhunen, H.a },
  title = {An automated control code generation approach for the SegBus platform},
  year = {2010},
  pages = {199-204},
  note = {cited By (since 1996) 0},
  abstract = {We present here a model-driven approach for the generation of low-level
	control code for the arbiters, to support application implementation
	and scheduled execution on a multi-core segmented bus platform, SegBus.
	The approach considers Model-Driven Architecture as a key to model
	the application at two different abstraction levels, namely as Packet-Synchronous
	Dataflow and Platform Specific Model, using the SegBus platform's
	Domain Specific Language. Both models are transformed into Extensible
	Markup Language schemes, and then utilized by an emulator program
	to generate the application-dependent VHDL code, the so-called snippets.
	The obtained code is inserted in a specific section of the platform
	arbiters. We present an example of a simplified stereo MP3 decoder
	where the methodology is employed to generate the control code of
	arbiters. © 2010 IEEE.},
  affiliation = {Turku Centre for Computer Science, Finland; Mlardalen University,
	Vsterås, Sweden},
  art_number = {5784752},
  document_type = {Conference Paper},
  journal = {Proceedings - IEEE International SOC Conference, SOCC 2010},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-79960732513&partnerID=40&md5=99e6c3f7be8def496b0b85c4c6427571}
}

@ARTICLE{Nie20103,
  author = {Nie, J., Cheng, B., Li, S., Wang, L., Li, X.-F.},
  title = {Vectorization for Java},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2010},
  volume = {6289 LNCS},
  pages = {3-17},
  note = {cited By (since 1996) 1},
  abstract = {Java is one of the most popular programming languages in today's software
	development, but the adoption of Java in some areas like high performance
	computing, gaming, and media processing is not as universal as in
	general-purpose computing. A major drawback preventing it from being
	extensively adopted in those areas is its lower performance than
	the traditional or domain-specific languages. This paper describes
	two approaches to improve Java's usability in those areas by introducing
	vector processing capability to Java. The first approach is to provide
	a Java vectorization interface (JVI) that developers can program
	with, to explicitly expose the programs' data parallelism. The other
	approach is to use automatic vectorization to generate vector instructions
	for Java programs. It does not require programmers to modify the
	original source code. We evaluate the two vectorization approaches
	with SPECjvm2008 benchmark. The performances of scimark.fft and scimark.lu
	are improved up to 55% and 107% respectively when running in single
	thread. We also investigate some factors that impact the vectorization
	effects, including the memory bus bandwidth and the superscalar micro-architecture.
	© 2010 Springer-Verlag.},
  affiliation = {China Runtime Technologies Lab., Intel China Research Center, China},
  author_keywords = {dependence graph; Java; memory bus bandwidth; superscalar micro-architecture;
	vectorization},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-78149268598&partnerID=40&md5=626fed46806324c16b23315e989bf30d}
}

@ARTICLE{Nilsson200554,
  author = {Nilsson, H.},
  title = {Dynamic optimization for functional reactive programming using Generalized
	Algebraic Data Types},
  journal = {ACM SIGPLAN Notices},
  year = {2005},
  volume = {40},
  pages = {54-65},
  number = {9},
  note = {cited By (since 1996) 2},
  abstract = {A limited form of dependent types, called Generalized Algebraic Data
	Types (GADTs), has recently been added to the list of Haskell extensions
	supported by the Glasgow Haskell Compiler. Despite not being full-fledged
	dependent types, GADTs still offer considerably enlarged scope for
	enforcing important code and data invariants statically. Moreover,
	GADTs offer the tantalizing possibility of writing more efficient
	programs since capturing invariants statically through the type system
	sometimes obviates entire layers of dynamic tests and associated
	data markup. This paper is a case study on the applications of GADTs
	in the context of Yampa, a domain-specific language for Functional
	Reactive Programming in the form of a self-optimizing, arrow-based
	Haskell combinator library. The paper has two aims. Firstly, to explore
	what kind of optimizations GADTs make possible in this context. Much
	of that should also be relevant for other domain-specific embedded
	language implementations, in particular arrow-based ones. Secondly,
	as the actual performance impact of the GADT-based optimizations
	is not obvious, to quantify this impact, both on tailored micro benchmarks,
	to establish the effectiveness of individual optimizations, and on
	two fairly large, realistic applications, to gauge the overall impact.
	The performance gains for the micro benchmarks are substantial. This
	implies that the Yampa API could be simplified as a number of "pre-composed"
	primitives that were there mainly for performance reasons are no
	longer needed. As to the applications, a worthwhile performance gain
	was obtained in one case whereas the performance was more or less
	unchanged in the other. Copyright © 2005ACM.},
  affiliation = {School of Computer Science and Information Technology, University
	of Nottingham},
  author_keywords = {Arrows; Combinator library; Domain-specific languages; DSEL; FRP;
	Functional programming; GADT; Haskell; Reactive programming; Synchronous
	dataflow languages; Yampa},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-33745213154&partnerID=40&md5=a4df2095359ded11cd1466dd52d2a568}
}

@ARTICLE{Nilsson-Nyman200995,
  author = {Nilsson-Nyman, E.a , Ekman, T.b , Hedin, G.a },
  title = {Practical scope recovery using bridge parsing},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2009},
  volume = {5452},
  pages = {95-113},
  note = {cited By (since 1996) 1},
  abstract = {Interactive development environments (IDEs) increase programmer productivity,
	but unfortunately also the burden on language implementors since
	sophisticated tool support is expected even for small domain-specific
	languages. Our goal is to alleviate that burden, by generating IDEs
	from high-level language specifications using the JastAdd meta-compiler
	system. This puts increased tension on scope recovery in parsers,
	since at least a partial AST is required by the system to perform
	static analysis, such as name completion and context sensitive search.
	In this paper we present a novel recovery algorithm called bridge
	parsing, which provides a light-weight recovery mechanism that complements
	existing parsing recovery techniques. An initial phase recovers nesting
	structure in source files making them easier to process by existing
	parsers. This enables batch parser generators with existing grammars
	to be used in an interactive setting with minor or no modifications.
	We have implemented bridge parsing in a generic extensible IDE for
	JastAdd based compilers. It is independent of parsing technology,
	which we validate by showing how it improves recovery in a set of
	typical interactive editing scenarios for three parser generators:
	ANTLR (LL(variable lookahead) parsers), LPG (LALR(k) parsers), and
	Beaver (LALR(1) parsers). ANTLR and LPG both contain sophisticated
	support for error recovery, while Beaver requires manual error productions.
	Bridge parsing complements these techniques and yields better recovery
	for all these tools with only minimal changes to existing grammars.},
  affiliation = {Department of Computer Science, Lund University, Lund, Sweden; Programming
	Tools Group, University of Oxford, Oxford, United Kingdom},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-67649949493&partnerID=40&md5=65f3a06b7bfd9e5dee681c352de15b6d}
}

@CONFERENCE{Nishino2011215,
  author = {Nishino, H.},
  title = {Misfits in abstractions: Towards user-centered design in domain-specific
	languages for end-user programming},
  year = {2011},
  pages = {215-216},
  note = {cited By (since 1996) 0},
  abstract = {In this paper, we discuss user-centered design of end-user programming
	languages with an example of computer music language. We describe
	an approach to analyze the misfits between the users'conceptualization
	and the programming language design in an existing usability problem
	with a focus on the abstraction layers both in conceptualization
	and language. When an entity in the users'conceptualization involved
	in problem-solving has no counterpart in a DSL, this can appear as
	a usability problem. Analysis of such a misfit caused by inappropriate
	abstraction in DSL design can contribute to better usability in end-user
	programming.},
  affiliation = {NUS Graduate School for Integrative Sciences and Engineering, National
	University of Singapore, Singapore},
  author_keywords = {Computer music; Domain- specific language; End-user programming; User-centered
	design},
  document_type = {Conference Paper},
  journal = {SPLASH'11 Compilation - Proceedings of OOPSLA'11, Onward! 2011, GPCE'11,
	DLS'11, and SPLASH'11 Companion},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-81355142070&partnerID=40&md5=67268d033e0236206ac31e55e8491114}
}

@CONFERENCE{Noguera2006175,
  author = {Noguera, C., Pawlak, R.},
  title = {AVal: An extensible attribute-oriented programming validator for
	Java},
  year = {2006},
  pages = {175-183},
  note = {cited By (since 1996) 0},
  abstract = {Attribute Oriented Programming (@OP) permits programmers to extend
	the semantics of a base program by annotating it with attributes
	that are related to a set of concerns. Examples of this are applications
	that rely on XDoclet (such as Hibernate) or, with the release of
	Java5's annotations, EJB3. The set of attributes that implements
	a concern defines a Domain Specific Language, and as such, imposes
	syntactic and semantic rules on the way attributes are included in
	the program or even on the program itself. We propose a framework
	for the definition and checking of these rules for @OP that uses
	Java5 annotations. We define an extensible set of meta-annotations
	to allow the validation of @OP programs, as well as the means to
	extend them using a compile-time model of the program's source code.
	We show the usefulness of the approach by presenting two examples
	of its use: an @OP extension for the Fractal component model called
	Fraclet, and the JSR 181 for web services definition. © 2006 IEEE.},
  affiliation = {INRIA - Futurs, Jacquard Project, Bâtiment M3, 59655 Villeneuve d'Ascq
	Cédex, France},
  art_number = {4026867},
  document_type = {Conference Paper},
  journal = {Proceedings - Sixth IEEE International Workshop on Source Code Analysis
	and Manipulation, SCAM 2006},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-34948831067&partnerID=40&md5=78ee6e0175f0b92ce5a5e8b983063487}
}

@ARTICLE{Noguera2007253,
  author = {Noguera, C.a , Pawlak, R.b },
  title = {AVal: An extensible attribute-oriented programming validator for
	Java},
  journal = {Journal of Software Maintenance and Evolution},
  year = {2007},
  volume = {19},
  pages = {253-275},
  number = {4},
  note = {cited By (since 1996) 2},
  abstract = {Attribute-oriented programming (@OP) permits programmers to extend
	the semantics of a base program by annotating it with attributes
	defined in an attribute domain-specific language ( AttDSL). In this
	article, we propose AVal: a Java5 framework for the definition and
	checking of rules for @OP in Java. We define a set of meta-annotations
	to allow the validation of @OP programs, as well as the means to
	extend these meta-annotations by using a compile-time model of the
	program's source code. AVal is fully integrated into the Eclipse
	IDE. We show the usefulness of the approach by using examples of
	its use applied to three AttDSLs: an @OP framework that helps programming
	Simple API for XML parsers, an @OP extension for the Fractal component
	model called Fraclet, and the JSR 181 for web services definition.
	Copyright © 2007 John Wiley & Sons, Ltd.},
  affiliation = {INRIA - Futurs, ADAM Project, Villeneuve d' Ascq, France; RPI, Hartford
	Campus, Hartford, CT, United States},
  author_keywords = {Annotations; Attributes; Program checking; Validation},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-35548979996&partnerID=40&md5=7166280f896fd4351465c789d5fdf7c5}
}

@ARTICLE{Nordstrom2003138,
  author = {Nordstrom, S., Shetty, S., Chhokra, K.G., Sprinkle, J., Eames, B.,
	Ledeczi, A.},
  title = {ANEMIC: Automatic interface enabler for model integrated computing},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2003},
  volume = {2830},
  pages = {138-150},
  note = {cited By (since 1996) 1},
  abstract = {A domain-specific language provides domain experts with a familiar
	abstraction for creating computer programs. As more and more domains
	embrace computers, programmers are tapping into this power by creating
	their own languages fitting the particular needs of the domain. Graphical
	domain-specific modeling languages are even more appealing for non-programmers,
	since the modeling language constructs are automatically transformed
	into applications through a special compiler called a translator.
	The Generic Modeling Environment (GME) at Vanderbilt University is
	a meta-programmable model-ing environment. Translators written to
	interface with GME models typically use a domain-independent API.
	This paper presents a tool called ANEMIC that generates a domain-specific
	API for GME translators using the same metamodel that generates the
	language. © Springer-Verlag Berlin Heidelberg 2003.},
  affiliation = {Institute for Software Integrated Systems, Vanderbilt University,
	2015 Terrace Place, Nashville, TN 37235, United States},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-35248813364&partnerID=40&md5=e756d3fc21a6aa47b56da208061e4806}
}

@CONFERENCE{Noubissi2010110,
  author = {Noubissi, A.C., Iguchi-Cartigny, J., Lanet, J.-L.},
  title = {Incremental dynamic update for Java-based smart cards},
  year = {2010},
  pages = {110-113},
  note = {cited By (since 1996) 1},
  abstract = {One of the most appealing feature for multiapplication smart cards
	is their ability to dynamically download or delete applications once
	the card has been issued. Applications can be updated by deleting
	old versions and loading the new ones. Nevertheless, for system components,
	the update is sligthly more complex because the systems never stop.
	Indeed, for smart cards based on Java called JavaCard, the virtual
	machine has a life cycle similar to the card because persistent objects
	are preserved after the communication sessions with the reader have
	expired. We present in this paper, our research in dynamic system
	components updating of JavaCard. Our technique requires a lot of
	off-card and on-card mechanisms. Our approach uses control flow graph
	to determine change between versions, a domain specific language
	to represent the change for minimization of the download overhead
	throughout the communication link with the card. © 2010 IEEE.},
  affiliation = {University of Limoges, Team SSD, France},
  art_number = {5464138},
  author_keywords = {Dynamic update; E-passport; Hotswup; Java card; Smart card},
  document_type = {Conference Paper},
  journal = {5th International Conference on Systems, ICONS 2010},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-77953769692&partnerID=40&md5=7238e0373fa67976bff2ae4657c684bd}
}

@ARTICLE{Novikov201048,
  author = {Novikov, F.A.a , Novoseltsev, V.B.b },
  title = {Interpretable program specification language},
  journal = {Programming and Computer Software},
  year = {2010},
  volume = {36},
  pages = {48-57},
  number = {1},
  note = {cited By (since 1996) 0},
  abstract = {In the paper, a domain-specific language of executable specifications
	is proposed. This language makes it possible to describe models of
	formalized subject domains in a graphical form, formulate computational
	problems on these models, and synthesize programs for solving these
	problems (including parallel ones) based on deductive inference in
	a special class of proposition calculus. © 2010 Pleiades Publishing,
	Ltd.},
  affiliation = {Institute of Applied Astronomy, Russian Academy of Sciences, nab.
	Kutuzova 10, St. Petersburg 191187, Russian Federation; Institute
	of Software Systems, Russian Academy of Sciences, ul. Petra Pervogo
	4a, s. Ves'kovo, Pereslavl' raion, Yaroslavl oblast 150020, Russian
	Federation},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-76649137605&partnerID=40&md5=17e7e132b843bc1613986156ef242c63}
}

@ARTICLE{Noyrit2010392,
  author = {Noyrit, F.a , Gérard, S.a , Terrier, F.a , Selic, B.b },
  title = {Consistent modeling using multiple UML profiles},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2010},
  volume = {6394 LNCS},
  pages = {392-406},
  number = {PART 1},
  note = {cited By (since 1996) 1},
  abstract = {The design of complex technical system invariably involves multiple
	domain-specific languages to cover the many different facets of such
	systems. However, unless the languages are designed to be used in
	combination, this typically leads to conflicting specifications that
	are difficult to reconcile due to the ontological and other differences
	between the languages used. In this paper, we describe a pragmatic
	but systematic approach to resolving this problem for the special
	but common case in which the domain-specific languages are all defined
	as UML profiles. © 2010 Springer-Verlag.},
  affiliation = {CEA, LIST, Laboratory of Model Driven Engineering for Embedded Systems,
	Point Courrier 94, Gif-sur-Yvette, 91191, France; Malina Software
	Corp., Nepean, ON, Canada},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-78349294609&partnerID=40&md5=e81248133bf45f89606a6c5db7e8d431}
}

@CONFERENCE{Nunes2009158,
  author = {Nunes, C.a , Araujo, J.a , Amaral, V.a , Silva, C.b },
  title = {A domain specific language for the I* framework},
  year = {2009},
  volume = {DISI},
  pages = {158-163},
  note = {cited By (since 1996) 1},
  abstract = {The i* framework proposes a goal-oriented analysis method for requirements
	engineering. It is a systematic approach to discover and structure
	requirements at organizational level where functional, non-functional
	requirements and their relations are specified. A Domain Specific
	Language (DSL) has the purpose to specify and model concepts in some
	domain, having several advantages in relation to general purpose
	languages, such as it allows expressing a solution in the desired
	language and at the desired abstraction level. In order to create
	such a DSL, normally it is necessary to start by specifying its syntax
	by means of a metamodel to be given as input to the language workbenches
	that generate the corresponding editors for it. With a proper editor
	for the language we can specify models with the proposed notation.
	This paper presents a DSL for the i* framework, with the purpose
	to handle complexity and scalability of its concrete models by introducing
	some innovations in the i* framework metamodel like mechanisms that
	will help to manage the models scalability.},
  affiliation = {CITI, Faculdade de Ciências e Tecnologia, Universidade Nova de Lisboa,
	Portugal; Centre de Informática, Universidade Federal de Pernambuco,
	Brazil},
  author_keywords = {CASE Tools; Domain Specific Languages; I* Framework; Metamodeling;
	Organizational Modeling},
  document_type = {Conference Paper},
  journal = {ICEIS 2009 - 11th International Conference on Enterprise Information
	Systems, Proceedings},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-74849119145&partnerID=40&md5=71f0858b1eea4575d004b821596e23ea}
}

@CONFERENCE{Nunes2006153,
  author = {Nunes, D.A., Schwabe, D.},
  title = {Rapid prototyping of web applications combining domain specific languages
	and model driven design},
  year = {2006},
  pages = {153-160},
  note = {cited By (since 1996) 9},
  abstract = {There have been several authoring methods proposed in the literature
	that are model based, essentially following the Model Driven Design
	philosophy. While useful, such methods need an effective way to allow
	the application designer to somehow synthesize the actual running
	application from the specification. In this paper, we describe HyperDe,
	an environment that combines Model Driven Design and Domain Specific
	Languages. We show the advantages of this combination to enable rapid
	authoring and prototyping of Web applications.},
  affiliation = {Departamento de Informática, PUC-Rio, Rua M. de S. Vicente, 222, Rio
	de Janeiro, RJ 22453-900, Brazil},
  author_keywords = {Hypermedia authoring; Model-based designs},
  document_type = {Conference Paper},
  journal = {ICWE'06: The Sixth International Conference on Web Engineering},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-34250638264&partnerID=40&md5=355396cb00918dccf05aba9149733fc0}
}

@CONFERENCE{Nunes2006889,
  author = {Nunes, D.A., Schwabe, D.},
  title = {Rapid prototyping of Web applications combining domain specific languages
	and model driven design},
  year = {2006},
  pages = {889-890},
  note = {cited By (since 1996) 1},
  abstract = {There have been several authoring methods proposed in the literature
	that are model based, essentially following the Model Driven Design
	philosophy. While useful, such methods need an effective way to allow
	the application designer to somehow synthesize the actual running
	application from the specification. In this paper, we describe HyperDE,
	an environment that combines Model Driven Design and Domain Specific
	Languages to enable rapid prototyping of Web applications.},
  affiliation = {Departamento de Informática, PUC-Rio, Rua M. de S. Vicente, 222, Rio
	de Janeiro, RJ 22453-900, Brazil},
  author_keywords = {Hypermedia authoring; Model-based designs},
  document_type = {Conference Paper},
  journal = {Proceedings of the 15th International Conference on World Wide Web},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-34250670022&partnerID=40&md5=ccb34396027eb46c70f6f5eb1ac99d0e}
}

@CONFERENCE{Nussbaumer2006893,
  author = {Nussbaumer, M., Freudenstein, P., Gaedke, M.},
  title = {Towards DSL-based web engineering},
  year = {2006},
  pages = {893-894},
  note = {cited By (since 1996) 3},
  abstract = {Strong user involvement and clear business objectives, both relying
	on efficient communication between the developers and the business,
	are key factors for a project's success. Domain-Specific Languages
	(DSLs) being simple, highly-focused and tailored to a clear problem
	domain are a promising alternative to heavy-weight modeling approaches
	in the field of Web Engineering. Thus, they enable stakeholders to
	validate, modify and even develop parts of a distributed Web-based
	solution.},
  affiliation = {University of Karlsruhe, Engesserstr. 4, 76128 Karlsruhe, Germany},
  author_keywords = {Conceptual modeling; DSL; Web engineering; Web services},
  document_type = {Conference Paper},
  journal = {Proceedings of the 15th International Conference on World Wide Web},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-34250675296&partnerID=40&md5=60ecde66e883cb36f77231404ac93281}
}

@ARTICLE{Nystrom2003138,
  author = {Nystrom, N., Clarkson, M.R., Myers, A.C.},
  title = {Polyglot: An extensible compiler framework for Java},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2003},
  volume = {2622},
  pages = {138-152},
  note = {cited By (since 1996) 85},
  abstract = {Polyglot is an extensible compiler framework that supports the easy
	creation of compilers for languages similar to Java, while avoiding
	code duplication. The Polyglot framework is useful for domain-specific
	languages, exploration of language design, and for simplified versions
	of Java for pedagogical use. We have used Polyglot to implement several
	major and minor modifications to Java; the cost of implementing language
	extensions scales well with the degree to which the language differs
	from Java. This paper focuses on the design choices in Polyglot that
	are important for making the framework usable and highly extensible.
	Polyglot source code is available. © Springer-Verlag Berlin Heidelberg
	2003.},
  affiliation = {Cornell University},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-35248882492&partnerID=40&md5=367444b7304a6e393b4567ac0a86af46}
}

@CONFERENCE{Nödler2009101,
  author = {Nödler, J.a , Neukirchen, H.b , Grabowski, J.a },
  title = {A flexible framework for quality assurance of software artefacts
	with applications to Java, UML, and TTCN-3 test specifications},
  year = {2009},
  pages = {101-110},
  note = {cited By (since 1996) 1},
  abstract = {Manual reviews and inspections of software artefacts are time consuming
	and thus, automated analysis tools have been developed to support
	the quality assurance of software artefacts. Usually, software analysis
	tools are implemented for analysing only one specific language as
	target and for performing only one class of analyses. Furthermore,
	most software analysis tools support only common programming languages,
	but not those domain-specific languages that are used in a test process.
	As a solution, a framework for software analysis is presented that
	is based on a flexible, yet high-level facade layer that mediates
	between analysis rules and the underlying target software artefact;
	the analysis rules are specified using high-level XQuery expressions.
	Hence, further rules can be quickly added and new types of software
	artefacts can be analysed without needing to adapt the existing analysis
	rules. The applicability of this approach is demonstrated by examples
	from using this framework to calculate metrics and detect bad smells
	in Java source code, in UML models, and in test specifications written
	using the Testing and Test Control Notation (TTCN-3).},
  affiliation = {Software Engineering for Distributed Systems Group, Institute for
	Computer Science, University of Göttingen, Goldschmidtstr. 7, 37077
	Göttingen, Germany; Faculty of Industrial Engineering, Mechanical
	Engineering and Computer Science, University of Iceland, Dunhagi
	5, 107 Reykjavík, Iceland},
  art_number = {4815342},
  document_type = {Conference Paper},
  journal = {Proceedings - 2nd International Conference on Software Testing, Verification,
	and Validation, ICST 2009},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-67650098689&partnerID=40&md5=82e802b3c6014e794fd3451d987c1192}
}

@ARTICLE{O'Hear2009577,
  author = {O'Hear, T., Boudjenane, Y.},
  title = {Using activity descriptions to generate user interfaces for ERP software},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2009},
  volume = {5613 LNCS},
  pages = {577-586},
  number = {PART 4},
  note = {cited By (since 1996) 0},
  abstract = {Delivering tailor-made ERP software requires automation of screen
	and printed report creation to be cost effective. Screens generated
	directly from data structures tend to have poor usability. An approach
	is considered using a domain specific language to describe use cases.
	Paper-prototyping and usability testing results define the usability
	characteristics the DSL portrays. The DSL is capable of defining
	a variety of screen types and user interface elements including forms,
	lists, pivot tables, Gantt charts, calendars and graphs. This approach
	is currently used in production to generate an interactive "AJAX"
	web user interface as well as HTML, PDF and Excel reports from descriptions
	stored in XML files. We believe that further research could extend
	our results to include non-ERP type software. © 2009 Springer Berlin
	Heidelberg.},
  affiliation = {Revelate SA, 38 ch. de Pré-Gentil, Satigny 1242, Switzerland},
  author_keywords = {AJAX; Domain specific language; DSL; ERP software; HTML; Interaction
	design; Paper-prototyping; Usability; User interface},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-70349160441&partnerID=40&md5=0d0e5598c43bb29ccbe727fd391d5111}
}

@ARTICLE{O'Keefe2006113,
  author = {O'Keefe, G.},
  title = {Dynamic logic semantics for UML consistency},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2006},
  volume = {4066 LNCS},
  pages = {113-127},
  note = {cited By (since 1996) 0},
  abstract = {The Unified Modelling Language (UML) is intended to describe systems,
	but, it is not clear what systems satisfy a given collection of UML
	diagrams. Stephen Mellor has described a small collection of diagrams
	which appear to be inconsistent, yet are "cool" according to UML.
	We describe an approach to defining semantics for UML diagrams using
	dynamic logic, and show that Mellor's example is inconsistent, given
	a reasonable assumption. Our approach interprets all diagrams, static
	and dynamic, in a single semantic space. The modeller specifies how
	the meaning of a model is made up from the meanings of its diagrams,
	thus the "viewpoint" taken by each diagram is made explicit. This
	composition is achieved through formation of the dynamic logic formulae.
	It is therefore very flexible, and we propose it as a means for defining
	semantics for domain specific languages, and for specifying "bridges"
	or "weaving" model transformations used in aspect oriented modelling.
	© Springer-Verlag Berlin Heidelberg 2006.},
  affiliation = {Research School of Information Science and Engineering, Australian
	National University, Canberra, ACT 0200, Australia},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-33746462778&partnerID=40&md5=4ee40ccdc5356115716df7d1d32b876b}
}

@ARTICLE{Ober2008354,
  author = {Ober, I., Abou Dib, A.},
  title = {Using ASM to achieve executability within a family of DSL},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2008},
  volume = {5238 LNCS},
  pages = {354},
  note = {cited By (since 1996) 0},
  abstract = {We propose an approach to achieve interoperability in a family of
	domain specific language based on the use of their ASM semantics
	and of the category theory. The approach is based on the construction
	of a unifying language of the family, by using categorical colimits.
	Since the unifying language is obtained by construction, translators
	to this one are obtained easily. These are the premises for using
	ASM tools for symbolically executing systems made of components specified
	in domain specific languages of a same family. © 2008 Springer-Verlag
	Berlin Heidelberg.},
  affiliation = {IRIT, Université Paul Sabatier Toulouse, 118, route de Narbonne, 3
	1062 Toulouse, France},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-56549089541&partnerID=40&md5=70a9067c07d6d3da7b01b520748fae6b}
}

@ARTICLE{Ober2008148,
  author = {Ober, I., Abou Dib, A., Féraud, L., Percebois, C.},
  title = {Towards interoperability in component based development with a family
	of DSLs},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2008},
  volume = {5292 LNCS},
  pages = {148-163},
  note = {cited By (since 1996) 1},
  abstract = {In this paper we address interoperability between components specified
	using various languages within a same family of DSLs. Our approach
	consists in applying results of the category theory in order to merge
	the languages into a unification one, automatically obtained. For
	this, we use the category of formal specifications of each DSL in
	the family. Using colimits on the category of algebraic specifications
	that implements the semantics of the DSLs in the family, we construct
	a language that unifies the family. Additionally we obtain translation
	morphisms from individual DSLs to the resulting unified one. By application
	of the translation morphisms, one can translate each component specifications
	into a specification written in the unification language. Moreover,
	properties established in the context of a DSL are transferred to
	the unifying language. In this paper, we illustrate the unification
	and the preservation of a property on an example. © 2008 Springer-Verlag
	Berlin Heidelberg.},
  affiliation = {IRIT, Université Paul Sabatier Toulouse, 118, route de Narbonne, 31062
	Toulouse, France},
  author_keywords = {Category theory; Domain specific language (DSL); Formal semantics;
	Heterogeneous components; Interoperability; Specware},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-56649107851&partnerID=40&md5=735e578593cfef8dc61637237cfc9a86}
}

@ARTICLE{Ober201021,
  author = {Ober, I., Féraud, L., Percebois, C.},
  title = {Dealing with variability within a family of domain-specific languages:
	Comparative analysis of different techniques},
  journal = {Innovations in Systems and Software Engineering},
  year = {2010},
  volume = {6},
  pages = {21-28},
  number = {1},
  note = {cited By (since 1996) 1},
  abstract = {Almost a decade has passed since the OMG has issued the Model Driven
	Architecture (MDA) initiative. It soon became obvious that raising
	the level of abstraction in development and reasoning at the model
	level would help in asking the right questions at the right time.
	Based on a concrete problem, we discuss four alternative solutions
	to a multi-language system design problem. These solutions use a
	traditional approach, a technique based on modeling, a domain-specific
	approach, and a mix of modeling and domain-specific techniques, respectively.
	The solutions depend on the problem, but they are representative
	for the situations we encounter in practice, therefore giving us
	a good basis for a larger discussion on the appropriateness of using
	modeling techniques and on the place of MDA in current software engineering
	practice and design. © Springer-Verlag London Limited 2010.},
  affiliation = {IRIT, Université de Toulouse, 118, route de Narbonne, 31062 Toulouse,
	France},
  author_keywords = {Automatic unification; Comparative analysis; Domain-specific (modeling)
	language; Model-based development},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-77949279212&partnerID=40&md5=d1348bfc47d2f1405ebaed590781cea0}
}

@ARTICLE{Obermeier2011497,
  author = {Obermeier, M., Braun, S., Sommer, K., Vogel-Heuser, B.},
  title = {Fundamental aspects concerning the usability evaluation of model-driven
	object oriented programming approaches in machine and plant automation},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2011},
  volume = {6770 LNCS},
  pages = {497-506},
  number = {PART 2},
  note = {cited By (since 1996) 0},
  abstract = {Within the world of automation the trend of model-driven object oriented
	(oo) engineering has brought up fundamental questions about the applicability
	of these programming paradigms for Programmable Logic Controller
	(PLC) software. The authors present the results of previously conducted
	experiments on the usability of the classic procedural paradigm (IEC
	61131-3) in machine and plant automation compared to model based
	approaches for PLC programming, in particular Unified Modeling Language
	(UML) and domain specific modeling languages. Extrapolating these
	experiments, we propose a way of enhancing usability evaluations
	by two means: First we present an improved modeling tool. Second,
	in order to determine the complexity of the tasks required to develop
	a PLC-program and to create constant boundary conditions for experimental
	studies, we propose using Hierarchical Task Analysis (HTA) on both
	model-driven oo and the state of the art programming approach, concerning
	typical scenarios. Finally the results of our work are discussed.
	© 2011 Springer-Verlag.},
  affiliation = {Institute of Automation and Information Systems in Mechanical Engineering,
	Technische Universität München, Boltzmannstraße 15, 85748 Garching,
	Germany},
  author_keywords = {model-driven engineering; PLC-Programming; Usability},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-79960511665&partnerID=40&md5=2ce1488a117f3b7ade25eee7cd6a5883}
}

@CONFERENCE{Oberortner200920,
  author = {Oberortner, E., Zdun, U., Dustdar, S.},
  title = {Tailoring a model-driven quality-of-service DSL for various stakeholders},
  year = {2009},
  pages = {20-25},
  note = {cited By (since 1996) 1},
  abstract = {Many service-oriented business systems have to comply to various contracts
	and agreements. Multiple technical and non-technical stakeholders
	with different background and knowledge are involved in modeling
	such business concerns. In many cases, these concerns are only encoded
	in the technical models and implementations of the systems, making
	it hard for non-technical stakeholders to get involved in the modeling
	process. In this paper we propose to tackle this problem by providing
	model-driven Domain-specific Languages (DSL) for specifying the contracts
	and agreements, as well as an approach to separate these DSLs into
	sub-languages at different abstraction levels, where each sub-language
	is tailored for the appropriate stakeholders. We exemplify our approach
	by describing a Quality-of-Service (QoS) DSL which can be used to
	describe Service Level Agreements (SLA). This work provides insights
	into how DSLs can be utilized to model and enrich service-oriented
	business systems with concerns defined in contracts and agreements.
	© 2009 IEEE.},
  affiliation = {Distributed Systems Group, Vienna University of Technology, Argentinierstr.
	8/184-1, 1040 Vienna, Austria},
  art_number = {5069892},
  document_type = {Conference Paper},
  journal = {Proceedings - International Conference on Software Engineering},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-77949830949&partnerID=40&md5=c9062b955c373c58bad51cec6b467553}
}

@ARTICLE{Oberortner2008159,
  author = {Oberortner, E., Zdun, U., Dustdar, S.},
  title = {Domain-specific languages for service-oriented architectures: An
	explorative study},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2008},
  volume = {5377 LNCS},
  pages = {159-170},
  note = {cited By (since 1996) 2},
  abstract = {Domain-specific languages (DSLs) are an important software development
	approach for many service-oriented architectures (SOAs). They promise
	to model the various SOA concerns in a suitable way for the various
	technical and non-technical stakeholders of a SOA. However, so far
	the research on SOA DSLs concentrates on novel technical contributions,
	and not much evidence or counter-evidence for the claims associated
	to SOA DSLs has been provided. In this paper, we present a qualitative,
	explorative study that provides an initial analysis of a number of
	such claims through a series of three prototyping experiments in
	which each experiment has developed, analyzed, and compared a set
	of DSLs for process-driven SOAs. Our result is to provide initial
	evidence for a number of popular claims about SOA DSLs which follow
	the model-driven software development (MDSD) approach, as well as
	a list of design trade-offs to be considered in the design decisions
	that must be made when developing a SOA DSL. © 2008 Springer Berlin
	Heidelberg.},
  affiliation = {Distributed Systems Group, Information Systems Institute, Vienna University
	of Technology, Vienna, Austria},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-58849150812&partnerID=40&md5=3b288a78bf3baa94c27510b475ec4281}
}

@CONFERENCE{Oberortner2010,
  author = {Oberortner, E.a , Zdun, U.a , Dustdar, S.a , Cavalcante, A.B.b ,
	Tluczek, M.b },
  title = {Supporting the evolution of model-driven service-oriented systems:
	A case study on QoS-aware process-driven SOAs},
  year = {2010},
  note = {cited By (since 1996) 0},
  abstract = {Process-driven service-oriented architectures (SOA) need to cope with
	constant changing requirements of various compliance requirements,
	such as quality of service (QoS) constraints within service level
	agreements (SLA). To the best of our knowledge, only little evidence
	is available if and in how far process-driven SOAs deal with the
	evolution of the requirements. In this work, we evaluate an incremental
	and model-driven development approach on the evolution of the requirements
	and the domain model in the context of an industrial case study.
	The case study focuses on advanced telecom services that need to
	be compliant to QoS constraints. This paper answers questions about
	the applicability of the incremental development approach, the impact
	of requirement changes, possible drawbacks of using a non-incremental
	development approach, and general recommendations based on the findings.
	Our results provide guidelines for dealing with the evolution of
	model-driven service-oriented systems.},
  affiliation = {Distributed Systems Group, Information Systems Institute, Vienna University
	of Technology, Vienna, Austria; Telcordia Poland Sp. z o.o., Poznan,
	Poland},
  art_number = {5707172},
  author_keywords = {Case study; Domain-specific language; Model evolution; Model-driven
	development; Service-oriented architecture},
  document_type = {Conference Paper},
  journal = {Proceedings - 2010 IEEE International Conference on Service-Oriented
	Computing and Applications, SOCA 2010},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-79952528754&partnerID=40&md5=833634ed92e31ef2b8fef0f4dfd42c05}
}

@CONFERENCE{Oger20092699,
  author = {Oger, S., Popescu, V., Linarès, G.},
  title = {Probabilistic and possibilistic language models based on the world
	wide web},
  year = {2009},
  pages = {2699-2702},
  note = {cited By (since 1996) 1},
  abstract = {Usually, language models are built either from a closed corpus, or
	by using World Wide Web retrieved documents, which are considered
	as a closed corpus themselves. In this paper we propose several other
	ways, more adapted to the nature of theWeb, of using this resource
	for language modeling. We first start by improving an approach consisting
	in estimating n-gram probabilities from Web search engine statistics.
	Then, we propose a new way of considering the information extracted
	from the Web in a probabilistic framework. Then, we also propose
	to rely on Possibility Theory for effectively using this kind of
	information. We compare these two approaches on two automatic speech
	recognition tasks: (i) transcribing broadcast news data, and (ii)
	transcribing domain-specific data, concerning surgical operation
	film comments. We show that the two approaches are effective in different
	situations. Copyright © 2009 ISCA.},
  affiliation = {Laboratoire d'Informatique d'Avignon (LIA), University of Avignon,
	France},
  author_keywords = {Automatic speech recognition; Language modeling; Possibility measure;
	World wide web},
  document_type = {Conference Paper},
  journal = {Proceedings of the 10th Annual Conference of the International Speech
	Communication Association, INTERSPEECH 2009},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-70450168876&partnerID=40&md5=91e41f08f128ccbf23a6051f0ac0bd5a}
}

@CONFERENCE{Oikarinen2007850,
  author = {Oikarinen, V.T.},
  title = {Extracting a domain specific language from an example a bottom-up
	method using the ngrease metalanguage},
  year = {2007},
  pages = {850-851},
  note = {cited By (since 1996) 0},
  abstract = {This demonstration shows a lightweight and fast method for creating
	a tested and working domain specific language. The method is demonstrated
	using the ngrease metalanguage. The creation of a new language is
	started by writing a representative example of the final product
	with a test that tests the transformation from a stub source to the
	result. The test is made to pass by writing a constant transformer
	that unconditionally outputs the result. At each step the language
	is extended by refactoring: Some part of the transformer template
	is converted from a constant subtree to a reference to data read
	from the source tree, thus driving additions to the new language.
	Optionally, each refactoring step can be driven by a new test that
	demonstrates the lack of parameterization of some part of the final
	product.},
  affiliation = {Sysart Oy},
  author_keywords = {Code generation; DSL; Metaprogramming; Method; Refactoring},
  document_type = {Conference Paper},
  journal = {Proceedings of the Conference on Object-Oriented Programming Systems,
	Languages, and Applications, OOPSLA},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-42149154553&partnerID=40&md5=c819bc25df4581357454b1c3655e3450}
}

@CONFERENCE{Oliveira201011,
  author = {Oliveira, A.R., Araújo, J., Amaral, V.},
  title = {The VisualAORE DSL},
  year = {2010},
  pages = {11-19},
  note = {cited By (since 1996) 0},
  abstract = {Aspect-Oriented Requirements Engineering consists of identifying,
	modularizing, specifying, and composing crosscutting concerns, also
	known as aspects. AORE is a pioneer systematic approach used to discover
	and structure requirements based on viewpoints and aspects. One of
	its limitations to be widely adopted is due to the fact that it lacks
	visual support to improve its usability. This paper describes a new
	Eclipse plug-in entitled VisualAORE. It is based on a DSL (Domain
	Specific Language) representing all the concepts of the AORE domain,
	allowing an implementation of an editor to specify models using the
	defined visual language. The work presented in this paper is a major
	contribution to AORE, since it replaces the traditional AORE's XML
	textual representation by a graphical one. This contribution helps
	software engineers to decrease AORE's model specification time, improving
	its understanding and usability. ©2010 IEEE.},
  affiliation = {CITI/FCT, Universidade Nova de Lisboa, Caparica, Portugal},
  art_number = {5625665},
  author_keywords = {Aspect oriented requirement engineering; Domain-Specific language;
	Model driven development},
  document_type = {Conference Paper},
  journal = {2010 5th International Workshop on Requirements Engineering Visualization,
	REV 2010},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-78650387392&partnerID=40&md5=f9e9e0590f61963d3be7586341c724a2}
}

@CONFERENCE{Oliveira2009699,
  author = {Oliveira, N.a , Henriques, P.R.a , Da Cruz, D.a , Pereira, M.J.V.b
	, Mernik, M.c , Kosar, T.c , Črepinšek, M.c },
  title = {Applying program comprehension techniques to Karel robot programs},
  year = {2009},
  volume = {4},
  pages = {699-706},
  note = {cited By (since 1996) 0},
  abstract = {In the context of program understanding, a challenge research topic
	1 is to learn how techniques and tools for the comprehension of General-Purpose
	Languages (GPLs) can be used or adjusted to the understanding of
	Domain-Specific Languages (DSLs). Being DSLs tailored for the description
	of problems within a specific domain, it becomes easier to improve
	these tools with specific visualizations (at a higher abstraction
	level, closer to the problem level) in order to understand the DSLs
	programs. In this paper, comprehension techniques will be applied
	to Karel language. This will allow us to explore the creation of
	problem domain visualizations for this language and to combine both
	problem and program domains in order to reach a full understanding
	of Karel programs. © 2009 IEEE.},
  affiliation = {Department of Computer Science, Campus de Gualtar, University of Minho,
	4715-057, Braga, Portugal; Polytechnic Institute of Bragaņca, Campus
	de Sta. Apolónia, Apartado 134 - 5301-857, Braganca, Portugal; Faculty
	of Electrical Engineering and Computer Science, University of Maribor,
	Smetanova 17, 2000 Maribor, Slovenia},
  art_number = {5352762},
  document_type = {Conference Paper},
  journal = {Proceedings of the International Multiconference on Computer Science
	and Information Technology, IMCSIT '09},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-78649742717&partnerID=40&md5=f4ee1b28f6a0b86e6a584411c0705cae}
}

@ARTICLE{Oliveira2011343,
  author = {Oliveira, N.a , Rodrigues, N.a b , Henriques, P.R.a },
  title = {Domain-specific language for coordination patterns},
  journal = {Computer Science and Information Systems},
  year = {2011},
  volume = {8},
  pages = {343-359},
  number = {2},
  note = {cited By (since 1996) 0},
  abstract = {The integration and composition of software systems requires a good
	architectural design phase to speed up communications between (remote)
	components. However, during implementation phase, the code to coordinate
	such components often ends up mixed in the main business code. This
	leads to maintenance problems, raising the need for, on the one hand,
	separating the coordination code from the business code, and on the
	other hand, providing mechanisms for analysis and comprehension of
	the architectural decisions once made. In this context our aim is
	at developing a domain-specific language, CoordL, to describe typical
	coordination patterns. From our point of view, coordination patterns
	are abstractions, in a graph form, over the composition of coordination
	statements from the system code. These patterns would allow us to
	identify, by means of pattern-based graph search strategies, the
	code responsible for the coordination of the several components in
	a system. The recovering and separation of the architectural decisions
	for a better comprehension of the software is the main purpose of
	this pattern language.},
  affiliation = {University of Minho, Department of Computer Science, Campus de Gualtar,
	4715-057, Braga, Portugal; IPCA-Polytechnic Institute of Cavado and
	Ave, Campus do IPCA, Barcelos, Portugal},
  author_keywords = {Coordination patterns; CoordInspector; Domain-specific languages;
	Software architectures},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-80755172315&partnerID=40&md5=0702a78b0c8cf0313dff402d9158985d}
}

@CONFERENCE{Onder199880,
  author = {Onder, Soner, Gupta, Rajiv},
  title = {Automatic generation of microarchitecture simulators},
  year = {1998},
  pages = {80-89},
  note = {cited By (since 1996) 22},
  abstract = {In this paper we describe the UPFAST system that automatically generates
	a cycle level simulator, an assembler and a disassembler from a microarchitecture
	specification written in a domain specific language called the Architecture
	Description Language (ADL). Using the UPFAST system it is easy to
	retarget a simulator for an existing architecture to a modified architecture
	since one has to simply modify the input specification and the new
	simulator is generated automatically. UPFAST also allows porting
	of simulators to different platforms with minimal effort. We have
	been able to develop three simulators ranging from simple pipelined
	processors to complicated out-of-order issue processors over a short
	period of three months. While the specifications of the architectures
	varied from 5000 to 6000 lines of ADL code, the sizes of automatically
	generated software varied from 20,000 to 30,000 lines of C++ code.
	The automatically generated simulators are less than 2 times slower
	than hand coded simulators for similar architectures.},
  affiliation = {Univ of Pittsburgh, Pittsburgh, United States},
  document_type = {Conference Paper},
  journal = {Proceedings of the IEEE International Conference on Computer Languages},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-0031644828&partnerID=40&md5=b619a08811ad78cfe0a38b022d410b5b}
}

@CONFERENCE{Opdahl2010301,
  author = {Opdahl, A.L.},
  title = {A platform for interoperable domain-specific enterprise modelling
	based on ISO 15926},
  year = {2010},
  pages = {301-310},
  note = {cited By (since 1996) 0},
  abstract = {The paper shows how to describe the semantics of domain-specific enterprise
	and information system (IS) modelling languages using the Unified
	Enterprise Modelling Language (UEML). The approach is illustrated
	with a fragment of a domain-specific modelling language based on
	the new ISO 15926 standard for data integration, sharing and hand-over
	between computer systems. The aim is to ensure that the semantics
	of new domain-specific languages (DSLs) can be quickly, easily and
	precisely defined in relation both to one another and to existing
	general-purpose languages. © 2010 IEEE.},
  affiliation = {Department of Information Science and Media Studies, University of
	Bergen, Bergen, Norway},
  art_number = {5629077},
  author_keywords = {Domain-specific modelling; Enterprise modelling; Interoperability;
	ISO 15926; Ontologies},
  document_type = {Conference Paper},
  journal = {Proceedings - IEEE International Enterprise Distributed Object Computing
	Workshop, EDOC},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-79951924698&partnerID=40&md5=16c7309451a226ecd38ea843a58c9e5a}
}

@CONFERENCE{Orchard201015,
  author = {Orchard, D.A., Bolingbroke, M., Mycroft, A.},
  title = {Ypnos: Declarative, parallel structured grid programming},
  year = {2010},
  pages = {15-24},
  note = {cited By (since 1996) 0},
  abstract = {A fully automatic, compiler-driven approach to parallelisation can
	result in unpredictable time and space costs for compiled code. On
	the other hand, a fully manual approach to parallelisation can be
	long, tedious, prone to errors, hard to debug, and often architecture-specific.
	We present a declarative domain-specific language, Ypnos, for expressing
	structured grid computations which encourages manual specification
	of causally sequential operations but then allows a simple, predictable,
	static analysis to generate optimised, parallel implementations.
	We introduce the language and provide some discussion on the theoretical
	aspects of the language semantics, particularly the structuring of
	computations around the category theoretic notion of a comonad. Copyright
	© 2010 ACM.},
  affiliation = {Computer Laboratory, University of Cambridge, Cambridge, United Kingdom},
  author_keywords = {Comonads; EDSL; Parallelism; Stencils; Structured grids; Ypnos},
  document_type = {Conference Paper},
  journal = {DAMP'10 - Proceedings of the 2010 ACM SIGPLAN Workshop on Declarative
	Aspects of Multicore Programming},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-77950901120&partnerID=40&md5=fd8cbb8aa06aef40a1f2e2bb2d626f1d}
}

@ARTICLE{Ortiz-Chamorro2009225,
  author = {Ortiz-Chamorro, S.a d , Rossi, G.a b , Schwabe, D.c },
  title = {Hypertextual programming for domain-specific end-user development},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2009},
  volume = {5435 LNCS},
  pages = {225-241},
  note = {cited By (since 1996) 1},
  abstract = {Domain-specific languages (DSLs) have successfully been used for end-user
	development. However, dealing with language syntax poses significant
	learning challenges. In this paper, we introduce hypertextual programming,
	a technique that represents language syntax as hypertext. With this
	technique, instead of dealing with textual languages, users can inspect
	and construct their programs mainly by using navigation. Beyond merely
	representing the syntax, hypertext can be used to provide various
	views of a single program code. Nevertheless, to reap the benefits
	of this technique, adequate hypertextual editors must be built. This
	paper argues that many of the lessons learned in the web engineering
	area can be used to deal with this problem. Millions of users navigate
	the World Wide Web. Hypertextual programming leverages this widely
	available end-user skill to facilitate the construction of computer
	programs. © 2009 Springer Berlin Heidelberg.},
  affiliation = {LIFIA, Universidad Nacional de la Plata, Argentina; CONICET, Argentina;
	Departamento de Informática, PUC-Rio, Brazil; Departamento de Electrónica
	e Informática, Universidad Católica de Asunción, Paraguay},
  author_keywords = {Domain-specific languages; End-user development; Hypertextual Programming;
	Interfaces for end-user development; Web engineering},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-63449136016&partnerID=40&md5=f290a9042127e98ca902d8bd4e4dd2e6}
}

@ARTICLE{Ortiz-Chamorro2010533,
  author = {Ortiz-Chamorro, S.S.a d , Rossi, G.a b , Schwabe, D.c },
  title = {Use of hypermedia tools for end-user development},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2010},
  volume = {6385 LNCS},
  pages = {533-537},
  note = {cited By (since 1996) 1},
  abstract = {Software development tools aimed at end-users tend to employ various
	forms of visual programming because these users find textual programming
	very difficult to learn. However, visual programming has known scalability
	issues. As an alternative, we propose hypertextual programming; a
	technique that represents the program as hypertext and allows the
	user to both browse it and manipulate it mainly by using navigation.
	This technique leverages the users' ability to navigate in hyperspace,
	a widely available skill, to edit the program under development.
	In order to reap the benefits of this technique, adequate hypertextual
	editors must be built. Many of the lessons learned in the web engineering
	area can be used to deal with this problem. This paper discusses
	the state of the current research efforts behind this novel programming
	technique. © 2010 Springer-Verlag.},
  affiliation = {LIFIA, Universidad Nacional de La Plata, Argentina; CONICET, Argentina;
	Departamento de Informática, PUC-Rio, Brazil; Departamento de Electrónica
	e Informática, Universidad Católica de Asunción, Paraguay},
  author_keywords = {domain-specific languages; end-user development; hypermedial programming;
	hypertextual programming; interfaces for end-user development; web
	engineering},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-78649886614&partnerID=40&md5=5101dc5cc772c33004fe02e13e5e1360}
}

@CONFERENCE{Ouraiba2011312,
  author = {Ouraiba, E.A., Choquet, C., Cottier, P.},
  title = {Opening tel systems for teachers : A domain-specific modeling \&
	model-driven engineering approach},
  year = {2011},
  volume = {1},
  pages = {312-317},
  note = {cited By (since 1996) 0},
  abstract = {Despite their quality, few TEL systems are actually adopted in educational
	institutions. These educational technologies have not always the
	necessary flexibility for use in real educational contexts that often
	requiring the rapid adaptations to new and often unexpected events
	(Cottier et al., 2008). Indeed, TEL environements should be designed
	as "open" in which the teacher himself is able to lead the adaptation
	and reengineering of learning system at an abstract level. In our
	work, we consider that opening of pedagogical scenario allows for
	the opening of TEL system. This article focuses on an approach based
	on the Domain- Specific Modeling and Model-driven Engineering for
	supporting practitioner teachers in their activities through the
	instructional design process. In order to verify our proposal we
	took Hop3x as experimentation field. Our objective is to open this
	TEL system for its users by providing them a user-friendly editor
	which allows the design and adaptation of learning sessions at a
	high-level of abstraction. We illustrate the development process
	of Hop3x's Domain-Specific Language and specific editor.},
  affiliation = {Maine University, IUT de Laval, 52 rue des Docteurs Calmette et Guérin,
	53020 Laval Cedex 9, France},
  author_keywords = {Domain-specific modeling; Instructional design; Learning session adaptation;
	Model-driven engineering; Open pedagogical scenario; Open technology
	enhanced learning systems},
  document_type = {Conference Paper},
  journal = {CSEDU 2011 - Proceedings of the 3rd International Conference on Computer
	Supported Education},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-80053022638&partnerID=40&md5=c5453273dd791e31469b67addf0d9927}
}

@CONFERENCE{Oury2008,
  author = {Oury, N., Swierstra, W.},
  title = {The power of Pi},
  year = {2008},
  pages = {39-50},
  note = {cited By (since 1996) 9},
  abstract = {This paper exhibits the power of programming with dependent types
	by dint of embedding three domain-specific languages: Cryptol, a
	language for cryptographic protocols; a small data description language;
	and relational algebra. Each example demonstrates particular design
	patterns inherent to dependently-typed programming. Documenting these
	techniques paves the way for further research in domain-specific
	embedded type systems. Copyright © 2008 ACM.},
  affiliation = {University of Nottingham},
  author_keywords = {Design; Languages; Theory},
  document_type = {Conference Paper},
  journal = {Proceedings of the ACM SIGPLAN International Conference on Functional
	Programming, ICFP},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-59249086782&partnerID=40&md5=9eedc946cae4bd6311e4b18c17575f9a}
}

@ARTICLE{Oury200839,
  author = {Oury, N., Swierstra, W.},
  title = {The power of Pi},
  journal = {ACM SIGPLAN Notices},
  year = {2008},
  volume = {43},
  pages = {39-50},
  number = {9},
  note = {cited By (since 1996) 2},
  abstract = {This paper exhibits the power of programming with dependent types
	by dint of embedding three domain-specific languages: Cryptol, a
	language for cryptographic protocols; a small data description language;
	and relational algebra. Each example demonstrates particular design
	patterns inherent to dependently-typed programming. Documenting these
	techniques paves the way for further research in domain-specific
	embedded type systems. Copyright © 2008 ACM.},
  affiliation = {University of Nottingham},
  author_keywords = {Design; Languages; Theory},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-67650085024&partnerID=40&md5=78e754e23ef306a6969580a5894e9fc3}
}

@ARTICLE{Ouyang2007162,
  author = {Ouyang, C.a , Verbeek, E.b , van der Aalst, W.M.P.a b , Breutel,
	S.a , Dumas, M.a , ter Hofstede, A.H.M.a },
  title = {Formal semantics and analysis of control flow in WS-BPEL},
  journal = {Science of Computer Programming},
  year = {2007},
  volume = {67},
  pages = {162-198},
  number = {2-3},
  note = {cited By (since 1996) 95},
  abstract = {Web service composition refers to the creation of new (Web) services
	by combining functionalities provided by existing ones. A number
	of domain-specific languages for service composition have been proposed,
	with consensus being formed around a process-oriented language known
	as WS-BPEL (or BPEL). The kernel of BPEL consists of simple communication
	primitives that may be combined using control-flow constructs expressing
	sequence, branching, parallelism, synchronization, etc. We present
	a comprehensive and rigorously defined mapping of BPEL constructs
	onto Petri net structures, and use this for the analysis of various
	dynamic properties related to unreachable activities, conflicting
	messages, garbage collection, conformance checking, and deadlocks
	and lifelocks in interaction processes. We use a mapping onto Petri
	nets because this allows us to use existing theoretical results and
	analysis tools. Unlike approaches based on finite state machines,
	we do not need to construct the state space, and can use structural
	analysis (e.g., transition invariants) instead. We have implemented
	a tool that translates BPEL processes into Petri nets and then applies
	Petri-net-based analysis techniques. This tool has been tested on
	different examples, and has been used to answer a variety of questions.
	© 2007 Elsevier B.V. All rights reserved.},
  affiliation = {Faculty of Information Technology, Queensland University of Technology,
	GPO Box 2434, Brisbane, QLD 4001, Australia; Department of Mathematics
	and Computer Science, Eindhoven University of Technology, P.O. Box
	513, NL-5600 MB Eindhoven, Netherlands},
  author_keywords = {BPEL; Business process modeling; Petri nets; Tool-based verification;
	Web services},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-34250718156&partnerID=40&md5=bf0c9555cf5b72210ddaad7afc3419ce}
}

@ARTICLE{Ovlinger1999,
  author = {Ovlinger, J., Wand, M.},
  title = {A language for specifying recursive traversals of object structures},
  journal = {SIGPLAN Notices (ACM Special Interest Group on Programming Languages)},
  year = {1999},
  volume = {34},
  pages = {70-81},
  number = {10},
  note = {cited By (since 1996) 1},
  abstract = {We present a domain-specific language for specifying recursive traversals
	of object structures, for use with the visitor pattern. Traversals
	are traditionally specified as iterations, forcing the programmer
	to adopt an imperative style, or are hard-coded into the program
	or visitor. Our proposal allows a number of problems best approached
	by recursive means to be tackled with the visitor pattern, while
	retaining the benefits of a separate traversal specification. © 1999
	ACM.},
  affiliation = {College of Computer Science, Northeastern University, 360 Huntington
	Avenue, Boston, MA 02115, United States},
  author_keywords = {Recursive Programming; Separation of Concerns; Visitor Pattern},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-0141665012&partnerID=40&md5=2ad709df52aa88e543c728bd9e3b94d4}
}

@CONFERENCE{Ovlinger199970,
  author = {Ovlinger, Johan, Wand, Mitchell},
  title = {Language for specifying recursive traversals of object structures},
  year = {1999},
  volume = {34},
  number = {10},
  pages = {70-81},
  note = {cited By (since 1996) 7},
  abstract = {We present a domain-specific language for specifying recursive traversals
	of object structures, for use with the visitor pattern. Traversals
	are traditionally specified as iterations, forcing the programmer
	to adopt an imperative style, or are hard-coded into the program
	or visitor. Our proposal allows a number of problems best approached
	by recursive means to be tackled with the visitor pattern, while
	retaining the benefits of a separate traversal specification.},
  affiliation = {Northeastern Univ, Boston, United States},
  document_type = {Conference Paper},
  journal = {Proceedings of the Conference on Object-Oriented Programming Systems,
	Languages, and Applications, OOPSLA},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-0033203785&partnerID=40&md5=3cf3662407741c5223c9e7cba87f2bf8}
}

@CONFERENCE{Pace201045,
  author = {Pace, G.J., Tabone, C.},
  title = {Meta-functional languages for hardware design and verification},
  year = {2010},
  pages = {45-50},
  note = {cited By (since 1996) 0},
  abstract = {General purpose functional languages have been widely used as host
	languages for the embedding of domain specific languages, especially
	for hardware description languages. The embedding approach provides
	various abstraction techniques, enabling the description of generators
	for whole families of circuits, in particular parameterised regular
	circuits. The twostage language setting that is achieved by means
	of embedding, provides a means to reason about the generated circuits
	as data objects within the host language. Nonetheless, these circuit
	objects lack information about their generators, and about the manner
	in which these where generated. In this paper, we explore the use
	of a meta-programming language to extend the embedding approach thus
	enabling us to access the underlying circuit generators, and not
	just the circuits themselves. We show the applicability of this approach
	by using circuit generator analysis techniques to extract information
	from a hardware compiler to enable verification, through the use
	of model-checking, of compiler invariants. The main contribution
	of this paper is to show how automatic verification of whole families
	of circuits can be used in an embedded language setting to verify
	hardware compiler invariants. © 2010 IEEE.},
  affiliation = {University of Malta, Malta},
  art_number = {5558166},
  author_keywords = {Correct compilation; Embedded languages; Hardware synthesis},
  document_type = {Conference Paper},
  journal = {Proceedings - 3rd International Conference on Advances in Circuits,
	Electronics and Micro-Electronics, CENICS 2010},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-77957951711&partnerID=40&md5=86e3cea54874c05d9340b0b8d4cc7c6f}
}

@CONFERENCE{Padioleau2007,
  author = {Padioleau, Y.a , Hansen, R.R.b , Lawall, J.L.b , Muller, G.a },
  title = {Semantic patches for documenting and automating collateral evolutions
	in Linux device drivers},
  year = {2007},
  note = {cited By (since 1996) 0},
  affiliation = {OBASCO Group, Ecole des Mines de Nantes-INRIA, LINA, 44307 Nantes
	cedex 3, France; DIKU, University of Copenhagen, Universitetsparken
	1, 2100 Copenhagen Ø, Denmark},
  art_number = {1216005},
  author_keywords = {Domain-specific languages; Software evolution},
  document_type = {Conference Paper},
  journal = {International Conference on Architectural Support for Programming
	Languages and Operating Systems - ASPLOS},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-34748898285&partnerID=40&md5=d65f9a990962eb0c8ccb58abb11a3b09}
}

@CONFERENCE{Padioleau2006,
  author = {Padioleau, Y.a , Hansen, R.R.b , Lawall, J.L.b , Muller, G.a },
  title = {Semantic patches for documenting and automating collateral evolutions
	in Linux device drivers},
  year = {2006},
  note = {cited By (since 1996) 0},
  affiliation = {OBASCO Group, Ecole des Mines de Nantes-INRIA, LINA, 44307 Nantes
	Cedex 3, France; DIKU, University of Copenhagen, Universitetsparken
	1, 2100 Copenhagen Ø, Denmark},
  art_number = {1216005},
  author_keywords = {domain-specific languages; software evolution},
  document_type = {Conference Paper},
  journal = {International Conference on Architectural Support for Programming
	Languages and Operating Systems - ASPLOS},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-77954014270&partnerID=40&md5=e57c23f9457447caa6426bea6b1d8eb0}
}

@CONFERENCE{Padioleau2008,
  author = {Padioleau, Y.a , Lawall, J.b , Hansen, R.R.c , Muller, G.a },
  title = {Documenting and automating collateral evolutions in linux device
	drivers},
  year = {2008},
  pages = {247-260},
  note = {cited By (since 1996) 16},
  abstract = {The internal libraries of Linux are evolving rapidly, to address new
	requirements and improve performance. These evolutions, however,
	entail a massive problem of collateral evolution in Linux device
	drivers: for every change that affects an API, all dependent drivers
	must be updated accordingly. Manually performing such collateral
	evolutions is time-consuming and unreliable, and has lead to errors
	when modifications have not been done consistently. In this paper,
	we present an automatic program transformation tool Coccinelle, for
	documenting and automating device driver collateral evolutions. Because
	Linux programmers are accustomed to manipulating program modifications
	in terms of patch files, this tool uses a language based on the patch
	syntax to express transformations, extending patches to semantic
	patches. Coccinelle preserves the coding style of the original driver,
	as would a human programmer. We have evaluated our approach on 62
	representative collateral evolutions that were previously performed
	manually in Linux 2.5 and 2.6. On a test suite of over 5800 relevant
	driver files, the semantic patches for these collateral evolutions
	update over 93% of the files completely. In the remaining cases,
	the user is typically alerted to a partial match against the driver
	code, identifying the files that must be considered manually. We
	have additionally identified over 150 driver files where the maintainer
	made an error in performing the collateral evolution, but Coccinelle
	transforms the code correctly. Finally, several patches derived from
	the use of Coccinelle have been accepted into the Linux kernel. Copyright
	2008 ACM.},
  affiliation = {Ecole des Mines de Nantes; DIKU, University of Copenhagen; Aalborg
	University},
  author_keywords = {Collateral evolutions; Device drivers; Domain-specific language; Linux;
	Program transformation; Software evolution},
  document_type = {Conference Paper},
  journal = {EuroSys'08 - Proceedings of the EuroSys 2008 Conference},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-55849102237&partnerID=40&md5=b5629832d69c91cf5fee5dfcdfa5e034}
}

@CONFERENCE{Padioleau2008247,
  author = {Padioleau, Y.a , Lawall, J.b , Hansen, R.R.c , Muller, G.a },
  title = {Documenting and automating collateral evolutions in Linux device
	drivers},
  year = {2008},
  volume = {42},
  number = {4},
  pages = {247-260},
  note = {cited By (since 1996) 3},
  abstract = {The internal libraries of Linux are evolving rapidly, to address new
	requirements and improve performance. These evolutions, however,
	entail a massive problem of collateral evolution in Linux device
	drivers: for every change that affects an API, all dependent drivers
	must be updated accordingly. Manually performing such collateral
	evolutions is time-consuming and unreliable, and has lead to errors
	when modifications have not been done consistently. In this paper,
	we present an automatic program transformation tool Coccinelle, for
	documenting and automating device driver collateral evolutions. Because
	Linux programmers are accustomed to manipulating program modifications
	in terms of patch files, this tool uses a language based on the patch
	syntax to express transformations, extending patches to semantic
	patches. Coccinelle preserves the coding style of the original driver,
	as would a human programmer. We have evaluated our approach on 62
	representative collateral evolutions that were previously performed
	manually in Linux 2.5 and 2.6. On a test suite of over 5800 relevant
	driver files, the semantic patches for these collateral evolutions
	update over 93% of the files completely. In the remaining cases,
	the user is typically alerted to a partial match against the driver
	code, identifying the files that must be considered manually. We
	have additionally identified over 150 driver files where the maintainer
	made an error in performing the collateral evolution, but Coccinelle
	transforms the code correctly. Finally, several patches derived from
	the use of Coccinelle have been accepted into the Linux kernel. Copyright
	2008 ACM.},
  affiliation = {Ecole des Mines de Nantes, France; DIKU, University of Copenhagen,
	Denmark; Aalborg University, Denmark},
  author_keywords = {Collateral evolutions; Device drivers; Domain-specific language; Linux;
	Program transformation; Software evolution},
  document_type = {Conference Paper},
  journal = {Operating Systems Review (ACM)},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-77952224331&partnerID=40&md5=10ef627b9443c9c0b70bc6281a648b4d}
}

@ARTICLE{Padioleau200747,
  author = {Padioleau, Y.a , Lawall, J.L.b , Muller, G.a },
  title = {SmPL: A Domain-Specific Language for Specifying Collateral Evolutions
	in Linux Device Drivers},
  journal = {Electronic Notes in Theoretical Computer Science},
  year = {2007},
  volume = {166},
  pages = {47-62},
  number = {SPEC. ISS.},
  note = {cited By (since 1996) 2},
  abstract = {Collateral evolutions are a pervasive problem in large-scale software
	development. Such evolutions occur when an evolution that affects
	the interface of a generic library entails modifications, i.e., collateral
	evolutions, in all library clients. Performing these collateral evolutions
	requires identifying the affected files and modifying all of the
	code fragments in these files that in some way depend on the changed
	interface. We have studied the collateral evolution problem in the
	context of Linux device drivers. Currently, collateral evolutions
	in Linux are mostly done manually using a text editor, possibly with
	the help of tools such as grep. The large number of Linux drivers,
	however, implies that this approach is time-consuming and unreliable,
	leading to subtle errors when modifications are not done consistently.
	In this paper, we propose a transformation language, SmPL, to specify
	collateral evolutions. Because Linux programmers are accustomed to
	exchanging, reading, and manipulating program modifications in terms
	of patches, we build our language around the idea and syntax of a
	patch, extending patches to semantic patches. © 2006 Elsevier B.V.
	All rights reserved.},
  affiliation = {OBASCO Group, Ecole des Mines de Nantes-INRIA, LINA, Nantes, France;
	DIKU, University of Copenhagen, Copenhagen, Denmark},
  author_keywords = {collateral evolutions; device drivers; domain-specific languages;
	Linux},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-33845408788&partnerID=40&md5=943b92743b9ff2d094d7457220bb5b1e}
}

@CONFERENCE{Paige2009162,
  author = {Paige, R.F., Kolovos, D.S., Rose, L.M., Drivalos, N., Polack, F.A.C.},
  title = {The design of a conceptual framework and technical infrastructure
	for model management language engineering},
  year = {2009},
  pages = {162-171},
  note = {cited By (since 1996) 2},
  abstract = {Model management is the discipline of managing artefacts used in Model-Driven
	Engineering (MDE). A model management framework defines and implements
	the operations (such as transformation or code generation) required
	to manipulate MDE artefacts. Modern approaches to model management
	generally implement these operations via domain-specific languages
	(DSLs). This paper presents and compares the principles behind three
	approaches to implementing DSLs for model management and identifies
	some of the key differences between DSL engineering in general and
	for model management. It then shows how theory relates to practice
	by illustrating how DSL design and implementation approaches have
	been used in practice to build working languages from the Epsilon
	model management framework. A set of questions for guiding the development
	of new model management DSLs is summarised, and data on development
	costs for the different approaches is presented. © 2009 IEEE.},
  affiliation = {Dept. of Computer Science, University of York, Heslington, York, United
	Kingdom},
  art_number = {5090524},
  document_type = {Conference Paper},
  journal = {Proceedings of the IEEE International Conference on Engineering of
	Complex Computer Systems, ICECCS},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-70350041761&partnerID=40&md5=e931ea1271e98d5063ed42d97da99a27}
}

@ARTICLE{Paige2009229,
  author = {Paige, R.F., Rose, L.M., Ge, X., Kolovos, D.S., Brooke, P.J.},
  title = {FPTC: Automated safety analysis for Domain-Specific languages},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2009},
  volume = {5421},
  pages = {229-242},
  note = {cited By (since 1996) 0},
  abstract = {Critical systems must be shown to be acceptably safe to deploy and
	use in their environment. The size, scale, heterogeneity, and distributed
	nature of these increasingly complex systems makes them difficult
	to verify and analyse. Additionally, domain experts use a variety
	of languages to model and build their systems. We present an automated
	safety analysis technique, Fault Propagation and Transformation Analysis,
	and explain how it can be used for automatically calculating the
	failure behaviour of an entire system from the failure behaviours
	of its components. We outline an implementation of the technique
	in the Epsilon model management platform, allowing it to be used
	with state-of-the-art model management languages and tools, and making
	it applicable to a variety of different domain-specific modelling
	languages.},
  affiliation = {Department of Computer Science, University of York, School of Computing,
	University of Teesside, United Kingdom},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-67650128691&partnerID=40&md5=f901ef35654ff1d1922c6c1dd852de94}
}

@ARTICLE{Pakin20071436,
  author = {Pakin, S.},
  title = {The design and implementation of a domain-specific language for network
	performance testing},
  journal = {IEEE Transactions on Parallel and Distributed Systems},
  year = {2007},
  volume = {18},
  pages = {1436-1449},
  number = {10},
  note = {cited By (since 1996) 5},
  abstract = {CONCEPTUAL is a toolset designed specifically to help measure the
	performance of high-speed interconnection networks such as those
	used in workstation clusters and parallel computers. It centers around
	a high-level, domain-specific language which makes it easy for a
	programmer to express, measure, and report the performance of complex
	communication patterns. The primary challenge in implementing a compiler
	for such a language is that the generated code must be extremely
	efficient so as not to misattribute overhead costs to the messaging
	library. At the same time, the language itself must not sacrifice
	expressiveness for compiler efficiency or there would be little point
	in using a high-level language for performance testing.This paper
	describes the CONCEPTUAL language and the CONCEPTUAL compiler's novel
	code-generation framework. The language provides primitives for a
	wide variety of idioms needed for performance testing and emphasizes
	a readable syntax. The core code-generation technique, based on unrolling
	CONCEPTUAL programs into sequences of communication events, is simple
	yet enables the efficient implementation of a variety of high-level
	constructs. The paper further explains how CONCEPTUAL implements
	time-bounded loops - even those which comprise blocking communication
	- in the absence of a timeout mechanism as this is a somewhat unique
	language/implementation feature. © 2007 IEEE.},
  affiliation = {Los Alamos National Laboratory, Los Alamos, NM 87545, United States},
  author_keywords = {Interprocessor communications; Measurement techniques; Specialized
	application languages},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-34648835100&partnerID=40&md5=a5e946f285a904e5ba03518c745b6f1e}
}

@CONFERENCE{Pakin2005149,
  author = {Pakin, S.},
  title = {Rapid development of application-specific network performance tests},
  year = {2005},
  volume = {3515},
  number = {II},
  pages = {149-157},
  note = {cited By (since 1996) 0},
  abstract = {Analyzing the performance of networks and messaging layers is important
	for diagnosing anomalous performance in parallel applications. However,
	general-purpose benchmarks rarely provide sufficient insight into
	any particular application's behavior. What is needed is a facility
	for rapidly developing customized network performance tests that
	mimic an application's use of the network but allow for easier experimentation
	to help determine performance bottlenecks. In this paper, we contrast
	four approaches to developing customized network performance tests:
	straight C, C with a helper library, Python with a helper library,
	and a domain-specific language. We show that while a special-purpose
	library can result in significant improvements in functionality without
	sacrificing language familiarity, the key to facilitating rapid development
	of network performances tests is to use a domain-specific language
	designed expressly for that purpose. © Springer-Verlag Berlin Heidelberg
	2005.},
  affiliation = {IOS Alamos National Laboratory, Los Alamos, NM 87545, United States},
  document_type = {Conference Paper},
  journal = {Lecture Notes in Computer Science},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-25144510528&partnerID=40&md5=43b4eba8e2b258895d348e8c9ddf0fcc}
}

@CONFERENCE{Palix200779,
  author = {Palix, N.a , Consel, C.a , Réveillère, L.a , Lawall, J.b },
  title = {A stepwise approach to developing languages for SIP telephony service
	creation},
  year = {2007},
  pages = {79-88},
  note = {cited By (since 1996) 1},
  abstract = {Developing a SIP-based telephony service requires a programmer to
	have expertise in telephony rules and constraints, the SIP protocol,
	distributed systems, and a SIP API, which is often large and complex.
	These requirements make the development of telephony software an
	overwhelming challenge. To overcome this challenge, various programming
	languages have been proposed to develop telephony services. Nevertheless,
	none of these languages as yet has a formal semantics. Therefore,
	the reference implementation, which may not be available, becomes
	the only source of information for the programmer to understand the
	subtleties of the language. Furthermore, this situation makes it
	difficult for third-party developers to port the language to another
	runtime system or to provide another implementation of the runtime
	system. This paper presents a semantics-based stepwise approach for
	designing and developing a scripting language dedicated to the development
	of telephony services. This approach enables critical properties
	of services to be guaranteed and captures expertise on the operational
	behavior of a service. We have applied this approach to developing
	the Session Processing Language (SPL) [3] dedicated to SIP-based
	service creation. A variety of services have been written in SPL
	for our university department. © 2007 ACM.},
  affiliation = {Department of Telecommunications, INRIA, LaBRI, 351 cours de la Libération,
	F-33405 Talence Cedex, France; DIKU, University of Copenhagen, 2100
	Copenhagen Ø, Denmark},
  author_keywords = {Domain-specific language; SIP; SPL; Telephony services},
  document_type = {Conference Paper},
  journal = {Proceedings of the 1st International Conference on Principles, Systems
	and Applications of IP Telecommunications, IPTComm '07},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-77952390015&partnerID=40&md5=5a69d6fded600f291d06d766e393dd39}
}

@ARTICLE{Palyart2011213,
  author = {Palyart, M.a b , Lugato, D.a , Ober, I.b , Bruel, J.-M.b },
  title = {Improving scalability and maintenance of software for high-performance
	scientific computing by combining MDE and frameworks},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2011},
  volume = {6981 LNCS},
  pages = {213-227},
  note = {cited By (since 1996) 0},
  abstract = {In recent years, numerical simulation has attracted increasing interest
	within industry and among academics. Paradoxically, the development
	and maintenance of high performance scientific computing software
	has become more complex due to the diversification of hardware architectures
	and their related programming languages and libraries. In this paper,
	we share our experience in using model-driven development for numerical
	simulation software. Our approach called MDE4HPC proposes to tackle
	development complexity by using a domain specific modeling language
	to describe abstract views of the software. We present and analyse
	the results obtained with its implementation when deriving this abstract
	model to target Arcane, a development framework for 2D and 3D numerical
	simulation software. © 2011 Springer-Verlag.},
  affiliation = {CEA/CESTA, 33114 Le Barp, France; IRIT - Université de Toulouse, 118,
	route de Narbonne, 31062 Toulouse, France},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-80054086527&partnerID=40&md5=4e396ea3c791bc9ec67bc282a98adad4}
}

@ARTICLE{Pan200592,
  author = {Pan, Y., Tu, P.H., Pontelli, E., Son, T.C.},
  title = {Construction of an agent-based framework for evolutionary biology:
	A progress report},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2005},
  volume = {3476 LNAI},
  pages = {92-111},
  note = {cited By (since 1996) 0},
  abstract = {We report on the development of an agent-based system, called ΦLOG,
	for the specification and execution of phylogenetic inference applications.
	We detail the implementation of the main components of the system.
	In the process, we discuss how advanced techniques developed in different
	research areas such as domain-specific languages, planning, Web Services
	discovery and invocation, and Web Service compositions can be applied
	in the building of the ΦLOG system. © Springer-Vertag Berlin Heidelberg
	2005.},
  affiliation = {Department of Computer Science, New Mexico State University},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-26844565952&partnerID=40&md5=d2e88944668dd567bf984fed916f3e08}
}

@CONFERENCE{Pandey2006,
  author = {Pandey, R., Wu, J.},
  title = {BOTS: A constraint-based component system for synthesizing scalable
	software systems},
  year = {2006},
  volume = {2006},
  pages = {189-198},
  note = {cited By (since 1996) 0},
  abstract = {Embedded application developers create applications for a wide range
	of devices with different resource constraints. Developers want to
	maximize the use of the limited resources available on the device
	while still not exceeding the capabilities of the device. To do this,
	the developer must be able to scale his software for different platforms.
	In this paper, we present a software engineering methodology that
	automatically scales software to different platforms. We intend to
	have the application developer write high level functional specifications
	of his software and have tools that automatically scale the underlying
	runtime. These tools will use the functional and non-functional constraints
	of both the hardware and client application to produce an appropriate
	runtime. Our initial results show that the proposed approach can
	scale operating systems and virtual machines that satisfy the constraints
	of varying hardware/application combinations. Copyright © 2006 ACM.},
  affiliation = {Department of Computer Science, University of California, Davis},
  author_keywords = {Components; Constraints; Embedded Systems; Generative Programming;
	Runtime Systems; Wireless Sensor Networks},
  document_type = {Conference Paper},
  journal = {Proceedings of the ACM SIGPLAN Conference on Languages, Compilers,
	and Tools for Embedded Systems (LCTES)},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-33746073723&partnerID=40&md5=2423cd613bfe34dc9cd5a61b9000d050}
}

@ARTICLE{Pandey2006189,
  author = {Pandey, R., Wu, J.},
  title = {BOTS: A constraint-based component system for synthesizing scalable
	software systems},
  journal = {ACM SIGPLAN Notices},
  year = {2006},
  volume = {41},
  pages = {189-198},
  number = {7},
  note = {cited By (since 1996) 1},
  abstract = {Embedded application developers create applications for a wide range
	of devices with different resource constraints. Developers want to
	maximize the use of the limited resources available on the device
	while still not exceeding the capabilities of the device. To do this,
	the developer must be able to scale his software for different platforms.
	In this paper, we present a software engineering methodology that
	automatically scales software to different platforms. We intend to
	have the application developer write high level functional specifications
	of his software and have tools that automatically scale the underlying
	runtime. These tools will use the functional and non-functional constraints
	of both the hardware and client application to produce an appropriate
	runtime. Our initial results show that the proposed approach can
	scale operating systems and virtual machines that satisfy the constraints
	of varying hardware/application combinations. Copyright © 2006 ACM.},
  affiliation = {Department of Computer Science, University of California, Davis},
  author_keywords = {Components; Constraints; Embedded Systems; Generative Programming;
	Runtime Systems; Wireless Sensor Networks},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-33749015230&partnerID=40&md5=fc25fedb9cd2650bc5a6a36f150c36e5}
}

@ARTICLE{Pardillo20102591,
  author = {Pardillo, J., Cachero, C.},
  title = {Domain-specific language modelling with UML profiles by decoupling
	abstract and concrete syntaxes},
  journal = {Journal of Systems and Software},
  year = {2010},
  volume = {83},
  pages = {2591-2606},
  number = {12},
  note = {cited By (since 1996) 1},
  abstract = {UML profiling presents some acknowledged deficiencies, among which
	the lack of expressiveness of the profiled notations, together with
	the high coupling between abstract and concrete syntaxes outstand.
	These deficiencies may cause distress among UML-profile modellers,
	who are often forced to extend from unsuitable metaclasses for mere
	notational reasons, or even to model domain-specific languages from
	scratch just to avoid the UML-profiling limitations. In order to
	palliate this situation, this article presents an extension of the
	UML profile metamodel to support arbitrarily-complex notational extensions
	by decoupling the UML abstract and concrete syntax. Instead of defining
	yet another metamodel for UML-notational profiling, notational extensions
	are modelled with DI, i.e., the UML notation metamodel for diagram
	interchange, keeping in this way the extension within the standard.
	Profiled UML notations are rendered with DI by defining the graphical
	properties involved, the domain-specific constraints applied to DI,
	and the rendering routines associated. Decoupling abstract and concrete
	syntax in UML profiles increases the notation expressiveness while
	decreasing the abstract-syntax complexity. © 2010 Elsevier Inc.},
  affiliation = {Department of Software and Computing Systems, University of Alicante,
	P.O. Box 99, E-03080, Spain},
  author_keywords = {Diagramming; Modelling; Profiles; Syntax; UML; Visual languages},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-78049349398&partnerID=40&md5=2b14ff4f64c10b8f708931c691fb22a1}
}

@CONFERENCE{Paredis20082350,
  author = {Paredis, C.J.J., Johnson, T.},
  title = {Using omg's sysml to support simulation},
  year = {2008},
  pages = {2350-2352},
  note = {cited By (since 1996) 2},
  abstract = {Currently, system engineering problems are solved using a wide range
	of domain-specific models and corresponding languages. It is unlikely
	that a single unified modeling language will be able to model in
	sufficient detail the large number of system aspects addressed by
	these domainspecific languages. Instead, a model integration framework
	is needed for managing the various modeling languages used to solve
	systems engineering problems. The Systems Modeling Language (OMG
	SysMLTM) can provide an answer to this need for model integration.
	Using SysML, a modeler can abstract a domain-specific language to
	a level that permits its interaction with other system models. In
	addition, graph transformation approach can be use to accomplishing
	automated, bidirectional transformation between SysML and the domain
	specific language. In this paper, a generic approach for defining
	such graph transformations is presented.©2008 IEEE.},
  affiliation = {Product and Systems Lifecycle Management Center, Georgia Institute
	of Technology, Atlanta, GA 30332, United States},
  art_number = {4736341},
  document_type = {Conference Paper},
  journal = {Proceedings - Winter Simulation Conference},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-60749123345&partnerID=40&md5=f3ee0bc7ef4c20282d8b71304839ed50}
}

@CONFERENCE{Parigot200437,
  author = {Parigot, D.},
  title = {Towards domain-driven development: The SmartTools software factory},
  year = {2004},
  pages = {37-38},
  note = {cited By (since 1996) 3},
  abstract = {Nowadays, software needs to be more open, flexible, and capable of
	evolving quickly to meet new user or technology requirements. It
	should be easy to adapt, even by none computer-specialists. To tackle
	these challenges for DSL (Domain-Specific Language) tools, we have
	developed a software factory, named SmartTools.},
  affiliation = {INRIA Sophia-Antipolis 2004, Route des Lucioles, F-06902 Sophia-Antipolis
	Cedex, France},
  author_keywords = {Design; Languages},
  document_type = {Conference Paper},
  journal = {Proceedings of the Conference on Object-Oriented Programming Systems,
	Languages, and Applications, OOPSLA},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-33745175296&partnerID=40&md5=2df5718da34d5d33df590da414f77c9f}
}

@ARTICLE{Parigot2002103,
  author = {Parigot, D., Courbis, C., Degenne, P., Fau, A., Pasquier, C., Fillon,
	J., Held, C., Attali, I.},
  title = {Aspect and XML-oriented semantic framework generator: SmartTools},
  journal = {Electronic Notes in Theoretical Computer Science},
  year = {2002},
  volume = {65},
  pages = {103-122},
  number = {3},
  note = {cited By (since 1996) 3},
  abstract = {SmartTools is a semantic framework generator, based on XML and object
	technologies. Thanks to a process of automatic generation from specifications,
	SmartTools makes it possible to quickly develop environments dedicated
	to domain-specific and programming languages. Some of these specifications
	(XML, DTD, Schemas, XSLT) are issued from the W3C which is an important
	source of varied emerging domain-specific languages. SmartTools uses
	object technologies such as visitor patterns and aspect-oriented
	programming. It provides code generation adapted to the usage of
	those technologies to support the development of semantic analyses.
	In this way, we obtain at minimal cost the design and implementation
	of a modular development platform which is open, interactive, uniform,
	and most important prone to evolution. ©2002 Published by Elsevier
	Science B.V.},
  affiliation = {INRIA Sophia-Antipolis - OASIS Project, 2004, route des Lucioles,
	06902 Sophia-Antipolis cedex, France},
  author_keywords = {Aspect-oriented programming; Development environment; Program transformation;
	Semantic analyses; Software generation; Visitor pattern; XML; XSLT},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-18944399544&partnerID=40&md5=58e4726d031397b69bd60b74fa31dd3e}
}

@CONFERENCE{Parreiras2009342,
  author = {Parreiras, F.S., Saathoff, C., Walter, T., Franz, T., Staab, S.},
  title = {APIs à gogo: Automatic generation of ontology APIs},
  year = {2009},
  pages = {342-348},
  note = {cited By (since 1996) 4},
  abstract = {When developing application programming interfaces of ontologies that
	include many instances of ontology design patterns, developers of
	semantic web applications usually have to handle complex mappings
	between descriptions of information given by ontologies and object
	oriented representations of the same information. In current approaches,
	annotations on API source code handle these mappings, leading to
	problems with reuse and maintenance. We propose a domain-specific
	language to tackle these mappings in a platform independent way -
	agogo. Agogo provides improvements on software engineering quality
	attributes like usability, reusability, maintainability, and portability.
	© 2009 IEEE.},
  affiliation = {ISWeb - Information Systems and Semantic Web, University of Koblenz-Landau,
	Universitaetsstrasse 1, Koblenz 56070, Germany},
  art_number = {5298648},
  author_keywords = {Code generation; Model driven engineering; Ontology API; Ontology
	design pattern},
  document_type = {Conference Paper},
  journal = {ICSC 2009 - 2009 IEEE International Conference on Semantic Computing},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-73449116027&partnerID=40&md5=cc7aecce74a3a66a79130a8e3c57831f}
}

@ARTICLE{Parreiras2009314,
  author = {Parreiras, F.S.a , Pan, J.Z.b , Assmann, U.c , Henriksson, J.c },
  title = {First workshop on transforming and weaving ontologies in model driven
	engineering (TWOMDE 2008)},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2009},
  volume = {5421},
  pages = {314-317},
  note = {cited By (since 1996) 0},
  abstract = {The First International Workshop on Transforming and Weaving Ontologies
	in Model Driven Engineering (TWOMDE 2008), affiliated with the 11th
	International Conference on Model Driven Engineering Languages and
	Systems (MoDELS2008), brought together researchers and practitioners
	from the modeling community with experience or interest in MDE and
	in Knowledge Representation to discuss about: (1) how the scientific
	and technical results around ontologies, ontology languages and their
	corresponding reasoning technologies can be used fruitfully in MDE;
	(2) the role of ontologies in supporting model transformation; (3)
	and how ontologies can improve designing domain specific languages.},
  affiliation = {ISWeb - Information Systems and Semantic Web, Institute for Computer
	Science, University of Koblenz-Landau Universitaetsstrasse 1, Koblenz
	56070, Germany; Department of Computing Science, The University of
	Aberdeen, Aberdeen AB24 3UE; Institute for Software- and Multimedia-Technology,
	TU Dresden, D-01062 Dresden, Germany},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-67650132996&partnerID=40&md5=d2135de340e24927c109c091ea701445}
}

@CONFERENCE{Parreiras2010311,
  author = {Parreiras, F.S.a , Walter, T.a , Wende, C.b , Thomas, E.c },
  title = {Bridging software languages and ontology technologies: Tutorial summary},
  year = {2010},
  pages = {311-315},
  note = {cited By (since 1996) 0},
  abstract = {Current model-driven development approaches allow for a more productive
	way of developing software systems. However, building tools and languages
	for software development still suffer a neglect of semantics in modeling
	and metamod-eling. An interest to strengthen semantics in modeling
	and metamodeling that gained scientific and commercial attention
	is the integration of ontology technology and software development.
	Ontology formalisms for consistency validation and dynamic classification
	as well as semantic web technologies for enabling shared terminologies
	and automated reasoning provide means for leveraging metamodeling
	and language engineering. This tutorial summary (1) enlightens the
	potential of ontology and semantic web technology for modeling and
	meta-modeling in software development, positioning it among modeling
	standards like UML, and MOF; and (2) illustrates ontology-enabled
	software development with real application scenarios in areas like
	software design patterns, domain-specific languages and variability
	management. © 2010 ACM.},
  affiliation = {Institute for Web Science and Technologies, University of Koblenz-Landau,
	D-56070 Koblenz, Germany; Institute for Software- and Multimedia-Technology,
	Dresden University of Technology, D-01062 Dresden, Germany; Department
	of Computing Science, University of Aberdeen, Aberdeen AB24 3UE,
	United Kingdom},
  author_keywords = {DSL; Model-driven development; Ontology technology; Semantic web;
	Software languages; UML},
  document_type = {Conference Paper},
  journal = {Proceedings of the ACM International Conference Companion on Object
	Oriented Programming Systems Languages and Applications Companion,
	SPLASH '10},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-78650121890&partnerID=40&md5=f9b9075b005e2d70ef4f772e3d3be30b}
}

@ARTICLE{Parson200067,
  author = {Parson, D.},
  title = {Using Java reflection to automate extension language parsing},
  journal = {SIGPLAN Notices (ACM Special Interest Group on Programming Languages)},
  year = {2000},
  volume = {35},
  pages = {67-80},
  number = {1},
  note = {cited By (since 1996) 0},
  abstract = {An extension language is an interpreted programming language designed
	to be embedded in a domain-specific framework. The addition of domain-specific
	primitive operations to an embedded extension language transforms
	that vanilla extension language into a domain-specific language.
	The LUxWORKS processor simulator and debugger from Lucent uses Tcl
	as its extension language. After an overview of extension language
	embedding and LUxWORKS experience, this paper looks at using Java
	reflection and related mechanisms to solve three limitations in extension
	language - domain framework interaction. The three limitations are
	gradual accumulation of ad hoc interface code connecting an extension
	language to a domain framework, over-coupling of a domain framework
	to a specific extension language, and inefficient command interpretation.
	Java reflection consists of a set of programming interfaces through
	which a software module in a Java system can discover the structure
	of classes, methods and their associations in the system. Java reflection
	and a naming convention for primitive domain operations eliminate
	ad hoc interface code by supporting recursive inspection of a domain
	command interface and translation of extension language objects into
	domain objects. Java reflection, name-based dynamic class loading,
	and a language-neutral extension language abstraction eliminate language
	over-coupling by transforming the specific extension language into
	a run-time parameter. Java reflection and command objects eliminate
	inefficiency by bypassing the extension language interpreter for
	stereotyped commands. Overall, Java reflection helps to eliminate
	these limitations by supporting reorganization and elimination of
	hand-written code, and by streamlining interpretation. © 2000 ACM.},
  affiliation = {Bell Laboratories, Lucent Technologies},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-17644403204&partnerID=40&md5=1cfaa76506054afcac1c820514d91ca7}
}

@CONFERENCE{Paterson2001229,
  author = {Paterson, R.},
  title = {A new notation for arrows},
  year = {2001},
  pages = {229-240},
  note = {cited By (since 1996) 35},
  abstract = {The categorical notion of monad, used by Moggi to structure denotational
	descriptions, has proved to be a powerful tool for structuring combinator
	libraries. Moreover, the monadic programming style provides a convenient
	syntax for many kinds of computation, so that each library defines
	a new sublanguage. Recently, several workers have proposed a generalization
	of monads, called variously "arrows" or Freyd-categories. The extra
	generality promises to increase the power, expressiveness and efficiency
	of the embedded approach, but does not mesh as well with the native
	abstraction and application. Definitions are typically given in a
	point-free style, which is useful for proving general properties,
	but can be awkward for programming specific instances. In this paper
	we define a simple extension to the functional language Haskell that
	makes these new notions of computation more convenient to use. Our
	language is similar to the monadic style, and has similar reasoning
	properties. Moreover, it is extensible, in the sense that new combining
	forms can be defined as expressions in the host language.},
  affiliation = {Department of Computing, City University, London, London, United Kingdom},
  document_type = {Conference Paper},
  journal = {Proceedings of the ACM SIGPLAN International Conference on Functional
	Programming, ICFP},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-0034782551&partnerID=40&md5=499bece4add102dcb03ddd0beea715fd}
}

@CONFERENCE{Paulik2009496,
  author = {Paulik, M.a , Waibel, A.b },
  title = {Automatic translation from parallel speech: Simultaneous interpretation
	as MT training data},
  year = {2009},
  pages = {496-501},
  note = {cited By (since 1996) 0},
  abstract = {State-of-the art statistical machine translation depends heavily on
	the availability of domain-specific bilingual parallel text. However,
	acquiring large amounts of bilingual parallel text is costly and,
	depending on the language pair, sometimes impossible. We propose
	an alternative to parallel text as machine translation (MT) training
	data; audio recordings of parallel speech (pSp) as it occurs in any
	scenario where interpreters are involved. Although interpretation
	(pSp) differs significantly from translation (parallel text), we
	achieve surprisingly strong translation results with our pSp-trained
	MT and speech translation systems.We argue that the presented approach
	is of special interest for developing speech translation in the context
	of resource-deficient languages where even monolingual resources
	are scarce. © 2009 IEEE.},
  affiliation = {Interactive Systems Laboratories (interACT), Carnegie Mellon University,
	United States; Universität Karlsruhe, Germany},
  art_number = {5372880},
  document_type = {Conference Paper},
  journal = {Proceedings of the 2009 IEEE Workshop on Automatic Speech Recognition
	and Understanding, ASRU 2009},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-77949363613&partnerID=40&md5=158d32505cbd037b013504a0b21bb17d}
}

@CONFERENCE{Paunov2006196,
  author = {Paunov, S.a , Hill, J.a , Schmidt, D.a , Baker, S.D.b , Slaby, J.M.b
	},
  title = {Domain-specific modeling languages for configuring and evaluating
	enterprise DRE system quality of service},
  year = {2006},
  pages = {196-205},
  note = {cited By (since 1996) 1},
  abstract = {The quality of service (QoS) of enterprise distributed real-time and
	embedded (DRE) systems can degrade under certain operating conditions
	and system architectures. This paper provides two contributions to
	research on modeldriven development (MDD) tools and methods that
	help identify and rectify these QoS problems in component-based enterprise
	DRE systems. First, we show how MDD tools can be used to simplify
	and automate the evaluation of component-based DRE systems to identify
	QoS problems. Second, we show how MDD tools can be used to specify
	alternative QoS polices for component-based DRE systems and synthesize
	metadata automatically to simplify system (reconfigurations that
	rectify QoS problems. We illustrate our MDD tools on a case study
	of multi-layer resource management services for shipboard computing
	systems that automate many aspects of power, navigation, command
	and control, and tactical operations. © 2006 IEEE.},
  affiliation = {Vanderbilt University, Nashville, TN, United States; Raytheon Company,
	Portsmouth, RI, United States},
  art_number = {1607369},
  document_type = {Conference Paper},
  journal = {Proceedings of the International Symposium and Workshop on Engineering
	of Computer Based Systems},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-34250010661&partnerID=40&md5=ecd192db3ee98f3147473c40cd5d28f1}
}

@CONFERENCE{Pavón2011179,
  author = {Pavón, J.a , Gómez-Sanz, J.a , Paredes, A.L.b },
  title = {The SiCoSSyS approach to SoS engineering},
  year = {2011},
  pages = {179-184},
  note = {cited By (since 1996) 0},
  abstract = {This paper presents a methodology and tools for SoS engineering. The
	approach is based on the experience acquired in several developments
	made in the context of the SiCoSSyS project. It considers that the
	nature of SoS requires (1) the participation of a diversity of people
	with different backgrounds and profiles, and (2) to cope with the
	heterogeneity of systems. These goals can be achieved by model-driven
	engineering methods and tools. In our work we have applied as well
	an agent-based modeling approach for the definition of domain-specific
	languages that constitute the main tool for specification, simulation
	and deployment of solutions. © 2011 IEEE.},
  affiliation = {GRASIA Research Group, Universidad Complutense Madrid, Madrid, Spain;
	INSISOC, Universidad de Valladolid, Valladolid, Spain},
  art_number = {5966594},
  author_keywords = {agent-based modeling; automatic code generation; domain specific languages;
	modeldriven engineering; Systems of Systems Engineering},
  document_type = {Conference Paper},
  journal = {Proceedings of 2011 6th International Conference on System of Systems
	Engineering: SoSE in Cloud Computing, Smart Grid, and Cyber Security,
	SoSE 2011},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-80052212407&partnerID=40&md5=f6cf701edd8bc7bda6cc6ce302ac6adf}
}

@ARTICLE{Paxson19992435,
  author = {Paxson, V.a b c },
  title = {Bro: A system for detecting network intruders in real-time},
  journal = {Computer Networks},
  year = {1999},
  volume = {31},
  pages = {2435-2463},
  number = {23},
  note = {cited By (since 1996) 413},
  abstract = {We describe Bro, a stand-alone system for detecting network intruders
	in real-time by passively monitoring a network link over which the
	intruder's traffic transits. We give an overview of the system's
	design, which emphasizes high-speed (FDDI-rate) monitoring, real-time
	notification, clear separation between mechanism and policy, and
	extensibility. To achieve these ends, Bro is divided into an `event
	engine' that reduces a kernel-filtered network traffic stream into
	a series of higher-level events, and a `policy script interpreter'
	that interprets event handlers written in a specialized language
	used to express a site's security policy. Event handlers can update
	state information, synthesize new events, record information to disk,
	and generate real-time notifications via syslog. We also discuss
	a number of attacks that attempt to subvert passive monitoring systems
	and defenses against these, and give particulars of how Bro analyzes
	the six applications integrated into it so far: Finger, FTP, Portmapper,
	Ident, Telnet and Rlogin. The system is publicly available in source
	code form.},
  affiliation = {Lawrence Berkeley Natl. Laboratory, Berkeley, CA, United States; AT
	and T Ctr. for Internet Research, ICSI, Berkeley, CA, United States;
	University of California, Berkeley, CA, United States},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-0033295259&partnerID=40&md5=1cedaed346d1819853c5834b0568a8ce}
}

@CONFERENCE{Pašalić2002218,
  author = {Pašalić, E.a , Taha, W.b , Sheard, T.a },
  title = {Tagless staged interpreters for typed languages},
  year = {2002},
  pages = {218-229},
  note = {cited By (since 1996) 18},
  abstract = {Multi-stage programming languages provide a convenient notation for
	explicitly staging programs. Staging a definitional interpreter for
	a domain specific language is one way of deriving an implementation
	that is both readable and efficient. In an untyped setting, staging
	an interpreter "removes a complete layer of interpretive overhead",
	just like partial evaluation. In a typed setting however, Hindley-Milner
	type systems do not allow us to exploit typing information in the
	language being interpreted. In practice, this can mean a slowdown
	cost by a factor of three or more. Previously, both type specialization
	and tag elimination were applied to this problem. In this paper we
	propose an alternative approach, namely, expressing the definitional
	interpreter in a dependently typed programming language. We report
	on our experience with the issues that arise in writing such an interpreter
	and in designing such a language. To demonstrate the soundness of
	combining staging and dependent types in a general sense, we formalize
	our language (called Meta-D) and prove its type safety. To formalize
	Meta-D, we extend Shao, Saha, Trifonov and Papaspyrou's λH language
	to a multilevel setting. Building on λH allows us to demonstrate
	type safety in a setting where the type language contains all the
	calculus of inductive constructions, but without having to repeat
	the work needed for establishing the soundness of that system.},
  affiliation = {OGI School of Sci. and Engineering, Oregon Health and Science University,
	Portland, OR, United States; Computer Science Department, Rice University,
	Houston, TX, United States},
  author_keywords = {Calculus of constructions; Definitional interpreters; Domain-specific
	languages; Multi-stage programming},
  document_type = {Conference Paper},
  journal = {Proceedings of the ACM SIGPLAN International Conference on Functional
	Programming, ICFP},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-0036949280&partnerID=40&md5=325a35f5ebb1fd1efaffdb29c263a0e1}
}

@CONFERENCE{Paška200958,
  author = {Paška, M.},
  title = {Generative programming with support for formal verification},
  year = {2009},
  pages = {58-61},
  note = {cited By (since 1996) 0},
  abstract = {This paper presents a novel approach to software development, mainly
	useful for embedded devices.Embedded software is described in a programming
	language with very high level of abstraction.Efficient production
	code is generated from this description; also code suitable for formal
	verification is generated.The paper investigates efficiency of both
	the verifiable and the production code.© 2009 IEEE.},
  affiliation = {University of West Bohemia, Department of Computer Science and Engineering,
	Pilsen, Czech Republic},
  art_number = {5196194},
  document_type = {Conference Paper},
  journal = {Proceedings - 2009 IEEE International Symposium on Industrial Embedded
	Systems, SIES 2009},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-70449433901&partnerID=40&md5=cac60dec72f010f724f6d5c695473716}
}

@CONFERENCE{Pedro200610,
  author = {Pedro, L., Lucio, L., Buchs, D.},
  title = {Principles for system prototype and verification using metamodel
	based transformations},
  year = {2006},
  volume = {2006},
  pages = {10-16},
  note = {cited By (since 1996) 1},
  abstract = {Using Domain Specific Modeling (DSM) allows solutions to be expressed
	in the idiom and at the level of abstraction of the problem domain.
	However, this does not imply that prototypes can be easily and rapidly
	generated. In reality, Domain Specific Languages (DSLs) are difficult
	to design, implement and maintain, and usually there is a potential
	loss of efficiency when compared with hand-coded software. In this
	paper we explain the principles based on which we expect to solve
	some of these problems by means of transformation from a DSL to a
	formalism with a well define semantics named Concurrent Object Oriented
	Petri-Nets (CO-OPN). The proposed methodology uses the meta-model
	of the DSL as the principle for the transformation. This transformation
	represents the semantic mapping between the DSL and CO-OPN. The achievement
	is both to provide a formally defined semantics to the DSL and, since
	CO-OPN is integrated in a framework, to provide the functionalities
	that allow model verification and fast prototype generation for the
	DSL. © 2006 IEEE.},
  affiliation = {University of Geneva, Centre Universitaire d'Informatique, 24, rue
	du General-Dufour, CH-1211 Genève 4, Switzerland},
  art_number = {1630744},
  document_type = {Conference Paper},
  journal = {Proceedings of the International Workshop on Rapid System Prototyping},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-33751401070&partnerID=40&md5=29e26a06148360cb33635a8407626c6a}
}

@ARTICLE{Pedro2006174,
  author = {Pedro, L., Lucio, L., Buchs, D.},
  title = {Prototyping domain specific languages with COOPN},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2006},
  volume = {3943 LNCS},
  pages = {174-189},
  note = {cited By (since 1996) 1},
  abstract = {The work described in this article presents how we use COOPN in the
	context of the MDA (Model Driven Architecture) philosophy for prototyping
	Domain Specific Languages. With this principle we increase the abstraction
	of COOPN language representation enabling standard data interchange
	with other applications that use the same approach. In particular
	we will present the architecture of the transformation from Domain
	Specific Languages; its advantages concerning the ability to have
	COOPN models as a standard format for representing the semantics
	of Domain Specific Languages and to reuse software prototyping and
	testing techniques developped for this formalism. As example we will
	show how our work is proceeding towards transformation from UML to
	COOPN. We also argue how our approach can be easily used in order
	to produce rapid system prototyping and verification for Domain Specific
	Languages (DSLs). © Springer-Verlag Berlin Heidelberg 2006.},
  affiliation = {University of Geneva, Centre Universitaire d'Informatique, 24, rue
	du General-Dufour, CH-1211 Genève, Switzerland},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-33745806902&partnerID=40&md5=25b4b640ec0041044a134c54cefe660d}
}

@ARTICLE{Pedro2007,
  author = {Pedro, L.a b , Lucio, L.a c , Buchs, D.a c },
  title = {Modeling languages: System prototype and verification using metamodel-based
	transformations},
  journal = {IEEE Distributed Systems Online},
  year = {2007},
  volume = {8},
  number = {4},
  note = {cited By (since 1996) 0},
  abstract = {The process of mapping core concepts of domain-specific languages
	(DSL) into the Concurrent Object-Oriented Petri Nets (CO-OPN) formal
	languages, provides users with the semantics necessary for developing
	prototypes for the DSL. DSLs are less comprehensive than general-purpose
	languages, such as C++ or Java and enable domain experts understand,
	validate, modify, and develop programs themselves. Domain experts
	transform a DSL into the Concurrent Object-Oriented Petri Net formal
	languages, to overcome the problems of unavailability of strong abstraction
	mechanisms, difficulty of designing, implementing, and maintaining
	the DSLs. The DSL metamodel serves as the starting point of the transformation,
	which represents the semantic mapping between the DSL and CO-OPN
	in a framework to provide the functionalities that allow model verification
	and prototype generation for the DSL.},
  affiliation = {University of Geneva, Switzerland; Software Modeling and Verification
	Group, Univ. of Geneva, CUI, 24 Rue du General-Dufour, CH-1204 Genéve,
	Switzerland; Software Modeling and Verification Group, Univ. of Geneva,
	CUI, 24 Rue du General-Dufour, CH-1211 Genève 4, Switzerland},
  art_number = {0704-o4001},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-34247616402&partnerID=40&md5=f7dae9f82db8c2f1051d126f7afffbd2}
}

@ARTICLE{Pedro2009889,
  author = {Pedro, L.a , Risoldi, M.a , Buchs, D.a , Barroca, B.b , Amaral, V.b
	},
  title = {Composing visual syntax for domain specific languages},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2009},
  volume = {5611 LNCS},
  pages = {889-898},
  number = {PART 2},
  note = {cited By (since 1996) 1},
  abstract = {With the increasing interest in metamodeling techniques for Domain
	Specific Modeling Languages (DSML) definition, there is a strong
	need to improve the language modeling process. One of the problems
	to solve is language evolution. Possible solutions include maximizing
	the reuse of metamodel patterns, composing them to form new, more
	expressive DSMLs. In this paper we improve the process of rapid prototyping
	of DSML graphical editors in meta-modeling tools, by defining composition
	rules for the graphical syntax layer. The goal is to provide formally
	defined operators to specify what happens to graphical mappings when
	their respective metamodels are composed. This improves reuse of
	Domain Specific Modeling Languages definitions and reduces development
	time. © 2009 Springer Berlin Heidelberg.},
  affiliation = {Centre Universitaire d'Informatique, Université de Genève, Switzerland;
	Departamento de Informática, Faculdade de Ciências e Tecnologia,
	Universidade Nova de Lisboa, Portugal},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-70350330864&partnerID=40&md5=c86f98f802e8eb49506336ea5ba62c14}
}

@CONFERENCE{Pembeci2003727,
  author = {Pembeci, I., Hager, G.},
  title = {Functional reactive programming as a hybrid system framework},
  year = {2003},
  volume = {1},
  pages = {727-734},
  note = {cited By (since 1996) 0},
  abstract = {In previous work we presented Functional Reactive Programming (FRP),
	a general framework for designing hybrid systems and developing domain-specific
	languages for related domains. FRP's synchronous dataflow features,
	like event driven switching, supported by higher-order lazy functional
	abstractions of Haskell allows rapid development of modular and reusable
	specifications. In this paper, we will look at more closely to the
	relation of Arrowized FRP (AFRP), the latest FRP implementation,
	and formal specification of hybrid systems. We will show how a formally
	specified hybrid system can be expressed in FRP and present a constructive
	proof showing that, for a subset of AFRP programs, there is a corresponding
	formal hybrid system specification.},
  affiliation = {Dept. of Computer Science, Johns Hopkins University, Baltimore, MD,
	United States},
  document_type = {Conference Paper},
  journal = {Proceedings - IEEE International Conference on Robotics and Automation},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-0345307704&partnerID=40&md5=8288ae51507e1ec3374ab28eaa09bf69}
}

@ARTICLE{Pereira20081,
  author = {Pereira, M.J.V.a , Mernik, M.b , da Cruz, D.c , Henriques, P.R.c
	},
  title = {Program comprehension for domain-specific languages},
  journal = {Computer Science and Information Systems},
  year = {2008},
  volume = {5},
  pages = {1-17},
  number = {2},
  note = {cited By (since 1996) 4},
  abstract = {In the past, we have been looking for program comprehension tools
	that are able to interconnect operational and behavioral views, aiming
	at aiding the software analyst to relate problem and program domains
	in order to reach a full understanding of software systems. In this
	paper we are concerned with Program Comprehension issues applied
	to Domain Specific Languages (DSLs). We are now willing to understand
	how techniques and tools for the comprehension of traditional programming
	languages fit in the understanding of DSLs. Being the language tailored
	for the description of problems in a specific domain, we believe
	that specific visualizations (at a higher abstraction level, closer
	to the problem level) could and should be defined to enhance the
	comprehension of the descriptions in that particular domain.},
  affiliation = {Polytechnic Institute of Bragança, Campus de Sta. Apolónia, Apartado
	134, 5301-857, Bragança, Portugal; University of Maribor, Faculty
	of Electrical Engineering and Computer Science, Smetanova ul. 17,
	2000, Maribor, Slovenia; University of Minho, Department of Computer
	Science, Campus de Gualtar, 4715-057, Braga, Portugal},
  author_keywords = {DSLs; Problem comprehension; Program understanding},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-70349690333&partnerID=40&md5=5222edbaf653f366d48eaa04ad6f2d97}
}

@ARTICLE{Perišić2011405,
  author = {Perišić, B., Milosavljević, G., Dejanović, I., Milosavljević, B.},
  title = {UML profile for specifying user interfaces of business applications},
  journal = {Computer Science and Information Systems},
  year = {2011},
  volume = {8},
  pages = {405-426},
  number = {2},
  note = {cited By (since 1996) 0},
  abstract = {This paper presents an approach to automatic user interface code generation
	that is based on our own HCI standard that defines layout and behaviour
	of coarse-grained objects for enterprise business applications. A
	domain-specific language (in the form of a UML profile) based on
	the concepts introduced by the HCI standard facilitates efficient
	modeling and generation of fully-functional UIs. Being a regular
	UML extension, this language can be used in any general-purpose UML
	modelling tool and can easily be integrated with other UML-based
	models of the application.},
  affiliation = {University of Novi Sad, Faculty of Technical Sciences, Serbia},
  author_keywords = {Code generation; MDA; UML profile; User interface},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-80755136746&partnerID=40&md5=64131760aaedb9b479fc5d8ace262e5f}
}

@ARTICLE{Perugini20055,
  author = {Perugini, S.a c , Ramakrishnan, N.b d },
  title = {Personalization by program slicing},
  journal = {Journal of Object Technology},
  year = {2005},
  volume = {4},
  pages = {5-11},
  number = {3},
  note = {cited By (since 1996) 1},
  abstract = {Personalization involves customizing information access to the end-user.
	As any new area of computer science research it lacks formal models
	to guide the design of systems. In this paper, we present a modeling
	methodology, based on generative programming, for personalizing interactions
	with hierarchical websites. The methodology entails modeling a user's
	interaction with a site in a program and applying program slicing
	to personalize the interaction. While preserving interactivity, this
	approach does not require the designer to anticipate all possible
	user interactions a priori and provide interfaces for each. Moreover,
	it provides a theoretical, systematic, and implementation- neutral
	way to design systems and is therefore a timely contribution to the
	young field of personalization as well as a novel application of
	generative programming. © JOT, 2005.},
  affiliation = {Department of Computer Science, University of Dayton, OH; Department
	of Computer Science, Virginia Tech., VA; Department of Computer Science,
	University of Dayton; Department of Computer Science, Virginia Tech.},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-22944452733&partnerID=40&md5=4526175a17c87f31a23cba15641ac65d}
}

@ARTICLE{Perugini2005205,
  author = {Perugini, S.a , Ramakrishnan, N.b },
  title = {A generative programming approach to interactive information retrieval:
	Insights and experiences},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2005},
  volume = {3676 LNCS},
  pages = {205-220},
  note = {cited By (since 1996) 0},
  abstract = {We describe the application of generative programming to a problem
	in interactive information retrieval. The particular interactive
	information retrieval problem we study is the support for 'out of
	turn interaction' with a website - how a user can communicate input
	to a website when the site is not soliciting such information on
	the current page, but will do so on a subsequent page. Our solution
	approach makes generous use of program transformations (partial evaluation,
	currying, and slicing) to delay the site's current solicitation for
	input until after the user's out-of-turn input is processed. We illustrate
	how studying outof-turn interaction through a generative lens leads
	to several valuable insights: (i) the concept of a web dialog, (ii)
	an improved understanding of web taxonomies, and (iii) new web interaction
	techniques and interfaces. These notions allow us to cast the design
	of interactive (and responsive) websites in terms of the underlying
	dialog structure and, further, suggest a simple implementation strategy
	with a clean separation of concerns. We also highlight new research
	directions opened up by the generative programming approach to interactive
	information retrieval such as the idea of web interaction axioms.
	© Springer-Verlag Berlin Heidelberg 2005.},
  affiliation = {Department of Computer Science, University of Dayton, OH 45469-2160,
	United States; Department of Computer Science, Virginia Tech., VA
	24061-0106, United States},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-33646127790&partnerID=40&md5=c53ceef28dc670f497ad6429fbdf6ca2}
}

@ARTICLE{Peterson200095,
  author = {Peterson, J.a , Hager, G.b },
  title = {Monadic robotics},
  journal = {SIGPLAN Notices (ACM Special Interest Group on Programming Languages)},
  year = {2000},
  volume = {35},
  pages = {95-108},
  number = {1},
  note = {cited By (since 1996) 0},
  abstract = {We have developed a domain specific language for the construction
	of robot controllers, Frob (Functional ROBotics). The semantic basis
	for Frob is Functional Reactive Programming, or simply FRP, a purely
	functional model of continuous time, interactive systems. FRP is
	built around two basic abstractions: behaviors, values defined continuously
	in time, and events, discrete occurances in time. On this foundation,
	we have constructed abstractions specific to the domain of robotics.
	Frob adds yet another abstraction: the task, a basic unit of work
	defined by a continuous behavior and a terminating event. This paper
	examines two interrelated aspects of Frob. First, we study the design
	of systems based on FRP and how abstractions defined using FRP can
	capture essential domain-specific concepts for systems involving
	interaction over time. Second, we demonstrate an application of monads,
	used here to implement Frob tasks. By placing our task abstraction
	in a monadic framework, we are able to organize task semantics in
	a modular way, allowing new capabilities to be added without pervasive
	changes to the system. We present several robot control algorithms
	specified using Frob. These programs are clear, succinct, and modular,
	demonstrating the power of our approach. © 2000 ACM.},
  affiliation = {Yale University; Johns Hopkins University},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-17644374835&partnerID=40&md5=3f76f77c160554ab78f587d0b40978ad}
}

@CONFERENCE{Petraşcu2008273,
  author = {Petraşcu, V., Chiorean, D., Petraşcu, D.},
  title = {ContractCML - A contract aware component modeling language},
  year = {2008},
  pages = {273-276},
  note = {cited By (since 1996) 0},
  abstract = {Providing software components with a four level contract specification
	- syntax, semantics, synchronization, quality of service - is important
	to their correct (re)use. The mandatory syntactic level is included
	by all current component models. Academic models also employ one
	of the others, but use different formalisms to represent it. Through
	this paper, we propose an integrated approach for handling component
	contracts. We focus on introducing ContractCML (Contract Component
	Modeling Language), a domain specific modeling language that ensures
	the basis of our proposal. © 2008 IEEE.},
  affiliation = {Computer Science Department, Babeş-Bolyai University, Cluj-Napoca,
	Romania},
  art_number = {5204823},
  document_type = {Conference Paper},
  journal = {Proceedings of the 2008 10th International Symposium on Symbolic
	and Numeric Algorithms for Scientific Computing, SYNASC 2008},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-70449495407&partnerID=40&md5=ac5765dbcf5fa28011e1de1ab3d0910e}
}

@ARTICLE{Peyton2004456,
  author = {Peyton, L., Rajwani, A.},
  title = {A generative framework for managed services},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2004},
  volume = {3286},
  pages = {456-468},
  note = {cited By (since 1996) 0},
  abstract = {We identify a special category of applications that manage delivery
	of services by reporting and configuring services based on data collected
	in the delivery of services. Managed delivery has typically been
	an aspect of software systems entangled In domain specific application
	logic. Generative approaches, and in particular domain specific languages,
	have attempted to release application logic from such aspects. We
	demonstrate that such aspects can be considered applications in their
	own right. For managed delivery of services, key elements of a generative
	approach are the domain specialist, reports, metrics, data model,
	configuration parameters, rules, and template-based generation. ©
	Springer-Verlag 2004.},
  affiliation = {School of Information Technology and Engineering, University of Ottawa,
	800 King Edward, Ottawa, Ont. K1N 6N5, Canada},
  author_keywords = {Data model; Generative programming; Managed services; Metrics; Rules;
	Templates},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-35048823323&partnerID=40&md5=ce6bfda17effc7b1e62aa1e053e1b4fd}
}

@CONFERENCE{Peña201080,
  author = {Peña, C., Villalobos, J.},
  title = {An MDE approach to design enterprise architecture viewpoints},
  year = {2010},
  pages = {80-87},
  note = {cited By (since 1996) 1},
  abstract = {Enterprise Architecture (EA) has risen as a tool to support the process
	of making strategic business decisions, by achieving an integral
	vision of business and IT elements of an enterprise. An EA approach
	provides a better understanding of relationships between concepts
	from several domains, such as strategy, process, applications, and
	information. However, this heterogeneous aspect makes EA modeling
	complex because there are many domain specific modeling languages
	that were not designed to be integrated. ArchiMate is an architecture
	description language (ADL) that provides a set of predefined viewpoints
	to model an EA and enhance the communication between business and
	IT people by establishing a common language. However, ArchiMate is
	not clear about the way to customize or create new viewpoints to
	integrate new domains. This paper describes a Model Driven Engineering
	(MDE) framework to support the EA modeling activity by taking the
	ArchiMate language as its foundation. The basis of this framework,
	are tools to specify ArchiMate and its future domain specific extensions.
	It also supports the composition and customization of these domains
	to define a common EA terminology. Finally, it offers tools to define
	customized viewpoints and to build the applications that stakeholders
	need to interact with the EA models. © 2010 IEEE.},
  affiliation = {Universidad de Los Andes, Department of Systems and Computing Engineering,
	Bogotá, Colombia},
  art_number = {5708396},
  author_keywords = {Archimate; Enterprise architecture modeling; Viewpoints},
  document_type = {Conference Paper},
  journal = {Proceedings - 12th IEEE International Conference on Commerce and
	Enterprise Computing, CEC 2010},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-79952389473&partnerID=40&md5=bc065fae3593bf0252690dd2507f5ae2}
}

@CONFERENCE{Pfahler2001293,
  author = {Pfahler, P., Kastens, U.},
  title = {Configuring component-based specifications for domain-specific languages},
  year = {2001},
  pages = {293},
  note = {cited By (since 1996) 1},
  abstract = {The Jacob system supports language design processes on a very high
	level of abstraction, enabling experts from application domains to
	design their own domain-specific languages. The system provides a
	representation of the language design space for a certain application
	domain. The user specifies his language design by composing and configuring
	language components. During this design process, the Jacob system
	checks the consistency of user decisions. The language components
	are provided by an expert in the field of computer languages and
	their implementation. Such a component consist of two parts: the
	implementation part defines how a given language feature is implemented.
	The interface part specifies relations and dependences between different
	components, e.g. to constrain the way different language features
	can be combined. This paper presents component based DSL design using
	the Jacob system and discusses some example applications.},
  author_keywords = {Component-based language specifications; Domain-specific languages;
	Eli; Jacob; Language Design Assistant},
  document_type = {Conference Paper},
  journal = {Proceedings of the Hawaii International Conference on System Sciences},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-0034974349&partnerID=40&md5=3c2c2f12c6b966639bd6bfaf5ec1110e}
}

@CONFERENCE{Pfeiffer201033,
  author = {Pfeiffer, M., Pichler, J.},
  title = {Trade: A language and its tool support for programming in electrical
	engineering},
  year = {2010},
  pages = {33-40},
  note = {cited By (since 1996) 0},
  abstract = {Domain-specific languages (DSL) are languages tailored to a specific
	problem domain. There is a common perception to distinguish between
	horizontal and vertical domains. Horizontal domains covering technical
	software areas as user interface, data base, and testing are elaborated
	resulting in different DSLs available today. On contrary, vertical
	domains such as insurance, telephony, or electrical engineering are
	much less elaborated with sporadic DSLs available and, as result,
	low experience about design and implementation of vertical DSLs.
	In this paper we describe the design and implementation of a domainspecific
	language in the domain of electrical engineering. Furthermore we
	present tool support for this language that enables domain experts
	(e.g. electrical engineers) to develop and maintain programs in their
	domain and to automatically generate corresponding C# programs for
	the .NET platform. The tool support was integrated with the Visual
	Studio development environment. The approach and solution presented
	in this paper enriches the set of successful applications and experiences
	in the field of domain-specific languages for vertical domains.},
  affiliation = {Software Competence Center Hagenberg, Softwarepark 21, A-4232 Hagenberg,
	Austria},
  author_keywords = {Domain-specific languages; Model-driven development; Programming tools},
  document_type = {Conference Paper},
  journal = {Proceedings of the IASTED International Conference on Software Engineering,
	SE 2010},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-77954608487&partnerID=40&md5=9ee532fee4bb9f38f4091982f80a4d29}
}

@CONFERENCE{Pfeiffer2009142,
  author = {Pfeiffer, M., Pichler, J.},
  title = {A DSM approach for end-user programming in the automation domain},
  year = {2009},
  pages = {142-148},
  note = {cited By (since 1996) 0},
  abstract = {In this paper we present an approach and a software prototype that
	enables domain experts to program control software in the automation
	domain. The approach follows the principles of domain-specific modeling
	providing a graphical domain-specific language to model the control
	cycle of an injection molding machine, a user interface to manipulate
	and monitor the control cycle as well as code generators to generate
	control code that can be executed by the machine. As result, domain
	experts like machine operators can manipulate and monitor the control
	cycle directly on the touch-screen of a machine without detailed
	software development expertise. © 2009 IEEE.},
  affiliation = {Software Competence Center Hagenberg GmbH, Hagenberg, Austria},
  art_number = {5195793},
  document_type = {Conference Paper},
  journal = {IEEE International Conference on Industrial Informatics (INDIN)},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-71049181887&partnerID=40&md5=93226319df2bb24d75b30079a3e6c22b}
}

@CONFERENCE{Pfeiffer201047,
  author = {Pfeiffer, R.-H., Wa̧sowski, A.},
  title = {An aspect-based traceability mechanism for domain specific languages},
  year = {2010},
  pages = {47-53},
  note = {cited By (since 1996) 0},
  abstract = {Development environments for domain specific modeling usually represent
	elements of visual models as objects when in memory and as XML elements
	when persisted. Visual models are editable using different kinds
	of editors, and both the in-memory representations and the serialization
	syntax can be manipulated by automatic tools. We present Tengja,
	a toolkit, that automatically collects the traces between model elements
	in abstract, visual, and serialization syntax. Once the trace model
	is established by Tengja it can be used by other applications to
	synchronize representations involved, or to navigate across models.
	We demonstrate the toolkit by implementing a simple navigation support
	on top of it. Copyright 2010 ACM.},
  affiliation = {IT University of Copenhagen, Denmark},
  author_keywords = {Aspect-oriented software development; Model-driven software development;
	Traceability},
  document_type = {Conference Paper},
  journal = {ACM International Conference Proceeding Series},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-77954980772&partnerID=40&md5=256f8c83fcf4f46a44ddb901eb50c523}
}

@CONFERENCE{Piho2011576,
  author = {Piho, G.a b , Tepandi, J.a , Parman, M.a , Puusep, V.a , Roost, M.a
	},
  title = {Test Driven domain modelling},
  year = {2011},
  pages = {576-581},
  note = {cited By (since 1996) 0},
  abstract = {To write software we have to know requirements; to know requirements
	we have to know domain; to know the domain we have to analyze and
	model one. We propose a methodology for applying Test Driven Modelling
	in engineering of domains, requirements and software. We will restrict
	ourselves here to enterprise information systems and therefore to
	business domains. As common for Software Factories, domain models
	(as well as all other models) are software artefacts, not only documentation
	artefacts. In our approach Test Driven Modelling utilizes Test Driven
	Development for domain modelling. Domain models engineered in this
	way are used as Domain Specific Language for specifying software
	requirements. The hypothesis is that such domain models can be used
	for validation of requirements and verification of software, lead
	developments towards Software Factories, and increase dependability
	of software. © 2011 MIPRO.},
  affiliation = {Department of Informatics, Tallinn University of Technology, Raja
	St. 15, Tallinn 12617, Estonia; Clinical and Biomedical Proteomics
	Group, CRUK, Univ. of Leeds, Beckett St, Leeds LS9 7TF, United Kingdom},
  art_number = {5967121},
  author_keywords = {Domain analysis and engineering; Domain model and domain modelling;
	Software engineering; Software factory; Software testing; Test driven
	development; Test driven modelling; Verification and validation},
  document_type = {Conference Paper},
  journal = {MIPRO 2011 - 34th International Convention on Information and Communication
	Technology, Electronics and Microelectronics - Proceedings},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-80052283624&partnerID=40&md5=5b649f2f7ce583252d9add31d12dfe5f}
}

@CONFERENCE{Piho2011570,
  author = {Piho, G.a b , Tepandi, J.a , Roost, M.a , Parman, M.a , Puusep, V.a
	},
  title = {From archetypes based domain model via requirements to software:
	Exemplified by LIMS software factory},
  year = {2011},
  pages = {570-575},
  note = {cited By (since 1996) 0},
  abstract = {The Archetypes Based Development (ABD) proceeds from archetypes based
	domain model via requirements to software. We give an overview of
	ABD and exemplify its application on Laboratory Information Management
	Systems (LIMS) Software Factory development. ABD is guided by Zachman
	Framework and utilizes software engineering triptych together with
	archetypes and archetype patterns. For modelling of domains the Test
	Driven Modelling (TDM) techniques are used. TDM utilizes test driven
	development techniques in domain engineering. The resultant domain
	models serve as the Domain Specific Language for prescribing requirements.
	Implementation and testing of the LIMS Software Factory proves feasibility
	of archetypes based techniques in real life systems. ABD helps developers
	to better understand business requirements, to design cost effective
	enterprise applications through systematic reuse of archetypal components,
	as well as to validate and verify requirements resulting in higher
	quality software. © 2011 MIPRO.},
  affiliation = {Department of Informatics, Tallinn University of Technology, Raja
	St. 15, Tallinn 12617, Estonia; Clinical and Biomedical Proteomics
	Group, CRUK, Univ. of Leeds, Beckett St, Leeds LS9 7TF, United Kingdom},
  art_number = {5967120},
  author_keywords = {Archetype patterns; Archetypes; Domain analysis; Domain model; Domain
	modelling; Laboratory domain model; Laboratory information management
	system (LIMS); Software engineering; Software factory},
  document_type = {Conference Paper},
  journal = {MIPRO 2011 - 34th International Convention on Information and Communication
	Technology, Electronics and Microelectronics - Proceedings},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-80052280525&partnerID=40&md5=f2a3b4e0bc84dc93259f7cda119ac370}
}

@CONFERENCE{Pingel2007823,
  author = {Pingel, A.},
  title = {Structured co-evolution of models and Web application platforms},
  year = {2007},
  pages = {823-824},
  note = {cited By (since 1996) 0},
  abstract = {Web applications exemplify the need for generative programming techniques
	in part due to the many languages, artifacts, and groups of developers
	involved. Some problems remain, including those that that arise from
	the interplay with versioning. This paper proposes addressing these
	problems with structured program transformations, and explores a
	framework for the co-evolution of platform artifacts and the models
	that generate them.},
  affiliation = {University of California, Los Angeles, United States},
  author_keywords = {Design; Languages},
  document_type = {Conference Paper},
  journal = {Proceedings of the Conference on Object-Oriented Programming Systems,
	Languages, and Applications, OOPSLA},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-42149096631&partnerID=40&md5=25aa34bd70c2aea2fa8d945bce8602e2}
}

@CONFERENCE{Pizka2007305,
  author = {Pizka, M., Jürgens, E.},
  title = {Automating language evolution},
  year = {2007},
  pages = {305-315},
  note = {cited By (since 1996) 4},
  abstract = {The design and implementation of complex software systems inherently
	spans multiple levels of abstractions. The concepts of each level
	of abstractions and their interplay are represented by formal languages
	that are either implicitly known or explicitly defined. Achieving
	high productivity in software development and maintenance is thus
	strongly connected with ruling the complexity of multi-level language
	design and evolution. This paper explains the necessity for automating
	multi-level language evolution, discusses its challenges and proposes
	concepts as well as a prototypical tool that support the incremental
	co-evolution of a staged language and program generation architecture.
	This approach reduces the cost of language maintenance and paves
	the ground for an incremental and bottom-up oriented way of developing
	domain specific languages. © 2007 IEEE.},
  affiliation = {Technische Universität München, Institut für Informatik, 85748 Garching,
	Germany},
  art_number = {4239974},
  document_type = {Conference Paper},
  journal = {First Joint IEEE/IFIP Symposium on Theoretical Aspects of Software
	Engineering, TASE '07},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-34548812302&partnerID=40&md5=7bc40bebe7659b64272b9174ad997ac6}
}

@ARTICLE{Pjanić201172,
  author = {Pjanić, E., Hasanović, A.},
  title = {A JRuby infrastructure for converged web and SIP applications},
  journal = {Communications in Computer and Information Science},
  year = {2011},
  volume = {188 CCIS},
  pages = {72-84},
  number = {PART 1},
  note = {cited By (since 1996) 0},
  abstract = {In this paper we present a Ruby infrastructure that can be used for
	rapid development of Web applications with SIP signaling capabilities.
	We construct this infrastructure by combining the Java based Cipango
	SIP/HTTP Servlet Application Server with the Ruby on Rails Web development
	framework. We provide detailed explanations of the steps required
	to build this infrastructure and produce a SIP registrar example
	application with a simple Web interface. The described infrastructure
	allows Ruby applications to utilize the entire functionality provided
	by the SIP Servlet API and can be used as a good starting point for
	the development of Ruby-based domain specific languages for the SIP
	protocol. We also compare the proposed infrastructure with the existing
	Ruby frameworks for SIP application development. © 2011 Springer-Verlag.},
  affiliation = {University of Tuzla, Faculty of Electrical Engineering, Franjevačka
	2, Tuzla 75000, Bosnia and Herzegovina},
  author_keywords = {Cipango; converged applications; dynamic languages; interoperability;
	Jetty; JRuby; Ruby; SIP; software infrastructure},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-79960332188&partnerID=40&md5=847ac15f758972b9a1697f7a179689d6}
}

@CONFERENCE{Plasmeijer2011,
  author = {Plasmeijer, R., Lijnse, B., Achten, P., Michels, S.},
  title = {Getting a grip on tasks that coordinate tasks},
  year = {2011},
  note = {cited By (since 1996) 0},
  abstract = {Workflow management systems (WFMS) are software systems that coordinate
	the tasks human workers and computers have to perform to achieve
	a certain goal. The tasks to do and their interdependencies are described
	in a Workflow Description Language (WDL). Work can be organized in
	many, many ways and in the literature already more than hundred of
	useful workflow patterns for WDL's have been identified. The iTask
	system is not a WFMS, but a combinator library for the functional
	language Clean to support the construction of WFMS applications.
	Workflows can be described in a compositional style, using pure functions
	and combinators as self-contained building blocks. Thanks to the
	expressive power of the underlying functional language, complex workflows
	can be defined on top of just a handful of core task combinators.
	However, it is not sufficient to define the tasks that need to be
	done. We also need to express the way these tasks are being supervised,
	managed and visualized. In this paper we report on our current research
	effort to extend the iTask system such that the coordination of work
	can be defined as special tasks in the system as well. We take the
	opportunity to redesign editors which share information and the combinators
	for defining GUI interfaces for tasks, such as buttons, menu's and
	windows. Even though the expressiveness of the resulting system increases
	significantly, the number of core combinators can be reduced. We
	argue that only two general Swiss-Army-Knife higher order functions
	are needed to obtain the desired functionality. This simplifies the
	implementation significantly and increases the maintainability of
	the system. We discuss the design space and decisions that lead to
	these two general functions for constructing tasks. © 2011 ACM.},
  affiliation = {Radboud University Nijmegen, Nijmegen, Netherlands},
  author_keywords = {embedded domain specific language; functional combinator library;
	workflow system},
  document_type = {Conference Paper},
  journal = {Proceedings of the 11th Workshop on Language Descriptions, Tools
	and Applications, LDTA'11},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-79959882405&partnerID=40&md5=d22ed29f58d205174638b9c23e5b65a1}
}

@ARTICLE{Pohjonen2005442,
  author = {Pohjonen, R.},
  title = {Metamodeling made easy - MetaEdit+},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2005},
  volume = {3676 LNCS},
  pages = {442-446},
  note = {cited By (since 1996) 0},
  abstract = {Many current metamodeling environments still require manual programming
	to build full tool support for the modeling language, especially
	for language constraints, representational elements and graphical
	editing tools. Because of this, a considerable part of development
	resources has to be reserved for secondary assets of the final environment
	instead of its main vehicle, the modeling language itself. In this
	demonstration, we present the MetaEdit+ metaCASE tool, and show how
	metamodeling and tool support for domain-specific modeling languages
	can be completed without programming. We will describe the metamodeling
	tool set of MetaEdit+ and explain how conceptual and representational
	metamodeling is carried out with it. Finally, we will look at the
	executable modeling environment derived from the metamodel. © Springer-Verlag
	Berlin Heidelberg 2005.},
  affiliation = {MetaCase, Ylistönmäentie 31, 40500 Jyväskylä, Finland},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-33646159966&partnerID=40&md5=b0aaf095eb88512636437fd22353298d}
}

@ARTICLE{Polak200275,
  author = {Polak, W.},
  title = {Formal methods in practice},
  journal = {Science of Computer Programming},
  year = {2002},
  volume = {42},
  pages = {75-85},
  number = {1},
  note = {cited By (since 1996) 0},
  abstract = {Technology transfer from academic research to industrial practice
	is hampered by social, political, and economic problems more than
	by technical issues. This paper describes one instance of successful
	technology transfer based on a special-purpose language and an associated
	translation tool tailored to the customer's needs. The key lesson
	to be learned from this example is that mathematical formalisms must
	be transparent to the user. Formalisms can be effectively employed
	if they are represented by tools that fit into existing work processes.
	It is suggested that special-purpose, domain-specific languages and
	their translators are an important vehicle to transition advanced
	technology to practice. This approach enables domain experts to solve
	problems using familiar terminology. It enables engineers of all
	disciplines to utilize computers without becoming software engineers.
	In doing so, we not only mitigate the chronic shortage of qualified
	software personnel but also simplify the problem of requirements
	analysis and specification. © 2002 Elsevier Science B.V. All rights
	reserved.},
  affiliation = {1021 Yorktown Drive, Sunnyvale, CA 94087-2071, United States},
  author_keywords = {Code synthesis; Domain-specific languages; Technology transfer},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-0036131855&partnerID=40&md5=0a352994ad1fecc456f69c2493addb1f}
}

@ARTICLE{Polak199962,
  author = {Polak, W.},
  title = {Formal methods in practice},
  journal = {Electronic Notes in Theoretical Computer Science},
  year = {1999},
  volume = {25},
  pages = {62-72},
  note = {cited By (since 1996) 0},
  abstract = {Technology transfer from academic research to industrial practice
	is hampered by social, political and economic problems more that
	by technical issues. This paper describes one instance of successful
	technology transfer based on a special-purpose language and associated
	translation tool tailored to the customer's needs. The key lesson
	to be learned from this example is that mathematical formalisms must
	be transparent to the user. Formalisms can be effectively employed
	if they are represented by tools that fit into existing work processes.
	It is suggested that the model of special-purpose, domain-specific
	languages and their translators are an important vehicle to transition
	advanced technology to practice. This approach enables domain experts
	to solve problems using familiar terminology. It enables engineers
	of all disciplines to utilize computers without becoming software
	engineers. In doing so we not only mitigate the chronic shortage
	of qualified software personnel but also simplify the problem of
	requirements analysis and specification. ©2000 Published by Elsevier
	Science B.V.},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-19144371289&partnerID=40&md5=11ec045a0c0b1e98f3839468a5231fca}
}

@ARTICLE{Polakovic2007242,
  author = {Polakovic, J.a b , Mazare, S.a , Stefani, J.-B.b , David, P.-C.c
	},
  title = {Experience with safe dynamic reconfigurations in component-based
	embedded systems},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2007},
  volume = {4608 LNCS},
  pages = {242-257},
  note = {cited By (since 1996) 4},
  abstract = {Supporting dynamic reconfiguration is required even in highly constrained
	embedded systems, to allow software patches and updates, and to allow
	adaptations to changes in environmental and operating conditions
	without service interruption. Dynamic reconfiguration, however, is
	a complex and error prone process. In this paper we report our experience
	in implementing safe dynamic reconfigurations in embedded devices
	with limited resources. Our approach relies on a component-based
	framework for building reconfigurable operating systems, and the
	use of a domain specific language (DSL) for reconfiguration. © Springer-Verlag
	Berlin Heidelberg 2007.},
  affiliation = {FranceTelecom. R and D, MAPS/AMS Lab., Grenoble, France; SARDES Project,
	INRIA Rhône Alpes, Grenoble, France; OBASCO Group, EMN/TNRIA, Lina,
	Nantes, France},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-38149133760&partnerID=40&md5=2688b40d87ea6e86ff2883782fd2c334}
}

@CONFERENCE{Pontelli20031005,
  author = {Pontelli, E., Son, T.C., Pan, Y., Phan, T.},
  title = {Developing agents for bioinformatics applications: A preliminary
	design},
  year = {2003},
  volume = {3},
  pages = {1005-1011},
  note = {cited By (since 1996) 0},
  abstract = {A brief overview of the φLOG project, aimed at the development of
	a domain specific framework for the rapid prototyping of applications
	in evolutionary biology. The framework is based on a DSL, whose execution
	model relies on the automatic combination of existing bioinformatics
	services. Moreover, the framework is under development as a collaboration
	between researchers in Computer Science and Biology at NMSU.},
  affiliation = {Department of Computer Science, New Mexico State University, Las Cruces,
	NM, United States},
  author_keywords = {Bioinformatics; Domain specific languages; Semantic web},
  document_type = {Conference Paper},
  journal = {Proceedings of the International Conference on Parallel and Distributed
	Processing Techniques and Applications},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-1642316408&partnerID=40&md5=b1432b05848f1bb0fc6a507ba5104069}
}

@ARTICLE{Pop2005137,
  author = {Pop, A., Savga, I., Aßmann, U., Fritzson, P.},
  title = {Composition of XML dialects: A modelicaXML case study},
  journal = {Electronic Notes in Theoretical Computer Science},
  year = {2005},
  volume = {114},
  pages = {137-152},
  number = {SPEC. ISS.},
  note = {cited By (since 1996) 1},
  abstract = {This paper investigates how software composition and transformation
	can be applied to domain specific languages used today in modeling
	and simulation of physical systems. More specifically, we address
	the composition and transformation of the Modelica language. The
	composition targets the ModelicaXML dialect which is the XML representation
	of the Modelica language. By extending the COMPOST concrete composition
	layer with a component model for Modelica, we provide composition
	and transformation of Modelica. The design of our COMPOST extension
	is presented togheter with examples of composition programs for Modelica.
	© 2004 Elsevier B.V.},
  affiliation = {Programming Environments Laboratory, Dept. of Comp. and Info. Science,
	Linköping University, Linköping, Sweden},
  author_keywords = {Composition of XML dialects; COMPOST; Domain Specific Languages; Modelica;
	ModelicaXML; XML},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-12344255210&partnerID=40&md5=d9d583d0ee597dfe6ba861cde426c1aa}
}

@ARTICLE{Porkoláb2010306,
  author = {Porkoláb, Z.},
  title = {Functional programming with C++ template metaprograms},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2010},
  volume = {6299 LNCS},
  pages = {306-353},
  note = {cited By (since 1996) 0},
  abstract = {Template metaprogramming is an emerging new direction of generative
	programming. With the clever definitions of templates we can force
	the C++ compiler to execute algorithms at compilation time. Among
	the application areas of template metaprograms are the expression
	templates, static interface checking, code optimization with adaption,
	language embedding and active libraries. However, as template metaprogramming
	was not an original design goal, the C++ language is not capable
	of elegant expression of metaprograms. The complicated syntax leads
	to the creation of code that is hard to write, understand and maintain.
	Although template metaprogramming has a strong relationship with
	functional programming, this is not reflected in the language syntax
	and existing libraries. In this paper we give a short and incomplete
	introduction to C++ templates and the basics of template metaprogramming.
	We will enlight the role of template metaprograms, and some important
	and widely used idioms. We give an overview of the possible application
	areas as well as debugging and profiling techniques. We suggest a
	pure functional style programming interface for C++ template metaprograms
	in the form of embedded Haskell code which is transformed to standard
	compliant C++ source. © 2010 Springer-Verlag.},
  affiliation = {Eötvös Loránd University, Faculty of Informatics, Dept. of Programming
	Languages and Compilers, Pazmany Peter setany 1/C, H-1117 Budapest,
	Hungary},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-78650882299&partnerID=40&md5=25db5d7f0bb3c05b8652c8905cdbd2cc}
}

@CONFERENCE{Porkoláb2010137,
  author = {Porkoláb, Z., Sinkovics, A.},
  title = {Domain-specific language integration with compile-time parser generator
	library},
  year = {2010},
  pages = {137-146},
  note = {cited By (since 1996) 0},
  abstract = {Smooth integration of domain-specific languages into a general purpose
	host language requires absorbing of domain code written in arbitrary
	syntax. The integration should cause minimal syntactical and semantic
	overhead and introduce minimal dependency on external tools. In this
	paper we discuss a DSL integration technique for the C++ programming
	language. The solution is based on compile-time parsing of the DSL
	code. The parser generator is a C++ template metaprogram reimplementation
	of a runtime Haskell parser generator library. The full parsing phase
	is executed when the host program is compiled. The library uses only
	standard C++ language features, thus our solution is highly portable.
	As a demonstration of the power of this approach, we present a highly
	efficient and type-safe version of printf and the way it can be constructed
	using our library. Despite the well known syntactical difficulties
	of C++ template metaprograms, building embedded languages using our
	library leads to self-documenting C++ source code. © 2010 ACM.},
  affiliation = {Eötvös Loránd University, Dept. of Programming Languages and Compilers,
	H-1117 Pazmany Peter setany 1/C, Budapest, Hungary},
  author_keywords = {C++ template metaprogram; DSL integration; Haskell; Parser generator},
  document_type = {Conference Paper},
  journal = {GPCE'10 - Proceedings of the 2010 Conference on Generative Programming
	and Component Engineering},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-78650093323&partnerID=40&md5=d0825fba335c775c0b5c5b9740e2feca}
}

@ARTICLE{Porkoláb2011137,
  author = {Porkoláb, Z., Sinkovics, Á.},
  title = {Domain-specific language integration with compile-time parser generator
	library},
  journal = {ACM SIGPLAN Notices},
  year = {2011},
  volume = {46},
  pages = {137-146},
  number = {2},
  note = {cited By (since 1996) 0},
  abstract = {Smooth integration of domain-specific languages into a general purpose
	host language requires absorbing of domain code written in arbitrary
	syntax. The integration should cause minimal syntactical and semantic
	overhead and introduce minimal dependency on external tools. In this
	paper we discuss a DSL integration technique for the C++ programming
	language. The solution is based on compile-time parsing of the DSL
	code. The parser generator is a C++ template metaprogram reimplementation
	of a runtime Haskell parser generator library. The full parsing phase
	is executed when the host program is compiled. The library uses only
	standard C++ language features, thus our solution is highly portable.
	As a demonstration of the power of this approach, we present a highly
	efficient and type-safe version of printf and the way it can be constructed
	using our library. Despite the well known syntactical difficulties
	of C++ template metaprograms, building embedded languages using our
	library leads to self-documenting C++ source code. Copyright © 2010
	ACM.},
  affiliation = {Eötvös Loránd University, Dept. of Programming Languages and Compilers,
	Pazmany Peter setany 1/C, Budapest, Hungary},
  author_keywords = {C++ template metaprogram; DSL integration; Haskell; Parser generator},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-79951735500&partnerID=40&md5=62bb39022514e553d877e56d8997f5f0}
}

@ARTICLE{Pottier201042,
  author = {Pottier, R., Léger, M., Menaud, J.-M.},
  title = {A reconfiguration language for virtualized grid infrastructures},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2010},
  volume = {6115 LNCS},
  pages = {42-55},
  note = {cited By (since 1996) 0},
  abstract = {The growing needs in computational power to answer to the increasing
	number of on-line services and the complexity of applications makes
	it mandatory to build corresponding hardware infrastructures and
	to share several distributed hardware and software resources thanks
	to grid computing. To help with optimizing resource utilization,
	system virtualization is a more and more adopted technique in data
	centers. However, this software layer adds to the administration
	complexity of servers and it requires specific management tools to
	deal with hypervisor functionalities like live migration. To address
	this problem, we propose VMScript, a domain specific language for
	administration of virtualized grid infrastructures. This language
	relies on set manipulation and is used to introspect physical and
	virtual grid architectures thanks to query expressions and notably
	to modify VM placement on machines. © 2010 Springer-Verlag Berlin
	Heidelberg.},
  affiliation = {Ascola (EMN/INRIA, LINA), Ecole des Mines de Nantes, 4, rue Alfred
	Kastler, Nantes 44307, France},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-77953736141&partnerID=40&md5=54be9dcac8a0cbcea70a11361c259d03}
}

@CONFERENCE{Pozo200952,
  author = {Pozo, S., Varela-Vaca, A.J., Gasca, R.M.},
  title = {AFPL2, an abstract language for firewall ACLs with NAT support},
  year = {2009},
  pages = {52-59},
  note = {cited By (since 1996) 0},
  abstract = {The design and management of firewall ACLs is a very hard and error-prone
	task. Part of this complexity comes from the fact that each firewall
	platform has its own low-level language with a different functionality,
	syntax, and development environment. Although high-level languages
	have been proposed to model firewall ACLs, none of them has been
	widely adopted by the industry due to a combination of factors: high
	complexity, no support of important features of firewalls, etc. In
	this paper the most important access control policy languages are
	reviewed, with special focus on the development of firewall ACLs.
	Based on this analysis, a new domain specific language for firewall
	ACLs (AFPL2) is proposed, supporting more features that other languages
	do not cover (e.g. NAT). As the result of our design methodology,
	AFPL2 is very lightweight and easy to use. AFPL2 can be translated
	to existing low-level firewall languages, or be directly interpreted
	by firewall platforms, and is an extension to a previously developed
	language. © 2009 IEEE.},
  affiliation = {Department of Computer Languages and Systems, ETS Ingenieria Informatica,
	University of Seville, 41012 Seville, Spain},
  art_number = {5211094},
  author_keywords = {Acl; Firewall; Language; Model; Nat},
  document_type = {Conference Paper},
  journal = {Proceedings - 2009 2nd International Conference on Dependability,
	DEPEND 2009},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-70449440803&partnerID=40&md5=a225563806333c542c1586e67e6a5cce}
}

@CONFERENCE{Prasetya2011,
  author = {Prasetya, I.S.W.B.a , Amorim, J.a , Vos, T.E.J.b , Baars, A.b },
  title = {Using Haskell to script combinatoric testing of web services},
  year = {2011},
  note = {cited By (since 1996) 0},
  abstract = {The Classification Tree Method (CTM) is a popular approach in functional
	testing as it allows the testers to systematically partition the
	input domain of an SUT, and specifies the combinations they want.
	We have implemented the approach as a small domain specific language
	(DSL) embedded in the functional language Haskell. Such an embedding
	leads to clean syntax and moreover we can natively access Haskell's
	full features. This paper will explain the approach, and how it is
	applied for testing Web Services. © 2011 AISTI.},
  affiliation = {Dept. of Inf. and Comp. Sciences, Utrecht University, Netherlands;
	Dept. de Sist. Informaticos Y Comp., Univ. Polit. de Valencia, Spain},
  art_number = {5974321},
  author_keywords = {automated testing; combinatoric testing},
  document_type = {Conference Paper},
  journal = {Proceedings of the 6th Iberian Conference on Information Systems
	and Technologies, CISTI 2011},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-80052440645&partnerID=40&md5=36e87a2f889a0d2c66d8f07e8d6aac36}
}

@ARTICLE{Prasse2007111,
  author = {Prasse, M.},
  title = {Let's modularize the data model specifications of the ObjectLens
	in VisualWorks/smalltalk},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2007},
  volume = {4406 LNCS},
  pages = {111-133},
  note = {cited By (since 1996) 0},
  abstract = {The ObjectLens framework of VisualWorks maps objects to tables. This
	mapping is described in a data mapping model, which itself is specified
	in one dataModelSpec method. This method is monolithic and defines
	the whole data model of an application. This is a suitable approach
	to start with. However, when the business area extends to a set of
	similar applications, like a software product family, each of these
	applications needs its own data model specification. All specifications
	of the product family would be quite similar but there is no appropriate
	reuse-mechanism, which could be used. Consequently, the monolithic
	design specifications lead to a high degree of redundancy, which
	complicates software development and maintenance. Therefore, this
	paper describes an approach, which leads to a separation of the monolithic
	data model specifications. The main idea is to define the mappings
	of each class in the class itself using inheritance and generate
	the whole specification from a list of single class data models.
	In this way, declarative and generative programming techniques are
	combined. © Springer-Verlag Berlin Heidelberg 2007.},
  affiliation = {Collogia Unternehmungsberatung AG, Ubierring 11, D-50678 Köln, Germany},
  author_keywords = {Design pattern; Generative programming; ObjectLens; OR-mapping; Smalltalk;
	Software product families; VisualWorks},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-38049150441&partnerID=40&md5=7bf0fb6de4a9fa1fa87018985fb87407}
}

@CONFERENCE{Priesnitz200730,
  author = {Priesnitz, A.P., Schupp, S.},
  title = {A pattern for static reflection on fields sharing internal representations
	in indexed family containers},
  year = {2007},
  volume = {PL},
  number = {DPS/KE//-},
  pages = {30-37},
  note = {cited By (since 1996) 0},
  abstract = {Reflection allows defining generic operations in terms of the constituents
	of objects. These definitions incur overhead if reflection takes
	place at run time, which is the common case in popular languages.
	If performance matters, some compile-time means of reflection is
	desired to obviate that penalty. Furthermore, the information provided
	by static reflection can be utilised for class generation, e.g.,
	to optimize internal representation. We demonstrate how to provide
	static reflection on class field properties by means of generic components
	in an OO language with static meta-programming facilities. Surprisingly,
	a major part of the solution is not specific to the particular task
	of providing reflection. We define the internal representation of
	classes by a reworked implementation of a generic container that
	models the concept of a statically indexed family. The proposed features
	of this implementation are also beneficial to its use as a common
	container.},
  affiliation = {Department of Computer Science, Department of Engineering, Chalmers
	Technical University, Goteborg, Sweden},
  author_keywords = {Container; Generative programming; High performance; Serialization;
	Static reflection},
  document_type = {Conference Paper},
  journal = {ICSOFT 2007 - 2nd International Conference on Software and Data Technologies,
	Proceedings},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-67649995082&partnerID=40&md5=f7307f7106f21091f10d8db88d74d8a0}
}

@ARTICLE{Proetzsch2010317,
  author = {Proetzsch, M.a , Zimmermann, F.b , Eschbach, R.b , Kloos, J.b , Berns,
	K.a },
  title = {A systematic testing approach for autonomous mobile robots using
	domain-specific languages},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2010},
  volume = {6359 LNAI},
  pages = {317-324},
  note = {cited By (since 1996) 0},
  abstract = {One aspect often neglected during the development of autonomous mobile
	robots is the systematic validation of their overall behavior. Especially
	large robots applied to real-world scenarios may cause injuries or
	even human death and must therefore be classified as safety-critical.
	In this paper, a generic approach to defining and executing purposeful
	test runs using domain-specific languages (dsls) is presented. Test
	cases can be defined in an appropriate test description language
	(first dsl). These test cases can be derived automatically using
	a model-based testing approach, for which a test model has to be
	created. Hence, a second dsl for the creation of the test model is
	presented. It is further shown how the generated test cases are automatically
	executed and evaluated. The paper concludes with the application
	of the approach to the autonomous off-road robot ravon. © 2010 Springer-Verlag
	Berlin Heidelberg.},
  affiliation = {Robotics Research Lab, TU Kaiserslautern, Kaiserslautern 67653, Germany;
	Department of Testing and Inspections, Fraunhofer IESE, Kaiserslautern
	67663, Germany},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-78349285133&partnerID=40&md5=7ccc6cad6d759ed4e20230b11b4c999e}
}

@CONFERENCE{Prähofer2010908,
  author = {Prähofer, H., Hurnaus, D.},
  title = {MONACO - A domain-specific language supporting hierarchical abstraction
	and verification of reactive control programs},
  year = {2010},
  pages = {908-914},
  note = {cited By (since 1996) 1},
  abstract = {Domain-specific languages aim to present software in the notations
	of domain experts and allow a straightforward mapping of application
	concepts to software solutions. In this paper, we present a domain-specific
	language for programming reactive control programs. The language
	differs from other approaches mainly by its hierarchical component
	approach, in which lower-level components provide elementary operations
	and upper components rely on the operations of their subordinates
	to implement higher control tasks. Moreover, the hierarchical component
	approach is leveraged in a hierarchical verification technique in
	which component implementations are verified against dynamic contracts
	of their subcomponents. We present the principles of the verification
	technique and discuss how it can be applied in a multi-stage development
	process. © 2010 IEEE.},
  affiliation = {Christian Doppler Laboratory of Automated Software Engineering, Institute
	for Systems Software, Johannes Kepler University, Linz, Austria},
  art_number = {5549622},
  document_type = {Conference Paper},
  journal = {IEEE International Conference on Industrial Informatics (INDIN)},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-77956578126&partnerID=40&md5=8327cb127cfc467463140081ea096d23}
}

@CONFERENCE{Prähofer200876,
  author = {Prähofer, H., Hurnaus, D., Schatz, R., Wirth, C., Mössenböck, H.},
  title = {Software support for building end-user programming environments in
	the automation domain},
  year = {2008},
  pages = {76-80},
  note = {cited By (since 1996) 0},
  abstract = {Projects in the automation domain often require that end users, who
	are the machine operators, have means to change control software
	to make adaptations and optimizations for the machining task at hand.
	Although they usually do not have any software development expertise,
	they intervene in safety-critical software systems. This results
	in high demands on end-user programming environments with respect
	to supporting, guiding, and supervising end users. In this paper
	we present a software framework which is intended to serve as a basis
	for developing end-user programming environments. The main parts
	of this framework are a domainspecific language for programming automation
	solutions at a high level of abstraction, different visual editors
	for supporting end users, an approach for checking program changes
	against formal specifications, a variability modeling approach for
	representing high-level user decisions, and an approach for setting
	up customized end-user environments from models. Copyright 2008 ACM.},
  affiliation = {Christian Doppler Laboratory for Automated Software Engineering, Johannes
	Kepler University, A-4040 Linz, Austria},
  art_number = {1370864},
  author_keywords = {Domain-specific language; End-user programming; Industrial automation;
	Visual language; Visual programming},
  document_type = {Conference Paper},
  journal = {Proceedings - International Conference on Software Engineering},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-57049090637&partnerID=40&md5=ce68a1bd9fc040ab000d569d1c28ed70}
}

@CONFERENCE{Prähofer2007104,
  author = {Prähofer, H., Hurnaus, D., Wirth, C., Mössenböck, H.},
  title = {The domain-specific language Monaco and its visual interactive programming
	environment},
  year = {2007},
  pages = {104-107},
  note = {cited By (since 1996) 1},
  abstract = {Monaco is a domain-specific language for machine automation programming.
	It has been developed with the objective to empower domain experts
	with limited programming capabilities. Its main language features
	are an imperative notation for reactive systems, concepts for describing
	asynchronous event handling in a concise way, and a state-of-the-art
	component approach. Monaco is a programming language with a Pascal-like
	syntax, but also comes with a visual programming environment. In
	this paper we review the language Monaco, show the visual representation
	scheme, report on the programming environment and compare our visual
	notation to Statecharts. © 2007 IEEE.},
  affiliation = {Christian Doppler Laboratory for Automated Software Engineering, Johannes
	Kepler University, A-4040 Linz, Austria},
  art_number = {4351334},
  author_keywords = {Automation control; Domain-specific language; End-user programming;
	Visual language; Visual programming},
  document_type = {Conference Paper},
  journal = {Proceedings - IEEE Symposium on Visual Languages and Human-Centric
	Computing, VL/HCC 2007},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-47949128910&partnerID=40&md5=d0384d7230bf31842fef4e1a51fb230e}
}

@CONFERENCE{Pu20052,
  author = {Pu, C., Swint, G.},
  title = {DSL weaving for distributed information flow systems},
  year = {2005},
  volume = {3399},
  pages = {2-14},
  note = {cited By (since 1996) 0},
  abstract = {Aspect-oriented programming (AOP) is a promising field for reducing
	application complexity. However, it has proven difficult to implement
	weavers for general purpose languages. Nevertheless, we felt some
	functionality for our information flow abstraction, Infopipes, might
	be best captures in aspects. In this paper, we describe a weaver
	built for domain specific languages (DSLs) related to Infopipes around
	an off-the-shelf XSLT processor. Aspects are written in XSLT, XML
	annotations are added to existing DSL generation templates, and XML
	directives are added to our Infopipes specification. Finally, we
	successfully demonstrate a generated+woven application that adds
	the quality of service (QoS) dimension CPU usage awareness to an
	image streaming application. © Springer-Verlag Berlin Heidelberg
	2005.},
  affiliation = {CERCS, College of Computing, Georgia Institute of Technology, 801
	Atlantic Drive, Atlanta, GA 30332-0280, United States},
  document_type = {Conference Paper},
  journal = {Lecture Notes in Computer Science},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-24144496862&partnerID=40&md5=0c2e70fa64061354f1923d70c12a566c}
}

@ARTICLE{Pu200125,
  author = {Pu, C., Schwan, K., Walpole, J.},
  title = {Infosphere project: System support for information flow applications},
  journal = {SIGMOD Record (ACM Special Interest Group on Management of Data)},
  year = {2001},
  volume = {30},
  pages = {25-34},
  number = {1},
  note = {cited By (since 1996) 16},
  abstract = {We describe the Infosphere project, which is building the systems
	software support for information-driven applications such as digital
	libraries and electronic commerce. The main technical contribution
	is the Infopipe abstraction to support information flow with quality
	of service. Using building blocks such as program specialization,
	software feedback, domain-specific languages, and personalized information
	filtering, the Infopipe software generates code and manages resources
	to provide the specified quality of service with support for composition
	and restructuring.},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-0003260789&partnerID=40&md5=9d6a87050065a97c3877d78a547928b7}
}

@ARTICLE{PérezAndrés200882,
  author = {Pérez Andrés, F.a , De Lara, J.a , Guerra, E.b },
  title = {Domain specific languages with graphical and textual views},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2008},
  volume = {5088 LNCS},
  pages = {82-97},
  note = {cited By (since 1996) 0},
  abstract = {We show our approach for the definition of Domain Specific Languages
	integrating both graphical and textual views. The approach is based
	on the meta-modelling concepts provided by the AToM3 tool. In this
	way, the language designer starts building the meta-model of the
	complete language. Then, he can select (possibly overlapping) submodels
	of the meta-model to define the different diagram types (i.e. language
	viewpoints). By default, the viewpoint is assigned a graphical concrete
	syntax, although a textual one can also be given. This is performed
	by selecting (or creating) triple graph grammar rules to translate
	from the viewpoint meta-model to a DSL called Textual that contains
	the most common elements of textual languages (such as expressions
	or operators). From a Textual model, a parser is automatically generated,
	where the semantic actions of the EBNF grammar are graph grammar
	rules, derived from the viewpoint meta-model. In this way, the parsing
	results in a model conformant to the viewpoint meta-model, which
	can be seamlessly integrated with other graphical and textual views.
	© 2008 Springer Berlin Heidelberg.},
  affiliation = {Polytechnic School, Univ. Autónoma de Madrid, Spain; Computer Science
	Department, Univ. Carlos III de Madrid, Spain},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-56749159161&partnerID=40&md5=5065e30837898f887c31660b88769e3c}
}

@CONFERENCE{Püschel20111,
  author = {Püschel, M.},
  title = {Automatic performance programming?},
  year = {2011},
  pages = {1-2},
  note = {cited By (since 1996) 0},
  abstract = {It has become extraordinarily difficult to write software that performs
	close to optimally on complex modern microarchitectures. Particularly
	plagued are domains that are data intensive and require complex mathematical
	computations such as information retrieval, scientific simulations,
	graphics, communication, control, and multimedia processing. In these
	domains, performance-critical components are usually written in C
	(with possible extensions) and often even in assembly, carefully
	tuned to the platforms architecture and microarchitecture. Specifically,
	the tuning includes optimization for the memory hierarchy and for
	different forms of parallelism. The result is usually long, rather
	unreadable code that needs to be re-written or re-tuned with every
	platform upgrade. On the other hand, the performance penalty for
	relying on straightforward, non-tuned, more elegant implementations
	is typically a factor of 10, 100, or even more. The reasons for this
	large gap are some (likely) inherent limitations of compilers including
	the lack of domain knowledge, and the lack of an efficient mechanism
	to explore the usually large set of transformation choices. The recent
	end of CPU frequency scaling, and thus the end of free software speed-up,
	and the advent of mainstream parallelism with its increasing diversity
	of platforms further aggravate the problem. No promising general
	solution (besides extensive and expensive hand-coding) to this problem
	is on the horizon. One approach that has emerged from the numerical
	computing and compiler community in the last decade is called automatic
	performance tuning, or autotuning [2, 3, 7-10, 15]. In its most common
	form it involves the consideration or enumeration of alternative
	implementations, usually controlled by parameters, coupled with algorithms
	for search to find the fastest. However, the search space still has
	to be identified manually, it may be very different even for related
	functionality, it is not clear how to handle parallelism, and a new
	platform may require a complete redesign of the autotuning framework.
	On the other hand, since the overall problem is one of productivity,
	maintainability, and quality (namely performance) it falls squarely
	into the domain of software engineering. However, even though a large
	set of sophisticated software engineering theory and tools exist,
	it appears that to date this community has not focused much on mathematical
	computations nor performance in the detailed, close-to-optimal sense
	above. The reason for the latter may be that performance, unlike
	various aspects of correctness, is not syntactic in nature (and in
	reality is often even unpredictable and, well, messy). The aim of
	this talk is to draw attention to the performance/ productivity problem
	for mathematical applications and to make the case for a more interdisciplinary
	attack. As a set of thoughts in this direction we offer some of the
	lessons we have learned in the last decade in our own research on
	Spiral [1, 11, 12]. Spiral can be viewed as an automatic performance
	programming framework for a small, but important class of functions
	called linear transforms. Key techniques used in Spiral include staged
	declarative domainspecific languages to express algorithm knowledge
	and algorithm transformations, the use of platform-cognizant rewriting
	systems for parallelism and locality optimizations, and the use of
	search and machine learning techniques to navigate possible spaces
	of choices [4-6, 13, 14, 16]. Experimental results show that the
	code generated by Spiral competes with, and sometimes outperforms,
	the best available humanwritten code. Spiral has been used to generate
	part of Intels commercial libraries IPP and MKL. Copyright © 2011
	ACM.},
  affiliation = {ETH, Zurich, Switzerland},
  author_keywords = {Automation; Domain-specific language; Fourier transform; High performance;
	Matrix algebra; Parallelization; Program generation; Rewriting; Vectorization},
  document_type = {Conference Paper},
  journal = {ONWARD!'11 - Proceedings of the 10th ACM Symposium on New Ideas,
	New Paradigms, and Reflections on Programming and Software},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-81455135712&partnerID=40&md5=26e85346438b26d9ec9cc7928d0fe414}
}

@CONFERENCE{Püschel20071,
  author = {Püschel, M.},
  title = {Can we teach computers to write fast libraries?},
  year = {2007},
  pages = {1-2},
  note = {cited By (since 1996) 0},
  abstract = {As the computing world "goes multicore", high performance library
	development finally becomes a nightmare. Optimal programs, and their
	underlying algorithms, have to be adapted to take full advantage
	of the platform's parallelism, memory hierarchy, and available instruction
	set. To make things worse, the best implementations are often platform-dependent
	and platforms are constantly evolving, which quickly renders libraries
	obsolete. As a consequence, developers are forced to permanently
	re-implement and re-optimize the same functionality and often even
	revert to assembly coding just as 50 years ago. A number of research
	efforts have started to address this problem in a new area called
	Automatic Performance Tuning with the common goal to rethink the
	way libraries are created. In this talk we present Spiral (www.spiral.net),
	a program generation system for linear transforms. Spiral generates
	highly optimized, platform-tuned implementations of transforms directly
	from a problem specification. For a user-specified transform, Spiral
	generates alternative algorithms, optimizes them, compiles them into
	programs, and "intelligently" searches for the best match to the
	computing platform. The main idea behind Spiral is a mathematical,
	declarative framework to represent algorithms and the use of rewriting
	systems to generate and optimize algorithms at a high level of abstraction.
	Optimization includes parallelization for vector architectures, shared
	and distributed memory platforms, GPUs, and even FPGAs. Experimental
	results show that the code generated by Spiral competes with, and
	sometimes outperforms, the best available human-written library code.
	Further, recent research shows that it may be possible to extend
	Spiral into other domains such as coding or linear algebra. As for
	the question in the title: Spiral shows that, at least for well-understood
	problem domains, a positive answer may be in reach.},
  affiliation = {Electrical and Computer Engineering, Carnegie Mellon University, 5000
	Forbes Ave, Pittsburgh, PA 15232, United States},
  author_keywords = {Automation; Domain-specific language; Fourier transform; High performance;
	Matrix algebra; Parallelization; Program generation; Rewriting; Vectorization},
  document_type = {Conference Paper},
  journal = {GPCE'07 - Proceedings of the Sixth International Conference on Generative
	Programming and Component Engineering},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-38849124793&partnerID=40&md5=0cb7e9907b29fdd83cf16539d32935f4}
}

@ARTICLE{Püschel200421,
  author = {Püschel, M.a , Moura, J.M.F.a , Singer, B.b , Xiong, J.c , Johnson,
	J.d , Padua, D.e , Veloso, M.f , Johnson, R.W.g },
  title = {SPIRAL: A generator for platform-adapted libraries of signal processing
	algorithms},
  journal = {International Journal of High Performance Computing Applications},
  year = {2004},
  volume = {18},
  pages = {21-45},
  number = {1},
  note = {cited By (since 1996) 32},
  abstract = {SPIRAL is a generator for libraries of fast software implementations
	of linear signal processing transforms. These libraries are adapted
	to the computing platform and can be re-optimized as the hardware
	is upgraded or replaced. This paper describes the main components
	of SPIRAL: the mathematical framework that concisely describes signal
	transforms and their fast algorithms; the formula generator that
	captures at the algorithmic level the degrees of freedom in expressing
	a particular signal processing transform; the formula translator
	that encapsulates the compilation degrees of freedom when translating
	a specific algorithm into an actual code implementation; and, finally,
	an intelligent search engine that finds within the large space of
	alternative formulas and implementations the "best" match to the
	given computing platform. We present empirical data that demonstrate
	the high performance of SPIRAL generated code.},
  affiliation = {Dept. of Elec. and Comp. Eng., Carnegie Mellon University, Pittsburgh,
	PA 15213-3890, United States; 716 Quiet Pond Ct., Odenton, MD 21113,
	United States; 3315 Digital Computer Laboratory, 1304 W Springfield
	Ave, Urbana, IL 61801, United States; Department of Computer Science,
	Drexel University Philadelphia, Philadelphia, PA 19104-2875, United
	States; Department of Computer Science, Univ. Illinois at Urbana-Champaign,
	3318 Digital Computer Laboratory, Urbana, IL 61801, United States;
	School of Computer Science, Carnegie Mellon University, Pittsburgh,
	PA 15213-3890, United States; 3324 21st Ave. South St, Cloud, MN
	56301, United States},
  author_keywords = {Automatic performance tuning; DFT; Domain-specific language; FFT;
	Fourier transform; Optimization; Program generation; Search; Signal
	processing; Signal transform},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-1542396679&partnerID=40&md5=baf3d7308e2dffd79c708301ba6819c5}
}

@CONFERENCE{Qattous200913,
  author = {Qattous, H.K.},
  title = {Constraint specification by example in a Meta-CASE tool},
  year = {2009},
  pages = {13-16},
  note = {cited By (since 1996) 1},
  abstract = {CASE tools are very helpful to software engineers in different ways
	and in different phases of software development. However, they are
	not easy to specialise to meet the needs of particular application
	domains or particular software modelling requirements. Meta-CASE
	tools offer a way of providing such specialisation by enabling a
	designer to specify a tool which is then generated automatically.
	Constraints are often used in such meta-CASE tools as a technique
	for governing the syntax and semantics of model elements and the
	values of their attributes. However, although constraint definition
	is a difficult process it has attracted relatively little research
	attention. The PhD research described here presents an approach for
	improving the process of CASE tool constraint specification based
	on the notion of programming by example (or demonstration). The feasibility
	of the approach will be demonstrated via experiments with a prototype
	using the meta-CASE tool Diagram Editor Constraints System (DECS)
	as context.},
  affiliation = {Department of Computing Science, Sir Alwyn Williams Building, University
	of Glasgow, G12 8QQ, United Kingdom},
  author_keywords = {Domain Specific Language; Meta-CASE tools; Programming By Example},
  document_type = {Conference Paper},
  journal = {ESEC/FSE Doctoral Symposium'09 - Proceedings of the Doctoral Symposium
	for ESEC/FSE},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-77950500086&partnerID=40&md5=2ab238129eade4c9c90a515c0698351a}
}

@CONFERENCE{Qattous2010,
  author = {Qattous, H., Gray, P., Welland, R.},
  title = {An empirical study of specification by example in a software engineering
	tool},
  year = {2010},
  note = {cited By (since 1996) 0},
  abstract = {Meta-CASE tools offer CASE tool specialisation by enabling a designer
	to specify a tool which is then generated automatically. Constraints
	are often used in such meta-CASE tools for governing the syntax and
	semantics of model elements and the values of their attributes. However,
	the constraint definition process is complex, time-consuming and
	error-prone. This paper presents an empirical study of the use of
	Specification by Example (SBE), based on the well-known notion of
	Programming by Example (PBE), as a user-computer interactive technique
	for such constraint specification. Two constraint specification techniques
	have been implemented in a meta-CASE tool a wizard that represents
	a conventional form-filling technique and an SBE technique that depends
	on the user providing one or more examples and the system inferring
	a list of possible intended constraints. The empirical study compared
	the wizard and SBE with respect to constraint definition correctness,
	task completion time, and user satisfaction. Two common modelling
	diagrams have been used, a State Transition Diagram and a Use Case
	Diagram. Results suggest that SBE is superior to the wizard in terms
	of measured criteria described above. Observations on the interaction
	of users with the system and opinions of participants are also presented.
	© 2010 ACM.},
  affiliation = {Department of Computing Science, Sir Alwyn Williams Building, University
	of Glasgow, G12 8QQ, United Kingdom},
  art_number = {1852808},
  author_keywords = {domain specific language; example-based interface; meta-CASE tools;
	programming by example; specification by example; user study},
  document_type = {Conference Paper},
  journal = {ESEM 2010 - Proceedings of the 2010 ACM-IEEE International Symposium
	on Empirical Software Engineering and Measurement},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-78149235743&partnerID=40&md5=41e23a55b6b29d91eb928a01fc71c7cc}
}

@ARTICLE{Radošević201173,
  author = {Radošević, D., Magdalenić, I.},
  title = {Source code generator based on dynamic frames},
  journal = {Journal of Information and Organizational Sciences},
  year = {2011},
  volume = {35},
  pages = {73-91},
  number = {1},
  note = {cited By (since 1996) 0},
  abstract = {This paper presents the model of source code generator based on dynamic
	frames. The model is named as the SCT model because if its three
	basic components: Specification (S), which describes the application
	characteristics, Configuration (C), which describes the rules for
	building applications, and Templates (T), which refer to application
	building blocks. The process of code generation dynamically creates
	XML frames containing all building elements (S, C ant T) until final
	code is produced. This approach is compared to existing XVCL frames
	based model for source code generating. The SCT model is described
	by both XML syntax and the appropriate graphical elements. The SCT
	model is aimed to build complete applications, not just skeletons.
	The main advantages of the presented model are its textual and graphic
	description, a fully configurable generator, and the reduced overhead
	of the generated source code. The presented SCT model is shown on
	development of web application example in order to demonstrate its
	features and justify our design choices.},
  affiliation = {University of Zagreb, Faculty of Organization and Informatics Varaždin,
	Croatia},
  author_keywords = {Configuration; Dynamic frames; Generative programming; Specification;
	Template},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-79960145544&partnerID=40&md5=f99cb4947e5b24f3a06a941fd9bc6073}
}

@CONFERENCE{Rahimi2010,
  author = {Rahimi, R., Khosravi, R.},
  title = {Architecture conformance checking of multi-language applications},
  year = {2010},
  note = {cited By (since 1996) 0},
  abstract = {As the development in a software project goes on, the structure of
	the implemented code diverges from the intended architecture. To
	prevent this, architecture conformance methods are used to check
	if the source code complies with the architecture. In the development
	of today's enterprise applications, general-purpose programming languages
	are used along with a number of domain specific languages. So, there
	is a need for a conformance checking method to support multi-language
	source artifacts. We present a model-based approach for checking
	cross-language architecture conformance rules. Our method is extensible,
	in the sense that it is independent of the specific set of languages
	used in the project.},
  affiliation = {School of Electrical and Computer Engineering, University of Tehran,
	North Karegar Avenue, Tehran, Iran},
  art_number = {5587025},
  document_type = {Conference Paper},
  journal = {2010 ACS/IEEE International Conference on Computer Systems and Applications,
	AICCSA 2010},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-78049484517&partnerID=40&md5=a45209f86df7028efa50733b39ee836d}
}

@CONFERENCE{Ramisch20101041,
  author = {Ramisch, C.a b , Villavicencio, A.b , Boitet, C.a },
  title = {Web-based and combined language models: A case study on noun compound
	identification},
  year = {2010},
  volume = {2},
  pages = {1041-1049},
  note = {cited By (since 1996) 0},
  abstract = {This paper looks at the web as a corpus and at the effects of using
	web counts to model language, particularly when we consider them
	as a domain-specific versus a general-purpose resource. We first
	compare three vocabularies that were ranked according to frequencies
	drawn from general-purpose, specialised and web corpora. Then, we
	look at methods to combine heterogeneous corpora and evaluate the
	individual and combined counts in the automatic extraction of noun
	compounds from English general-purpose and specialised texts. Better
	n-gram counts can help improve the performance of empirical NLP systems
	that rely on n-gram language models.},
  affiliation = {GETALP - Laboratory of Informatics of Grenoble, University of Grenoble,
	France; Institute of Informatics, Federal University of Rio Grande
	do Sul, Brazil},
  document_type = {Conference Paper},
  journal = {Coling 2010 - 23rd International Conference on Computational Linguistics,
	Proceedings of the Conference},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-80053423842&partnerID=40&md5=e478243e69be1b5d8881f3612190936d}
}

@ARTICLE{Ramos2003277,
  author = {Ramos, J.G.a , Silva, J.b , Vidal, G.b },
  title = {An embedded language approach to router specification in curry},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2003},
  volume = {2932},
  pages = {277-288},
  note = {cited By (since 1996) 0},
  abstract = {The development of modern routers require a significant effort to
	be designed, built, and verified. While hardware routers are faster,
	they are difficult to configure and maintain. Software routers, on
	the other hand, are slower but much more flexible, easier to configure
	and maintain, less expensive, etc. Recently, a modular architecture
	and toolkit for building software routers and other packet processors
	has been introduced: the Click system. It includes a specification
	language with features for declaring and connecting router elements
	and for designing abstractions. In this work, we introduce the domain-specific
	language Rose for the specification of software routers. Rose is
	embedded in Curry, a modern declarative multi-paradigm language.
	An advantage of this approach is that we have available a framework
	where router specifications can be transformed, optimized, verified,
	etc., by using a number of existing formal techniques already developed
	for Curry programs. Furthermore, we show that the features of Curry
	are particularly useful to specify router configurations with a high-level
	of abstraction. Our first experiments point out that the proposed
	methodology is both useful and practical. © Springer-Verlag Berlin
	Heidelberg 2004.},
  affiliation = {Institute Tecnológico de La Piedad, Av. Tecnológico 2000, La Piedad,
	Mich., Mexico; DSIC, UPV, Camino de Vera s/n, E-46022 Valencia, Spain},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-35048900275&partnerID=40&md5=95f497a149fdf9c9ea283e56c53a9329}
}

@ARTICLE{Ranabahu201185,
  author = {Ranabahu, A.a , Anderson, P.b , Sheth, A.a },
  title = {The cloud agnostic e-Science analysis platform},
  journal = {IEEE Internet Computing},
  year = {2011},
  volume = {15},
  pages = {85-89},
  number = {6},
  note = {cited By (since 1996) 0},
  abstract = {The amount of data being generated for e-Science domains has grown
	exponentially in the past decade, yet the adoption of new computational
	techniques in these fields hasn't seen similar improvements. The
	presented platform can exploit the power of cloud computing while
	providing abstractions for scientists to create highly scalable data
	processing workflows. © 2011 IEEE.},
  affiliation = {Kno.e.sis, Wright State University, United States; College of Charleston,
	United States},
  art_number = {6062550},
  author_keywords = {cloud computing; domain specific languages; scientific workflows},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-80555135930&partnerID=40&md5=b0fe464919e6d8c7e6a2ab92a28460dd}
}

@CONFERENCE{Razavi2009435,
  author = {Razavi, A.a , Kontogiannis, K.b },
  title = {ProtoTalk: A generative software engineering framework for prototyping
	protocols in smalltalk},
  year = {2009},
  volume = {1},
  pages = {435-442},
  note = {cited By (since 1996) 0},
  abstract = {Network protocols are complex systems implemented by collections of
	equally complex software components. In many cases, the realization
	of such protocols requires extensive prototyping and experimentation
	with different alternative implementations. In this paper, we present
	ProtoTalk, a generative, domain-specific software framework that
	utilizes model driven software engineering principles for prototyping
	state and message driven protocols with emphasis on telecommunication
	and network protocols. The framework allows first, for modeling a
	variety of common protocol features by using mappings from state
	machines, sequence diagrams and packet encodings to ProtoTalk models,
	and second, for the consequent automatic generation of prototype
	Smalltalk code from the aforementioned ProtoTalk models. In this
	respect, the paper attempts to shed light on the use of generative
	model driven programming techniques within reflective object oriented
	programming languages and environments. As a proof of concept, we
	have specified in ProtoTalk and consequently generated in Smalltalk,
	several core features of the Session Initiation Protocol. © 2009
	IEEE.},
  affiliation = {Software Engineering Laboratory, University of Waterloo, Waterloo,
	ON N2L 3G1, Canada; Department of Electrical and Computer Engineering,
	Natl. Technical University of Athens, Athens 15780, Greece},
  art_number = {5254228},
  author_keywords = {Software Engineering, Domain Specific Frameworks, Generative Programming,
	Protocol Development},
  document_type = {Conference Paper},
  journal = {Proceedings - International Computer Software and Applications Conference},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-70449640162&partnerID=40&md5=c97aa0a562184c58e675fd0924dca22b}
}

@CONFERENCE{Reeder2006131,
  author = {Reeder, J.a , Giegerich, R.b },
  title = {A graphical programming system for molecular motif search},
  year = {2006},
  pages = {131-140},
  note = {cited By (since 1996) 2},
  abstract = {We describe a graphical programming system for a domain specific language
	in biosequence analysis. It supports the development of programs
	for RNA structure prediction and motif search, created by biologists
	with little or no programming skills. The system combines several
	programming paradigms in a productive way. It has a client - server
	architecture, with a transport layer in XML. The graphical front-end
	is implemented in the object-oriented paradigm (using Java). Graphics
	are compiled into a declarative domain-specific language for dynamic
	programming (ADP) that is embedded in Haskell. Finally, motif search
	programs expressed in ADP are compiled to imperative code in C, a
	step which includes substantial domain-specific optimization. Copyright
	© 2006 ACM.},
  affiliation = {International NRW Graduate School of Bioinformatics and Genome Research,
	Center of Biotechnology (CeBiTec), Bielefeld University, D-33615
	Bielefeld, Germany; Practical Computer Science, Faculty of Technology,
	Bielefeld University, D-33615 Bielefeld, Germany},
  author_keywords = {Dynamic programming; RNA structure},
  document_type = {Conference Paper},
  journal = {Proceedings of the 5th International Conference on Generative Programming
	and Component Engineering, GPCE'06},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-34547426364&partnerID=40&md5=15b5398454f82bb829e4ad025a9186fd}
}

@CONFERENCE{Reichert2008593,
  author = {Reichert, T.a , Klaus, E.b , Schoch, W.b , Meroth, A.c , Herzberg,
	D.b },
  title = {A language for advanced protocol analysis in automotive networks},
  year = {2008},
  pages = {593-602},
  note = {cited By (since 1996) 1},
  abstract = {The increased use and interconnection of electronic components in
	automobiles has made communication behavior in automotive networks
	drastically more complex. Both communication designs at application
	level and complex communication scenarios are often under-specified
	or out of scope of existing analysis techniques. We extend traditional
	protocol analyzers in order to capture communication at the level
	of abstraction that reflects application design and show that the
	same technique can be used to specify, monitor and test complex scenarios.
	We present CFR (Channel Filter Rule) models, a novel approach for
	the specification of analyzers and a domain-specific language that
	implements this approach. From CFR models, we can fully generate
	powerful analyzers that extract design intentions, abstract protocol
	layers and even complex scenarios from low level communication data.
	We show that three basic concepts (channels, filters and rules) are
	sufficient to build such powerful analyzers and identify possible
	areas of application. Copyright 2008 ACM.},
  affiliation = {School of Computing, Engineering and Inf. Sciences, Northumbria University,
	Newcastle upon Tyne, NE2 1XE, United Kingdom; Department of Software
	Engineering, Heilbronn University, 74081 Heilbronn, United Kingdom;
	Automotive Competence Center, Heilbronn University, 74081 Heilbronn,
	United Kingdom},
  author_keywords = {Automotive systems engineering; Protocol analysis; Protocol specifications},
  document_type = {Conference Paper},
  journal = {Proceedings - International Conference on Software Engineering},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-57349129308&partnerID=40&md5=98da398b3aec1fc9f68fc51316abe5f3}
}

@CONFERENCE{Reid1999484,
  author = {Reid, Alastair, Peterson, John, Hager, Greg, Hudak, Paul},
  title = {Prototyping real-time vision systems: An experiment in DSL design},
  year = {1999},
  pages = {484-493},
  note = {cited By (since 1996) 4},
  abstract = {We describe the enhancement of XVision, a large library of C++ code
	for real-time vision processing, into FVision (pronounced `fission'),
	a fully-featured domain-specific language embedded in Haskell. The
	resulting prototype system substantiates the claims of increased
	modularity, effective code reuse, and rapid prototyping that characterize
	the DSL approach to system design. It also illustrates the need for
	judicious interface design: relegating computationally expensive
	tasks to XVision (pre-existing C++ components), and leaving modular
	compositional tasks to FVision (Haskell). At the same time, our experience
	demonstrates how Haskell's advanced language features (specifically
	parametric polymorphism, lazy evaluation, higher order functions
	and automatic storage reclamation) permit a rapid DSL design that
	is itself highly modular and easily modified. Overall, the resulting
	hybrid system exceeded our expectations: visual tracking programs
	continue to spend most of their time executing low level image-processing
	code, while Haskell's advanced features allow us to quickly develop
	and test small prototype systems within a matter of a few days and
	to develop realistic applications within a few weeks.},
  affiliation = {Yale Univ, New Haven, United States},
  document_type = {Article},
  journal = {Proceedings - International Conference on Software Engineering},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-0032668897&partnerID=40&md5=713db21941cdd6a3b15298065fb684e9}
}

@ARTICLE{Reinhartz-Berger2010210,
  author = {Reinhartz-Berger, I., Sturm, A., Bettin, J., Clark, T., Cohen, S.},
  title = {Third Workshop on Domain Engineering (DE@ER 2010)},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2010},
  volume = {6413 LNCS},
  pages = {210},
  note = {cited By (since 1996) 0},
  abstract = {Domain Engineering is relevant to various fields in software and systems
	development, such as conceptual modeling, software product line engineering,
	domain-specific languages engineering, and so on. It deals with identifying,
	modeling, constructing, cataloging, and disseminating artifacts that
	represent the commonalities and differences within a domain, as well
	as with providing mechanisms, techniques, and tools to reuse and
	validate these artifacts in the development of particular systems.
	The aims of most up-and-coming methods and techniques in the area
	of domain engineering are to help reduce time-to-market, development
	cost, and projects risks on one hand, and help improve systems quality
	and performance on a consistent basis on the other hand. © 2010 Springer-Verlag.},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-78649958726&partnerID=40&md5=1ee198681b83974a2d466be58cb06518}
}

@ARTICLE{Reinhartz-Berger2011118,
  author = {Reinhartz-Berger, I., Sturm, A., Mens, K.},
  title = {Preface to variability@ER'11},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2011},
  volume = {6999 LNCS},
  pages = {118},
  note = {cited By (since 1996) 0},
  abstract = {As software requirements constantly increase in size and complexity,
	the need for methods, formalisms, techniques, tools and languages
	for managing and evolving software artifacts become crucial. One
	way to manage variability when dealing with a rapidly growing variety
	of software products is through developing and maintaining families
	of software products rather than individual products. Variability
	management is concerned with controlling the versions and the possible
	variants of software systems. Variability management gained a special
	interest in various software-related areas in different phases of
	the software development lifecycle. These areas include conceptual
	modeling, product line engineering, feature analysis, software reuse,
	configuration management, generative programming and programming
	language design. In the context of conceptual modeling, the terminology
	of variability management has been investigated, yielding ontologies,
	modeling languages, and classification frameworks. In the areas of
	software product line engineering and feature analysis, methods for
	developing core assets and efficiently using them in particular contexts
	have been introduced. In the software reuse and configuration management
	fields, different mechanisms for reusing software artifacts and managing
	software versions have been proposed, including adoption, specialization,
	controlled extension, parameterization, configuration, generation,
	template instantiation, analogy construction, assembly, and so on.
	Finally, generative programming deals with developing programs that
	synthesize or generate other programs and programming language design
	provides techniques for expressing and exploiting commonality of
	source code artifacts, but also for specifying the allowed or potential
	variability, whether it is static or dynamic. © 2011 Springer-Verlag.},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-81055124437&partnerID=40&md5=29cb75fc94beffacc22adaa9ee3c8813}
}

@CONFERENCE{Reiter200627,
  author = {Reiter, T.a , Kapsammer, E.a , Retschitzegger, W.a , Schwinger, W.b
	, Stumptner, M.c },
  title = {A generator framework for domain-specific model transformation languages},
  year = {2006},
  volume = {ISAS},
  pages = {27-35},
  note = {cited By (since 1996) 0},
  abstract = {Domain specific languages play an important role in model driven development,
	as they allow to model a system using modeling constructs carrying
	implicit semantics specific to a domain. Consequently, possibly many
	reusable, domain specific languages will emerge. Thereby, certain
	application areas, such as business process engineering, can be jointly
	covered by a number of conceptually related DSLs, that are similar
	in a sense of sharing semantically equal concepts. Although, a crucial
	role in being able to use, manage and integrate all these DSLs comes
	to model transformation languages with QVT as one of their most prominent
	representatives, existing approaches have not aimed at reaping benefit
	of these semantically overlapping DSLs in terms of providing abstraction
	mechanisms for shared concepts. Therefore, as opposed to a general-purpose
	model transformation language sought after with the QVT-RFP, this
	work discusses the possibility of employing domain-specific model
	transformation languages. These are specifically tailored for defining
	transformations between metamodels sharing certain characteristics.
	In this context, the paper introduces a basic framework which allows
	generating the necessary tools to define and execute transformations
	written in such a domain-specific transformation language. To illustrate
	the approach, an example language will be introduced and its realization
	within the framework is shown.},
  affiliation = {Dept. of Information Systems, Johannes Kepler University, Linz, Austria;
	Dept. of Telecooperation, Johannes Kepler University, Linz, Austria;
	Adv. Computing Research Center, University of South Australia, Adelaide,
	SA, Australia},
  author_keywords = {Domain-specific languages; MDA; Model transformation; QVT; Workflow
	patterns},
  document_type = {Conference Paper},
  journal = {ICEIS 2006 - 8th International Conference on Enterprise Information
	Systems, Proceedings},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-77953884428&partnerID=40&md5=e8b17489b9d2e4b22a300ae8a43418b6}
}

@CONFERENCE{Rendel20101,
  author = {Rendel, T., Ostermann, K.},
  title = {Invertible syntax descriptions: Unifying parsing and pretty printing},
  year = {2010},
  pages = {1-12},
  note = {cited By (since 1996) 0},
  abstract = {Parsers and pretty-printers for a language are often quite similar,
	yet both are typically implemented separately, leading to redundancy
	and potential inconsistency. We propose a new interface of syntactic
	descriptions, with which both parser and pretty-printer can be described
	as a single program. Whether a syntactic description is used as a
	parser or as a pretty-printer is determined by the implementation
	of the interface. Syntactic descriptions enable programmers to describe
	the connection between concrete and abstract syntax once and for
	all, and use these descriptions for parsing or pretty-printing as
	needed. We also discuss the generalization of our programming technique
	towards an algebra of partial isomorphisms. © 2010 ACM.},
  affiliation = {University of Marburg, Marburg, Germany},
  author_keywords = {embedded domain specific languages; invertible computation; parser
	combinators; pretty printing},
  document_type = {Conference Paper},
  journal = {Proceedings of the ACM SIGPLAN International Conference on Functional
	Programming, ICFP},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-78249265326&partnerID=40&md5=f5730f45679fa4599ba6f16cc32a7dab}
}

@CONFERENCE{Renggli2009107,
  author = {Renggli, L., Gîrba, T.},
  title = {Why Smalltalk wins the host languages shootout},
  year = {2009},
  pages = {107-113},
  note = {cited By (since 1996) 1},
  abstract = {Integration of multiple languages into each other and into an existing
	development environment is a difficult task. As a consequence, developers
	often end up using only internal DSLs that strictly rely on the constraints
	imposed by the host language. Infrastructures do exist to mix languages,
	but they often do it at the price of losing the development tools
	of the host language. Instead of inventing a completely new infrastructure,
	our solution is to integrate new languages deeply into the existing
	host environment and reuse the infrastructure offered by it. In this
	paper we show why Smalltalk is the best practical choice for such
	a host language. Copyright 2009 ACM.},
  affiliation = {Software Composition Group, University of Bern, Switzerland},
  author_keywords = {domain-specific languages; embedded languages; programming environments
	and tools},
  document_type = {Conference Paper},
  journal = {Proceedings of the International Workshop on Smalltalk Technologies
	2009, IWST'09 - ESUG 2009 Smalltalk Joint Event},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-77954482734&partnerID=40&md5=115542ebc53647c1bf7ba644fca8edf5}
}

@ARTICLE{Renggli2010380,
  author = {Renggli, L., Gîrba, T., Nierstrasz, O.},
  title = {Embedding languages without breaking tools},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2010},
  volume = {6183 LNCS},
  pages = {380-404},
  note = {cited By (since 1996) 4},
  abstract = {Domain-specific languages (DSLs) are increasingly used as embedded
	languages within general-purpose host languages. DSLs provide a compact,
	dedicated syntax for specifying parts of an application related to
	specialized domains. Unfortunately, such language extensions typically
	do not integrate well with the development tools of the host language.
	Editors, compilers and debuggers are either unaware of the extensions,
	or must be adapted at a non-trivial cost. We present a novel approach
	to embed DSLs into an existing host language by leveraging the underlying
	representation of the host language used by these tools. Helvetia
	is an extensible system that intercepts the compilation pipeline
	of the Smalltalk host language to seamlessly integrate language extensions.
	We validate our approach by case studies that demonstrate three fundamentally
	different ways to extend or adapt the host language syntax and semantics.
	© 2010 Springer-Verlag Berlin Heidelberg.},
  affiliation = {Software Composition Group, University of Bern, Switzerland},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-77955032362&partnerID=40&md5=d8a4711b8bbc9207392e04e9d62192aa}
}

@ARTICLE{Renggli2010274,
  author = {Renggli, L.a , Denker, M.b , Nierstrasz, O.a },
  title = {Language boxes: Bending the host language with modular language changes},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2010},
  volume = {5969 LNCS},
  pages = {274-293},
  note = {cited By (since 1996) 0},
  abstract = {As domain-specific modeling begins to attract widespread acceptance,
	pressure is increasing for the development of new domain-specific
	languages. Unfortunately these DSLs typically conflict with the grammar
	of the host language, making it difficult to compose hybrid code
	except at the level of strings; few mechanisms (if any) exist to
	control the scope of usage of multiple DSLs; and, most seriously,
	existing host language tools are typically unaware of the DSL extensions,
	thus hampering the development process. Language boxes address these
	issues by offering a simple, modular mechanism to encapsulate (i)
	compositional changes to the host language, (ii) transformations
	to address various concerns such as compilation and syntax highlighting,
	and (iii) scoping rules to control visibility of fine-grained language
	extensions. We describe the design and implementation of language
	boxes, and show with the help of several examples how modular extensions
	can be introduced to a host language and environment. © 2010 Springer-Verlag.},
  affiliation = {Software Composition Group, University of Bern, Switzerland; PLEIAD,
	University of Chile, Santiago, Chile},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-77951543322&partnerID=40&md5=065097fce8229a12fa882a9ce57b17f2}
}

@ARTICLE{Renggli2010213,
  author = {Renggli, L.a , Ducasse, S.b , Gîrba, T.c , Nierstrasz, O.a },
  title = {Domain-specific program checking},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2010},
  volume = {6141 LNCS},
  pages = {213-232},
  note = {cited By (since 1996) 1},
  abstract = {Lint-like program checkers are popular tools that ensure code quality
	by verifying compliance with best practices for a particular programming
	language. The proliferation of internal domain-specific languages
	and models, however, poses new challenges for such tools. Traditional
	program checkers produce many false positives and fail to accurately
	check constraints, best practices, common errors, possible optimizations
	and portability issues particular to domain-specific languages. We
	advocate the use of dedicated rules to check domain-specific practices.
	We demonstrate the implementation of domain-specific rules, the automatic
	repair of violations, and their application to two case-studies:
	(1) Seaside defines several internal DSLs through a creative use
	of the syntax of the host language; and (2) Magritte adds meta-descriptions
	to existing code by means of special methods. Our empirical validation
	demonstrates that domain-specific program checking significantly
	improves code quality when compared with general purpose program
	checking. © 2010 Springer-Verlag.},
  affiliation = {Software Composition Group, University of Bern, Switzerland; RMoD,
	INRIA-Lille Nord Europe, France; Sw-eng. Software Engineering GmbH,
	Switzerland},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-77954751609&partnerID=40&md5=27973e78acb23d01ad64cbc1e53afd29}
}

@CONFERENCE{Reyes2003570,
  author = {Reyes, A.A., Espino, J.R., Mohan, V., Nadkar, M.},
  title = {Ad Hoc Software Interfacing: Enterprise Application Integration (EAI)
	when Middleware is Overkill},
  year = {2003},
  pages = {570-575},
  note = {cited By (since 1996) 0},
  abstract = {Enterprise application integration (EAI) is cooperation of disparate
	systems and components to implement business rules in a distributed
	environment. "Systems and components" can be computer-aided design
	(CAD) or software engineering (CASE) tools, enterprise databases,
	COTS applications, or in-house software. Ad hoc software interfacing
	(AHSI) is a special kind of EAI. A tradeoff analysis classifies an
	EAI problem as an AHSI problem when middleware solutions are seen
	as heavy-handed. I.e., the planned EAI is not expected to become
	broad enough to justify the generality of a middleware solution or
	the client is unwilling to pay for a unified data model. AHSI seeks
	to "wire" extant software applications as components in new, larger
	software applications. We call applications-as-components "appliponents".
	AHSI seeks to minimize appliponent modification to the greatest extent
	possible. We demonstrate solutions to AHSI problems using XML toolkits,
	domain-specific language toolkits, and Microsoft BizTalk Server.},
  affiliation = {Dept. of Comp. Sci. and Engineering, University of Texas at Arlington,
	Arlington, TX 76019-0015, United States},
  document_type = {Conference Paper},
  journal = {Proceedings - IEEE Computer Society's International Computer Software
	and Applications Conference},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-0345529054&partnerID=40&md5=4543bb1dd94435869eff21cd7618b07f}
}

@CONFERENCE{Riccobene2010,
  author = {Riccobene, E.a , Scandurra, P.b },
  title = {An ASM-based executable formal model of service-oriented component
	interactions and orchestration},
  year = {2010},
  note = {cited By (since 1996) 0},
  abstract = {Formal design methods, that might serve as a basis for spec- ifying
	and analyzing abstract models of service orchestra- tions, are needed
	to complement the wide range of domain- specific languages (mainly
	based on graphical notations) that are currently being defined for
	engineering service-oriented systems. This paper presents a formal
	and executable se- mantic framework for UML4SOA models of service-oriented
	systems. The UML4SOA language is a UML profile de- veloped in the
	EU SENSORIA project for modeling services behavior focusing on service
	orchestration aspects. We com- plement the graphical model of a service
	orchestration sce- nario with a formal description that is suitable
	for rigorous execution-platform-independent analysis. We map the
	be- havioral primitives of UML4SOA activity diagrams into a particular
	class of Abstract State Machines (ASMs) able to model notions of
	service interactions and orchestrations. Copyright 2010 ACM.},
  affiliation = {Università Degli Studi di Milano, DTI, via Bramante 65, Crema (CR),
	Italy; Università Degli Studi di Bergamo, DIIMM, via Marconi 5, Dalmine
	(BG), Italy},
  art_number = {5},
  author_keywords = {Abstract state machines; Service behaviour modeling; Service-oriented
	computing; UML4SOA},
  document_type = {Conference Paper},
  journal = {ACM International Conference Proceeding Series},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-77955002422&partnerID=40&md5=809b8f0c294da83c85cb37b0e3a8e6d9}
}

@CONFERENCE{Ridene2011,
  author = {Ridene, Y., Barbier, F.},
  title = {A model-driven approach for automating mobile applications testing},
  year = {2011},
  note = {cited By (since 1996) 0},
  abstract = {Software testing faces up several challenges. One out of these is
	the opposition between time-to-market software delivery and the excessive
	length of testing activities. The latter results from the growth
	of the application complexity along with the diversity of handheld
	devices. The economical competition, branding impose zero-defect
	products, putting forward testing as an even more crucial activity.
	In this paper, we describe a Domain-Specific Modeling Language (DSML)
	built upon an industrial platform (a test bed) which aims to automate
	mobile application checking. A key characteristic of this DSML is
	its ability to cope with variability in the spirit of software product
	line engineering. We discuss this DSML as part of a tool suite enabling
	the test of remote devices having variable features. Copyright ©
	2011 ACM.},
  affiliation = {LIUPPA, University of Pau, Avenue de l'université, 64013 Pau, France},
  art_number = {9},
  author_keywords = {Mobile software; Model-driven engineering; Testing; Variability management},
  document_type = {Conference Paper},
  journal = {ACM International Conference Proceeding Series},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-80053907180&partnerID=40&md5=327fe885cd339a0b1bcb5f11427b887e}
}

@CONFERENCE{Riehl200621,
  author = {Riehl, J.},
  title = {Assimilating MetaBorg: Embedding language tools in languages},
  year = {2006},
  pages = {21-28},
  note = {cited By (since 1996) 0},
  abstract = {The MetaBorg usage pattern allows concrete syntax to be associated
	with application programmer interfaces (API's). Once a concrete syntax
	is defined, library writers use the Stratego language to write transformations
	from the concrete syntax to API data and calls in the host language.
	The result is a compile time translator from the combined host and
	domain languages to the host language. This translator is not programmable
	at compile time, and little or none of the infrastructure can be
	leveraged by a program at run time.These limitations make the MetaBorg
	pattern difficult or impractical to use in interactive programming.
	One possibility for adding interactivity to language assimilation
	is the application of the MetaBorg pattern to Stratego/XT itself.
	Assimilating language tools into languages, especially dynamic languages,
	better serves incremental and interactive development. Furthermore,
	language tool assimilation allows experimentation with language extension
	at compiler-compile time, compile time, load time and run time.This
	paper looks at language tool assimilation and makes three contributions.
	First, it introduces the domain-specific optimization use case as
	an additional problem that Stratego and related technology might
	solve. Second, it "partially evaluates" the MetaBorg pattern on the
	domain-specific languages used in Stratego/XT. Third, and finally,
	it generalizes the result of the MetaBorg partial evaluation, identifying
	several applications and application strategies. Copyright © 2006
	ACM.},
  affiliation = {University of Chicago},
  author_keywords = {Concrete syntax macros; Extensible syntax; MetaBorg; SDF; Self application;
	Staged multi - language programming; Stratego},
  document_type = {Conference Paper},
  journal = {Proceedings of the 5th International Conference on Generative Programming
	and Component Engineering, GPCE'06},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-34547452165&partnerID=40&md5=dccc9656c3ce1c8282f010fdcd34335b}
}

@CONFERENCE{Risi2001292,
  author = {Risi, W., López, P., Marcos, D.},
  title = {Hycom: A domain specific language for hypermedia application development},
  year = {2001},
  pages = {292},
  note = {cited By (since 1996) 0},
  abstract = {This paper presents HyCom, a DSL for hypermedia authoring embedded
	in the language Haskell. HyCom prOvides a declarative framework for
	describing hypermedia designs and also automatic application generation.
	We propose HyCom as the bridge between engineering models and implementation
	environments. HyCom is based on the principle of programming by combination.
	A hypermedia application is constructed by the combination and transformation
	of components, promoting the reuse of existing assets and the abstraction
	of common patterns. The resulting framework is flexible and practical
	- yet rigorous and formal - enabling the effective representation
	of existing engineering methods primitives without loss of expressiveness.
	We present a real situation in which HyCom is used in the definition
	of an application developed following systematic steps. By means
	of an example, we show the general principles underlying its use
	for the mapping of design concepts to implementation environments.},
  author_keywords = {DSL; Functional framework; Haskell library; HyCom; Hypermedia authoring},
  document_type = {Conference Paper},
  journal = {Proceedings of the Hawaii International Conference on System Sciences},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-0034965956&partnerID=40&md5=b5de339b0ade96ad86aa0e6e39d5a064}
}

@CONFERENCE{Risoldi2007179,
  author = {Risoldi, M., Buchs, D.},
  title = {A domain specific language and methodology for control systems GUI
	specification, verification and prototyping},
  year = {2007},
  pages = {179-182},
  note = {cited By (since 1996) 1},
  abstract = {A work-in-progress domain-specific language and methodology for modeling
	complex control systems GUIs is presented. MDA techniques are applied
	for language design and verification, simulation and prototyping.
	© 2007 IEEE.},
  affiliation = {Université de Genève, CUI Battelle, Bat. A, 1227 Carouge, Switzerland},
  art_number = {4351345},
  document_type = {Conference Paper},
  journal = {Proceedings - IEEE Symposium on Visual Languages and Human-Centric
	Computing, VL/HCC 2007},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-47949116769&partnerID=40&md5=ea56aaad6ec25c4d626721c7d46cc687}
}

@ARTICLE{Risoldi2009221,
  author = {Risoldi, M.b , Amaral, V.a , Barroca, B.a , Bazargan, K.b , Buchs,
	D.b , Cretton, F.c , Falquet, G.b , Le Calvé, A.c , Malandain, S.d
	, Zoss, P.d },
  title = {A language and a methodology for prototyping user interfaces for
	control systems},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2009},
  volume = {5440 LNCS},
  pages = {221-248},
  note = {cited By (since 1996) 0},
  abstract = {The BATIC3S project1 (Building Adaptive Three-dimensional Interfaces
	for Controlling Complex Control Systems) proposes a methodology to
	prototype adaptive graphical user interfaces (GUI) for control systems.
	We present a domain specific language for the control systems domain,
	including useful and understandable abstractions for domain experts.
	This is coupled with a methodology for validation, verification and
	automatic GUI prototype generation. The methodology is centered on
	metamodel-based techniques and model transformations, and its foundations
	rely on formal models. Our approach is based on the assumption that
	a GUI can be induced from the characteristics of the system to control.
	© 2009 Springer Berlin Heidelberg.},
  affiliation = {Universidade Nova de Lisboa; Université de Genève; HES-SO Valais;
	Ecole d'Ingénieurs de Genève},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-70350623277&partnerID=40&md5=e8b27abbf3cbca974fb34045581bc577}
}

@ARTICLE{Ritson2011243,
  author = {Ritson, C.G.a , Andrews, P.S.b , Sampson, A.T.c },
  title = {Object store based simulation interworking},
  journal = {Concurrent Systems Engineering Series},
  year = {2011},
  volume = {68},
  pages = {243-253},
  note = {cited By (since 1996) 0},
  abstract = {The CoSMoS project is building generic modelling tools and simulation
	techniques for complex systems. As part of this project a number
	of simulations have been developed in many programming languages.
	This paper describes a framework for interconnecting simulation components
	written in different programming languages. These simulation components
	are synchronised and coupled using a shared object space. This approach
	allows us to combine highly concurrent agent-based simulations written
	in occam-π, with visualisation and analysis components written in
	flexible scripting languages such as Python and domain specific languages
	such as MATLAB. © 2011 The authors and IOS Press. All rights reserved.},
  affiliation = {School of Computing, University of Kent, United Kingdom; Department
	of Computer Science, University of York, United Kingdom; Institute
	of Arts, Media and Computer Games, University of Abertay Dundee,
	United Kingdom},
  author_keywords = {Complexity; CoSMoS; Flocking; Occam-pi; Python},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-79959364513&partnerID=40&md5=d95b343cebc6090c2e98199f90222e56}
}

@CONFERENCE{Rivera200951,
  author = {Rivera, J.E., Durán, F., Vallecillo, A.},
  title = {A graphical approach for modeling time-dependent behavior of DSLs},
  year = {2009},
  pages = {51-55},
  note = {cited By (since 1996) 2},
  abstract = {Domain specific languages (DSLs) play a cornerstone role in Model-Driven
	Software Development for representing models and metamodels. DSLs'
	abstract syntax are usually defined by a metamodel. In-place model
	transformations provide an intuitive way to complement metamodels
	with behavioral specifications. In this paper we extend in-place
	rules with a quantitative model of time and with mechanisms that
	allow designers to state action properties, facilitating the design
	of real-time complex systems. This approach avoids making unnatural
	changes to the DSL metamodels to represent behavioral and time aspects.
	We present the graphical modeling tool we have built for visually
	specifying these timed specifications. ©2009 IEEE.},
  affiliation = {University of Málaga, Spain},
  art_number = {5295300},
  document_type = {Conference Paper},
  journal = {2009 IEEE Symposium on Visual Languages and Human-Centric Computing,
	VL/HCC 2009},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-73449086657&partnerID=40&md5=106bbf4ee81495fe245381b20eb70cc2}
}

@ARTICLE{Rivera2009778,
  author = {Rivera, J.E., Durán, F., Vallecillo, A.},
  title = {Formal specification and analysis of domain specific models using
	maude},
  journal = {Simulation},
  year = {2009},
  volume = {85},
  pages = {778-792},
  number = {11-12},
  note = {cited By (since 1996) 5},
  abstract = {Modeling languages play a cornerstone role in model-driven software
	development for representing models and metamodels. Modeling languages
	are usually defined in terms of their abstract and concrete syntax.
	This allows the rapid development of languages and some associated
	tools (e.g. editors), but does not allow the representation of their
	behavioral semantics, something especially important in certain industrial
	environments in which simulation and verification are critical issues.
	In this paper we explore the use of Maude as a formal notation for
	describing models, metamodels, and their dynamic behavior, making
	models amenable to formal analysis, reasoning, and simulation. ©
	2009 The Society for Modeling and Simulation International.},
  affiliation = {Departamento de Lenguajes y Ciencias de la Computación, Universidad
	de Málaga, Málaga, Spain},
  author_keywords = {Domain Specific Languages; Formal semantics; Maude; Model Analysis;
	Model Driven Engineering; Model Simulation},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-70350236280&partnerID=40&md5=67b51b95e7e02bf7986dd3845dd9dfad}
}

@CONFERENCE{Rivera2007169,
  author = {Rivera, J.E., Vallecillo, A.},
  title = {Adding behavioral semantics to models},
  year = {2007},
  pages = {169-180},
  note = {cited By (since 1996) 9},
  abstract = {Domain Specific Languages (DSLs) play a cornerstone role in Model-Driven
	Software Development for representing models and metamodels. DSLs
	are usually defined in terms of their abstract and concrete syntax
	only. This allows the rapid and inexpensive development of DSLs and
	their associated tools (e.g., editors), but does not allow the representation
	of their behavioral semantics, something especially important for
	model operations like simulation and verification. In this paper
	we explore the use of Maude as a formal notation for describing models
	and melamodels, including the specification of their dynamic behavior.
	© 2007 IEEE.},
  affiliation = {Dpto. de Lenguajes y Ciencias de la Computación, Universidad de Málaga,
	Spain},
  art_number = {4383991},
  document_type = {Conference Paper},
  journal = {Proceedings - IEEE International Enterprise Distributed Object Computing
	Workshop, EDOC},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-47949129971&partnerID=40&md5=34203431917fbd80433bb72a927437cd}
}

@CONFERENCE{Robert2009155,
  author = {Robert, S.a , Gérard, S.a , Terrier, F.a , Lagarde, F.b },
  title = {A lightweight approach for domain-specific modeling languages design},
  year = {2009},
  pages = {155-161},
  note = {cited By (since 1996) 1},
  abstract = {Off-the-shelves general purpose modeling languages cannot obviously
	cover the whole range of needs that can be encountered in current
	systems design. Therefore, putting efficiently Model-Driven Engineering
	into practice involves designing specific modeling languages. The
	goal is to cover in a more suitable manner a particular application
	domain (e.g. automotive) or specific concerns (e.g. hardware modeling)
	or even to focus on a given class of practitioners. In this respect,
	two design approaches are generally opposed which respectively propose
	to define domain-specific modeling languages from scratch or to customize
	an existing general-purpose language. This paper focuses on the latter
	approach and claims that UML profiles do provide handy and powerful
	mechanisms to design domain-specific modeling languages but are penalized
	by lacks of methodological guidelines and tool support. To cope with
	these lacks, a profile design approach is introduced, which includes
	a methodological framework to structure profiles design process and
	tool support to partly automate this process. © 2009 IEEE.},
  affiliation = {Laboratory of Model Driven Engineering for Embedded Systems, CEA LIST,
	Gif-sur-Yvette, F-91191, France; Défense Sécurité R and D, SAGEM,
	Massy, F-91300, France},
  art_number = {5349876},
  author_keywords = {Domain-Specific Modeling Languages; Model-Driven Engineering; Profiles;
	UML},
  document_type = {Conference Paper},
  journal = {Conference Proceedings of the EUROMICRO},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-74549190042&partnerID=40&md5=38172f88821d12dfb398051837cbf769}
}

@ARTICLE{Robertson199739,
  author = {Robertson, P.},
  title = {Integrating Legacy Systems with Modern Corporate Applications},
  journal = {Communications of the ACM},
  year = {1997},
  volume = {40},
  pages = {39-46},
  number = {5},
  note = {cited By (since 1996) 16},
  abstract = {Implementing the new without compromising the old.},
  affiliation = {Dynamic Object Language Laboratories, Andover, MA, United States},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-0031139454&partnerID=40&md5=c22e13d4b45279e4ed70a1bf5bf328c6}
}

@ARTICLE{Robinson2008481,
  author = {Robinson, J., Wakeman, I., Chalmers, D.},
  title = {Composing software services in the pervasive computing environment:
	Languages or APIs?},
  journal = {Pervasive and Mobile Computing},
  year = {2008},
  volume = {4},
  pages = {481-505},
  number = {4},
  note = {cited By (since 1996) 0},
  abstract = {The pervasive computing environment will be composed of heterogeneous
	services. In this work, we have explored how a domain specific language
	for service composition can be implemented to capture the common
	design patterns for service composition, yet still retain a comparable
	performance to other systems written in mainstream languages such
	as Java. In particular, we have proposed the use of the method delegation
	design pattern, the resolution of service bindings through the use
	of dynamically adjustable characteristics and the late binding of
	services as key features in simplifying the service composition task.
	These are realised through the Scooby language, and the approach
	is compared to the use of APIs to define adaptable services. © 2008
	Elsevier B.V. All rights reserved.},
  affiliation = {Department of Informatics, University of Sussex, Brighton, United
	Kingdom},
  author_keywords = {Performance evaluation; Pervasive computing; Programming languages},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-47749119636&partnerID=40&md5=2c6f22bb79d52edf2f6df9b8ef954172}
}

@CONFERENCE{RoblesLuna2010297,
  author = {Robles Luna, E.a b , Burella, J.b c , Grigera, J.a , Rossi, G.a b
	},
  title = {A flexible tool suite for change-aware test-driven development of
	web applications},
  year = {2010},
  volume = {2},
  pages = {297-298},
  note = {cited By (since 1996) 0},
  abstract = {Though Web Applications development fits well with Test-Driven Development,
	there are some problems that hinder its success. In this demo we
	present a tool suite to improve TDD; the suite supports the representation
	of web requirements using a domain-specific language and the automatic
	generation of interaction tests among others. © 2010 ACM.},
  affiliation = {LIFIA. F. Informática, UNLP, La Plata, Argentina; CONICET, Argentina;
	DC. F. Cs Exactas, UBA, Buenos Aires, Argentina},
  author_keywords = {change management; TDD; web engineering; web requirements},
  document_type = {Conference Paper},
  journal = {Proceedings - International Conference on Software Engineering},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-77954739347&partnerID=40&md5=071a42916db7daa10c4901849bff72c8}
}

@ARTICLE{Rompf2011127,
  author = {Rompf, T., Odersky, M.},
  title = {Lightweight modular staging: A pragmatic approach to runtime code
	generation and compiled DSLs},
  journal = {ACM SIGPLAN Notices},
  year = {2011},
  volume = {46},
  pages = {127-136},
  number = {2},
  note = {cited By (since 1996) 0},
  abstract = {Software engineering demands generality and abstraction, performance
	demands specialization and concretization. Generative programming
	can provide both, but developing high-quality program generators
	takes a large effort, even if a multi-stage programming language
	is used. We present lightweight modular staging, a library-based
	multistage programming approach that breaks with the tradition of
	syntactic quasi-quotation and instead uses only types to distinguish
	between binding times. Through extensive use of component technology,
	lightweight modular staging makes an optimizing compiler framework
	available at the library level, allowing programmers to tightly integrate
	domain-specific abstractions and optimizations into the generation
	process. We argue that lightweight modular staging enables a form
	of language virtualization, i.e. allows to go from a pure-library
	embedded language to one that is practically equivalent to a standalone
	implementation with only modest effort. Copyright © 2010 ACM.},
  affiliation = {École Polytechnique Fédérale de Lausanne (EPFL), Switzerland},
  author_keywords = {Code generation; Domainspecific languages; Language virtualization;
	Multi-stage programming},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-79951764539&partnerID=40&md5=3ad725bfabed1e59d9812d355b5e4fc8}
}

@CONFERENCE{Rompf2010127,
  author = {Rompf, T., Odersky, M.},
  title = {Lightweight modular staging: A pragmatic approach to runtime code
	generation and compiled DSLs},
  year = {2010},
  pages = {127-136},
  note = {cited By (since 1996) 1},
  abstract = {Software engineering demands generality and abstraction, performance
	demands specialization and concretization. Generative programming
	can provide both, but developing high-quality program generators
	takes a large effort, even if a multi-stage programming language
	is used. We present lightweight modular staging, a library-based
	multistage programming approach that breaks with the tradition of
	syntactic quasi-quotation and instead uses only types to distinguish
	between binding times. Through extensive use of component technology,
	lightweight modular staging makes an optimizing compiler framework
	available at the library level, allowing programmers to tightly integrate
	domain-specific abstractions and optimizations into the generation
	process. We argue that lightweight modular staging enables a form
	of language virtualization, i.e. allows to go from a pure-library
	embedded language to one that is practically equivalent to a standalone
	implementation with only modest effort. © 2010 ACM.},
  affiliation = {École Polytechnique Fédérale de Lausanne (EPFL), Switzerland},
  author_keywords = {Code generation; Domain-specific languages; Language virtualization;
	Multi-stage programming},
  document_type = {Conference Paper},
  journal = {GPCE'10 - Proceedings of the 2010 Conference on Generative Programming
	and Component Engineering},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-78650151869&partnerID=40&md5=93d2be7a59e4ca6fc12e777c41ceabd9}
}

@ARTICLE{Rosa2009423,
  author = {Rosa, A., Amaral, V., Barroca, B.},
  title = {Designing a DSL solution for the domain of augmented reality software
	applications specification},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2009},
  volume = {5670 LNCS},
  pages = {423-434},
  note = {cited By (since 1996) 0},
  abstract = {Code repetition, lack of reuse and basic errors are typical problems
	in the industry that decrease the productivity during the software
	development process, and this is no exception in the domain of interactive
	applications with focus on Augmented Reality (AR). In this paper,
	we describe a new Domain-Specific Language (DSL), based on an existing
	AR software framework that tackles this problem by adding a new abstraction
	layer for product specification. The proposed language's abstract
	syntax covers the definition of application logic's organization,
	its configuration, objects construction and behaviour definition.
	The language's concrete syntax was implemented using a metamodeling
	language workbench. A real case study within the context of an AR
	software house was used for validation purposes. © 2009 Springer
	Berlin Heidelberg.},
  affiliation = {Research Center for Informatics and Information Technologies, Faculdade
	de Ciências e Tecnologia, Universidade Nova de Lisboa, Quinta da
	Torre, 2829-516 Caparica, Portugal},
  author_keywords = {Augmented Reality; Domain-Specific Language; Interactive Applications;
	Model Driven Development; Modeling Language},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-69949128660&partnerID=40&md5=cd47f8fa9c49badc983ac6394c4edeb5}
}

@CONFERENCE{Rosenberg2009151,
  author = {Rosenberg, F., Celikovic, P., Michlmayr, A., Leitner, P., Dustdar,
	S.},
  title = {An end-to-end approach for QoS-aware service composition},
  year = {2009},
  pages = {151-160},
  note = {cited By (since 1996) 12},
  abstract = {A simple and effective composition of software services into higher-level
	composite services is still a very challenging task. Especially in
	enterprise environments, Quality of Service (QoS) concerns play a
	major role when building software systems following the Service-Oriented
	Architecture (SOA) paradigm. In this paper we present a composition
	approach based on a domain-specific language (DSL) for specifying
	functional requirements of services and the expected QoS in form
	of constraint hierarchies by leveraging hard and soft constraints.
	A composition runtime will resolve the user's constraints to find
	an optimized composition semi-automatically. To this end we leverage
	data flow analysis to generate a structured composition model and
	use two different techniques for the optimization, a constraint programming
	and an integer programming approach. © 2009 IEEE.},
  affiliation = {Distributed Systems Group, Technical University Vienna, Argentierstrasse
	8/184-1, Vienna, Austria},
  art_number = {5277690},
  document_type = {Conference Paper},
  journal = {Proceedings - 13th IEEE International Enterprise Distributed Object
	Computing Conference, EDOC 2009},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-71249086319&partnerID=40&md5=0c3d4322803fab39b72d0c30be13cdd6}
}

@CONFERENCE{Rosenberg20091733,
  author = {Rosenberg, F., Leitner, P., Michlmayr, A., Celikovic, P., Dustdar,
	S.},
  title = {Towards composition as a service - a quality of service driven approach},
  year = {2009},
  pages = {1733-1740},
  note = {cited By (since 1996) 6},
  abstract = {Software as a Service (SaaS) and the possibility to compose Web services
	provisioned over the Internet are important assets for a service-oriented
	architecture (SOA). However, the complexity and time for developing
	and provisioning a composite service is very high and it is generally
	an error-prone task. In this paper we address these issues by describing
	a semi-automated "Composition as a Service" (CAAS) approach combined
	with a domain-specific language called VCL (Vienna Composition Language).
	The proposed approach facilitates rapid development and provisioning
	of composite services by specifying what to compose in a constraint-hierarchy
	based way using VCL. Invoking the composition service triggers the
	composition process and upon success the newly composed service is
	immediately deployed and available. This solution requires no client-side
	composition infrastructure because it is transparently encapsulated
	in the CAAS infrastructure. © 2008 IEEE.},
  affiliation = {Distributed Systems Group, Technical University Vienna, Argentinierstrasse
	8/184-1, 1040 Vienna, Austria},
  art_number = {4812599},
  document_type = {Conference Paper},
  journal = {Proceedings - International Conference on Data Engineering},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-67649644338&partnerID=40&md5=44bd9177a3d247346aeb0f6620fe5283}
}

@CONFERENCE{Rosique2011265,
  author = {Rosique, F., Sánche, P., Jiménez, M., Alonso, D.},
  title = {Lessons learned in applying MDE to the development of Home Automation
	systems},
  year = {2011},
  volume = {2},
  pages = {265-268},
  note = {cited By (since 1996) 0},
  abstract = {Home Automation (HA) systems represent a domain of interest to evaluate
	the benefits and difficulties of adopting the well known Model Driven
	Engineering (MDE) approach. This is due to the existence of determining
	factors in the development of such systems that makes MDE applicable
	with some considerations. This article presents the lessons learned
	after the definition of a methodology and the implementation of a
	set of tools to support the MDE-base development of HA systems. In
	particular, the definition of a Domain Specific Language has made
	possible the generation of code although we have identified some
	peculiarities and differences from a classical MDE perspective. These
	results can be extrapolated to other domains with similar characteristic.},
  affiliation = {DSIE Research Group, Technical University of Cartagena, Campus Muralla
	del Mar s/n, E-30202, Cartagena, Spain},
  author_keywords = {Domain specific languages; Home Automation; Model Driven Engineering;
	Model transformations},
  document_type = {Conference Paper},
  journal = {ICSOFT 2011 - Proceedings of the 6th International Conference on
	Software and Database Technologies},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-80052571882&partnerID=40&md5=9e2041547cc599fb6b04d49f02bf5585}
}

@ARTICLE{Rougemaille2009105,
  author = {Rougemaille, S., Arcangeli, J.-P., Gleizes, M.-P., Migeon, F.},
  title = {ADELFE design, AMAS-ML in action: A case study},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2009},
  volume = {5485 LNAI},
  pages = {105-120},
  note = {cited By (since 1996) 1},
  abstract = {The complexity of engineers tasks leads us to provide means to bring
	the Adaptive Multi-Agent Systems (AMAS) design to a higher stage
	of automation and confidence thanks to Model Driven Development (MDD).
	This paper focuses on a practical example and illustrates the modifications
	that have been done to the ADELFE methodology. In the Design phase,
	we propose to use a Domain Specific Modeling Language (DSML) for
	the specification of cooperative agents. We also, add a Model Diven
	Implementation phase using model transformation, DSMLs and code generation.
	These phases carry out a model centric process to produce and partially
	generate the system code. We present the use of our MD process applied
	to a simple, but very illustrative example: the foraging ants simulation.
	© 2009 Springer Berlin Heidelberg.},
  affiliation = {IRIT, SMAC, 118, route de Narbonne, F-31062 Toulouse Cedex 9, France},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-70349329557&partnerID=40&md5=6c22aa7c5f1daf8458fa478006836f04}
}

@ARTICLE{Roychoudhury20111,
  author = {Roychoudhury, S.a , Gray, J.b , Jouault, F.c },
  title = {A model-driven framework for aspect weaver construction},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2011},
  volume = {6580},
  pages = {1-45},
  note = {cited By (since 1996) 0},
  abstract = {Aspect orientation has been used to improve the modularization of
	crosscutting concerns that emerge at different levels of software
	abstraction. Although initial research was focused on imparting aspect-oriented
	(AO) capabilities to programming languages, the paradigm was later
	on extended to software artifacts that appear at higher levels of
	abstraction (e.g., models). In particular, the Model-Driven Engineering
	(MDE) paradigm has largely benefitted from the inclusion of aspect-oriented
	techniques. In a converse way, we believe it may also be productive
	to investigate how MDE techniques can be adopted to benefit the development
	of aspect-oriented tools. The main objective of this paper is to
	show how MDE techniques can be used to improve the construction of
	aspect weavers for General-Purpose Languages (GPLs) through reusable
	models and transformations. The approach described in the paper uses
	models to capture the concepts of various Aspect-Oriented Programming
	(AOP) language constructs at a metamodeling level. These models are
	then mapped to concrete weavers for GPLs through a combination of
	higher-order model transformation and program transformation rules.
	A generic extension to the framework further supports reusability
	of artifacts among weavers during the construction process. Aspect
	weavers for FORTRAN and Object Pascal have been constructed using
	the framework, and their features evaluated against several case
	study applications. © 2011 Springer-Verlag Berlin Heidelberg.},
  affiliation = {Tata Research Development and Design Center, Pune 411013, India; Department
	of Computer Science, University of Alabama, Tuscaloosa, AL 35487,
	United States; AtlanMod (INRIA and EMN), Nantes, France},
  author_keywords = {aspect-oriented software development; generative programming; model
	engineering; model transformation; program transformation},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-80051722659&partnerID=40&md5=e3af9cb7a7d6d8b599055b651c3da4d2}
}

@CONFERENCE{Rubin1999,
  author = {Rubin, Stuart H., Smith, Michael H., Trajkovic, Ljiljana},
  title = {Randomizing the knowledge acquisition bottleneck},
  year = {1999},
  volume = {5},
  pages = {V-790 - V-795},
  note = {cited By (since 1996) 1},
  abstract = {This paper addresses the knowledge acquisition bottleneck. It first
	takes an information-theoretic view of knowledge acquisition as having
	a basis in randomization theory and subsequently gives practical
	examples. The examples are taken from the field of expert compiler
	technology. Such technology can be used to effect the realization
	of fourth generation languages. These languages have been shown to
	be among software engineering's greatest success stories. Expert
	compilers have the advantage of being easily maintainable and extensible.
	They randomize translational information in the form of rules. The
	capture of domain-specific knowledge allows for the construction
	of context-sensitive languages that are easy to work with. Of course,
	such languages are necessarily domain-specific; but even here expert
	compilers lend their advantage of promoting rapid prototyping within
	similar domains. It follows that if one builds a text-oriented domain-specific
	language that one can build a more complex expert compiler and so
	on. Clearly, randomization has application to not just the data,
	but to the representation of the data as well.},
  affiliation = {Cent Michigan Univ, Mt. Pleasant, United States},
  document_type = {Conference Paper},
  journal = {Proceedings of the IEEE International Conference on Systems, Man
	and Cybernetics},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-0033325769&partnerID=40&md5=4bbdb9d891a8408bf4698c7701d7c287}
}

@CONFERENCE{Rubini2011338,
  author = {Rubini, S.a , Singhoff, F.a , Hugues, J.b },
  title = {Modeling and verification of memory architectures with AADL and REAL},
  year = {2011},
  pages = {338-343},
  note = {cited By (since 1996) 0},
  abstract = {Real-Time Embedded systems must respect a wide range of non-functional
	properties, including safety, respect of deadlines, power or memory
	consumption. We note that correct hardware resource dimensioning
	requires taking into account the impact of the whole software, both
	the user code and the underlying runtime environment. AADL allows
	one to precisely capture all of them. In this article, we evaluate
	the AADL modeling to define memory architectures, and then verification
	rules to assess that the memory is correctly dimensioned. We use
	the REAL domain-specific language to express memory requirements
	(such as layout or size) and then validate them on a case-study using
	the VxWorks real-time kernel. © 2011 IEEE.},
  affiliation = {LISyC, University of Brest - UEB 20, Avenue he Gorgeu, CS 93837, 29238
	Brest Cedex 3, France; University de Toulouse, ISAE, 10, Avenue E.
	Belin, 31055 Toulouse Cedex 4, France},
  art_number = {5773407},
  author_keywords = {AADL; Architecture; Constraint language; Memory architecture; REAL;
	Verification},
  document_type = {Conference Paper},
  journal = {Proceedings - 2011 16th IEEE International Conference on Engineering
	of Complex Computer Systems, ICECCS 2011},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-79960485542&partnerID=40&md5=6c57ea4b583be23cb7f1f6948a96d6c4}
}

@CONFERENCE{Rudolph201015,
  author = {Rudolph, J., Thiemann, P.},
  title = {Mnemonics: Type-safe bytecode generation at run time},
  year = {2010},
  pages = {15-24},
  note = {cited By (since 1996) 0},
  abstract = {Mnemonics is a Scala library for generating method bodies in JVM bytecode
	at run time. Mnemonics supports a large subset of the JVM instructions,
	for which the static typing of the generator guarantees the well-formedness
	of the generated bytecode. The library exploits a number of advanced
	features of Scala's type system (type inference with bounded polymorphism,
	implicit parameters, and reflection) to guarantee that the compiler
	only accepts legal combinations of instructions at compile time.
	Additional instructions can be supported at the price of a check
	at run time of the generator. In either case, bytecode verification
	of generated code is guaranteed to succeed. Copyright © 2010 ACM.},
  affiliation = {University of Freiburg, Germany},
  author_keywords = {Embedded domain specific language; Metaprogramming; Program generation},
  document_type = {Conference Paper},
  journal = {Proceedings of the ACM SIGPLAN Symposium on Partial Evaluation and
	Semantics-Based Program Manipulation},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-77950868781&partnerID=40&md5=7072da0bea634e4c8975783c0053768c}
}

@ARTICLE{Rumpe2011387,
  author = {Rumpe, B., Schindler, M., Völkel, S., Weisemöller, I.},
  title = {Agile development with domain specific languages},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2011},
  volume = {6698 LNCS},
  pages = {387-388},
  note = {cited By (since 1996) 0},
  abstract = {An increasing number of software development projects uses domain
	specific languages (DSLs) at least at one stage. Such languages allow
	domain experts to take part in the product development, and they
	can often contribute to improved efficiency. As a drawback, the development
	of a DSL is a complex and error-prone software development process
	itself, which causes additional efforts and costs. Moreover, the
	actual software product and the DSL are often developed concurrently,
	and the requirements for the DSL may change according to the needs
	of developers of the actual product. Therefore, we have to address
	two interdependent development processes: the product development
	process, in which we may need to react on requirement changes by
	the customer quickly, and the language development process, in which
	we want to define an adaptable and extensible DSL. © 2011 Springer-Verlag.},
  affiliation = {Software Engineering, RWTH Aachen University, Germany},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-79959225141&partnerID=40&md5=f6f440396823e195cced9e2d397b8ef6}
}

@CONFERENCE{Rumpe2010473,
  author = {Rumpe, B., Schindler, M., Völkel, S., Weisemöller, I.},
  title = {Generative software development},
  year = {2010},
  volume = {2},
  pages = {473-474},
  note = {cited By (since 1996) 1},
  abstract = {Generation of software from modeling languages such as UML and domain
	specific languages (DSLs) has become an important paradigm in software
	engineering. In this contribution, we present some positions on software
	development in a model based, generative manner based on home grown
	DSLs as well as the UML. This includes development of DSLs as well
	as development of models in these languages in order to generate
	executable code, test cases or models in different languages. Development
	of formal DSLs contains concepts of metamodels or grammars (syntax),
	context conditions (static analysis and quality assurance) as well
	as possibilities to define the semantics of a language. The growing
	number and complexity of DSLs is addressed by concepts for the modular
	and compositional development of languages and their tools. Moreover,
	we introduce approaches to code generation and model transformation.
	Finally, we give an overview of the relevance of DSLs for various
	steps of software development processes. © 2010 Copyright is held
	by author/owner(s).},
  affiliation = {Software Engineering, RWTH Aachen University, Germany},
  document_type = {Conference Paper},
  journal = {Proceedings - International Conference on Software Engineering},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-77954747884&partnerID=40&md5=67c4eb2757b5c9ba3976b43be724178f}
}

@CONFERENCE{Runde20081488,
  author = {Runde, S.a , Dibowski, H.b , Fay, A.a , Kabitzsch, K.b },
  title = {Integrated automated design approach for building automation systems},
  year = {2008},
  pages = {1488-1495},
  note = {cited By (since 1996) 3},
  abstract = {The planning and design of building automation systems is a time consuming,
	error prone and nowadays more and more expensive task, consisting
	of a lot of repeated manual design steps done by specialized engineers.
	To reduce the engineering costs for such systems, the authors present
	a new automated top-down design approach within this paper. A knowledge-based
	system supports the planner at the requirement analysis by means
	of a guided dialog. Subsequently, the complete automation system
	is automatically designed in two steps. The abstract design proceeds
	a design based on platform- and manufacturer- independent function
	blocks via generative programming. The detailed design replaces the
	function blocks by platform- and manufacturerspecific profiles by
	means of evolutionary techniques. © 2008 IEEE.},
  affiliation = {Helmut Schmidt University Hamburg, Department of Mechanical Engineering,
	Institute for Automation; Dresden University of Technology, Department
	of Computer Science, Institute for Applied Computer Science},
  art_number = {4638592},
  document_type = {Conference Paper},
  journal = {IEEE Symposium on Emerging Technologies and Factory Automation, ETFA},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-56349118862&partnerID=40&md5=f15625c39798741d510fd61dcb9278ba}
}

@ARTICLE{Rust2007128,
  author = {Rust, P.M.},
  title = {Mathematics and scientific markup},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2007},
  volume = {4573 LNAI},
  pages = {128-129},
  note = {cited By (since 1996) 0},
  abstract = {The development of e-Science (cyberScience, Grid, etc.) is starting
	to become a reality with formalised data resources, services on demand,
	domain-specific search engines, digital repositories, etc. Increasingly
	STM 1 information will be contained in compound XML documents, representing
	scientific communication (articles, theses, repository entries, etc.).
	In physical sciences such as chemistry, materials science, engineering,
	physics, earth sciences, these "datuments" [1] normally contain hypertext,
	graphics, tables, graphs and numerical data, mathematical objects
	and relationships. In addition they may also contain domain-specific
	content such as chemical formula and reactions, thermodynamic and
	mechanical properties, electric, magnetic and optical properties.
	Among the domain-specific languages, CML (Chemical Markup Language)
	is the oldest and broadest, and is now being actively used for publishing
	by the Royal Society of Chemistry (Project Prospect [2]) which gives
	an idea of what chemistry in datuments can look like. CML has had
	to develop the domain-specific objects (molecules, atoms, bonds,
	spectra, crystallography, etc.) and the relationships between them.
	However, due to the text-based nature of early XML, it has also had
	to design an implement domain-independent infrastructure which can
	support much of physical science. Originally called STMML [3] it
	supports data types (float, integer, complex, etc.), data structures
	(arrays, lists, matrices, etc.), geometrical concepts (points, planes,
	lines, etc.) and scientific units of measurement. In addition CML
	bases much of its flexibility one usercreated dictionaries (ontologies)
	which are hyperlinked from objects in the datuments. It is now clear
	that the domain-independent parts of CML (and by extension some other
	markup languages in physical science) are loosely isomorphic with
	approaches in MathML and OMDOC. If a synthesis can be found, then
	CML can happily forget about the "non-chemistry" knowing that the
	mathematical and physical science community has a general way forward.
	In easiest-first order, the following are suggested: Mathematical
	variables and equations in chemical documents. An obvious challenge
	is that the variables represent types, often physical quantities
	(but also chemical objects such as atomTypes). This would be one
	of the first areas to explore with publishers. Graphs and tables.
	A high proportion of graphs are functions of one of more dependent
	variables against one or more independent variables, currently supported
	by 〈table〉. Dictionaries. The CML dictionaries and OMDOC content
	dictionaries seem fairly similar in approach. Mathematical relationships.
	A large area of physical science is based on theoretically and experimentally
	validated relationships which have been proved over many years (e.g.
	Maxwell's equations in thermodynamics). Often a quantity can be most
	easily determined by measuring different ones and transforming them.
	However most transformations are currently hidden in procedural non-portable
	code and it would be an exciting challenge to create a self-consistent
	declarative model of parts of physical science. It would be very
	exciting to have a discovery engine which could, on demand, decide
	which quantities were deducible from which (with similarity to theorem
	proving). A major challenge for distributed mathematics and science
	is discovery through search engines. These currently work on "free
	text" and are optimised to recognise strings. In a few cases domain-specific
	canonicalisations can be used (e.g. our Google Inchi [4] transforms
	a molecular graph into a string which is recognised by search engines).
	However most cases require mathematical operations (arithmetic, transformations,
	subgraph-matching, etc.). How - and where - can these be performed?
	A new generation of domain-independent and domain-specific indexing
	and searching tools needs to be developed. Recently CML has had to
	evolve a grammar to support fuzzy concepts representing sets of molecules.
	These have a distinguished mathematical history (see, e.g. enumeration
	of alkanes [5] and references therein). Polymers and chemicals in
	patents ("Markush") are often expressed in text when a grammar would
	be more precise. Chemical searches are also often expressed in a
	grammar and evaluation or comparison of representations is a common
	activity. The presentation will give a number of interactive demonstrations.
	No chemical knowledge is required! © Springer-Verlag Berlin Heidelberg
	2007.},
  affiliation = {Unilever Centre for Molecular Science Informatics, Department of Chemistry,
	University of Cambridge, United Kingdom},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-38049049675&partnerID=40&md5=c7826374d5a05881d124e4e16539ec4c}
}

@ARTICLE{Rutherford2003377,
  author = {Rutherford, M.J., Wolf, A.L.},
  title = {A case for test-code generation in model-driven systems},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2003},
  volume = {2830},
  pages = {377-396},
  note = {cited By (since 1996) 0},
  abstract = {A primary goal of generative programming and model-driven development
	is to raise the level of abstraction at which designers and developers
	interact with the software systems they are building. During initial
	development, the benefits of abstraction are clear. However, during
	testing and maintenance, increased distance from the implementation
	can be a disadvantage. We view test cases and test harnesses as an
	essential bridge between the high-level specifications and the implementation.
	As such, the generation of test cases for fully generated components
	and test harnesses for partially generated components is of fundamental
	importance to model-driven systems. In this paper we present our
	experience with test-case and test-harness generation for a family
	of model-driven, component-based distributed systems. We describe
	our development tool, MODEST, and motivate our decision to invest
	the extra effort needed to generate test code. We present our approach
	to test-case and test-harness generation and describe the benefits
	to developers and maintainers of generated systems. Furthermore,
	we quantify the relative cost of generating test code versus application
	code and find that the artifact templates for producing test code
	are simpler than those used for application code. Given the described
	benefits to developers and maintainers and the relatively low cost
	of test-code development, we argue that test-code generation should
	be a fundamental feature of model-driven development efforts. © Springer-Verlag
	Berlin Heidelberg 2003.},
  affiliation = {Department of Computer Science, University of Colorado, Boulder, CO
	80309-430, United States},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-35248862534&partnerID=40&md5=bed3b25cfec04f50892888f4d55632c1}
}

@ARTICLE{Ryssel201123,
  author = {Ryssel, U., Ploennigs, J., Kabitzsch, K.},
  title = {Automatic variation-point identification in function-block-based
	models},
  journal = {ACM SIGPLAN Notices},
  year = {2011},
  volume = {46},
  pages = {23-32},
  number = {2},
  note = {cited By (since 1996) 0},
  abstract = {Function-block-based modeling is often used to develop embedded systems,
	particularly as system variants can be developed rapidly from existing
	modules. Generative approaches can simplify the handling and development
	of the resulting high variety of functionblock- based models. But
	they often require the development of new generic models that do
	not utilize existing ones. Reusing existing models will significantly
	decrease the effort to apply generative programming. This work introduces
	an automatic approach to recognize variants in a set of models and
	identify the variation points and their dependencies within variants.
	As result it offers automatically generated feature models and ICCL
	content to regenerate the given variants. Copyright © 2010 ACM.},
  affiliation = {Institute for Applied Computer Science, Dresden University of Technology,
	Dresden, Germany},
  author_keywords = {Formal Concept Analysis; Function-Block-Based Models; Library Migration;
	Variation-Point Identification},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-79951746832&partnerID=40&md5=9112e5dbbdb07137b50a786ae3f6e101}
}

@CONFERENCE{Ryssel201023,
  author = {Ryssel, U., Ploennigs, J., Kabitzsch, K.},
  title = {Automatic variation-point identification in function-block-based
	models},
  year = {2010},
  pages = {23-32},
  note = {cited By (since 1996) 1},
  abstract = {Function-block-based modeling is often used to develop embedded systems,
	particularly as system variants can be developed rapidly from existing
	modules. Generative approaches can simplify the handling and development
	of the resulting high variety of function-block-based models. But
	they often require the development of new generic models that do
	not utilize existing ones. Reusing existing models will significantly
	decrease the effort to apply generative programming. This work introduces
	an automatic approach to recognize variants in a set of models and
	identify the variation points and their dependencies within variants.
	As result it offers automatically generated feature models and ICCL
	content to regenerate the given variants. © 2010 ACM.},
  affiliation = {Institute for Applied Computer Science, Dresden University of Technology,
	Dresden, Germany},
  author_keywords = {Formal concept analysis; Function-block-based models; Library migration;
	Variation-point identification},
  document_type = {Conference Paper},
  journal = {GPCE'10 - Proceedings of the 2010 Conference on Generative Programming
	and Component Engineering},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-78650152822&partnerID=40&md5=ad2980357d1113d47b792c411792af04}
}

@CONFERENCE{Ryzhyk2009275,
  author = {Ryzhyk, L.a b , Chubb, P.a b , Kuz, I.a b , Heiser, G.a b c },
  title = {Dingo: Taming device drivers},
  year = {2009},
  pages = {275-288},
  note = {cited By (since 1996) 1},
  abstract = {Device drivers are notorious for being a major source of failure in
	operating systems. In analysing a sample of real defects in Linux
	drivers, we found that a large proportion (39%) of bugs are due to
	two key shortcomings in the device-driver architecture enforced by
	current operating systems: poorly-defined communication protocols
	between drivers and the OS, which confuse developers and lead to
	protocol violations, and a multithreaded model of computation that
	leads to numerous race conditions and deadlocks. We claim that a
	better device driver architecture can help reduce the occurrence
	of these faults, and present our Dingo framework as constructive
	proof. Dingo provides a formal, state-machine based, language for
	describing driver protocols, which avoids confusion and ambiguity,
	and helps driver writers implement correct behaviour. It also enforces
	an event-driven model of computation, which eliminates most concurrency-related
	faults. Our implementation of the Dingo architecture in Linux offers
	these improvements, while introducing negligible performance overhead.
	It allows Dingo and native Linux drivers to coexist, providing a
	gradual migration path to more reliable device drivers. Copyright
	© 2009 ACM.},
  affiliation = {NICTA; University of New South Wales; Open Kernel Labs, Sydney, NSW,
	Australia},
  author_keywords = {Concurrent programming; Device drivers; Domain-specific languages;
	Fault avoidance; Reliability},
  document_type = {Conference Paper},
  journal = {Proceedings of the 4th ACM European Conference on Computer Systems,
	EuroSys'09},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-70349130245&partnerID=40&md5=ec072f3ed4355613285d853d7ec5f146}
}

@CONFERENCE{Ryzhyk200973,
  author = {Ryzhyk, L.a b , Chubb, P.a b , Kuz, I.a b , Le Sueur, E.a b , Heiser,
	G.a b c },
  title = {Automatic device driver synthesis with termite},
  year = {2009},
  pages = {73-86},
  note = {cited By (since 1996) 1},
  abstract = {Faulty device drivers cause significant damage through down time and
	data loss. The problem can be mitigated by an improved driver development
	process that guarantees correctness by construction. We achieve this
	by synthesising drivers automatically from formal specifications
	of device interfaces, thus reducing the impact of human error on
	driver reliability and potentially cutting down on development costs.
	We present a concrete driver synthesis approach and tool called Termite.
	We discuss the methodology, the technical and practical limitations
	of driver synthesis, and provide an evaluation of non-trivial drivers
	for Linux, generated using our tool. We show that the performance
	of the generated drivers is on par with the equivalent manually developed
	drivers. Furthermore, we demonstrate that device specifications can
	be reused across different operating systems by generating a driver
	for FreeBSD from the same specification as used for Linux. Copyright
	2009 ACM.},
  affiliation = {NICTA, Sydney, NSW, Australia; University of New South Wales, Sydney,
	NSW, Australia; Open Kernel Labs., Sydney, NSW, Australia},
  author_keywords = {Device drivers; Domain-specific languages; Software synthesis; Two-player
	games},
  document_type = {Conference Paper},
  journal = {SOSP'09 - Proceedings of the 22nd ACM SIGOPS Symposium on Operating
	Systems Principles},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-72249114480&partnerID=40&md5=376a10a416ccc342fb3ab935ebded61a}
}

@ARTICLE{Ráth2010453,
  author = {Ráth, I.a , Ökrös, A.b , Varró, D.a },
  title = {Synchronization of abstract and concrete syntax in domain-specific
	modeling languages: By mapping models and live transformations},
  journal = {Software and Systems Modeling},
  year = {2010},
  volume = {9},
  pages = {453-471},
  number = {4},
  note = {cited By (since 1996) 1},
  abstract = {Modern domain-specific modeling (DSM) frameworks provide refined techniques
	for developing new languages based on the clear separation of conceptual
	elements of the language (called abstract syntax) and their graphical
	visual representation (called concrete syntax). This separation is
	usually achieved by recording traceability information between the
	abstract and concrete syntax using mapping models. However, state-of-the-art
	DSM frameworks impose severe restrictions on traceability links between
	elements of the abstract syntax and the concrete syntax. In the current
	paper, we propose a mapping model which allows to define arbitrarily
	complex mappings between elements of the abstract and concrete syntax.
	Moreover, we demonstrate how live model transformations can complement
	mapping models in providing bidirectional synchronization and implicit
	traceability between models of the abstract and the concrete syntax.
	In addition, we introduce a novel architecture for DSM environments
	which enables these concepts, and provide an overview of the tool
	support. © 2009 Springer-Verlag.},
  affiliation = {Department of Measurement and Information Systems, Budapest University
	of Technology and Economics, Magyar tudósok krt. 2, 1117 Budapest,
	Hungary; OptXware Research and Development LLC., Katona J.u. 39.,
	1137 Budapest, Hungary},
  author_keywords = {Domain-specific modeling languages; Live model transformations; Model
	synchronization; Traceability},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-77956268447&partnerID=40&md5=75e8cc209155e72b59e88beee02d705b}
}

@CONFERENCE{Sabo2009267,
  author = {Sabo, A.a , Schramm, N.b },
  title = {Concurrent programming method for digital signal processing},
  year = {2009},
  pages = {267-271},
  note = {cited By (since 1996) 0},
  abstract = {The task of programming concurrent systems is substantially more difficult
	than the task of programming sequential systems with respect to both
	correctness and efficiency. The tendency in development of embedded,
	DSP systems and processors are shifting to multi core and multiprocessor
	setups as well. The problem of easy concurrency and algorithm development
	is an important for embedded and DSP systems as well. The goal of
	this paper is to define and present a high level language that allows
	description and development of signal processing algorithms. With
	the usage of a domain specific language, we can create compact and
	easy to understand definition of algorithms. In the paper the authors
	present the advantages granted by DSL for DSP applications. The created
	definitions are hardware independent can be executed and functionally
	verified. Efficient code can be generated for various targets without
	porting. The design of the presented DSL allows code generation for
	multi-core targets in case of computing-intensive algorithms, code
	generation for multiple streams, threads. Code reuse is supported
	by merging, re-grouping, and splitting of algorithms and groups of
	algorithms. © 2009 IEEE.},
  affiliation = {Polytechnical Engineering College, Subotica, Serbia; Inovacioni Centar
	D.O.O., Subotica, Serbia},
  art_number = {5291151},
  document_type = {Conference Paper},
  journal = {SISY 2009 - 7th International Symposium on Intelligent Systems and
	Informatics},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-74349090204&partnerID=40&md5=004cde95d5a0529784a7672602613291}
}

@ARTICLE{Sadat-Mohtasham20081196,
  author = {Sadat-Mohtasham, S.H., Ghorbani, A.A.},
  title = {A language for high-level description of adaptive web systems},
  journal = {Journal of Systems and Software},
  year = {2008},
  volume = {81},
  pages = {1196-1217},
  number = {7},
  note = {cited By (since 1996) 0},
  abstract = {Adaptive Web systems (AWS) are Web-based systems that can adapt their
	features such as, presentation, content, and structure, based on
	users' behaviour and preferences, device capabilities, and environment
	attributes. A framework was developed in our research group to provide
	the necessary components and protocols for the development of adaptive
	Web systems; however, there were several issues and shortcomings
	(e.g. low productivity, lack of verification mechanisms, etc.) in
	using the framework that inspired the development of a domain-specific
	language for the framework. This paper focuses on the proposal, design,
	and implementation of AWL, the Adaptive Web Language, which is used
	to develop adaptive Web systems within our framework. Not only does
	AWL address the existing issues in the framework, but it also offers
	mechanisms to increase software quality attributes, especially, reusability.
	An example application named PENS (a personalized e-News system)
	is explained and implemented in AWL. AWL has been designed based
	on the analysis of the adaptive Web domain, having taken into account
	the principles of reuse-based software engineering (product-lines),
	domain-specific languages, and aspect-oriented programming. Specially,
	a novel design decision, inspired by aspect-oriented programming
	paradigm, allows separate specification of presentation features
	in an application from its adaptation features. The AWL's design
	decisions and their benefits are explained. © 2007 Elsevier Inc.
	All rights reserved.},
  affiliation = {Intelligent and Adaptive Systems Group, Faculty of Computer Science,
	University of New Brunswick, Fredericton, NB E3B 5A3, Canada},
  author_keywords = {Adaptive web system; Aspect-oriented programming; Domain-specific
	programming language},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-43849104607&partnerID=40&md5=95688e8353cfb6e2142aff265efb46c9}
}

@CONFERENCE{Sadilek2008895,
  author = {Sadilek, D.A.},
  title = {Prototyping domain-specific language semantics},
  year = {2008},
  pages = {895-896},
  note = {cited By (since 1996) 3},
  abstract = {Domain-specific languages (DSLs) need semantics. For an external,
	executable, metamodel-based DSL, this can be done in an operational
	or a translational way. In my dissertation, I develop a framework
	that allows both. It provides flexibility for semantics description
	in two axes: on the one axis, operational semantics is fixed and
	one can choose between different description languages (QVT, Java,
	Prolog, Abstract State Machines, and Scheme); on the other axis,
	Scheme is fixed and one can choose between operational and translational
	semantics. Using operational semantics, DSL program interpretation
	can be animated and debugged. Equivalence of operational semantics
	described with different languages can be tested by comparing execution
	traces.},
  affiliation = {Humboldt-Universität zu Berlin, Computer Science Department, Germany},
  author_keywords = {Domain-specific languages; Language engineering; Metamodelling; Operational
	semantics},
  document_type = {Conference Paper},
  journal = {Proceedings of the Conference on Object-Oriented Programming Systems,
	Languages, and Applications, OOPSLA},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-63349085830&partnerID=40&md5=a8ede2d4128aeda2d804b7112a805787}
}

@CONFERENCE{Saidani200967,
  author = {Saidani, T.a , Tadonki, C.a , Lacassagne, L.a , Falcou, J.b , Etiemble,
	D.b },
  title = {Algorithmic skeletons within an embedded domain specific language
	for the cell processor},
  year = {2009},
  pages = {67-76},
  note = {cited By (since 1996) 0},
  abstract = {Efficiently using the hardware capabilities of the Cell processor,
	a heterogeneous chip multiprocessor that uses several levels of parallelism
	to deliver high performance, and being able to reuse legacy code
	are real challenges for application developers. We propose to use
	Generative Programming and more precisely template meta-programing
	to design an Embedded Domain Specific Language using algorithmic
	skeletons to generate applications based on a high-level mapping
	description. The method is easy to use by developers and delivers
	performance close to the performance of optimized hand-written code,
	as shown on various benchmarks ranging from simple BLAS kernels to
	image processing applications.},
  affiliation = {Institut d'Electronique Fondamentale, University Paris-Sud XI, Orsay,
	France; Laboratoire de Recherche en Informatique, University Paris-Sud
	XI, Orsay, France},
  art_number = {5260551},
  author_keywords = {Algorithmic skeletons; C++ meta-programing; Cell processor; Embedded
	domain specific language; Generative programming},
  document_type = {Conference Paper},
  journal = {Parallel Architectures and Compilation Techniques - Conference Proceedings,
	PACT},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-70449652922&partnerID=40&md5=f65e35e179e9e9b00ea3c9abad5c6aa0}
}

@CONFERENCE{Salehi201035,
  author = {Salehi, P.a , Hamou-Lhadj, A.a , Colombo, P.a , Khendek, F.a , Toeroe,
	M.b },
  title = {A UML-based domain specific modeling language for the availability
	management framework},
  year = {2010},
  pages = {35-44},
  note = {cited By (since 1996) 1},
  abstract = {The Service Availability Forum (SA Forum) is a consortium of several
	telecommunications and computing companies that defines standard
	solutions for high availability platforms. One of the most important
	SA Forum services is the Availability Management Framework (AMF)
	which is responsible for managing the availability of an application
	running under its control. To achieve this, AMF requires a complete
	configuration, which consists of several entities organized according
	to AMF rules and constraints. In this paper, we argue that AMF concepts
	form a domain for which a domain-specific modeling language can greatly
	facilitate the generation, analysis and the management of AMF configurations.
	We define such a language by extending UML through its profiling
	mechanism and we implement it. More important, we discuss the challenges
	and the lessons learned in the course of this project. © 2010 IEEE.},
  affiliation = {Electrical and Computer Engineering Department, Concordia University,
	Montréal, Canada; Ericsson Inc., Montréal, Canada},
  art_number = {5634309},
  author_keywords = {Availability management framework, configurations; Domain-specific
	modeling languages; High availability; UML profiles},
  document_type = {Conference Paper},
  journal = {Proceedings of IEEE International Symposium on High Assurance Systems
	Engineering},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-79951923429&partnerID=40&md5=a41254b5027a9cfeb6299dd4f64f4206}
}

@ARTICLE{Salgueiro2011203,
  author = {Salgueiro, P., Abreu, S.},
  title = {Modeling distributed network attacks with constraints},
  journal = {Studies in Computational Intelligence},
  year = {2011},
  volume = {382},
  pages = {203-212},
  note = {cited By (since 1996) 0},
  abstract = {In this work we demonstrate how to model and perform the detection
	of Distributed Network attacks using NeMODe, a declarative system
	for Computer Network Intrusion Detection which provides a declarative
	Domain Specific Language for describing computer network intrusion
	signatures which span several network packets by stating constraints
	over network packets, thus, describing relations between several
	packets, in a declarative and expressive way. © 2011 Springer-Verlag
	Berlin Heidelberg.},
  affiliation = {CENTRIA, Dep. de Informática, Universidade de Évora, Portugal},
  author_keywords = {Constraint Programming; Domain Specific Languages; Intrusion Detection
	Systems},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-81355123290&partnerID=40&md5=47741d95f5cba03a7b870deb30e302f6}
}

@ARTICLE{Salgueiro2011115,
  author = {Salgueiro, P.a , Diaz, D.b , Brito, I.c , Abreu, S.a },
  title = {Using constraints for intrusion detection: The NeMODe system},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2011},
  volume = {6539 LNCS},
  pages = {115-129},
  note = {cited By (since 1996) 0},
  abstract = {In this work we present NeMODe a declarative system for Computer Network
	Intrusion detection which provides a declarative Domain Specific
	Language for describing computer network intrusion signatures that
	could spread across several network packets, which allows to state
	constraints over network packets, describing relations between several
	packets, and providing several back-end detection mechanisms which
	relies on Constraint Programming (CP) methodologies to find those
	intrusions. © 2011 Springer-Verlag.},
  affiliation = {Departamento de Informática, Universidade de Évora, CENTRIA FCT/UNL,
	Portugal; University of Paris 1-Sorbonne, Paris, France; Departamento
	de Engenharia, Escola Superior de Tecnologia e Gestão, Instituto
	Politécnico de Beja, Portugal},
  author_keywords = {Constraint Programming; Domain Specific Languages; Intrusion Detection
	Systems},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-79551587941&partnerID=40&md5=548f21654692597b028aea960c770c13}
}

@CONFERENCE{Salgueiro2010224,
  author = {Salgueiro, P.D., Abreu, S.P.},
  title = {A DSL for intrusion detection based on Constraint Programming},
  year = {2010},
  pages = {224-232},
  note = {cited By (since 1996) 1},
  abstract = {Intrusion Detection Systems (IDS) are increasingly important in computer
	networks, allowing the early diagnosis and detection of anomalous
	situations, which could otherwise put network performance at risk
	or even compromise the security or integrity of user data. In this
	work we present NeMODe, a domain specific language for network intrusion
	detection that allows to describe network intrusions that spread
	across several network packets, relying on Constraint Programming(CP),
	a programming methodology that starts with a declarative description
	of the desirable network situations and, based on that description,
	a set of parameterizations for network intrusion detection mechanisms
	will execute to find those intrusions. Copyright 2010 ACM.},
  affiliation = {Universidade de Évora, Évora and CENTRIA FCT/UNL, Caparica, Portugal},
  author_keywords = {Constraint Programming; Domain-specific languages; Intrusion detection
	systems},
  document_type = {Conference Paper},
  journal = {SIN'10 - Proceedings of the 3rd International Conference of Security
	of Information and Networks},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-77958027072&partnerID=40&md5=c9f3e91a695078dc9b20c22f741ca0d1}
}

@ARTICLE{SanchezCuadrado2009825,
  author = {Sanchez Cuadrado, J., Molina, J.G.},
  title = {A model-based approach to families of embedded domain-specific languages},
  journal = {IEEE Transactions on Software Engineering},
  year = {2009},
  volume = {35},
  pages = {825-840},
  number = {6},
  note = {cited By (since 1996) 3},
  abstract = {With the emergence of model-driven engineering (MDE), the creation
	of domain-specific languages (DSLs) is becoming a fundamental part
	of language engineering. The development cost of a DSL should be
	modest compared to the cost of developing a general-purpose programming
	language. Reducing the implementation effort and providing reuse
	techniques are key aspects for DSL approaches to be really effective.
	In this paper, we present an approach to build embedded domain-specific
	languages applying the principles of model-driven engineering. On
	the basis of this approach, we will tackle reuse of DSLs by defining
	families of DSLs, addressing reuse both from the DSL developer and
	user point of views. A family of DSLs will be built up by composing
	several DSLs, so we will propose composition mechanisms for the abstract
	syntax, concrete syntax, and model transformation levels of a DSL's
	definition. Finally, we contribute a software framework to support
	our approach, and we illustrate the paper with a case study to demonstrate
	its practical applicability. © 2009 IEEE.},
  affiliation = {Department of Computers and Systems, Facultad de Informática, University
	of Murcia, Murcia 30071, Spain},
  art_number = {4782971},
  author_keywords = {Domain-specific languages; DSL composition; Families of DSLs; Model-driven
	development},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-73549110067&partnerID=40&md5=37e9c32cd600a90c9bdea76418d041e0}
}

@CONFERENCE{Sanders2010,
  author = {Sanders, B.A.a , Bartlett, R.b , Deumens, E.b , Lotrich, V.c , Ponton,
	M.c },
  title = {A block-oriented language and runtime system for tensor algebra with
	very large arrays},
  year = {2010},
  note = {cited By (since 1996) 0},
  abstract = {Important classes of problems in computational chemistry, notably
	coupled cluster methods, consist of solutions to complicated expressions
	defined in terms of tensors. Tensors are represented by multidimensional
	arrays that are typically extremely large, thus requiring distribution
	or in some cases backing on disk. We describe a parallel programming
	environment, the Super Instruction Architecture (SIA) comprising
	a domain specific programming language SIAL and its runtime system
	SIP that are specialized for this class of problems. A novel feature
	of the programming language is that SIAL programmers express algorithms
	in terms of operations on blocks rather than individual floating
	point numbers. Efficient implementations of the block operations
	as well as management of memory, communication, and I/O are provided
	by the runtime system. The system has been successfully used to develop
	ACES III, a software package for computational chemistry. © 2010
	IEEE.},
  affiliation = {Department of Computer and Information Science and Engineering, University
	of Florida, United States; Department of Chemistry, University of
	Florida, United States; ACES QC, Gainesville, FL, United States},
  art_number = {5644881},
  author_keywords = {Blocked arrays; Computational chemistry; Domain specific language;
	MPI; Parallel; Petascale; Tiled arrays; Very large arrays},
  document_type = {Conference Paper},
  journal = {2010 ACM/IEEE International Conference for High Performance Computing,
	Networking, Storage and Analysis, SC 2010},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-78650825962&partnerID=40&md5=69742727d8df9daf52337cf20dc192b2}
}

@ARTICLE{Santos20101078,
  author = {Santos, A.L.a , Koskimies, K.b , Lopes, A.a },
  title = {Automating the construction of domain-specific modeling languages
	for object-oriented frameworks},
  journal = {Journal of Systems and Software},
  year = {2010},
  volume = {83},
  pages = {1078-1093},
  number = {7},
  note = {cited By (since 1996) 1},
  abstract = {The extension of frameworks with domain-specific modeling languages
	(DSML) has proved to be an effective way of improving the productivity
	in software product-line engineering. However, developing and evolving
	a DSML is typically a difficult and time-consuming task because it
	requires to develop and maintain a code generator, which transforms
	application models into framework-based code. In this paper, we propose
	a new approach for extending object-oriented frameworks that aims
	to alleviate this problem. The approach is based on developing an
	additional aspect-oriented layer that encodes a DSML for building
	framework-based applications, eliminating the need of implementing
	a code generator. We further show how a language workbench is capable
	of automating the construction of DSMLs using the proposed layer.
	© 2010 Elsevier Inc. All rights reserved.},
  affiliation = {Department of Informatics, Faculty of Sciences, University of Lisbon,
	Campo Grande, 1749-016 Lisboa, Portugal; Department of Software Systems,
	Tampere University of Technology, P.O. Box 553, FIN-33101 Tampere,
	Finland},
  author_keywords = {Aspect-oriented programming; Domain-specific modeling; Object-oriented
	frameworks; Software product-lines},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-77953128100&partnerID=40&md5=079a04d9ad9bd05447479d75faa2364f}
}

@CONFERENCE{Santos2008149,
  author = {Santos, A.L.a , Koskimies, K.b , Lopes, A.a },
  title = {Automated Domain-Specific Modeling Languages for generating framework-based
	applications},
  year = {2008},
  pages = {149-158},
  note = {cited By (since 1996) 1},
  abstract = {The adoption of Domain-Specific Modeling Languages (DSMLs) for generating
	framework-based applications has proved to be an effective way of
	enforcing the correct use of frameworks and improve the productivity
	of application developers. However, the development of the code generator
	of a DSML is typically a laborious task with difficulties in what
	concerns complexity, understandability, and maintainability. In this
	paper, we address this problem with a new approach for developing
	DSMLs for frameworks that allows to eliminate the need of implementing
	code generators. The approach relies on the extension of frameworks
	with an additional layer based on aspect-oriented programming that
	encodes a DSML. By means of a generic language workbench, framework-based
	applications can be generated from application models described in
	that DSML. The proposed language workbench was implemented in a prototype
	tool and a case study on the Eclipse Rich Client Platform was performed.
	© 2008 IEEE.},
  affiliation = {Faculty of Sciences, University of Lisbon, Campo Grande, 1749-016,
	Portugal; Department of Software Systems, Tampere University of Technology,
	P.O.BOX 553, FIN-33101 Tampere, Finland},
  art_number = {4626849},
  document_type = {Conference Paper},
  journal = {Proceedings - 12th International Software Product Line Conference,
	SPLC 2008},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-55049120802&partnerID=40&md5=6fe589b1e81677cc0c4db46a3538b8c8}
}

@CONFERENCE{Sarinho200983,
  author = {Sarinho, V.T., Apolinário, A.L.},
  title = {A generative programming approach for game development},
  year = {2009},
  pages = {83-92},
  note = {cited By (since 1996) 0},
  abstract = {Nowadays, due to the great distance between design and implementation
	worlds, different skills are necessary to create a game system. To
	solve this problem, a lot of strategies for game development, trying
	to increase the abstraction level necessary for the game production,
	were proposed. In this way, a lot of game engines, game frameworks
	and others, in most cases without any compatibility or reuse criteria
	between them, were developed. This paper presents a new generative
	programming approach, able to increase the production of a digital
	game by the integration of different game development artifacts,
	following a system family strategy focused on variable and common
	aspects of a computer game. As result, high level abstractions of
	games, based on a common language, can be used to configure metaprogramming
	transformations during the game production, providing a great compatibility
	level between game domain and game implementation artifacts. © 2009
	IEEE.},
  affiliation = {State University of Feira de Santana, Feira de Santana, Bahia, Brazil},
  art_number = {5479106},
  author_keywords = {Component; Game feature models; Game metaprogramming; Game specification
	language; Generative game development},
  document_type = {Conference Paper},
  journal = {SBGAMES2009 - 8th Brazilian Symposium on Games and Digital Entertainment},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-77954414927&partnerID=40&md5=2afaf610f7f33876bdcfea507eda99f6}
}

@CONFERENCE{Sarkar2004,
  author = {Sarkar, D.a , Waddell, O.b , Dybvig, R.K.a },
  title = {A nanopass infrastructure for compiler education},
  year = {2004},
  pages = {201-212},
  note = {cited By (since 1996) 1},
  abstract = {Compilers structured as a small number of monolithic passes are difficult
	to understand and difficult to maintain. Adding new optimizations
	often requires major restructuring of existing passes that cannot
	be understood in isolation. The steep learning curve is daunting,
	and even experienced developers find it hard to modify existing passes
	without introducing subtle and tenacious bugs. These problems are
	especially frustrating when the developer is a student in a compiler
	class. An attractive alternative is to structure a compiler as a
	collection of many small passes, each of which performs a single
	task. This "micropass" structure aligns the actual implementation
	of a compiler with its logical organization, simplifying development,
	testing, and debugging. Unfortunately, writing many small passes
	duplicates code for traversing and rewriting abstract syntax trees
	and can obscure the meaningful transformations performed by individual
	passes. To address these problems, we have developed a methodology
	and associated tools that simplify the task of building compilers
	composed of many fine-grained passes. We describe these compilers
	as "nanopass" compilers to indicate both the intended granularity
	of the passes and the amount of source code required to implement
	each pass. This paper describes the methodology and tools comprising
	the nanopass framework.},
  affiliation = {Indiana University; Abstrax, Inc.},
  author_keywords = {Compiler writing tools; Domain-specific languages; Nanopass compilers;
	Syntactic abstraction},
  document_type = {Conference Paper},
  journal = {Proceedings of the ACM SIGPLAN International Conference on Functional
	Programming, ICFP},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-13344280975&partnerID=40&md5=5732f81a8d4a4e83b71f030578008056}
}

@ARTICLE{Sarkar2004201,
  author = {Sarkar, D.a , Waddell, O.b , Dybvig, R.K.a },
  title = {A nanopass infrastructure for compiler education},
  journal = {ACM SIGPLAN Notices},
  year = {2004},
  volume = {39},
  pages = {201-212},
  number = {9},
  note = {cited By (since 1996) 2},
  abstract = {Compilers structured as a small number of monolithic passes are difficult
	to understand and difficult to maintain. Adding new optimizations
	often requires major restructuring of existing passes that cannot
	be understood in isolation. The steep learning curve is daunting,
	and even experienced developers find it hard to modify existing passes
	without introducing subtle and tenacious bugs. These problems are
	especially frustrating when the developer is a student in a compiler
	class. An attractive alternative is to structure a compiler as a
	collection of many small passes, each of which performs a single
	task. This "micropass" structure aligns the actual implementation
	of a compiler with its logical organization, simplifying development,
	testing, and debugging. Unfortunately, writing many small passes
	duplicates code for traversing and rewriting abstract syntax trees
	and can obscure the meaningful transformations performed by individual
	passes. To address these problems, we have developed a methodology
	and associated tools that simplify the task of building compilers
	composed of many fine-grained passes. We describe these compilers
	as "nanopass" compilers to indicate both the intended granularity
	of the passes and the amount of source code required to implement
	each pass. This paper describes the methodology and tools comprising
	the nanopass framework.},
  affiliation = {Indiana University; Abstrax, Inc.},
  author_keywords = {Compiler writing tools; Domain-specific languages; Nanopass compilers;
	Syntactic abstraction},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-9744264111&partnerID=40&md5=75c9b54783822eb649fde738aad2ca9e}
}

@CONFERENCE{Sarkar20081,
  author = {Sarkar, V.a b },
  title = {Code optimization of parallel programs: Evolutionary vs. revolutionary
	approaches},
  year = {2008},
  pages = {1},
  note = {cited By (since 1996) 0},
  abstract = {Code optimization has a rich history that dates back over half a century.
	Over the years, it has contributed deep innovations to address challenges
	posed by new computer system and programming language features. Examples
	of the former include optimizations for improved register utilization,
	instruction-level parallelism, vector parallelism, multiprocessor
	parallelism and memory hierarchy utilization. Examples of the latter
	include optimizations for procedural, object-oriented, functional
	and domain-specific languages as well as dynamic optimization for
	managed runtimes. These optimizations have contributed significantly
	to programmer productivity by reducing the effort that programmers
	need to spend on hand-implementing code optimizations and by enabling
	code to be more portable, especially as programming models and computer
	architectures change. While compiler frameworks are often able to
	incorporate new code optimizations in an evolutionary manner, there
	have been notable periods in the history of compilers when more revolutionary
	changes were necessary. Examples of such paradigm shifts in the history
	of compilers include interprocedural whole program analysis, coloring-based
	register allocation, static single assignment form, array dependence
	analysis, pointer alias analysis, loop transformations, adaptive
	profile-directed optimizations, and dynamic compilation. The revolutionary
	nature of these shifts is evidenced by the fact that production-strength
	optimization frameworks (especially those in industry) had to be
	rewritten from scratch or significantly modified to support the new
	capabilities. In this talk, we claim that the current multicore trend
	in the computer industry is forcing a new paradigm shift in compilers
	to address the challenge of code optimization of parallel programs,
	regardless of whether the parallelism is implicit or explicit in
	the programming model. All computers - embedded, mainstream, and
	high-end - are now being built from multicore processors with little
	or no increase in clock speed per core. This trend poses multiple
	challenges for compilers for future systems as the number of cores
	per socket continues to grow, and the cores become more heterogeneous.
	In addition, compilers have to keep pace with emerging parallel programming
	models embodied in a proliferation of new libraries and new languages.
	To substantiate our claim, we examine the historicalfoundations of
	code optimization including intermediate representations (IR's),
	abstract execution models, legality and cost analyses of IR transformations
	and show that they are all deeply entrenched in the von Neumann model
	of sequential computing. We discuss ongoing evolutionary efforts
	to support optimization of parallel programs in the context of existing
	compiler frameworks, and their inherent limitations for the long
	term. We then outline what a revolutionary approach will entail,
	and identify where its underlying paradigm shifts are likely to lie.
	We provide examples of past research that are likely to influence
	future directions in code optimization of parallel programs such
	as program dependence graphs, partitioning and scheduling of lightweight
	parallelism, synchronization optimizations, communication optimizations,
	transactional memory optimizations, code generation for heterogeneous
	accelerators, impact of memory models on code optimization, and general
	forms of data and computation alignment. Finally, we briefly describe
	the approach to code optimization of parallel programs being taken
	in the Habanero Multicore Software Research project at Rice University.},
  affiliation = {Rice University; Department of Computer Science, Rice University},
  author_keywords = {Code optimization; Multicore processors; Parallel programs},
  document_type = {Conference Paper},
  journal = {Proceedings of the 2008 CGO - Sixth International Symposium on Code
	Generation and Optimization},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-43449131859&partnerID=40&md5=b45425cef52bde3ff59f7df01b1de32a}
}

@ARTICLE{Savidis20071577,
  author = {Savidis, A.},
  title = {Rapidly implementing languages to compile as C++ without crafting
	a compiler},
  journal = {Software - Practice and Experience},
  year = {2007},
  volume = {37},
  pages = {1577-1620},
  number = {15},
  note = {cited By (since 1996) 1},
  abstract = {We present a heuristic implementation method for programming languages
	that is appropriate when the following requirements or conditions
	are met: (a) there is a need for very rapid development of a language
	with significant performance demands, while exploiting a comprehensive
	host language and/or library; (b) need of customized runtime execution
	environment supporting of execution tracing and visualization instruments;
	(c) the facilitation of hybrid code exists, such as mixing with the
	native language, and there is the potential for allowing multiple
	languages to be deployed concurrently in the same program. This may
	account for a wide range of domain-specific languages such as learning-oriented,
	scripting, assembly style, data manipulation, rule-based, or event
	languages. The proposed technique is presented for the C++ language,
	supporting the development of languages whose source programs compile
	as C++ code. The software architecture shifts from the tradition
	of lexical analysis, syntax-directed translation and code generation,
	and we propose a complementary, conditionally advantageous, heuristic
	development paradigm. The method has been applied to the development
	of a high-level imperative language, an assembly language and a functional
	language, which are all currently deployed for teaching purposes.
	Copyright © 2007 John Wiley & Sons, Ltd.},
  affiliation = {Institute of Computer Science, Foundation for Research and Technology
	- Hellas, Heraklion, Crete, GR-70013, Greece},
  author_keywords = {Domain-specific languages; Embedded programming languages; Rapid language
	development; Syntax emulation},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-37149019748&partnerID=40&md5=5afa588bc2f0f89ffe9863d07530b857}
}

@ARTICLE{Savikko2004427,
  author = {Savikko, V.},
  title = {Generative and incremental implementation for a scripting interface},
  journal = {Journal of Systems Architecture},
  year = {2004},
  volume = {50},
  pages = {427-439},
  number = {7},
  note = {cited By (since 1996) 0},
  abstract = {Many systems may benefit from scripting support, but the implementation
	of it is seldom trivial, especially if the system has not originally
	been developed with scripting support in mind. In this paper we describe
	a generative, incremental process for creating an intuitive Python
	interface to a large, hierarchic COM library. The approach is illuminated
	with the original, real-life case study. © 2003 Elsevier B.V. All
	rights reserved.},
  affiliation = {VTT Information Technology, P.O. Box 1206, FIN-33101 Tampere, Finland},
  author_keywords = {Generative programming; Hierarchic COM library; Incremental development;
	Python; Scripting},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-2942601322&partnerID=40&md5=f9e8da6cc9506cdc85df9c8d84fc1080}
}

@CONFERENCE{Savikko2003105,
  author = {Savikko, V.},
  title = {Generative and Incremental Approach to Scripting Support Implementation},
  year = {2003},
  volume = {1},
  pages = {105-111},
  note = {cited By (since 1996) 0},
  abstract = {Many systems may benefit from scripting support, but the implementation
	of it is seldom trivial, especially if the system has not originally
	been developed with scripting support in mind. In this paper we describe
	a generative, incremental process for creating an intuitive Python
	interface to a large, hierarchic COM library. The approach is illuminated
	with the original, real-life case study.},
  affiliation = {VTT Information Technology, P.O.Box 1206, FIN-33101 Tampere, Finland},
  author_keywords = {Generative programming; Hierarchic COM library; Incremental development;
	Python; Scripting},
  document_type = {Conference Paper},
  journal = {Proceedings of the International Conference on Software Engineering
	Research and Practise},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-1642619158&partnerID=40&md5=bc5f6234ac93e5b19d192d3f13a090fc}
}

@CONFERENCE{Sawyer2007,
  author = {Sawyer, P.a , Bencomo, N.a , Hughes, D.a , Grace, P.b , Goldsby,
	H.J.c , Cheng, B.H.C.c },
  title = {Visualizing the analysis of dynamically adaptive systems using i*
	and DSLs},
  year = {2007},
  note = {cited By (since 1996) 0},
  abstract = {Self-adaptation is emerging as a crucial enabling capability for many
	applications, particularly those deployed in dynamically changing
	environments. One key challenge posed by Dynamically Adaptive Systems
	(DASs) is the need to handle changes to the requirements und corresponding
	behavior of a DAS in response to varying environmental conditions.
	In this paper we propose a visual model-driven approach that uses
	the i* modeling language to represent goal models for the DAS requirements.
	Our approach applies a rigorous separation of concerns between the
	requirements for the DAS to operate in stable conditions and those
	that enable it to adapt at run-time to enable it to cope with changes
	in its environment. We further show how requirements derived from
	the i* modeling can be used by a domain-specific language to achieve
	requirements model-driven development. We describe our experiences
	with applying this approach to GridStix, an adaptive flood warning
	system, deployed on the River Ribble in North Yorkshire, England.
	© 2007 IEEE.},
  affiliation = {Computing Department, InfoLab21, Lancaster University, LA1 4WA, United
	Kingdom; Departement Computerwetenschappen, Katholieke Universiteit
	Leuven, B-3001 Heverlee, Belgium; Department of Computer Science
	and Engineering, Michigan State University, East Lansing, MI 48824,
	United States},
  art_number = {4473003},
  document_type = {Conference Paper},
  journal = {2nd International Workshop on Requirements Engineering Visualization,
	REV 2007},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-49749127330&partnerID=40&md5=2d4531fd1a0064baa40084162d8ab067}
}

@ARTICLE{Saxena201046,
  author = {Saxena, T., Karsai, G.},
  title = {MDE-based approach for generalizing design space exploration},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2010},
  volume = {6394 LNCS},
  pages = {46-60},
  number = {PART 1},
  note = {cited By (since 1996) 3},
  abstract = {Design Space Exploration (DSE) is the exploration of design alternatives
	before the implementation. Existing DSE frameworks are domain-specific
	where the representation, evaluation method as well as exploration
	algorithm are tightly coupled with domain-dependent assumptions.
	Although the tasks involved in DSE are similar, the inflexibility
	of the existing frameworks restricts their reuse for solving DSE
	problems from other domains. This paper presents an MDE-based approach
	for generalizing DSE techniques. The framework supports a reconfigurable
	representation of a design space, which is decoupled from exploration
	algorithm. The framework can be configured to solve DSE problems
	from different domains and enables the designer to experiment with
	different approaches to solve the same problem with minimum effort.
	The main contributions of this framework are: (1) rapid modeling
	of DSE problems, (2) reuse of previously defined artifacts, (3) multiple
	solver support and (4) a tool for scalability study. © 2010 Springer-Verlag.},
  affiliation = {Department of Electrical Engineering and Computer Science, Vanderbilt
	University, Nashville, TN 37205, United States},
  author_keywords = {Design Space Exploration; Domain-Specific Modeling Languages},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-78349273160&partnerID=40&md5=a41d21e7140df96144b8b90b39aeef6a}
}

@CONFERENCE{Schauerhuber2007569,
  author = {Schauerhuber, A.a d , Wimmer, M.a , Schwinger, W.b , Kapsammer, E.c
	, Retschitzegger, W.c },
  title = {Aspect-oriented modeling of ubiquitous Web applications: The aspectWebML
	approach},
  year = {2007},
  pages = {569-576},
  note = {cited By (since 1996) 5},
  abstract = {Ubiquitous web applications (UWA) are required to be customizable,
	meaning their services need to be adaptable towards the context of
	use, e.g., user, location, time, and device. Considering UWA's from
	a software engineering point of view, a systematic development on
	basis of models is crucial. Current web modeling languages, however,
	often disregard the crosscutting nature of customization potentially
	affecting all parts of a web application, and often mingle core and
	customization functionality. This leads to inefficient development
	processes, high maintenance overheads, and a low potential for reuse.
	We regard customization as a crosscutting concern in the sense of
	the aspect-oriented paradigm. As a proof of concept, we extend the
	prominent web modeling language WebML on basis of our reference architecture
	for aspect-oriented modeling. This allows for a clear separation
	between the core and customization functionality, and - as a spin-off
	- demonstrates how to bridge existing (domain-specific) modeling
	languages with aspect-oriented concepts. © 2007 IEEE.},
  affiliation = {Institute of Software Technologies and Interactive Systems, Vienna
	University of Technology, Austria; Department of Telecooperation,
	University of Linz, Austria; Information Systems Group, University
	of Linz, Austria; Women's Postgraduate College for Internet Technologies,
	Austria},
  art_number = {4148975},
  document_type = {Conference Paper},
  journal = {Proceedings of the International Symposium and Workshop on Engineering
	of Computer Based Systems},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-34250188501&partnerID=40&md5=cc01373ceb6e9a341f4bc2347a770bcd}
}

@CONFERENCE{Schmidmeier2007,
  author = {Schmidmeier, A.},
  title = {Aspect oriented DSLs for business process implementation},
  year = {2007},
  note = {cited By (since 1996) 0},
  abstract = {Domain specific languages (DSLs) are a very important approach to
	raise abstraction and enable an efficient communication between business
	experts and application software developers. Some DSLs could benefit
	from the application of ideas from the AOSD world. Therefore, it
	is a natural idea to enhance an existing DSL with AOP based programming
	ideas. This paper describes such an attempt. The approach has been
	successfully applied in several commercial projects. Commercially
	available DSLs in the domain of application integration, service
	orchestration and business process management have been enhanced
	with composition filters. Copyright © 2007 ACM.},
  affiliation = {AspectSoft, Lohweg 9, 91217 Hersbruck, Germany},
  art_number = {5},
  author_keywords = {AOP; Aspect oriented software development; BPEL; BPM; DSL; Enterprise
	application integration; Process engines; Workflow engines},
  document_type = {Conference Paper},
  journal = {DSAL'07: Second Workshop on Domain-Specific Aspect Languages},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-35448992116&partnerID=40&md5=d4ba0a4c8c33f69703b9dac0ce750f47}
}

@CONFERENCE{Schmidt2009,
  author = {Schmidt, A., Von Löwis, M., Polze, A.},
  title = {KStruct: Preserving consistency through C annotations},
  year = {2009},
  note = {cited By (since 1996) 0},
  abstract = {Debuggers and instrumentation tools have been proven valuable for
	understanding the inner workings of software systems. Although these
	tools are essential for various people, e.g., system administrators,
	developers, or teachers, they have one major drawback, especially
	in multi-threaded environments: They completely ignore data races.
	Within this paper, we present KStruct, a holistic approach for inspecting
	state information of a system while running. We therefore use a multi-level
	approach: First KStruct Access, our domain-specific language, can
	be used to model lock dependencies. Second, based on that model,
	we generate an access driver that dynamically attaches to the system
	under investigation and leverages that model to access state information.
	Our proposed approach can therefore improve quality in two dimensions:
	The code by making locking first-class primitives, and second the
	retrieved data is more reliable to be consistent. © 2010 ACM.},
  affiliation = {Hasso Plattner Institute, University of Potsdam, Operating Systems
	and Middleware Group, Prof.-Dr.-Helmert-Str. 2-3, 14482 Potsdam,
	Germany},
  art_number = {1745447},
  author_keywords = {consistency models; kernel data inspection; KStruct; model driven
	architectures},
  document_type = {Conference Paper},
  journal = {Proceedings of the 5th Workshop on Programming Languages and Operating
	Systems, PLOS 2009, in Conjunction with the 22nd ACM Symposium on
	Operating Systems Principles, SOSP 2009},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-77954568834&partnerID=40&md5=46aa5ddb28387ab5928e695a6311926c}
}

@ARTICLE{Schmidt20051,
  author = {Schmidt, D.C.},
  title = {Keynote address 1: Model driven development for distributed real-time
	and embedded systems},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2005},
  volume = {3713 LNCS},
  pages = {1},
  note = {cited By (since 1996) 1},
  abstract = {Despite advances in standards-based commercial-off-the-shelf (COTS)
	technologies, key challenges must be addressed before COTS software
	can be used to build mission-critical DRE systems effectively and
	productively. For example, developers of DRE systems continue to
	use ad hoc means to develop, configure, and deploy their applications
	and middleware due to the lack of formally analyzable and verifiable
	building block components. This talk will describe how Model Driven
	Development (MDD) techniques and tools can be used to specify, analyze,
	optimize, synthesize, validate, and deploy product-line architectures
	(PLAs) and standards-compliant middleware platforms that can be customized
	for the needs of next-generation DRE systems. MDD is an emerging
	paradigm that combines: - Domain-specific modeling languages (DSMLs),
	which provide programming notations that formalize the process of
	specifying application logic and quality of service (QoS)-related
	requirements in a PLA. - Metamodeling, which define type systems
	that precisely express key characteristics and constraints associated
	with DSMLs for PLAs in particular application domains, such as software
	defined radios, avionics, vehtronics, and process automation. - Model
	transformations and synthesis techniques that automate and ensure
	the consistency of software implementations with analysis information
	associated with functional and QoS requirements captured by models
	of PLA structure and behavior. This talk will compare and contrast
	various model-based approaches (e.g., MIC, MDD, MDA, etc) to developing
	PLA-based DRE systems. It will also illustrate how MDD techniques
	and tools have been successfully integrated with standards-based
	QoS-enabled component middleware to develop PLAs that significantly
	improve the quality and productivity associated with developing next-generation
	mission-critical DRE systems. Concrete examples from avionics, process
	control, software defined radios, and warehouse management systems
	will be used to illustrate key points. © Springer-Verlag Berlin Heidelberg
	2005.},
  affiliation = {Vanderbilt University, United States},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-33646178284&partnerID=40&md5=f527fa2eb975e5f3be943e9e7865b832}
}

@CONFERENCE{Schnarr2001321,
  author = {Schnarr, E.C., Hill, M.D., Larus, J.R.},
  title = {Facile: A language and compiler for high-performance processor simulators},
  year = {2001},
  pages = {321-331},
  note = {cited By (since 1996) 8},
  abstract = {Architectural simulators are essential tools for computer architecture
	and systems research and development. Simulators, however, are becoming
	frustratingly slow, because they must now model increasingly complex
	micro-architectures running realistic workloads. Previously, we developed
	a technique called fast-forwarding, which applied partial evaluation
	and memoization to improve the performance of detailed architectural
	simulations by as much as an order of magnitude. While writing a
	detailed processor simulator is difficult, implementing fast-forwarding
	is even more complex. This paper describes Facile, a domain-specific
	language for writing detailed, accurate micro-architecture simulators.
	Architectural descriptions written in Facile can be compiled, using
	partial evaluation techniques, into fast-forwarding simulators that
	achieve significant performance improvements with far less programmer
	effort. Facile and its compiler make this performance-enhancing technique
	accessible to computer architects.},
  affiliation = {QUIQ Incorporated, 25 Kessel Court, Madison, WI 53711, United States},
  author_keywords = {Memoization; Micro-architecture simulation; Out-of-orderprocessor
	simulation; Partial evaluation},
  document_type = {Conference Paper},
  journal = {Proceedings of the ACM SIGPLAN Conference on Programming Language
	Design and Implementation (PLDI)},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-0034826999&partnerID=40&md5=d53aa8b6f7ad9ce6189a57d444b2fd5c}
}

@ARTICLE{Schnarr2001,
  author = {Schnarr, E.C.a , Hill, M.D.b , Larus, J.R.c },
  title = {Facile: A language and compiler for high-performance processor simulators},
  journal = {SIGPLAN Notices (ACM Special Interest Group on Programming Languages)},
  year = {2001},
  volume = {36},
  pages = {321-331},
  number = {5},
  note = {cited By (since 1996) 2},
  abstract = {Architectural simulators are essential tools for computer architecture
	and systems research and development. Simulators, however, are becoming
	frustratingly slow, because they must now model increasingly complex
	micro-architectures running realistic workloads. Previously, we developed
	a technique called fast-forwarding, which applied partial evaluation
	and memoization to improve the performance of detailed architectural
	simulations by as much as an order of magnitude [14]. While writing
	a detailed processor simulator is difficult, implementing fast-forwarding
	is even more complex. This paper describes Facile, a domain-specific
	language for writing detailed, accurate micro-architecture simulators.
	Architectural descriptions written in Facile can be compiled, using
	partial evaluation techniques, into fast-forwarding simulators that
	achieve significant performance improvements with far less programmer
	effort. Facile and its compiler make this performance-enhancing technique
	accessible to computer architects. © 2001 ACM.},
  affiliation = {QUIQ Incorporated, 25 Kessel Court, Madison, WI 53711, United States;
	University of Wisconsin - Madison, 1210 West Dayton Street, Madison,
	WI 53706, United States; Microsoft Research, One Microsoft Way, Redmond,
	WA 98052, United States},
  author_keywords = {D.3.2 [Programming Languages]: Language Classifications - specialized
	application languages; D.3.3 [Programming Languages]: Language Contructs
	and Features - constraints, frameworks; D.3.4 [Programming Languages]:
	Processors - optimization, compilers},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-18844404933&partnerID=40&md5=e26e9c3e603f6ab4ab56dee2f6e11fc0}
}

@ARTICLE{Schoenboeck20105,
  author = {Schoenboeck, J.a , Kappel, G.a , Kusel, A.b , Retschitzegger, W.b
	, Schwinger, W.b , Wimmer, M.a },
  title = {Catch me if you can - Debugging support for model transformations},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2010},
  volume = {6002 LNCS},
  pages = {5-20},
  note = {cited By (since 1996) 0},
  abstract = {Model-Driven Engineering places models as first-class artifacts throughout
	the software lifecycle requiring the availability of proper transformation
	languages. Although numerous approaches are available, they lack
	convenient facilities for supporting debugging and understanding
	of the transformation logic. This is because execution engines operate
	on a low level of abstraction, hide the operational semantics of
	a transformation, scatter metamodels, models, transformation logic,
	and trace information across different artifacts, and provide limited
	verification support. To tackle these problems, we propose a Domain-Specific
	Language (DSL) on top of Colored Petri Nets (CPNs)-called Transformation
	Nets-for the execution and debugging of model transformations on
	a high level of abstraction. This formalism makes the afore hidden
	operational semantics explicit by providing a runtime model in terms
	of places, transitions and tokens, integrating all artifacts involved
	into a homogenous view. Moreover, the formal underpinnings of CPNs
	enable comprehensive verification of model transformations. © Springer-Verlag
	Berlin Heidelberg 2010.},
  affiliation = {Vienna University of Technology, Austria; Johannes Kepler University
	Linz, Austria},
  author_keywords = {CPN; Debugging; Model transformation; Runtime model},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-78650369922&partnerID=40&md5=4f22bff6f761dd4619bcb24bcafe023a}
}

@ARTICLE{Schultz2004244,
  author = {Schultz, U.P.},
  title = {A unification of inheritance and automatic program specialization},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2004},
  volume = {3286},
  pages = {244-265},
  note = {cited By (since 1996) 0},
  abstract = {The object-oriented style of programming facilitates program adaptation
	and enhances program genericness, but at the expense of efficiency.
	Automatic program specialization can be used to generate specialized,
	efficient implementations for specific scenarios, but requires the
	program to be structured appropriately for specialization and is
	yet another new concept for the programmer to understand and apply.
	We have unified automatic program specialization and inheritance
	into a single concept, and implemented this approach in a modified
	version of Java named JUST. When programming in JUST, inheritance
	is used to control the automatic application of program specialization
	to class members during compilation to obtain an efficient implementation.
	This paper presents the language JUST, which integrates object-oriented
	concepts, block structure, and techniques from automatic program
	specialization to provide both a generative programming language
	where object-oriented designs can be efficiently implemented and
	a simple yet powerful automatic program specializer for an object-oriented
	language. © Springer-Verlag 2004.},
  affiliation = {DAIMI, ISIS, University of Aarhus, Denmark},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-35048888939&partnerID=40&md5=052ac3d932d0a864241633f86686ac9c}
}

@ARTICLE{Schultz-Møller2009134,
  author = {Schultz-Møller, N.P., Hølmer, C., Hansen, M.R.},
  title = {Declarative business process modelling and the generation of ERP
	systems},
  journal = {Communications in Computer and Information Science},
  year = {2009},
  volume = {47},
  pages = {134-146},
  note = {cited By (since 1996) 0},
  abstract = {We present an approach to the construction of Enterprise Resource
	Planning (ERP) Systems, which is based on the Resources, Events and
	Agents (REA) ontology. This framework deals with processes involving
	exchange and flow of resources in a declarative, graphically-based
	manner describing what the major entities are rather than how they
	engage in computations. We show how to develop a domain-specific
	language on the basis of REA, and a tool which automatically can
	generate running web-applications. A main contribution is a proof-of-concept
	showing that business-domain experts can generate their own applications
	without worrying about implementation details. In order to have a
	well-defined domain-specific language, a formal model of REA has
	been developed using the specification language Object-Z and this
	led to clarifications as well as the introduction of new concepts.
	The compiler for our language is written in Objective CAML and as
	implementation platform we used Ruby on Rails. Our aim here is to
	give an overview of whole construction of a running application from
	a REA specification and to illustrate the adequacy of the development
	process. © 2009 Springer-Verlag Berlin Heidelberg.},
  affiliation = {Department of Informatics and Mathematical Modelling, Technical University
	of Denmark, 2800 Kgs., Lyngby, Denmark},
  author_keywords = {Declarative domain specific language; Enterprise Resource Planning
	systems; REA; Web-applications},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-70449403227&partnerID=40&md5=24e64d8961b8422cf01bf5230425c0e4}
}

@CONFERENCE{Schultz-Møller200812,
  author = {Schultz-Møller, N.P.a , Hølmer, C.b , Hansen, M.R.c },
  title = {Generation of ERP systems from REA specifications},
  year = {2008},
  volume = {ISDM},
  number = {ABF/-},
  pages = {12-19},
  note = {cited By (since 1996) 0},
  abstract = {We present an approach to the construction of Enterprise Resource
	Planning (ERP) Systems, which is based on the Resources, Events and
	Agents (REA) ontology. Though this framework deals with processes
	involving exchange and flow of resources, the conceptual models have
	high-level graphical representations describing what the major entities
	are rather than how they engage in computations. We show how to develop
	a declarative, domain-specific language on the basis of REA, and
	for this language we have developed a tool which automatically can
	generate running web-applications. A main contribution is a proof-of-concept
	result showing that business-domain experts can, using a declarative,
	REA-based domain-specific language, generate their own applications
	without worrying about implementation details. In order to have a
	well-defined domain-specific language, a formal model of REA has
	been developed using the specification language Object-Z. This formalization
	led to clarifications as well as the introduction of new concepts.
	The compiler for our language is written in Objective CAML and as
	implementation platform we used Ruby on Rails. The aim of this paper
	is to give an overview of whole construction of a running application
	on the basis of a REA specification.},
  affiliation = {Department of Computing, Imperial College London, 180 Queen's Gate,
	London, United Kingdom; Upsido, Kgs. Lyngby, Denmark; Department
	of Informatics and Mathematical Modelling, Technical University of
	Denmark, Kgs. Lyngby, Denmark},
  author_keywords = {Domain specific language; Enterprise resource planning systems; REA;
	Web-applications},
  document_type = {Conference Paper},
  journal = {ICSOFT 2008 - Proceedings of the 3rd International Conference on
	Software and Data Technologies},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-58049137060&partnerID=40&md5=c68df2daea059dc8eb01527f343e00f8}
}

@ARTICLE{Schulz20101,
  author = {Schulz, O., Peleska, J.},
  title = {Reliability analysis of safety-related communication architectures},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2010},
  volume = {6351 LNCS},
  pages = {1-14},
  note = {cited By (since 1996) 0},
  abstract = {In this paper we describe a novel concept for reliability analysis
	of communication architectures in safety-critical systems. This concept
	has been motivated by applications in the railway control systems
	domain, where transitions into stable safe state are usually considered
	as undesired events because they cause a severe deterioration of
	the service reliability expected by end users. We introduce a domain-specific
	language for modelling communication architectures, the protocols
	involved and the fault hypotheses about anticipated deviations of
	communication channels and possibly other components from expected
	behaviour. From such model, a generator creates mutant models associated
	with probability formulae expressing each mutant's probability of
	occurrence. Each mutant is analysed with respect to its unreliability,
	that is, whether it contains paths leading into stable safe state.
	Then the system reliability can be conservatively estimated by calculating
	an upper bound of the probability for the system to perform a transition
	into stable safe state within a given operational period. Our approach
	deliberately refrains from utilising probabilistic model checking,
	in order to avoid the state space explosions typically occurring
	when considering all possible erroneous behaviours within a single
	model. Instead, we analyse many different models, each only containing
	a restricted variant of deviations, which leads to faster evaluation
	times. In addition, several models can be evaluated in parallel in
	a distributed multi-core environment. © 2010 Springer-Verlag Berlin
	Heidelberg.},
  affiliation = {University of Bremen, Bremen 28359, Germany},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-77956585543&partnerID=40&md5=cff7ae99935ec02a5027dd155833fb91}
}

@ARTICLE{Schwerdfeger2009,
  author = {Schwerdfeger, A.C., Van Wyk, E.R.},
  title = {Verifiable composition of deterministic grammars},
  journal = {ACM SIGPLAN Notices},
  year = {2009},
  volume = {44},
  pages = {199-210},
  number = {6},
  note = {cited By (since 1996) 1},
  abstract = {There is an increasing interest in extensible languages, (domain-specific)
	language extensions, and mechanisms for their specification and implementation.
	One challenge is to develop tools that allow non-expert programmers
	to add an eclectic set of language extensions to a host language.
	We describe mechanisms for composing and analyzing concrete syntax
	specifications of a host language and extensions to it. These specifications
	consist of context-free grammars with each terminal symbol mapped
	to a regular expression, from which a slightly-modified LR parser
	and context-aware scanner are generated. Traditionally, conflicts
	are detected when a parser is generated from the composed grammar,
	but this comes too late since it is the non-expert programmer directing
	the composition of independently developed extensions with the host
	language. The primary contribution of this paper is a modular analysis
	that is performed independently by each extension designer on her
	extension (composed alone with the host language). If each extension
	passes this modular analysis, then the language composed later by
	the programmer will compile with no conflicts or lexical ambiguities.
	Thus, extension writers can verify that their extension will safely
	compose with others and, if not, fix the specification so that it
	will. This is possible due to the context-aware scanner's lexical
	disambiguation and a set of reasonable restrictions limiting the
	constructs that can be introduced by an extension. The restrictions
	ensure that the parse table states can be partitioned so that each
	state can be attributed to the host language or a single extension.
	Copyright © 2009 ACM.},
  affiliation = {Department of Computer Science and Engineering, University of Minnesota,
	Minneapolis, MN},
  author_keywords = {Context-aware scanning; Extensible languages; Grammar composition;
	Language composition; LR parsing},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-67650802341&partnerID=40&md5=7460aac9bb8d485c3c21d2598152e9f1}
}

@CONFERENCE{Schwerdfeger2009199,
  author = {Schwerdfeger, A.C., Van Wyk, E.R.},
  title = {Verifiable composition of deterministic grammars},
  year = {2009},
  pages = {199-210},
  note = {cited By (since 1996) 4},
  abstract = {There is an increasing interest in extensible languages, (domain-specific)
	language extensions, and mechanisms for their specification and implementation.
	One challenge is to develop tools that allow non-expert programmers
	to add an eclectic set of language extensions to a host language.
	We describe mechanisms for composing and analyzing concrete syntax
	specifications of a host language and extensions to it. These specifications
	consist of context-free grammars with each terminal symbol mapped
	to a regular expression, from which a slightly-modified LR parser
	and context-aware scanner are generated. Traditionally, conflicts
	are detected when a parser is generated from the composed grammar,
	but this comes too late since it is the non-expert programmer directing
	the composition of independently developed extensions with the host
	language. The primary contribution of this paper is a modular analysis
	that is performed independently by each extension designer on her
	extension (composed alone with the host language). If each extension
	passes this modular analysis, then the language composed later by
	the programmer will compile with no conflicts or lexical ambiguities.
	Thus, extension writers can verify that their extension will safely
	compose with others and, if not, fix the specification so that it
	will. This is possible due to the context-aware scanner's lexical
	disambiguation and a set of reasonable restrictions limiting the
	constructs that can be introduced by an extension. The restrictions
	ensure that the parse table states can be partitioned so that each
	state can be attributed to the host language or a single extension.
	Copyright © 2009 ACM.},
  affiliation = {Department of Computer Science and Engineering, University of Minnesota,
	Minneapolis, MN, United States},
  author_keywords = {Context-aware scanning; Extensible languages; Grammar composition;
	Language composition; LR parsing},
  document_type = {Conference Paper},
  journal = {Proceedings of the ACM SIGPLAN Conference on Programming Language
	Design and Implementation (PLDI)},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-70450228505&partnerID=40&md5=bf0dd08c3690803dd4d31107cb428006}
}

@CONFERENCE{Schätz2011454,
  author = {Schätz, B.},
  title = {From solution to problem spaces: Formal methods in the context of
	model-based development and domain-specific languages},
  year = {2011},
  pages = {454-455},
  note = {cited By (since 1996) 0},
  abstract = {With the increased use of model-based techniques and the provision
	of domain-specific languages, the focus of the development process
	is shifting from the implementation to the analysis and the design
	phase. With this shift from the generalpurpose, technical-oriented
	solution space to the application-specific, domain-oriented problem
	space, new possibilities of application open up for rigorous engineering
	techniques, both on the analysis and on the synthesis side of applications.
	© 2011 IEEE.},
  affiliation = {Fortiss GmbH, Guerickestr. 25, 80805 München, Germany},
  art_number = {6032381},
  document_type = {Conference Paper},
  journal = {Proceedings - International Computer Software and Applications Conference},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-80054998859&partnerID=40&md5=77f28cba220b99405a07bee8887245b6}
}

@CONFERENCE{Sculthorpe2009,
  author = {Sculthorpe, N., Nilsson, H.},
  title = {Safe functional reactive programming through dependent types},
  year = {2009},
  pages = {23-34},
  note = {cited By (since 1996) 1},
  abstract = {Functional Reactive Programming (FRP) is an approach to reactive programming
	where systems are structured as networks of functions operating on
	signals. FRP is based on the synchronous dataflow paradigm and supports
	both continuous-time and discrete-time signals (hybrid systems).What
	sets FRP apart from most other languages for similar applications
	is its support for systems with dynamic structure and for higher-order
	reactive constructs. Statically guaranteeing correctness properties
	of programs is an attractive proposition. This is true in particular
	for typical application domains for reactive programming such as
	embedded systems. To that end, many existing reactive languages have
	type systems or other static checks that guarantee domain-specific
	properties, such as feedback loops always being well-formed. However,
	they are limited in their capabilities to support dynamism and higher-order
	data-flow compared with FRP. Thus, the onus of ensuring such properties
	of FRP programs has so far been on the programmer as established
	static techniques do not suffice. In this paper, we show how dependent
	types allow this concern to be addressed. We present an implementation
	of FRP embedded in the dependently-typed language Agda, leveraging
	the type system of the host language to craft a domain-specific (dependent)
	type system for FRP. The implementation constitutes a discrete, operational
	semantics of FRP, and as it passes the Agda type, coverage, and termination
	checks, we know the operational semantics is total, which means our
	type system is safe. Copyright © 2009 ACM.},
  affiliation = {School of Computer Science, University of Nottingham, United Kingdom},
  author_keywords = {Dependent types; Domain-specific languages; Dsels; Frp; Functional
	programming; Reactive programming; Synchronous data-flow},
  document_type = {Conference Paper},
  journal = {Proceedings of the ACM SIGPLAN International Conference on Functional
	Programming, ICFP},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-70450286358&partnerID=40&md5=d04ab703956e8e3ee43682e3a25c666b}
}

@ARTICLE{Sculthorpe200923,
  author = {Sculthorpe, N., Nilsson, H.},
  title = {Safe functional reactive programming through dependent types},
  journal = {ACM SIGPLAN Notices},
  year = {2009},
  volume = {44},
  pages = {23-34},
  number = {9},
  note = {cited By (since 1996) 0},
  abstract = {Functional Reactive Programming (FRP) is an approach to reactive programming
	where systems are structured as networks of functions operating on
	signals. FRP is based on the synchronous dataflow paradigm and supports
	both continuous-time and discrete-time signals (hybrid systems).What
	sets FRP apart from most other languages for similar applications
	is its support for systems with dynamic structure and for higher-order
	reactive constructs. Statically guaranteeing correctness properties
	of programs is an attractive proposition. This is true in particular
	for typical application domains for reactive programming such as
	embedded systems. To that end, many existing reactive languages have
	type systems or other static checks that guarantee domain-specific
	properties, such as feedback loops always being well-formed. However,
	they are limited in their capabilities to support dynamism and higher-order
	data-flow compared with FRP. Thus, the onus of ensuring such properties
	of FRP programs has so far been on the programmer as established
	static techniques do not suffice. In this paper, we show how dependent
	types allow this concern to be addressed. We present an implementation
	of FRP embedded in the dependently-typed language Agda, leveraging
	the type system of the host language to craft a domain-specific (dependent)
	type system for FRP. The implementation constitutes a discrete, operational
	semantics of FRP, and as it passes the Agda type, coverage, and termination
	checks, we know the operational semantics is total, which means our
	type system is safe. © 2009 ACM.},
  affiliation = {School of Computer Science, University of Nottingham, Nottingham,
	United Kingdom},
  author_keywords = {Dependent types; Domain-specific languages; DSELS; FRP; Functional
	programming; Reactive programming; Synchronous data-flow},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-70449116371&partnerID=40&md5=18a8a560e6f6485df2b827fb66104571}
}

@ARTICLE{Seefried2004186,
  author = {Seefried, S., Chakravarty, M., Keller, G.},
  title = {Optimising embedded DSLs using Template Haskell},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2004},
  volume = {3286},
  pages = {186-205},
  note = {cited By (since 1996) 1},
  abstract = {Embedded domain specific languages (EDSLs) provide a specialised language
	for a particular application area while harnessing the infrastructure
	of an existing general purpose programming language. The reduction
	in implementation costs that results from this approach comes at
	a price: the EDSL often compiles to inefficient code since the host
	language's compiler only optimises at the level of host language
	constructs. The paper presents an approach to solving this problem
	based on compile-time meta-programming which retains the simplicity
	of the embedded approach. We use PanTHeon, our implementation of
	an existing EDSL for image synthesis to demonstrate the benefits
	and drawbacks of this approach. Furthermore, we suggest potential
	improvements to Template Haskell, the meta-programming framework
	we are using, which would greatly improve its applicability to this
	kind of task. © Springer-Verlag 2004.},
  affiliation = {PLC Research Group, University of New South Wales, Sydney, National
	ICT Australia},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-35048823325&partnerID=40&md5=cd3aba790f48fd8860261cc01eef5f49}
}

@ARTICLE{Seehusen2011152,
  author = {Seehusen, F., Stølen, K.},
  title = {An evaluation of the Graphical Modeling Framework (GMF) based on
	the development of the CORAS tool},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2011},
  volume = {6707 LNCS},
  pages = {152-166},
  note = {cited By (since 1996) 0},
  abstract = {We present an evaluation of the Graphical Modeling Framework (GMF)
	based on our experiences in developing an editor for the risk modeling
	language CORAS using GMF. Our main hypothesis is that GMF shortens
	development time and results in more reliable and maintainable systems
	than alternative approaches which are not based on code generation.
	We conclude that the hypothesis is true, but that the answer is not
	as clear cut as we initially believed, and that there is still a
	large potential for improvement. © 2011 Springer-Verlag.},
  affiliation = {SINTEF Information and Communication Technology, Norway},
  author_keywords = {Domain Specific Languages; Evaluation; GMF; Model-Driven Development},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-79960241683&partnerID=40&md5=365f26dd455beecddb4f42723232e274}
}

@CONFERENCE{Selic20072,
  author = {Selic, B.},
  title = {A systematic approach to domain-specific language design using UML},
  year = {2007},
  pages = {2-9},
  note = {cited By (since 1996) 22},
  abstract = {UML includes special extensibility mechanisms, which are used to define
	domain-specific modeling languages that are based on UML. These mechanisms
	have been significantly improved in the latest versions of UML. Unfortunately,
	there is currently a dearth of published material on how to best
	exploit these capabilities and, consequently, many UML profiles are
	either invalid or of poor quality. In this paper, we first provide
	an overview of the new extensibility mechanisms of UML 2.1 and then
	describe a method for defining profiles that greatly increases the
	likelihood of producing technically correct quality UML profiles.
	© 2007 IEEE.},
  affiliation = {IBM Canada},
  art_number = {4208820},
  document_type = {Conference Paper},
  journal = {Proceedings - 10th IEEE International Symposium on Object and Component-Oriented
	Real-Time Distributed Computing, ISORC 2007},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-36348949572&partnerID=40&md5=c6e98bd3401ba5856cd6235cb5301ef7}
}

@ARTICLE{Sen2008259,
  author = {Sen, S.a b , Baudry, B.a , Vangheluwe, H.b },
  title = {Domain-specific model editors with model completion},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2008},
  volume = {5002 LNCS},
  pages = {259-270},
  note = {cited By (since 1996) 1},
  abstract = {Today, integrated development environments such as Eclipse allow users
	to write programs quickly by presenting a set of recommendations
	for code completion. Similarly, word processing tools such as Microsoft
	Word present corrections for grammatical errors in sentences. Both
	of these existing systems use a set of constraints expressed in the
	form of a grammar to restrict/correct the user. Taking this idea
	further, in this paper we present an integrated software system capable
	of generating recommendations for model completion of partial models
	built in arbitrary domain specific model editors. We synthesize the
	model editor equipped with automatic completion from a modelling
	language's declarative specification consisting of a meta-model and
	constraints on it along with a visual syntax. The automatic completion
	feature is powered by a Prolog engine whose input is a constraint
	logic program derived from some models. The input logic program is
	obtained by a model transformation from models in multiple languages:
	the meta-model (as a class diagram), constraints on it (as constraint
	logic clauses), and a partial model (in the domain specific language).
	The Prolog engine solves the generated logic program and the solution(if
	there is one) is returned to the model editor as a set of recommendations
	for properties of the partial model. We incorporate automatic completion
	in the generative tool AToM 3 and use SWI-Prolog for constraint representation
	and satisfaction. We present examples using an illustrative visual
	language of Finite State Machines. © 2008 Springer-Verlag Berlin
	Heidelberg.},
  affiliation = {IRISA, INRIA, Campus universitaire de Beaulieu, Rennes, France; School
	of Computer Science, McGill University, Montreal, QC, Canada},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-47749145787&partnerID=40&md5=55a53742f63054454daf83874853bf7a}
}

@ARTICLE{Sen2010109,
  author = {Sen, S.a , Baudry, B.a , Vangheluwe, H.b },
  title = {Towards domain-specific model editors with automatic model completion},
  journal = {Simulation},
  year = {2010},
  volume = {86},
  pages = {109-126},
  number = {2},
  note = {cited By (since 1996) 5},
  abstract = {Integrated development environments such as Eclipse allow users to
	write programs quickly by presenting a set of recommendations for
	code completion. Similarly, word processing tools such as Microsoft
	Word present corrections for grammatical errors in sentences. Both
	of these existing structure editors use a set of constraints expressed
	in the form of a natural language grammar to restrict/correct the
	user ( syntax-directed editing) or formal grammar (language-directed
	editing ) to aid document completion. Taking this idea further, in
	this paper we present an integrated software system capable of generating
	recommendations for model completion of partial models built in editors
	for domain-specific modeling languages. We present a methodology
	to synthesize model editors equipped with automatic completion from
	a modeling languages declarative specification consisting of a meta-model
	with a visual syntax. This meta-model directed completion feature
	is powered by a first-order relational logic engine implemented in
	ALLOY. We incorporate automatic completion in the generative tool
	AToM3. We use the finite state machines modeling language as a concise
	running example. Our approach leverages a correct by construction
	philosophy that renders subsequent simulation of models considerably
	less error-prone. © 2010 The Society for Modeling and Simulation
	International.},
  affiliation = {INRIA Rennes Bretagne-Atlantique, Campus Universitaire de Beaulieu,
	Rennes 35042, France; School of Computer Science, McGill University,
	McConnell Engineering Bldg., 3480 University Street, Montreal, QC,
	Canada},
  author_keywords = {Alloy; AToM3; Domain-specific modeling language; Meta-model directed
	editing; Model completion; Partial model; Structure editor},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-76349083874&partnerID=40&md5=8ea5a9b57c0de1d153fb0b3db0be5473}
}

@CONFERENCE{Sendall2004110,
  author = {Sendall, S.},
  title = {Domain-driven software development - A world of transformations},
  year = {2004},
  pages = {110-112},
  note = {cited By (since 1996) 0},
  abstract = {The techniques for improving current software development practice,
	which relate to the theme of domain-driven software development are
	discussed. Domain-driven software development is concerned with making
	use of languages that better capture the problem by using abstractions
	that are more familiar to experts in the domain. The principles of
	abstraction, separation of concerns and problem decomposition are
	essential in providing in intutive and manageable domain-specific
	languages. The practice of software modeling has become a significant
	way of applying these principles to software development.},
  affiliation = {IBM Research, Zurich Research Laboratory, CH-8803 Rüschlikon, Switzerland},
  document_type = {Conference Paper},
  journal = {Proceedings of the International Workshop on Rapid System Prototyping},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-4944251247&partnerID=40&md5=7d4616f451f9fac7c5b3e4290d90c858}
}

@ARTICLE{Serot2008154,
  author = {Serot, J.a , Falcou, J.b },
  title = {Functional meta-programming for parallel skeletons},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2008},
  volume = {5101 LNCS},
  pages = {154-163},
  number = {PART 1},
  note = {cited By (since 1996) 0},
  abstract = {We describe the implementation in MetaOcaml of a small domain specific
	language for skeleton-based parallel programming. We show how the
	meta-programming facilities offered by this language make it possible
	to virtually eliminate the run-time overhead for the resulting programs,
	compared to a hand-crafted, low-level implementation. © 2008 Springer-Verlag
	Berlin Heidelberg.},
  affiliation = {LASMEA, UMR 66O2 CNRS/U. Blaise Pascal, Campus des Cézeaux, F-63177
	Aubière, France; IEF, Université Paris-Sud, F-91405 Orsay Cedex,
	France},
  author_keywords = {Meta-programming; Parallel programming; Skeletons},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-47749086291&partnerID=40&md5=38d445d755c8024569810150df81f154}
}

@CONFERENCE{Sethy2006382,
  author = {Sethy, A., Georgiou, P.G., Narayanan, S.},
  title = {Text data acquisition for domain-specific language models},
  year = {2006},
  pages = {382-389},
  note = {cited By (since 1996) 5},
  abstract = {The language modeling community is showing a growing interest in using
	large collections of text mined from the World Wide Web (WWW) to
	supplement sparse in-domain text resources. However, in most cases
	the style and content of the text harvested from these corpora differs
	significantly from the specific nature of these domains. In this
	paper we present a relative entropy (r.e.) based method to select
	relevant subsets of sentences whose distribution in an n-gram sense
	matches the domain of interest. Using simulations, we provide an
	analysis of how the proposed scheme outperforms filtering techniques
	proposed in recent language modeling literature on mining text from
	the web. A comparative study is presented using a text collection
	of over 800M words collected from the WWW. Experimental results show
	that by using the proposed subset selection scheme we can get performance
	improvement in both Word Error Rate (WER) and Perplexity (PPL) over
	the models built from the entire collection by using just 10% of
	the data. Improvements in data selection also translated to a significant
	reduction in the vocabulary size as well as the number of estimated
	parameters in the adapted language model. © 2006 Association for
	Computational Linguistics.},
  affiliation = {Department of Electrical Engineering-Systems, Viterbi School of Engineering,
	University of Southern California, United States},
  document_type = {Conference Paper},
  journal = {COLING/ACL 2006 - EMNLP 2006: 2006 Conference on Empirical Methods
	in Natural Language Processing, Proceedings of the Conference},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-80053375672&partnerID=40&md5=7e6ce87567ea13e8019c5420ec78fe8d}
}

@CONFERENCE{Shah2004332,
  author = {Shah, B., Dennison, R., Gray, J.},
  title = {A model-driven approach for generating embedded robot navigation
	control software},
  year = {2004},
  pages = {332-335},
  note = {cited By (since 1996) 1},
  abstract = {Real-time embedded systems are time-critical systems that are hard
	to implement as compared to traditional commercial software, due
	to the large number of conflicting requirements. This paper describes
	undergraduate research into the use of advanced modeling techniques
	to improve the development of embedded systems. In particular, we
	have developed domain-specific models that describe the configuration
	and layout of a hazardous environment, which is symbolically represented
	as an area contaminated with hazardous materials (e.g., land mines),
	as well as objects to be rescued (e.g., babies). The motivation is
	to model a disaster site that is too dangerous for humans to search
	for survivors. From the visual model specifications, model interpreters
	will generate the embedded code that will control two LEGO Mindstorms
	robots. The mission of the robots is to traverse the hostile terrain
	and rescue the surviving babies. The modeling environment and generative
	techniques are described. Copyright 2004 ACM.},
  affiliation = {Department of Computer and Information Sciences, University of Alabama
	at Birmingham, Birmingham, AL 35294, United States},
  author_keywords = {Generative programming; LEGO mindstorms; Model integrated computing},
  document_type = {Conference Paper},
  journal = {Proceedings of the Annual Southeast Conference},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-77953085312&partnerID=40&md5=b9ba3008eb7858b7ec3ba13c0b8c9043}
}

@ARTICLE{Shah200445,
  author = {Shah, N., Plishker, W., Ravindran, K., Keutzer, K.},
  title = {NP-click: A productive software development approach for network
	processors},
  journal = {IEEE Micro},
  year = {2004},
  volume = {24},
  pages = {45-54},
  number = {5},
  note = {cited By (since 1996) 15},
  abstract = {Ideally, program processors are programmed using networking-specific
	languages. However, there is currently a large gap between these
	languages and the complex programmable architecures used for implementation.
	To close the implementation gap, the NP-Click programming model is
	proposed for the Intel IXP1200. NP-Clik is evaluated by implementing
	two applications on the Intel IXP1200 with NP-click, using two approaches:
	manual task allocation and IXP-C. For each application, the performance
	and development process of these approaches are compared. Analysis
	of the data reveals that NP-Click delivers large productivity gain
	at a slight performance expense.},
  affiliation = {EECS Department, University of California, 211 Cory Hall, Berkeley,
	CA, United States},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-8844226032&partnerID=40&md5=70c8231fbaff1fb7290bb03ae3640dc1}
}

@CONFERENCE{Shani20101,
  author = {Shani, U., Sela, A.},
  title = {Integrating domain-specific programming into software design},
  year = {2010},
  pages = {1-6},
  note = {cited By (since 1996) 0},
  abstract = {Domain-specific languages (DSLs) have recently become a focus of attention
	in the software engineering community. We look at domain-specific
	modeling (DSM) methods that drive modeling languages for specific
	domains with a strong emphasis on visual tools and suggest a method
	for integrating them into common software design methodologies. We
	demonstrate a practical approach, whereby components of software
	are designed to be externalized as specific domain-oriented tasks.
	The logic in such tasks is intended to be developed by skilled personnel,
	different from those required to implement the main application.
	Furthermore, the application will become adaptable to a large class
	of solutions that do not require new version releases when business
	logic changes. Unlike application customization via configuration
	parameters, the logic implemented in DSL languages requires a meaningful
	imperative expressive power. Our method starts with the common software
	design methodologies based on UML and uses the Eclipse Modeling Framework
	(EMF) tools to externalize a selected subset of the design. © 2010
	IEEE.},
  affiliation = {IBM Research - Haifa, Haifa University, Mount Carmel, CO 31905, Israel},
  art_number = {5532548},
  author_keywords = {Domain specific languages; EMF; Imperative languages; Language modeling;
	Software engineering methodologies},
  document_type = {Conference Paper},
  journal = {SwSTE2010: IEEE International Conference on Software Science, Technology,
	and Engineering},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-77956424851&partnerID=40&md5=0071d722d2cf180781182b27351a1f85}
}

@CONFERENCE{Shani200852,
  author = {Shani, U., Sela, A.},
  title = {Software design using UML for empowering end-users with an external
	Domain Specific Language},
  year = {2008},
  pages = {52-55},
  note = {cited By (since 1996) 0},
  abstract = {Domain Specific Languages (DSL) also known as "small languages" lack
	the power of a general purpose language (GPL), but are very productive
	for the purpose they are designed. While "internal" DSLs require
	and rely on the use of a hosting GPL, "external" DSLs are independent
	of a GPL and are thus more suitable for the non-programmer - but
	domain expert - end-user. Empowering this end-user via DSLs is our
	prime goal as software designers and architects. Our product will
	be stronger since much of the final tuning of the application can
	be done by the end-user and will reduce the number of software revisions
	that require stringent GPL software testing and validations. As software
	engineers, the design of a DSL as part of our product should fit
	into the tools of the trade of software development. We adopt UML
	for this purpose and propose that the design of DSL can be embedded
	as an extension of the traditional software modeling and design tools.
	In this paper we present firstly a view of software development process
	in which DSLs are an integral part, and than how we use UML to design
	a DSL which, via empowering a domain expert end-user, achieves challenging
	software delivery requirements with good stability and excellent
	performance. Copyright 2008 ACM.},
  affiliation = {IBM Haifa Research Lab., Haifa University, Mount Carmel, Haifa, 31905,
	Israel},
  art_number = {1370859},
  author_keywords = {Domain Specific Languages; Eclipse; EMF; IDE; Software development},
  document_type = {Conference Paper},
  journal = {Proceedings - International Conference on Software Engineering},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-57049151430&partnerID=40&md5=d02996319657a65adc4944a6b771e38f}
}

@CONFERENCE{Shani2006698,
  author = {Shani, U., Sela, A.},
  title = {OO design methodology of a DSL using EMF: (Demonstration for the
	telco revenue assurance domain)},
  year = {2006},
  volume = {2006},
  pages = {698-699},
  note = {cited By (since 1996) 1},
  abstract = {The software engineering community has taken a great interest in using
	domain-specific languages (DSLs) [1] to improve the productivity
	of software development. We demonstrate the design of a DSL as a
	variant of object-oriented development by applying UML[2] via the
	Eclipse Modeling Framework (EMF) [3] [4], exposing significant software
	functionality to the nonprogrammer domain experts.},
  affiliation = {IBM Haifa Research Lab., Haifa University, Mount Carmel, Haifa, 31905,
	Israel},
  art_number = {1176680},
  author_keywords = {Domain specific languages; Eclipse; EMF; IDE; Software development},
  document_type = {Conference Paper},
  journal = {Proceedings of the Conference on Object-Oriented Programming Systems,
	Languages, and Applications, OOPSLA},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-34248328755&partnerID=40&md5=5943b992b492b4eda8af8e6baf51aac8}
}

@ARTICLE{Sheard200081,
  author = {Sheard, T., Benaissa, Z.-E.-A., Pasalic, E.},
  title = {DSL implementation using staging and monads},
  journal = {SIGPLAN Notices (ACM Special Interest Group on Programming Languages)},
  year = {2000},
  volume = {35},
  pages = {81-94},
  number = {1},
  note = {cited By (since 1996) 0},
  abstract = {The impact of Domain Specific Languages (DSLs) on software design
	is considerable. They allow programs to be more concise than equivalent
	programs written in a high-level programming languages. They relieve
	programmers from making decisions about data-structure and algorithm
	design, and thus allows solutions to be constructed quickly. Because
	DSL's are at a higher level of abstraction they are easier to maintain
	and reason about than equivalent programs written in a high-level
	language, and perhaps most importantly they can be written by domain
	experts rather than programmers. The problem is that DSL implementation
	is costly and prone to errors, and that high level approaches to
	DSL implementation often produce inefficient systems. By using two
	new programming language mechanisms, program staging and monadic
	abstraction, we can lower the cost of DSL implementations by allowing
	reuse at many levels. These mechanisms provide the expressive power
	that allows the construction of many compiler components as reusable
	libraries, provide a direct link between the semantics and the low-level
	implementation, and provide the structure necessary to reason about
	the implementation. © 2000 ACM.},
  affiliation = {Pacific Software Research Center, Oregon Graduate Institute, P.O.
	Box 91000, Portland, OR 97291-1000, United States},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-17644417874&partnerID=40&md5=450f0adbcfc9e6c2db90d599f8727887}
}

@CONFERENCE{Shonle200328,
  author = {Shonle, M.a , Lieberherr, K.b , Shah, A.b },
  title = {XAspects: An extensible system for domain-specific aspect languages},
  year = {2003},
  pages = {28-37},
  note = {cited By (since 1996) 22},
  abstract = {Current general aspect-oriented programming solutions fall short of
	helping the problem of separation of concerns for several concern
	domains. Because of this limitation good solutions for these concern
	domains do not get used and the opportunity to benefit from separation
	of these concerns is missed. By using XAspects, a plug-in mechanism
	for domain-specific aspect languages, separation of concerns can
	be achieved at a level beyond what is possible for objectoriented
	programming languages. As a result, XAspects allows for certain domain-specific
	solutions to be used as easily as a new language feature.},
  affiliation = {Department of Computer Science and Engineering, UC San Diego, San
	Diego, CA 92093-0114, United States; College of Computer and Information
	Science, Northeastern University, Boston, MA 02115, United States},
  author_keywords = {Aspect-oriented programming; Domain-specific languages; Generative
	programming; Language extensions},
  document_type = {Conference Paper},
  journal = {Proceedings of the Conference on Object-Oriented Programming Systems,
	Languages, and Applications, OOPSLA},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-79951602751&partnerID=40&md5=e8d1b5cc1b365d9222517331e9c939be}
}

@ARTICLE{Shtelma2009622,
  author = {Shtelma, M., Cartsburg, M., Milanovic, N.},
  title = {Executable domain specific language for message-based system integration},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2009},
  volume = {5795 LNCS},
  pages = {622-626},
  note = {cited By (since 1996) 3},
  abstract = {Heterogeneous IT-systems rarely rely on a common data format and structure,
	so in order to integrate them, the corresponding data/message transformations
	must be developed. Transformations may also be required by the business
	logic. We present a platform-independent approach for message transformation
	specification, in form of a system integration DSL, and discuss approaches
	for making it executable. © 2009 Springer Berlin Heidelberg.},
  affiliation = {Technische Universität Berlin, Germany},
  author_keywords = {Domain specific language; Model execution; System integration},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-77249153359&partnerID=40&md5=cfab99786e0c15e3203bda474e39ba94}
}

@ARTICLE{Sierra2008112,
  author = {Sierra, J.-L., Fernández-Manjón, B., Fernández-Valmayor, A.},
  title = {A language-driven approach for the design of interactive applications},
  journal = {Interacting with Computers},
  year = {2008},
  volume = {20},
  pages = {112-127},
  number = {1},
  note = {cited By (since 1996) 2},
  abstract = {In this paper we propose a language-driven approach for the high-level
	design of interactive applications architected according to the model-view-controller
	pattern. The approach is especially well-suited for applications
	that incorporate contents with sophisticated structures, and whose
	interactive behavior is driven by these structures. In our approach
	we characterize the structure of the contents stored in the applications'
	models with suitable domain-specific languages. Then we characterize
	the interactive behavior of these applications by assigning suitable
	operational semantics to these languages. The resulting designs are
	amenable to support rapid prototyping, exploration and early discovery
	of application features, systematic implementation using standard
	web-based technologies, and rational collaboration processes between
	domain experts and developers during production and maintenance.
	We exemplify the approach in the e-learning domain with a system
	for the production of Socratic tutors. © 2007 Elsevier B.V. All rights
	reserved.},
  affiliation = {Dpto. Ingeniería del Software e Inteligencia Artificial, Fac. Informática,
	Universidad Complutense, 28040 Madrid, Spain},
  author_keywords = {Document-oriented approach; Domain-specific language; e-Learning;
	Language-driven development; Model-view-controller},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-37249015468&partnerID=40&md5=6d68bf3b4815aa571401c6431d536085}
}

@ARTICLE{Sierra2008520,
  author = {Sierra, J.-L., Fernández-Manjón, B., Fernández-Valmayor, A.},
  title = {Language-driven development of Web-based learning applications},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2008},
  volume = {4823 LNCS},
  pages = {520-531},
  note = {cited By (since 1996) 0},
  abstract = {In this paper we propose a language-driven approach for the high-level
	design of web-based learning applications. In our approach we define
	a domain-specific language that characterizes the key application
	aspects. Then we assign a suitable operational semantics to this
	language, and we keep it independent of low-level implementation
	details such as interaction / presentation or database updating.
	The resulting design can be easily implemented using the model-view-controller
	pattern that is very well supported by standard implementation technologies.
	In addition, these language-driven designs also allow for rapid prototyping,
	exploration and early discovery of application features, as well
	as for rational collaboration processes between instructors and developers.
	We exemplify our approach with a Socratic Tutoring System. © 2008
	Springer-Verlag Berlin Heidelberg.},
  affiliation = {Dpto. Ingeniería del Software e Inteligencia Artificial., Fac. Informática,
	Universidad Complutense de Madrid, C/ Profesor José García Santesmases
	s/n, 28040 Madrid, Spain},
  author_keywords = {Development of web-based learning applications; Domain-specific languages
	document-oriented approach; Language-driven development; Socratic
	tutors},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-41549152447&partnerID=40&md5=20ae0f860c98e57837c3db8fb3af4d18}
}

@ARTICLE{Sierra2003230,
  author = {Sierra, J.L., Fernández-Valmayor, A., Fernández-Manjón, B., Navarro,
	A.},
  title = {Building applications with domain-specific markup languages: A systematic
	approach to the development of XML-based software},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2003},
  volume = {2722},
  pages = {230-240},
  note = {cited By (since 1996) 0},
  abstract = {This paper, presents ADDS, a systematic approach to sofware development
	using Domain-Specific Languages (DSLs) and markup technologies. XML
	is used as a common descriptive framework for DSLs formulation, obtaining
	Domain Specific Markup Languages (DSMLs). According to ADDS, the
	construction of applications in a domain starts with the provision
	of suitable DSMLs. Then, the applications in such a domain are described
	by means of sets of structured documents conforming these DSMLs.
	Finally, the application is produced by processing this documentation
	according to an operationalization model called OADDS. Hence ADDS
	provides a systematic approach to software development based on the
	processing of XML documentation that can be used in a great variety
	of domains. © Springer-Verlag Berlin Heidelberg 2003.},
  affiliation = {Dpto. Sistemas Informáticos y Programación, Fac. Informática, Universidad
	Complutense, C/ Juan del Rosal no 8, 28040. Madrid, Spain},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-35248830690&partnerID=40&md5=47356b989f1cd7cdfd4572a386a3bd90}
}

@ARTICLE{Sikri2011411,
  author = {Sikri, M.},
  title = {Design of domain specific language for web services QoS constraints
	definition},
  journal = {Communications in Computer and Information Science},
  year = {2011},
  volume = {147 CCIS},
  pages = {411-416},
  note = {cited By (since 1996) 0},
  abstract = {Semantic Webservices (SWS) has raised interest in mechanisms for Ontological
	representation of Web Services. A number of mechanisms most notably
	WSMO and OWL-S are being developed to represent the same. An important
	area in description of Web Services is the QoS characterization and
	discovery which is the focus of research for this paper. A Domain
	Specific language is being proposed for definition of observable
	QoS characteristics and conditions. The syntax of this proposed language
	is being kept closer to WSML considering it the standard modeling
	language. © 2011 Springer-Verlag.},
  affiliation = {Cisco Systems India Pvt Ltd., SEZ Unit, Cesssna Business Park, Bangalore,
	Karnataka 560103, India},
  author_keywords = {QoS; SOA; Web Services; WSML},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-79955098305&partnerID=40&md5=5f3aaefdbc0992497f53dcaff0087b15}
}

@ARTICLE{Silva2008118,
  author = {Silva, F.a , Pan, J.Z.b , Assmann, U.c , Herinksson, J.c },
  title = {First workshop on transforming and weaving ontologies in model driven
	engineering (TWOMDE 2008)},
  journal = {SIGMOD Record},
  year = {2008},
  volume = {37},
  pages = {118-120},
  number = {4},
  note = {cited By (since 1996) 0},
  abstract = {The First International Workshop on Transforming and Weaving Ontologies
	in Model Driven Engineering (TWOMDE 2008), affiliated with the 11th
	International Conference on Model Driven Engineering Languages and
	Systems (MoD-ELS2008), brought together researchers and practitioners
	from the modeling community with experience or interest in MDE and
	in Knowledge Representation to discuss about: (1) how the scientific
	and technical results around ontologies, ontology languages and their
	corresponding reasoning technologies can be used fruitfully in MDE;
	(2) the role of ontologies in supporting model transformation; (3)
	and how ontologies can improve designing domain specific languages.},
  affiliation = {Parreiras, ISWeb, University of Koblenz-Landau, Universitatsstr. 1,
	56070 Koblenz, Germany; Department of Computing Science, University
	of Aberdeen, Aberdeen AB24 3UE; Institute for Software- and Multimedia-Technology,
	TU Dresden, D-01062 Dresden, Germany},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-63749113203&partnerID=40&md5=33dea9931a9655e6e709e5bfb00fbb86}
}

@ARTICLE{Simon2010529,
  author = {Simon, B., Goldschmidt, B.},
  title = {A human readable platform independent domain specific language for
	WSDL},
  journal = {Communications in Computer and Information Science},
  year = {2010},
  volume = {87 CCIS},
  pages = {529-536},
  number = {PART 1},
  note = {cited By (since 1996) 0},
  abstract = {The basic building blocks of SOA systems are web services. WSDL, the
	standard language for defining web services, is far too complex and
	redundant to be efficiently handled by humans. Existing solutions
	use either graphical representations (UML, etc.), which are again
	inefficient in large scale projects, or define web services in the
	implementation's native language, which is a bottom-up approach risking
	interface stability. Both lack support for concepts like conditions,
	access-rights, etc. The domain specific language introduced in this
	paper uses a Java and C#-like language for describing web service
	interfaces. It has the same descriptive power as WSDL while maintaining
	simplicity and readability. Examples show how to use the language,
	and how it can be compiled into WSDL. © 2010 Springer-Verlag.},
  affiliation = {Department of Control Engineering and Information Technology, Budapest
	University of Technology and Economics, Magyar tudosok krt. 2, H-1117,
	Budapest, Hungary},
  author_keywords = {Domain Specific Language; SOA; Web Services; WSDL},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-77955737168&partnerID=40&md5=15aca9cb43fe7e30f2f23c03b1c398e7}
}

@ARTICLE{Simon2010537,
  author = {Simon, B., Goldschmidt, B., Kondorosi, K.},
  title = {A human readable platform independent domain specific language for
	BPEL},
  journal = {Communications in Computer and Information Science},
  year = {2010},
  volume = {87 CCIS},
  pages = {537-544},
  number = {PART 1},
  note = {cited By (since 1996) 0},
  abstract = {The basic building blocks of SOA systems are web services. High-level
	service orchestration is usually achieved by defining processes in
	BPEL. The available development environments, however, usually have
	visual tools for BPEL handling. The problem with this is that they
	are not satisfactory when efficiency, repeatability, and manageability
	is necessary. The domain specific language introduced in this paper
	uses a Java and C#-like language for describing web service interfaces
	and BPEL processes. It has the same descriptive power as WSDL and
	BPEL while maintaining simplicity and readability. Examples show
	how to use the language, and how it can be compiled into BPEL process
	descriptions. © 2010 Springer-Verlag.},
  affiliation = {Department of Control Engineering and Information Technology, Budapest
	University of Technology and Economics, Magyar tudosok krt. 2, H-1117,
	Budapest, Hungary},
  author_keywords = {BPEL; Domain Specific Language; SOA; Web Services},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-77955719977&partnerID=40&md5=e42de668768e1cb5217fa34a931998fd}
}

@CONFERENCE{Simonyi2006,
  author = {Simonyi, C., Christerson, M., Clifford, S.},
  title = {Intentional software},
  year = {2006},
  volume = {2006},
  pages = {451-464},
  note = {cited By (since 1996) 11},
  abstract = {Wysiwyg editors simplified document creation by separating the document
	contents from the looks and by automating the re-application of the
	looks to changing contents. In the same way Intentional Software
	simplifies software creation by separating the software contents
	in terms of their various domains from the implementation of the
	software and by enabling automatic re-generation of the software
	as the contents change. This way, domain experts can work in parallel
	with programmers in their respective areas of expertise; and the
	repeated intermingling can be automated. Intentional Software is
	supported by a Domain Workbench tool where multiple domains can be
	defined, created, edited, transformed and integrated during software
	creation. Key features include a uniform representation of multiple
	interrelated domains, the ability to project the domains in multiple
	editable notations, and simple access for a program generator. Copyright
	© 2006 ACM.},
  affiliation = {Intentional Software Corporation, 500 108th Ave NE, #1050, Bellevue,
	WA 98004, United States},
  author_keywords = {Generative programming; Intentional software},
  document_type = {Conference Paper},
  journal = {Proceedings of the Conference on Object-Oriented Programming Systems,
	Languages, and Applications, OOPSLA},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-34248171630&partnerID=40&md5=9f46c0e52f8bb3162f4128c299e543c0}
}

@ARTICLE{Simonyi2006451,
  author = {Simonyi, C., Christerson, M., Clifford, S.},
  title = {Intentional software},
  journal = {ACM SIGPLAN Notices},
  year = {2006},
  volume = {41},
  pages = {451-463},
  number = {10},
  note = {cited By (since 1996) 8},
  abstract = {Wysiwyg editors simplified document creation by separating the document
	contents from the looks and by automating the reapplication of the
	looks to changing contents. In the same way Intentional Software
	simplifies software creation by separating the software contents
	in terms of their various domains from the implementation of the
	software and by enabling automatic regeneration of the software as
	the contents change. This way, domain experts can work in parallel
	with programmers in their respective areas of expertise; and the
	repeated intermingling can be automated. Intentional Software is
	supported by a Domain Workbench tool where multiple domains can be
	defined, created, edited, transformed and integrated during software
	creation. Key features include a uniform representation of multiple
	interrelated domains, the ability to project the domains in multiple
	editable notations, and simple access for a program generator. Copyright
	© 2006 ACM.},
  affiliation = {Intentional Software Corporation, 500 108th Ave NE, #1050, Bellevue,
	WA 98004},
  author_keywords = {Generative programming; Intentional software},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-33750395305&partnerID=40&md5=a1ca71d946ffe8d7fdeea587c7ef511d}
}

@CONFERENCE{Sindico2009,
  author = {Sindico, A., Grassi, V.},
  title = {Model driven development of context aware software systems},
  year = {2009},
  pages = {a7},
  note = {cited By (since 1996) 0},
  abstract = {This paper presents the first results of an ongoing work towards the
	realization of a model driven development framework for context awareness.
	Its core element consists of a domain specific modeling language
	called CAMEL (Context Awareness ModEling Language), and defined as
	a UML extension. CAMEL can be used to enrich a UML model of an application
	with elements related to contexts and context dependent behaviors.
	The resulting UML+CAMEL model is the starting point for model transformation
	aimed at generating executable code or other artifacts. CAMEL is
	implemented by an Eclipse plugin. © 2009 ACM.},
  affiliation = {University of Rome Tor Vergata, Elettronica S.p.A.},
  author_keywords = {Context Awareness; Context Oriented Modeling; Context Oriented Programming;
	MDA; Modeling; UML},
  document_type = {Conference Paper},
  journal = {International Workshop on Context-Oriented Programming, COP '09},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-70350630270&partnerID=40&md5=2039ff605d61c35db7891b26ecf9ef9b}
}

@CONFERENCE{Sindico20081,
  author = {Sindico, A.a , Bartolomeo, G.b , Grassi, V.c , Salsano, S.b },
  title = {Design and development of a context oriented language for middleware
	based applications},
  year = {2008},
  pages = {1-5},
  note = {cited By (since 1996) 0},
  abstract = {Nowadays context-aware adaptation is becoming an important feature
	for pervasive computing applications. In this paper we present JCOOL,
	a COntext Oriented Language tailored to handle context awareness
	in Java applications. JCOOL exploits Aspect Oriented techniques so
	that context changes detection and related adaptations can be considered
	as two separated crosscutting concerns with respect to the core 'business
	logic' of new or legacy Java applications. Moreover, mobile and pervasive
	applications generally rely on middlewares that hide the complexity
	of the underlying environment. In order to show how JCOOL support
	can be introduced into middleware based application, in the second
	part of the paper we also describe JCOOL integration in SMILE [1],
	a Middleware Independent Layer developed in the scope of the SMS
	project [2]. © 2008 ACM.},
  affiliation = {Elettronica S.p.A., Italy; DIE - Dept of Electronic Engineering, University
	of Rome Tor Vergata, Italy; University of Rome Tor Vergata, Italy},
  author_keywords = {Aspect oriented programming; Context awareness; Domain specific language;
	Middleware},
  document_type = {Conference Paper},
  journal = {Next Generation Aspect Oriented Middleware Workshop, NOMI 2008 -
	AOSD Conference 2008 Brussels, 7th International Conference on Aspect-Oriented
	Software Development},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-59249087926&partnerID=40&md5=c4ce252d66bffcc39e8513515857007a}
}

@ARTICLE{Singhoff2007180,
  author = {Singhoff, F., Plantee, A.},
  title = {Towards user-level extensibility of an Ada library: An experiment
	with Cheddar},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2007},
  volume = {4498 LNCS},
  pages = {180-191},
  note = {cited By (since 1996) 2},
  abstract = {In this article, we experiment a way to extend an Ada library called
	Cheddar. Cheddar provides a domain specific language. Programs written
	with this domain specific language can be interpreted in order to
	perform real time scheduling analysis of real time systems. By the
	past, different projects showed that the Cheddar programming language
	is useful for the modeling of real time schedulers. But these experiments
	also showed that the interpreter is lacking of efficiency in case
	of large scheduling simulations. In this article, by designing a
	Cheddar metamodel, we investigate on how to compile such Cheddar
	programs in order to extend the Cheddar library. For such a purpose,
	we use Platypus, a meta CASE Tool based on EXPRESS. For a given Cheddar
	program and with a metarmodel of Cheddar handled by Platypus, we
	can generate a set of Ada packages. Such Ada packages can be compiled
	and integrated as builtin schedulers into Cheddar. Then, the efficiency
	of scheduling simulations can be increased. © Springer-Verlag Berlin
	Heidelberg 2007.},
  affiliation = {LISYC/EA 3883, University of Brest, CS 93837, 20, av Le Gorgeu, 29238
	Brest Cedex 3, France},
  author_keywords = {Ada code generating; Cheddar; Meta-modeling; Platypus},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-37849044671&partnerID=40&md5=166558abbead075e621a2df88346d67f}
}

@CONFERENCE{Singhoff200741,
  author = {Singhoff, F., Plantec, A.},
  title = {AADL modeling and analysis of hierarchical schedulers},
  year = {2007},
  pages = {41-49},
  note = {cited By (since 1996) 7},
  abstract = {A system based on a hierarchical scheduler is a system in which the
	processor is shared between several collaborative schedulers. Such
	schedulers exist since 1960 and they are becoming more and more investigated
	and proposed in real-life applications. For example, the ARINC 653
	international standard which defines an Ada interface for avionic
	real time operating systems provides such a kind of collaborative
	schedulers. This article focuses on the modeling and the performance
	analysis of hierarchical schedulers. We investigate the modeling
	of hierarchical schedulers with AADL. Hierarchical scheduler timing
	and synchronization relationships are expressed with a domain specific
	language based on timed automata: the Cheddar language. With the
	meta CASE tool Platypus, we generate Ada packages implementing the
	Cheddar language. These Ada packages are part of Cheddar, a real
	time scheduling simulator. With these Ada packages, Cheddar is able
	to perform analysis by scheduling simulation of AADL systems composed
	of hierarchical schedulers. An AADL model of the ARINC 653 hierarchical
	scheduling is described as an illustration. Copyright 2007 ACM.},
  affiliation = {LISYC/EA 3883, University of Brest, CS 93837, 20, av Le Gorgeu, 29238
	Brest Cedex 3, France},
  author_keywords = {AADL; ada framework; cheddar; platypus; real time; scheduling analysis;
	timed automaton},
  document_type = {Conference Paper},
  journal = {Proceedings of the ACM SIGAda Annual International Conference; SIGAda},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-74549146061&partnerID=40&md5=15f6f570c90c323473ed077ecc78dda7}
}

@ARTICLE{Sinha2006173,
  author = {Sinha, A.a c , Smidts, C.b d },
  title = {An experimental evaluation of a higher-ordered-typed-functional specification-based
	test-generation technique},
  journal = {Empirical Software Engineering},
  year = {2006},
  volume = {11},
  pages = {173-202},
  number = {2},
  note = {cited By (since 1996) 3},
  abstract = {HOTTest is a model based test automation technique of software systems
	based on models of the system described using HaskellDB. HaskellDB
	is an embedded domain specific language derived from Haskell. HOTTest
	enforces a systematic abstraction process and exploits system invariants
	for automatically producing test cases for domain specific requirements.
	Use of functional languages for system modeling is a new concept
	and hence HOTTest is subject to concerns of usability, like any other
	new technique. Also, the syntax and the declarative style of Haskell
	based languages make them difficult to learn. Similar concerns can
	be raised for HOTTest as it shares the same syntax with Haskell.
	In this paper we describe an experiment designed to study the usability
	of HOTTest and to compare it with existing model based test design
	techniques. The results show that HOTTest is more usable than the
	traditional technique and demonstrate that the test suites produced
	by HOTTest are more effective and efficient than those generated
	using the traditional model based test design technique. © Springer
	Science + Business Media, Inc. 2006.},
  affiliation = {IBM TJ Watson Research Center, Hawthrone, NY, United States; Department
	of Mechanical Engineering, Center for Risk and Reliability Engineering,
	University of Maryland, College Park, United States; IBM TJ Watson
	Research Center, Hawthrone, NY; Dept. of Mechanical Engineering,
	Center for Risk and Reliability Engineering, University of Maryland,
	College Park},
  author_keywords = {Controlled experiment; EFSM software model; Empirical study; Functional
	specification language; Software test automation},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-33644906370&partnerID=40&md5=2b811eb58c8df7db56073ecabe3df259}
}

@ARTICLE{Sinha2006242,
  author = {Sinha, A.a c , Smidts, C.b d },
  title = {HOTTest: A model-based test design technique for enhanced testing
	of domain-specific applications},
  journal = {ACM Transactions on Software Engineering and Methodology},
  year = {2006},
  volume = {15},
  pages = {242-278},
  number = {3},
  note = {cited By (since 1996) 5},
  abstract = {Model-based testing is an effective black-box test generation technique
	for applications. Existing model-based testing techniques, however,
	fail to capture implicit domain-specific properties, as they overtly
	rely on software artifacts such as design documents, requirement
	specifications, etc., for completeness of the test model. This article
	presents a technique, HOTTest, which uses a strongly typed domain-specific
	language to model the system under test. This allows extraction of
	type-related system invariants, which can be related to various domain-specific
	properties of the application. Thus, using HOTTest, it is possible
	to automatically extract and embed domain-specific requirements into
	the test models. In this article we describe HOTTest, its principles
	and methodology, and how it is possible to relate domain-specific
	properties to specific type constraints. HOTTest is described using
	the example of HaskellDB, which is a Haskell-based embedded domain-specific
	language for relational databases. We present an example application
	of the technique and compare the results to some other commonly used
	Model-based test automation techniques like ASML-based testing, UML-based
	testing, and EFSM-based testing. © 2006 ACM.},
  affiliation = {IBM T. J. Watson Research Center; University of Maryland; IBM T. J.
	Watson Research Center, 19 Skyline Drive, 2NF07, Hawthorne, NY 10562;
	Center for Risk and Reliability Engineering, University of Maryland,
	MD 20742},
  author_keywords = {Database-specific test case generation; Domain-specific languages;
	Domain-specific testing; Haskell; HaskellDB; Model-based testing;
	Test case generation; Test generation tools},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-33748528112&partnerID=40&md5=94cff23de24607a7ca4a7a7dbfdaf3d0}
}

@ARTICLE{Sirer20001,
  author = {Sirer, E.G., Bershad, B.N.},
  title = {Using production grammars in software testing},
  journal = {SIGPLAN Notices (ACM Special Interest Group on Programming Languages)},
  year = {2000},
  volume = {35},
  pages = {1-13},
  number = {1},
  note = {cited By (since 1996) 0},
  abstract = {Extensible typesafe systems, such as Java, rely critically on a large
	and complex software base for their overall protection and integrity,
	and are therefore difficult to test and verify. Traditional testing
	techniques, such as manual test generation and formal verification,
	are too time consuming, expensive, and imprecise, or work only on
	abstract models of the implementation and are too simplistic. Consequently,
	commercial virtual machines deployed so far have exhibited numerous
	bugs and security holes. In this paper, we discuss our experience
	with using production grammars in testing large, complex and safety-critical
	software systems. Specifically, we describe lava, a domain specific
	language we have developed for specifying production grammars, and
	relate our experience with using lava to generate effective test
	suites for the Java virtual machine. We demonstrate the effectiveness
	of production grammars in generating complex test cases that can,
	when combined with comparative and variant testing techniques, achieve
	high code and value coverage. We also describe an extension to production
	grammars that enables concurrent generation of certificates for test
	cases. A certificate is a behavioral description that specifies the
	intended outcome of the generated test case, and therefore acts as
	an oracle by which the correctness of the tested system can be evaluated
	in isolation. We report the results of applying these testing techniques
	to commercial Java implementations. We conclude that the use of production
	grammars in combination with other automated testing techniques is
	a powerful and effective method for testing software systems, and
	is enabled by a special purpose language for specifying extended
	production grammars. © 2000 ACM.},
  affiliation = {Department of Computer Science, University of Washington, Box 352350,
	Seattle, WA 98195-2350, United States},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-17644387253&partnerID=40&md5=989b806e596fc2991087018ec0c476c0}
}

@ARTICLE{Skene2010288,
  author = {Skene, J.a , Raimondi, F.b , Emmerich, W.c },
  title = {Service-level agreements for electronic services},
  journal = {IEEE Transactions on Software Engineering},
  year = {2010},
  volume = {36},
  pages = {288-304},
  number = {2},
  note = {cited By (since 1996) 5},
  abstract = {The potential of communication networks and middleware to enable the
	composition of services across organizational boundaries remains
	incompletely realized. In this paper, we argue that this is in part
	due to outsourcing risks and describe the possible contribution of
	Service-Level Agreements (SLAs) to mitigating these risks. For SLAs
	to be effective, it should be difficult to disregard their original
	provisions in the event of a dispute between the parties. Properties
	of understandability, precision, and monitorability ensure that the
	original intent of an SLA can be recovered and compared to trustworthy
	accounts of service behavior to resolve disputes fairly and without
	ambiguity. We describe the design and evaluation of a domain-specific
	language for SLAs that tend to exhibit these properties and discuss
	the impact of monitorability requirements on service-provision practices.
	© 2010 IEEE.},
  affiliation = {Department of Computer Science, University of Auckland, Building 303,
	38 Princes Street, Auckland, New Zealand; School of Engineering and
	Information Sciences, Middlesex University, Burroughs, London NW4
	4BTT, United Kingdom; Department of Computer Science, University
	College London, Malet Place Engineering Building, London WC1E 6BT,
	United Kingdom},
  art_number = {5210121},
  author_keywords = {Contracts; Domain-specific languages; Electronic services; Model-driven
	engineering; Service-level agreements},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-77950627694&partnerID=40&md5=066ef03d3cf5d1a25809ad034cb0e31d}
}

@ARTICLE{Sloane2011408,
  author = {Sloane, A.M.},
  title = {Lightweight language processing in Kiama},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2011},
  volume = {6491 LNCS},
  pages = {408-425},
  note = {cited By (since 1996) 1},
  abstract = {Kiama is a lightweight language processing library for the Scala programming
	language. It provides Scala programmers with embedded domain-specific
	languages for attribute grammars and strategy-based term rewriting.
	This paper provides an introduction to the use of Kiama to solve
	typical language processing problems by developing analysers and
	evaluators for a simply-typed lambda calculus. The embeddings of
	the attribute grammar and rewriting processing paradigms both rely
	on pattern matching from the base language and each add a simple
	functional interface that hides details such as attribute caching,
	circularity checking and strategy representation. The similarities
	between embeddings for the two processing paradigms show that they
	have more in common than is usually realised. © 2011 Springer-Verlag.},
  affiliation = {Department of Computing, Macquarie University, Sydney, Australia},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-79251548250&partnerID=40&md5=88984ba7596b5c1c07222eb9c1448f90}
}

@ARTICLE{Sloane2010205,
  author = {Sloane, A.M.a , Kats, L.C.L.b , Visser, E.b },
  title = {A pure object-oriented embedding of attribute grammars},
  journal = {Electronic Notes in Theoretical Computer Science},
  year = {2010},
  volume = {253},
  pages = {205-219},
  number = {7},
  note = {cited By (since 1996) 0},
  abstract = {Attribute grammars are a powerful specification paradigm for many
	language processing tasks, particularly semantic analysis of programming
	languages. Recent attribute grammar systems use dynamic scheduling
	algorithms to evaluate attributes by need. In this paper, we show
	how to remove the need for a generator, by embedding a dynamic approach
	in a modern, object-oriented programming language to implement a
	small, lightweight attribute grammar library. The Kiama attribution
	library has similar features to current generators, including cached,
	uncached, circular, higher-order and parameterised attributes, and
	implements new techniques for dynamic extension and variation of
	attribute equations. We use the Scala programming language because
	of its combination of object-oriented and functional features, support
	for domain-specific notations and emphasis on scalability. Unlike
	generators with specialised notation, Kiama attribute grammars use
	standard Scala notations such as pattern-matching functions for equations
	and mixins for composition. A performance analysis shows that our
	approach is practical for realistic language processing. © 2010 Elsevier
	B.V. All rights reserved.},
  affiliation = {Department of Computing, Macquarie University, Sydney, Australia;
	Software Engineering Research Group, Delft University of Technology,
	Delft, Netherlands},
  author_keywords = {compilers; domain-specific languages; language processing},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-77956398397&partnerID=40&md5=f9bc823c35307a186540aed868be83d1}
}

@ARTICLE{Smaragdakis200419,
  author = {Smaragdakis, Y.},
  title = {Program Generators and the Tools to Make Them},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2004},
  volume = {3148},
  pages = {19-20},
  note = {cited By (since 1996) 0},
  abstract = {© Springer-Verlag 2004 Program generation is among the most promising
	techniques in the effort to increase the automation of programming
	tasks. In this talk, we discuss the potential impact and research
	value of program generation, we give examples of our research in
	the area, and we outline a future work direction that we consider
	most interesting. Specifically, we first discuss why program generators
	have significant applied potential. We believe that program generators
	can be made easyto-implement so that they are competitive with traditional
	software libraries in many software domains. Compared to a common
	library, a generator implementing a domain-specific language can
	offer more concise syntax, better static error checking, and better
	performance through cross-operation optimizations. Despite the significant
	applied value of generators, however, we argue that meta-programming
	tools (i.e., language tools for writing program generators) may be
	of greater value as a research topic. The reason has to do with the
	domain-specificity of generators. The value of a program generator
	is often tied so closely to a software domain that there is little
	general and reusable knowledge to transmit to other generator researchers.
	We discuss meta-programming tools as an area with both interesting
	conceptual problems and great value. A good meta-programming infrastructure
	can simplify the creation of generators to make them an effective
	solution for many more domains. We illustrate our views on generators
	and meta-programming tools with two artifacts from our latest work:
	the Meta-AspectJ meta-programming language [6] and the GOTECH generator
	[5]. Meta-AspectJ enables generating Java and AspectJ programs using
	code templates, i.e., quote and unquote operators. Meta-AspectJ has
	two interesting elements. First, we believe that using the AspectJ
	language as a back-end simplifies the task of writing a generator.
	The GOTECH generator uses this technique to adapt a Java program
	for server side execution in a J2EE application server. Second, Meta-AspectJ
	is a technically mature meta-programming tool - in many respects
	the most advanced meta-programming tool for Java. For instance, Meta-AspectJ
	reduces the need to deal with low level syntactic types for quoted
	entities (e.g., "expression", "statement", "identifier", etc.) through
	type inference and a context-sensitive parsing algorithm. Finally,
	we examine the problem of statically determining the safety of a
	generator and present its intricacies. We limit our focus to one
	particular kind of guarantee for generated code: ensuring that the
	generated program is free of compile-time errors, such as type errors,
	references to undefined variables, etc. We argue that it is the responsibility
	of a good meta-programming tool to ensure that the generators written
	in it will always produce legal programs. Nevertheless, if we do
	not severely limit the generator, the problem becomes one of arbitrary
	control- and data-flow analysis. We discuss why the limitations of
	current meta-programming tools that offer safety guarantees [1, 4]
	are too strict and we present possible avenues for future research.
	For further reading, a full paper accompanying this talk can be found
	in the PEPM'04 proceedings. The reader may also want to consult one
	of the good surveys on program generation, examining the topic either
	from an applied perspective [3] or from a partial evaluation perspective
	[2].},
  affiliation = {College of Computing, Georgia Institute of Technology, Atlanta, GA
	30332, United States},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-35048899730&partnerID=40&md5=6d1d78cfe4df5389182be547a891ee39}
}

@CONFERENCE{Smaragdakis200492,
  author = {Smaragdakis, Y., Huang, S.S., Zook, D.},
  title = {Program generators and the tools to make them},
  year = {2004},
  pages = {92-100},
  note = {cited By (since 1996) 8},
  abstract = {Program generation is among the most promising techniques in the effort
	to increase the automation of programming tasks. In this paper, we
	discuss the potential impact and research value of program generation,
	we give examples of our research in the area, and we outline a future
	work direction that we consider most interesting. Specifically, we
	first discuss why program generators have significant applied potential.
	At the same time we argue that, as a research topic, meta-programming
	tools (i.e., language tools for writing program generators) may be
	of greater value. We then illustrate our views on generators and
	meta-programming tools with our latest work on the Meta-AspectJ meta-programming
	language and the GOTECH generator. Finally, we examine the problem
	of statically determining the safety of a generator and present its
	intricacies. We limit our focus to one particular kind of guarantee
	for generated code - ensuring that the generated program is free
	of compile-time errors. We believe that this research direction will
	see significant attention and will make a difference in the mainstream
	adoption of meta-programming technology.},
  affiliation = {College of Computing, Georgia Institute of Technology, Atlanta, GA
	30332, United States},
  author_keywords = {Meta-programming; Program generators; Safety guarantees},
  document_type = {Conference Paper},
  journal = {Proceedings of the ACM SIGPLAN Symposium on Partial Evaluation and
	Semantics-Based Program Manipulation},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-11244353163&partnerID=40&md5=eb24c4fd8db3ac3386774620e9f220dc}
}

@CONFERENCE{Sobernig2011157,
  author = {Sobernig, S.a , Gaubatz, P.b , Strembeck, M.a , Zdun, U.b },
  title = {Comparing complexity of API designs: An exploratory experiment on
	DSL-based framework integration},
  year = {2011},
  pages = {157-166},
  note = {cited By (since 1996) 0},
  abstract = {Embedded, textual DSLs are often provided as an API wrapped around
	object-oriented application frameworks to ease framework integration.
	While literature presents claims that DSL-based application development
	is beneficial, empirical evidence for this is rare. We present the
	results of an experiment comparing the complexity of three different
	object-oriented framework APIs and an embedded, textual DSL. For
	this comparative experiment, we implemented the same, non-trivial
	application scenario using these four different APIs. Then, we performed
	an Object-Points (OP) analysis, yielding indicators for the API complexity
	specific to each API variant. The main observation for our experiment
	is that the embedded, textual DSL incurs the smallest API complexity.
	Although the results are exploratory, as well as limited to the given
	application scenario and a single embedded DSL, our findings can
	direct future empirical work. The experiment design is applicable
	for similar API design evaluations. Copyright © 2011 ACM.},
  affiliation = {Institute for IS and New Media, WU Vienna, Vienna, Austria; Software
	Architecture Group, University of Vienna, Vienna, Austria},
  author_keywords = {Application programming interface; Complexity; Domain-specific language;
	Object points},
  document_type = {Conference Paper},
  journal = {GPCE'11 - Proceedings of the 10th International Conference on Generative
	Programming and Component Engineering},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-81455154933&partnerID=40&md5=75fe43282ceca3234ba918f7f2dc68fe}
}

@CONFERENCE{Sobernig2010139,
  author = {Sobernig, S.a , Zdun, U.b },
  title = {Evaluating Java runtime reflection for implementing cross-language
	method invocations},
  year = {2010},
  pages = {139-147},
  note = {cited By (since 1996) 0},
  abstract = {Cross-language method invocations are commonly used for integrating
	objects residing in different programming language environments.
	In this experience report, we evaluate the performance and the design
	impact of alternative implementations of cross-language method invocations
	for the object-oriented scripting language Frag, implemented and
	embedded in Java. In particular, we compare reflective integration
	and generative integration techniques. For that, we present a performance
	evaluation based on a large set of test cases. In addition, we propose
	a new method for quantifying and comparing the implementation efforts
	needed for cross-language method invocations based on cross-language
	refactorings. We report on the lessons learnt and discuss the consequences
	of the implementation variants under review. © 2010 ACM.},
  affiliation = {Institute for Information Systems and New Media, Vienna University
	of Economics and Business, Austria; Information Systems Institute,
	Vienna University of Technology, Austria},
  author_keywords = {cross-language method invocation; design science; domain-specific
	languages; refactoring; reflection},
  document_type = {Conference Paper},
  journal = {Proceedings of the 8th International Conference on the Principles
	and Practice of Programming in Java, PPPJ 2010},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-78549251471&partnerID=40&md5=dbc0d91f5d0f5e24c9b89a3cd5bb8653}
}

@CONFERENCE{Sobral2008,
  author = {Sobral, J.L.a , Monteiro, M.P.b },
  title = {A domain-specific language for parallel and grid computing},
  year = {2008},
  note = {cited By (since 1996) 0},
  abstract = {This paper overviews a Domain-Specific Language (DSL) for parallel
	and grid computing, layered on top of AspectJ. This DSL aims to bridge
	the gap between sequential code and parallel/grid applications, by
	avoiding invasive source code changes in scientific applications.
	Moreover, it aims to promote the localization of parallelization
	and gridification issues into well defined modules that can be (un)plugged
	(from)to existing scientific applications. This paper builds on previous
	work based on AspectJ and presents the main motivations for implementing
	a DSL in preference to a pure-AspectJ solution. The paper presents
	the DSL's design rationale, overviews current implementation and
	open research issues. © 2008 ACM.},
  affiliation = {Departamento de Informática, Universidade Do Minho, 4710-057 Braga,
	Portugal; Departamento de Informática, Faculdade de Ciências e Tecnologia,
	Universidade Nova de Lisboa, 2829-516 Caparica, Portugal},
  art_number = {2},
  author_keywords = {Aspect composition; Domain-specific aspect languages; Parallel computing},
  document_type = {Conference Paper},
  journal = {DSAL'08: Proceedings of the 2008 AOSD Workshop on Domain-specific
	Aspect Languages},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-65249091908&partnerID=40&md5=ac854ce8748ed74b2e23eadd5b53ddad}
}

@ARTICLE{Sochos2004138,
  author = {Sochos, P., Philippow, I., Riebisch, M.},
  title = {Feature-Oriented Development of Software Product Lines: Mapping Feature
	Models to the Architecture},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2004},
  volume = {3263},
  pages = {138-152},
  note = {cited By (since 1996) 11},
  abstract = {Software product lines (PLs) present a solid approach in large scale
	reuse. Due to the PLs' inherit complexity, many PL methods use the
	notion of "features" to support requirements analysis and domain
	modelling (e.g. FODA, FORM, FeatuRSEB). Nevertheless, the link between
	features and architecture remains weak in all methodologies, with
	a large impact on the traceability of high-level concerns in respect
	to lower-lever architectural structures. This paper provides an analysis
	on the state of the art of feature-oriented PL methodologies from
	the point of view of the linkage between feature models and architecture.
	Based on the identified shortcomings it introduces an approach to
	allow a strong mapping between features and architecture. The approach
	makes use of extensions in the feature modelling techniques and adopts
	plug-in architectures as a means of mapping feature structures and
	at the same time satisfying the demanded PL variability and flexibility.
	© Springer-Verlag 2004.},
  affiliation = {Technical University Ilmenau, Process Informatics, Postfach 10 00
	565, 98684 Ilmenau, Germany},
  author_keywords = {Feature modelling; Feature-architecture mapping; Generative programming;
	Plug-in architectures; Product line methods; Separation of concerns;
	Software product lines},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-34249978194&partnerID=40&md5=abdcaf3f64828b7cfe03a1f6aac00764}
}

@CONFERENCE{Sochos2006308,
  author = {Sochos, P., Riebisch, M., Philippow, I.},
  title = {The Feature-Architecture Mapping (FArM) method for feature-oriented
	development of software product lines},
  year = {2006},
  pages = {308-316},
  note = {cited By (since 1996) 3},
  abstract = {Software product lines (PLs) are large, complex systems, demanding
	high maintainability and enhanced flexibility. Nonetheless, in the
	state of the art PL methods, features are scattered and tangled throughout
	the system components, leading to poor maintainability. Additionally,
	the majority of PL methods support manual product composition, while
	the implementation of feature-level variability in PL products influences
	the system's conceptual integrity. Generative programming techniques
	do enhance flexibility, but on the cost of maintainability. The Feature-Architecture
	Mapping (FArM) method provides a stronger mapping between features
	and the architecture. It is based on a series of transformations
	on the initial PL feature model. During these transformations architectural
	components are derived, encapsulating the business logic of each
	transformed feature and having interfaces reflecting the feature
	interactions. The flexibility of FArM architectures is supported
	through the explicit integration of plug-in mechanisms. The methodology
	is evaluated in the context of a wireless handheld-device PL. © 2006
	IEEE.},
  affiliation = {Technical University of Ilmenau, Software Systems/Process Informatics,
	Ilmenau 98684, Germany},
  art_number = {1607380},
  document_type = {Conference Paper},
  journal = {Proceedings of the International Symposium and Workshop on Engineering
	of Computer Based Systems},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-34249996808&partnerID=40&md5=cfae748e5b38c0bb1497b3384d8b5132}
}

@CONFERENCE{Soden20094,
  author = {Soden, M., Eichler, H.},
  title = {Towards a model execution framework for eclipse},
  year = {2009},
  pages = {4},
  note = {cited By (since 1996) 0},
  abstract = {The Eclipse Modeling Project (EMP) is one of the most striking foundation
	for model driven development. With its core frameworks for metamodeling,
	textual and graphical editors, validation&constraints, transformations,
	etc. it provides broad support for creation of model driven tooling
	such as for Domain Specific Languages (DSLs). However, there is currently
	a lack of support for making models executable by means of operational
	semantics. This paper outlines the M3Actions, a framework to develop
	execution semantics for MOF metamodels, which is on the verge of
	being adopted as basis of a new Eclipse project named Model Execution
	Framework (MXF). We discuss requirements upon model execution and
	sketch requirements of a common execution infrastructure. © 2009
	ACM.},
  affiliation = {Humboldt University, Unter den Linden 6, 10099 Berlin, Germany},
  author_keywords = {Metamodels; Model execution; Model execution framework; Operational
	semantics},
  document_type = {Conference Paper},
  journal = {ACM International Conference Proceeding Series},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-71049148526&partnerID=40&md5=bb8f92c05ed80333141520314bb75f0c}
}

@ARTICLE{Solar-Lezama2005,
  author = {Solar-Lezama, A.a , Rabbah, R.b , Bodík, R.a , Ebcioǧlu, K.c },
  title = {Programming by sketching for bit-streaming programs},
  journal = {ACM SIGPLAN Notices},
  year = {2005},
  volume = {40},
  pages = {281-294},
  number = {6},
  note = {cited By (since 1996) 3},
  abstract = {This paper introduces the concept of programming with sketches, an
	approach for the rapid development of high-performance applications.
	This approach allows a programmer to write clean and portable reference
	code, and then obtain a high-quality implementation by simply sketching
	the outlines of the desired implementation. Subsequently, a compiler
	automatically fills in the missing details while also ensuring that
	a completed sketch is faithful to the input reference code. In this
	paper, we develop StreamBit as a sketching methodology for the important
	class of bit-streaming programs (e.g., coding and cryptography).
	A sketch is a partial specification of the implementation, and as
	such, it affords several benefits to programmer in terms of productivity
	and code robustness. First, a sketch is easier to write compared
	to a complete implementation. Second, sketching allows the programmer
	to focus on exploiting algorithmic properties rather than on orchestrating
	low-level details. Third, a sketch-aware compiler rejects "buggy"
	sketches, thus improving reliability while allowing the programmer
	to quickly evaluate sophisticated implementation ideas. We evaluated
	the productivity and performance benefits of our programming methodology
	in a user-study, where a group of novice StreamBit programmers competed
	with a group of experienced C programmers on implementing a cipher.
	We learned that, given the same time budget, the ciphers developed
	in StreamBit ran 2.5× faster than ciphers coded in C. We also produced
	implementations of DES and Serpent that were competitive with hand
	optimized implementations available in the public domain. Copyright
	2005 ACM.},
  affiliation = {Computer Science Division, University of California, Berkeley; Computer
	Science and Artificial Intelligence Laboratory, Massachusetts Institute
	of Technology; T.J. Watson Research Center, IBM Corporation},
  author_keywords = {Domain Specific Compiler; Domain Specific Language; Sketching; Stream
	Programming; Streamit; Synchronous Dataflow},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-33745280921&partnerID=40&md5=8096b76f0fbb90e58bfe2b389a8c3b9c}
}

@CONFERENCE{Solar-Lezama2005281,
  author = {Solar-Lezama, A.a , Rabbah, R.b , Bodík, R.a , Ebcioǧlu, K.c },
  title = {Programming by sketching for bit-streaming programs},
  year = {2005},
  pages = {281-294},
  note = {cited By (since 1996) 19},
  abstract = {This paper introduces the concept of programming with sketches, an
	approach for the rapid development of high-performance applications.
	This approach allows a programmer to write clean and portable reference
	code, and then obtain a high-quality implementation by simply sketching
	the outlines of the desired implementation. Subsequently, a compiler
	automatically fills in the missing details while also ensuring that
	a completed sketch is faithful to the input reference code. In this
	paper, we develop StreamBit as a sketching methodology for the important
	class of bit-streaming programs (e.g., coding and cryptography).
	A sketch is a partial specification of the implementation, and as
	such, it affords several benefits to programmer in terms of productivity
	and code robustness. First, a sketch is easier to write compared
	to a complete implementation. Second, sketching allows the programmer
	to focus on exploiting algorithmic properties rather than on orchestrating
	low-level details. Third, a sketch-aware compiler rejects "buggy"
	sketches, thus improving reliability while allowing the programmer
	to quickly evaluate sophisticated implementation ideas. We evaluated
	the productivity and performance benefits of our programming methodology
	in a user-study, where a group of novice StreamBit programmers competed
	with a group of experienced C programmers on implementing a cipher.
	We learned that, given the same time budget, the ciphers developed
	in StreamBit ran 2.5× faster than ciphers coded in C. We also produced
	implementations of DES and Serpent that were competitive with hand
	optimized implementations available in the public domain. Copyright
	2005 ACM.},
  affiliation = {Computer Science Division, University of California, Berkeley; Computer
	Science and Artificial Intelligence Laboratory, Massachusetts Institute
	of Technology; T.J. Watson Research Center, IBM Corporation},
  author_keywords = {Domain Specific Compiler; Domain Specific Language; Sketching; Stream
	Programming; Streamit; Synchronous Dataflow},
  document_type = {Conference Paper},
  journal = {Proceedings of the ACM SIGPLAN Conference on Programming Language
	Design and Implementation (PLDI)},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-31844442829&partnerID=40&md5=3cae0da6d3741bd32cbe7e267f440362}
}

@ARTICLE{Soltenborn2011233,
  author = {Soltenborn, C., Engels, G.},
  title = {Using rule overriding to improve reusability and understandability
	of Dynamic Meta Modeling specifications},
  journal = {Journal of Visual Languages and Computing},
  year = {2011},
  volume = {22},
  pages = {233-250},
  number = {3},
  note = {cited By (since 1996) 0},
  abstract = {Dynamic Meta Modeling (DMM) is a visual semantics specification technique
	targeted at languages based on a metamodel. A DMM specification consists
	of a runtime metamodel and operational rules which describe how instances
	of the runtime metamodel change over time. A known deficiency of
	the DMM approach is that it does not support the refinement of a
	DMM specification, e.g., in the case of defining the semantics for
	a refined and extended domain-specific language (DSL). Up to now,
	DMM specifications could only be reused by adding or removing DMM
	rules. In this paper, we enhance DMM such that DMM rules can override
	other DMM rules, similar to a method being overridden in a subclass,
	and we show how rule overriding can be realized with the graph transformation
	tool GROOVE. We argue that rule overriding does not only have positive
	impact on reusability, but also improves the intuitive understandability
	of DMM semantics specifications. © 2010 Elsevier Ltd.},
  affiliation = {University of Paderborn, Warburger Straße 100, 33098 Paderborn, Germany},
  author_keywords = {Dynamic Meta Modeling; Graph transformation; Inheritance; Metamodel;
	Semantics},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-79957941315&partnerID=40&md5=028b4ea28f7e965bf4c9fee58b2777b5}
}

@CONFERENCE{Son200476,
  author = {Son, T.C.a , Pontelli, E.a , Ranjan, D.a , Milligan, B.b , Gupta,
	G.c },
  title = {An agent-based domain specific framework for rapid prototyping of
	applications in evolutionary biology},
  year = {2004},
  volume = {2990},
  pages = {76-96},
  note = {cited By (since 1996) 0},
  abstract = {In this paper we present a brief overview of the ΦLOG project, aimed
	at the development of a domain specific framework for the rapid prototyping
	of applications in evolutionary biology. This includes the development
	of a domain specific language, called ΦLOG, and an agent-based implementation
	for the monitoring and execution of ΦLOG's programs. A ΦLOG program
	- representing an intended application from an evolutionary biologist
	- is a specification of what to do to achieve her/his goal. The execution
	and monitoring component of our system will automatically figure
	out how to do it. We achieve that by viewing the available bioinformatic
	tools and data repositories as web services and casting the problem
	of execution of a sequence of bioinformatic services (possibly with
	loops, branches, and conditionals, specified by biologists) as the
	web services composition problem. © Springer-Verlag Berlin Heidelberg
	2004.},
  affiliation = {Department of Computer Science, New Mexico State University; Department
	of Biology, New Mexico State University; Department of Computer Science,
	University of Texas, Dallas},
  document_type = {Conference Paper},
  journal = {Lecture Notes in Artificial Intelligence (Subseries of Lecture Notes
	in Computer Science)},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-23144438516&partnerID=40&md5=079e9dd37d2aea847a87eeedd92227d1}
}

@CONFERENCE{Song2009,
  author = {Song, M., Tilevich, E.},
  title = {Enhancing source-level programming tools with an awareness of transparent
	program transformations},
  year = {2009},
  pages = {301-319},
  note = {cited By (since 1996) 0},
  abstract = {Programs written in managed languages are compiled to a platform-independent
	intermediate representation, such as Java bytecode. The relative
	high level of Java bytecode has engendered a widespread practice
	of changing the bytecode directly, without modifying the maintained
	version of the source code. This practice, called bytecode engineering
	or enhancement, has become indispensable in introducing various concerns,
	including persistence, distribution, and security, transparently.
	For example, transparent persistence architectures help avoid the
	entanglement of business and persistence logic in the source code
	by changing the bytecode directly to synchronize objects with stable
	storage. With functionality added directly at the bytecode level,
	the source code reflects only partial semantics of the program. Specifically,
	the programmer can neither ascertain the program's runtime behavior
	by browsing its source code, nor map the runtime behavior back to
	the original source code. This paper presents an approach that improves
	the utility of source-level programming tools by providing enhancement
	specifications written in a domain-specific language. By interpreting
	the specifications, a source-level programming tool can gain an awareness
	of the bytecode enhancements and improve its precision and usability.
	We demonstrate the applicability of our approach by making a source
	code editor and a symbolic debugger enhancements-aware. Copyright
	© 2009 ACM.},
  affiliation = {Dept. of Computer Science, Virginia Tech., Blacksburg, VA 24061, United
	States},
  author_keywords = {Bytecode engineering; Debugging; Domain-specific languages; Enhancement;
	Program transformation},
  document_type = {Conference Paper},
  journal = {Proceedings of the Conference on Object-Oriented Programming Systems,
	Languages, and Applications, OOPSLA},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-72249122536&partnerID=40&md5=5435fdf8e398b7497f0986abc680d3e3}
}

@ARTICLE{Song2009301,
  author = {Song, M., Tilevich, E.},
  title = {Enhancing source-level programming tools with an awareness of transparent
	program transformations},
  journal = {ACM SIGPLAN Notices},
  year = {2009},
  volume = {44},
  pages = {301-319},
  number = {10},
  note = {cited By (since 1996) 0},
  abstract = {Programs written in managed languages are compiled to a platform-independent
	intermediate representation, such as Java bytecode. The relative
	high level of Java bytecode has engendered a widespread practice
	of changing the bytecode directly, without modifying the maintained
	version of the source code. This practice, called bytecode engineering
	or enhancement, has become indispensable in transparently introducing
	various concerns, including persistence, distribution, and security.
	For example, transparent persistence architectures help avoid the
	entanglement of business and persistence logic in the source code
	by changing the bytecode directly to synchronize objects with stable
	storage. With functionality added directly at the bytecode level,
	the source code reflects only partial semantics of the program. Specifically,
	the programmer can neither ascertain the program's runtime behavior
	by browsing its source code, nor map the runtime behavior back to
	the original source code. This paper presents an approach that improves
	the utility of source-level programming tools by providing enhancement
	specifications written in a domain-specific language. By interpreting
	the specifications, a source-level programming tool can gain an awareness
	of the bytecode enhancements and improve its precision and usability.
	We demonstrate the applicability of our approach by making a source
	code editor and a symbolic debugger enhancements-aware. © 2009 ACM.},
  affiliation = {Dept. of Computer Science, Virginia Tech, Blacksburg, VA 24061, United
	States},
  author_keywords = {Bytecode engineering; Debugging; Domain-specific languages; Enhancement;
	Program transformation},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-70350645442&partnerID=40&md5=c14497de014d6134d00cf456e62d3f0f}
}

@CONFERENCE{Song2009811,
  author = {Song, M., Tilevich, E.},
  title = {The anti-goldilocks debugger: Helping the average bear debug transparently
	transformed programs},
  year = {2009},
  pages = {811-812},
  note = {cited By (since 1996) 0},
  abstract = {The practice of enhancing the bytecode of Plain Old Java Objects (POJOs)
	with additional capabilities, including persistence, distribution,
	and security, has become an indispensable part of enterprise software
	development. The resulting transparently-applied, large-scale structural
	changes to the bytecode significantly complicate symbolic debugging.
	This demonstration will showcase the Anti-Goldilocks Java (AGJ) debugger,
	which enables the programmer to trace and debug transparently transformed
	programs, without the distraction of the bytecode-level enhancements
	obfuscating the program's source code. AGJ executes a structurally-enhanced
	program, while dynamically reinterpreting the debugging output (e.g.,
	'step', 'print variable', etc.) to display program information as
	pertaining to the original version of the code. AGJ is based on a
	new debugging architecture that leverages our domain-specific language
	for describing enhancements. A paper in the main technical program
	of OOPSLA 2009 [5] describes the design rationale and implementation
	details of AGJ. This demonstration will showcase the functionality
	of our reference implementation by using it to locate bugs in a framework-based
	enterprise application from the financial industry. Using the domain
	of transparent persistence, this demonstration will compare AGJ to
	the standard JDK debugger, thereby highlighting the capabilities
	of AGJ to cut through the morass of transparent bytecode enhancements
	in order to find obscure bugs.},
  affiliation = {Dept. of Computer Science, Virginia Tech., Blacksburg, VA 24061, United
	States},
  author_keywords = {Bytecode enhancement; Debugging; Program transformation},
  document_type = {Conference Paper},
  journal = {Proceedings of the Conference on Object-Oriented Programming Systems,
	Languages, and Applications, OOPSLA},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-72249105147&partnerID=40&md5=2d7ae38e82e29ec75eae0b19ebba14a7}
}

@ARTICLE{Sonnenberg2011252,
  author = {Sonnenberg, C.b , Huemer, C.a , Hofreiter, B.b , Mayrhofer, D.a ,
	Braccini, A.c },
  title = {The REA-DSL: A domain specific modeling language for business models},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2011},
  volume = {6741 LNCS},
  pages = {252-266},
  note = {cited By (since 1996) 0},
  abstract = {In the discipline of accounting, the resource-event-agent (REA) ontology
	is a well accepted conceptual accounting framework to analyze the
	economic phenomena within and across enterprises. Accordingly, it
	seems to be appropriate to use REA in the requirements elicitation
	to develop an information architecture of accounting and enterprise
	information systems. However, REA has received comparatively less
	attention in the field of business informatics and computer science.
	Some of the reasons may be that the REA ontology despite of its well
	grounded core concepts is (1) sometimes vague in the definition of
	the relationships between these core concepts, (2) misses a precise
	language to describe the models, and (3) does not come with an easy
	to understand graphical notation. Accordingly, we have started developing
	a domain specific modeling language specifically dedicated to REA
	models and corresponding tool support to overcome these limitations.
	In this paper we present our REA DSL which supports the basic set
	of REA concepts. © 2011 Springer-Verlag.},
  affiliation = {TU, Vienna, Austria; University of Liechtenstein, Liechtenstein; LUISS
	University, Italy},
  author_keywords = {Accounting Information Systems; Business Models; Conceptual Modeling;
	Domain Specific Languages},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-79960311380&partnerID=40&md5=d855dbf4821294b6be78ce2bcb38a9ed}
}

@ARTICLE{Soulé2010507,
  author = {Soulé, R.a , Hirzel, M.b , Grimm, R.a , Gedik, B.b , Andrade, H.b
	, Kumar, V.b , Wu, K.-L.b },
  title = {A universal calculus for stream processing languages},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2010},
  volume = {6012 LNCS},
  pages = {507-528},
  note = {cited By (since 1996) 2},
  abstract = {Stream processing applications such as algorithmic trading, MPEG processing,
	and web content analysis are ubiquitous and essential to business
	and entertainment. Language designers have developed numerous domain-specific
	languages that are both tailored to the needs of their applications,
	and optimized for performance on their particular target platforms.
	Unfortunately, the goals of generality and performance are frequently
	at odds, and prior work on the formal semantics of stream processing
	languages does not capture the details necessary for reasoning about
	implementations. This paper presents Brooklet, a core calculus for
	stream processing that allows us to reason about how to map languages
	to platforms and how to optimize stream programs. We translate from
	three representative languages, CQL, StreamIt, and Sawzall, to Brooklet,
	and show that the translations are correct. We formalize three popular
	and vital optimizations, data-parallel computation, operator fusion,
	and operator re-ordering, and show under which conditions they are
	correct. Language designers can use Brooklet to specify exactly how
	new features or languages behave. Language implementors can use Brooklet
	to show exactly under which circumstances new optimizations are correct.
	In ongoing work, we are developing an intermediate language for streaming
	that is based on Brooklet. We are implementing our intermediate language
	on System S, IBM's high-performance streaming middleware. © 2010
	Springer-Verlag.},
  affiliation = {New York University, United States; IBM Research, Switzerland},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-77951270754&partnerID=40&md5=d64e8758459d2f0738745341c389eebe}
}

@CONFERENCE{Sousa2007910,
  author = {Sousa, V., Amaral, V., Barroca, B.},
  title = {Towards a full implementation of a robust solution of a Domain Specific
	Visual Query Language for HEP Physics analysis},
  year = {2007},
  volume = {1},
  pages = {910-917},
  note = {cited By (since 1996) 0},
  abstract = {We focus our research on developing the right methodology and gathering
	the adequate re-usable methodology and toolset in order to design
	a domain specific language for High Energy Physics (HEP) data analysis.
	We aim at a framework that from a specification model using a simple
	high level abstraction language (Domain Specific Visual Query Language
	- commonly known as DSL) we generate automatically the target source
	code in some General Purpose Language (GPL, at the level of the analysis
	framework) which exactly expresses the querys modeled by the physicist.
	This source code can then be compiled and run against the analysis
	framework of a specific HEP experiment. In this communication we
	will focus on methodological issues, although presenting the conclusions
	on the latest survey done on domain specific languages (DSL) development
	tools. © 2007 IEEE.},
  affiliation = {Centro de Informática e Tecnologias de Informação (CITI), Universidade
	Nova Lisboa (UNL)},
  art_number = {4436475},
  document_type = {Conference Paper},
  journal = {IEEE Nuclear Science Symposium Conference Record},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-48349144605&partnerID=40&md5=8574016f7260b1502eced8c17041df12}
}

@ARTICLE{Sperber2001,
  author = {Sperber, M.},
  title = {Developing a stage lighting system from scratch},
  journal = {SIGPLAN Notices (ACM Special Interest Group on Programming Languages)},
  year = {2001},
  volume = {36},
  pages = {122-133},
  number = {10},
  note = {cited By (since 1996) 0},
  abstract = {Lula is a system for computer-assisted stage lighting design and control.
	Whereas other systems for the same purpose are usually the results
	of long chains of incremental improvements of historic concepts,
	Lula represents a complete redesign. Whereas other systems focus
	on control aspects of lighting, Lula focuses on design and generates
	control information from it. This approach gives significantly more
	flexibility to the lighting designer and shortens the design process
	itself. Lula's design and implementation draw from a number of disciplines
	in advanced programming. It is written in Scheme and runs atop PLT
	Scheme, and benefits from its high-level GUI library. Lula uses an
	algebraic model for lighting looks based on just three combinators.
	It employs Functional Reactive Programming for all dynamic aspects
	of lighting, and is programmable via a functional-reactive domain-specific
	language. Lula is an actual product and has users who have neither
	interest in nor knowledge of functional programming. Copyright 2001
	ACM.},
  affiliation = {Wilhelm-Schickard-Inst. F. I., Universität Tübingen},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-17144413806&partnerID=40&md5=aa0ccfceab86e8639629bec7d646535a}
}

@CONFERENCE{Sperber2001122,
  author = {Sperber, M.},
  title = {Developing a stage lighting system for scratch},
  year = {2001},
  pages = {122-133},
  note = {cited By (since 1996) 0},
  abstract = {Lula is a system for computer-assisted stage lighting design and control.
	Whereas other systems for the same purpose are usually the results
	of long chains of incremental improvements of historic concepts.
	Lula represents a complete redesign. Whereas other systems focus
	on control aspects of lighting. Lula focuses on design and generates
	control information from it. This approach gives significantly more
	flexibility to the lighting designer and shortens the design process
	itself. Lula's design and implementation draw from a number of disciplines
	in advanced programming. It is written in Scheme and runs atop PLT
	Scheme, and benefits from its high-level GUI library. Lula uses an
	algebraic model for lighting looks based on just three combinators.
	It employs Functional Reactive Programming for all dynamic aspects
	of lighting, and is programmable via a functional-reactive domain-specific
	language. Lula is an actual product and has users who have neither
	interest in nor knowledge of functional programming.},
  affiliation = {Wilhelm-Schickard-Institut fur Info., Universität Tübingen, Tübingen,
	Germany},
  document_type = {Conference Paper},
  journal = {Proceedings of the ACM SIGPLAN International Conference on Functional
	Programming, ICFP},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-0034777807&partnerID=40&md5=a08280634b50c25eec39d349c7dde8ec}
}

@ARTICLE{Spicher2010298,
  author = {Spicher, A.a , Michel, O.a , Giavitto, J.-L.b },
  title = {Declarative mesh subdivision using topological rewriting in MGS},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2010},
  volume = {6372 LNCS},
  pages = {298-313},
  note = {cited By (since 1996) 2},
  abstract = {Mesh subdivision algorithms are usually specified informally using
	graphical schemes defining local mesh refinements. These algorithms
	are then implemented efficiently in an imperative framework. The
	implementation is cumbersome and implies some tricky indices management.
	Smith et al. (2004) asks the question of the declarative programming
	of such algorithms in an index-free way. In this paper, we positively
	answer this question by presenting a rewriting framework where mesh
	refinements are described by simple rules. This framework is based
	on a notion of topological chain rewriting. Topological chains generalize
	the notion of labeled graph to higher dimensional objects. This framework
	has been implemented in the domain specific language MGS. The same
	generic approach has been used to implement Loop as well as Butterfly,
	Catmull-Clark and Kobbelt subdivision schemes. © 2010 Springer-Verlag.},
  affiliation = {Université Paris-Est Créteil, LACL, 61 rue du Général de Gaulle, F-94010
	Créteil, France; CNRS - Université d'Évry, Laboratoire IBISC, 523
	place des terrasses de l'Agora, F-91000 Évry, France},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-78649832849&partnerID=40&md5=888a028a8d794c06854a5c5aa580fa1e}
}

@ARTICLE{Spiewak2009149,
  author = {Spiewak, D., Zhao, T.},
  title = {Method proxy-based AOP in scala},
  journal = {Journal of Object Technology},
  year = {2009},
  volume = {8},
  pages = {149-169},
  number = {7},
  note = {cited By (since 1996) 1},
  abstract = {This paper describes a fully-functional Aspect-Oriented Programming
	framework in Scala - a statically typed programming language with
	object-oriented and functional features. This framework is implemented
	as internal domain-specific languages with syntax that is both intuitive
	and expressive. The implementation also enforces some static type
	safety in aspect definitions. © JOT, 2008.},
  affiliation = {University of Wisconsin, Milwaukee, United States},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-77954724926&partnerID=40&md5=abe17722d0d5fedd5f31b3d28212598e}
}

@ARTICLE{Spinellis200878,
  author = {Spinellis, D.},
  title = {Rational metaprogramming},
  journal = {IEEE Software},
  year = {2008},
  volume = {25},
  pages = {78-79},
  number = {1},
  note = {cited By (since 1996) 2},
  abstract = {Metaprogramming takes place when programs manipulate other programs.
	It is a powerful but tricky technique that can lead to unmaintainable
	code and bugs. None of the many current approaches to metaprogramming
	is mature. An ideal solution would use the same language for programming
	and metaprogramming. The language would be based on a small set of
	familiar programming constructs, and its compile-time objects would
	be first class citizens guaranteed to be syntactically correct and
	valid. © 2008 IEEE.},
  affiliation = {Athens University of Economics and Business, Athens, Greece},
  author_keywords = {Functional programming; Generative programming; Metaprogramming; Templates},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-39449130721&partnerID=40&md5=6e22e7d431a4ac9c1a24bcdb20712f9f}
}

@ARTICLE{Spinellis200720,
  author = {Spinellis, D.},
  title = {The tools we use},
  journal = {IEEE Software},
  year = {2007},
  volume = {24},
  pages = {20-21},
  number = {4},
  note = {cited By (since 1996) 0},
  abstract = {If we look at the tools we use to convert source code into executable
	format, we can get an accurate picture of the abstraction level that
	programmers face during construction and maintenance (where the largest
	chunk of software development effort takes place). Collecting data
	from the building of 7,000 application programs showed that most
	CPU time is spent compiling C and C++ code using tools with roots
	in the 1970s and 1980s. To see order-of-magnitude productivity improvements,
	we must raise our code's level of abstraction by adopting more modern
	technologies such as domain-specific languages, general purpose declarative
	languages, and executable UML. © 2007 IEEE.},
  affiliation = {Department of Management Science and Technology, Athens University
	of Economics and Business, Athens, Greece},
  author_keywords = {Abstraction; Build-process; Declarative language; Domain-specific
	language; Executable UML; Programming language},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-34547105563&partnerID=40&md5=92eecdd18c45b055de52a58ad76f95a9}
}

@ARTICLE{Spinellis200724,
  author = {Spinellis, D.},
  title = {Abstraction and variation},
  journal = {IEEE Software},
  year = {2007},
  volume = {24},
  pages = {24-25},
  number = {5},
  note = {cited By (since 1996) 0},
  abstract = {Copy-pasting code is a source of bugs. By employing in our programs
	abstraction mechanisms such as functions, classes, types, decision
	tables, domain-specific languages, and databases, we can abstract
	common elements into parameterized reusable functionality. However,
	abstraction has its cost. Its early gains are large, but eventually
	the benefits turn negative and the code becomes less comprehensible
	and maintainable. Deciding when abstracting is appropriate is what
	makes programming an art. © 2007 IEEE.},
  affiliation = {Department of Management Science and Technology, Athens University
	of Economics and Business, Athens, Greece},
  author_keywords = {Abstraction; Class; Function; Generics; Types},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-34648846762&partnerID=40&md5=a2267cb9e7a146f48c6d684fc48a0ee6}
}

@ARTICLE{Spinellis200257,
  author = {Spinellis, D.},
  title = {Unix tools as visual programming components in a GUI-builder environment},
  journal = {Software - Practice and Experience},
  year = {2002},
  volume = {32},
  pages = {57-71},
  number = {1},
  note = {cited By (since 1996) 3},
  abstract = {Development environments based on ActiveX controls and JavaBeans are
	marketed as 'visual programming' platforms; in practice their visual
	dimension is limited to the design and implementation of an application's
	graphical user interface (GUI). The availability of sophisticated
	GUI development environments and visual component development frameworks
	is now providing viable platforms for implementing visual programming
	within general-purpose platforms, i.e. for the specification of non
	GUI program functionality using visual representations. We describe
	how specially designed reflective components can be used in an industry-standard
	visual programming environment to graphically specify sophisticated
	data transformation pipelines that interact with GUI elements. The
	components are based on Unix-style filters repackaged as ActiveX
	controls. Their visual layout on the development environment canvas
	is used to specify the connection topology of the resultant pipeline.
	The process of converting filter style programs into visual controls
	is automated using a domain-specific language. We demonstrate the
	approach through the design and the visual implementation of a GUI-based
	spell-checker. Copyright © 2001 John Wiley & Sons, Ltd.},
  affiliation = {Dept. of Mgmt. Sci. and Technology, Athens Univ. of Econ. and Business,
	Patision 76, Athens GR-10434, Greece},
  author_keywords = {Components; Pipe and filter architecture; Reflection; Reuse; Unix
	tools; Visual programming},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-0036140704&partnerID=40&md5=db08340aeea01e600c309457e5fca859}
}

@ARTICLE{Spinellis200191,
  author = {Spinellis, D.},
  title = {Notable design patterns for domain-specific languages},
  journal = {Journal of Systems and Software},
  year = {2001},
  volume = {56},
  pages = {91-99},
  number = {1},
  note = {cited By (since 1996) 42},
  abstract = {The realisation of domain-specific languages (DSLS) differs in fundamental
	ways from that of traditional programming languages. We describe
	eight recurring patterns that we have identified as being used for
	DSL design and implementation. Existing languages can be extended,
	restricted, partially used, or become hosts for DSLS. Simple DSLS
	can be implemented by lexical processing. In addition, DSLS can be
	used to create front-ends to existing systems or to express complicated
	data structures. Finally, DSLS can be combined using process pipelines.
	The patterns described form a pattern language that can be used as
	a building block for a systematic view of the software development
	process involving DSLS. © 2001 Elsevier Science Inc. All rights reserved.},
  affiliation = {Dept. of Info. and Commun. Systems, University of the Aegean, GR-83
	200 Karlovasi, Greece},
  author_keywords = {Design patterns; Domain-specific languages},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-0346026383&partnerID=40&md5=b7d07ad667df71c3c35c6b16252050b6}
}

@ARTICLE{Spinellis201010,
  author = {Spinellis, D.a b },
  title = {Software tracks},
  journal = {IEEE Software},
  year = {2010},
  volume = {27},
  pages = {10-11},
  number = {2},
  note = {cited By (since 1996) 1},
  abstract = {Railroad tracks offer guidance and support. There are various tools
	that can give our software the same handling. The main tool for guiding
	the code's direction is the language's type system. For values, the
	type system can help us by establishing a separate type for each
	distinct class; for code, interfaces and abstract classes ensure
	that we won't forget some crucial methods when we add functionality
	through a new class. With domain-specific languages or even suitably
	initialized data structures we can efficiently express exactly what
	the designer intended and nothing more. At a higher level, architectures
	that enforce a particular open-ended but well-defined interface will
	also guide a software's progress. Finally, the most flexible track-laying
	approach is a tool-supported software development process. © 2010
	IEEE.},
  affiliation = {Department of Management Science and Technology, Athens University
	of Economics and Business, Greece; Greek Ministry of Finance, Greece},
  art_number = {5420789},
  author_keywords = {Architecture; Domain-specific languages; Railroad track metaphor;
	Software process; Type checking},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-77649258165&partnerID=40&md5=d67f8552c35f6c0bc36bdf0fa1880d2f}
}

@ARTICLE{Spinellis2002159,
  author = {Spinellis, D.a , Gritzalis, D.b },
  title = {Panoptis: Intrusion detection using a domain-specific language},
  journal = {Journal of Computer Security},
  year = {2002},
  volume = {10},
  pages = {159-176},
  number = {1-2},
  note = {cited By (since 1996) 2},
  abstract = {We describe the use of a domain-specific language (DSL) for expressing
	critical design values and constraints in an intrusion detection
	application. Through the use of this specialised language, information
	that is critical to the correct operation of the software can be
	expressed in a form that can be easily drafted, verified, and maintained
	by domain experts (security officers), thus minimising the risk inherent
	from the mediation of software engineers. Our application, Panoptis,
	is a DSL-based low-cost, easy-to-use intrusion detection system using
	the process accounting records kept by most Unix systems. A set of
	database tables contain resource usage profiles for processes, terminals,
	users, and time intervals. Panoptis monitors new process data against
	the recorded profiles and reports on entities diverging from the
	established resource usage envelopes implying possible data security
	threats. We demonstrate the operation of Panoptis by a case study
	of a real attack and subsequent system compromise that occured on
	a system under our administrative control.},
  affiliation = {Department of Technology and Management, Athens University of Economics
	and Business, GR10434 Athens, Greece; Department of Informatics,
	Athens University of Economics and Business, GR10434 Athens, Greece},
  author_keywords = {Domain-specific languages; Intrusion detection; Security monitoring;
	Unix process accounting},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-0036093231&partnerID=40&md5=1767c2ba7bf8b61332571ea5cdee43dd}
}

@ARTICLE{Spjuth2009,
  author = {Spjuth, O.a , Alvarsson, J.a , Berg, A.a , Eklund, M.a , Kuhn, S.b
	, Mäsak, C.a , Torrance, G.b , Wagener, J.c , Willighagen, E.L.a
	, Steinbeck, C.b , Wikberg, J.E.S.a },
  title = {Bioclipse 2: A scriptable integration platform for the life sciences},
  journal = {BMC Bioinformatics},
  year = {2009},
  volume = {10},
  note = {cited By (since 1996) 11},
  abstract = {Background: Contemporary biological research integrates neighboring
	scientific domains to answer complex questions in fields such as
	systems biology and drug discovery. This calls for tools that are
	intuitive to use, yet flexible to adapt to new tasks. Results: Bioclipse
	is a free, open source workbench with advanced features for the life
	sciences. Version 2.0 constitutes a complete rewrite of Bioclipse,
	and delivers a stable, scalable integration platform for developers
	and an intuitive workbench for end users. All functionality is available
	both from the graphical user interface and from a built-in novel
	domain-specific language, supporting the scientist in interdisciplinary
	research and reproducible analyses through advanced visualization
	of the inputs and the results. New components for Bioclipse 2 include
	a rewritten editor for chemical structures, a table for multiple
	molecules that supports gigabyte-sized files, as well as a graphical
	editor for sequences and alignments. Conclusion: Bioclipse 2 is equipped
	with advanced tools required to carry out complex analysis in the
	fields of bio- and cheminformatics. Developed as a Rich Client based
	on Eclipse, Bioclipse 2 leverages on today's powerful desktop computers
	for providing a responsive user interface, but also takes full advantage
	of the Web and networked (Web/Cloud) services for more demanding
	calculations or retrieval of data. The fact that Bioclipse 2 is based
	on an advanced and widely used service platform ensures wide extensibility,
	making it easy to add new algorithms, visualizations, as well as
	scripting commands. The intuitive tools for end users and the extensible
	architecture make Bioclipse 2 ideal for interdisciplinary and integrative
	research. Bioclipse 2 is released under the Eclipse Public License
	(EPL), a flexible open source license that allows additional plugins
	to be of any license. Bioclipse 2 is implemented in Java and supported
	on all major platforms; Source code and binaries are freely available
	at http://www.bioclipse.net. © 2009 Spjuth et al; licensee BioMed
	Central Ltd.},
  affiliation = {Department of Pharmaceutical Biosciences, Uppsala University, Uppsala,
	Sweden; Wellcome Trust Genome Campus, European Bioinformatics Institute,
	Hinxton, United Kingdom; Max von Pettenkofer-Institut, Ludwig-Maximilians-Universität,
	Munich, Germany},
  art_number = {397},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-74049154443&partnerID=40&md5=a0800931e955f6b92779e0d0153c0be4}
}

@ARTICLE{Sprinkle20119,
  author = {Sprinkle, J.a , Eames, B.b },
  title = {Time-triggered buffers for event-based middleware systems},
  journal = {Innovations in Systems and Software Engineering},
  year = {2011},
  volume = {7},
  pages = {9-22},
  number = {1},
  note = {cited By (since 1996) 0},
  abstract = {Application developers utilizing event-based middleware have sought
	to leverage domain-specific modeling for the advantages of intuitive
	specification, code synthesis, and support for design evolution.
	For legacy and cysber-physical systems, the use of event-based middleware
	may mean that changes in computational platform can result anomalous
	system behavior, due to the presence of implicit temporal dependencies.
	These anomalies are a function not of the component implementation,
	but of the model of computation employed for supporting system composition.
	In order to address these behavioral anomalies, the paper presents
	an approach where time-based blocks are inserted into the system
	to account for the temporal dependencies. An advantage of capturing
	the system composition in a domain-specific modeling language is
	the ability to efficiently re factor an application to include time-triggered,
	event-based schedulers. This paper describes how an existing event-based
	component topology can be modified to permit a time-triggered model
	of computation, with no changes to the existing component software.
	Further, the time-triggered components can be deployed alongside
	standard publish/subscribe methodologies. This strategy is beneficial
	to the maintenance of existing legacy systems upon upgrade, since
	the current operational mode could be maintained with minimal changes
	to the legacy software even under changes to the target platform
	which alter execution speed. These time-triggered layers are discussed
	in three permutations: fully triggered, start triggered, and release
	triggered. A discussion is provided regarding the limitations of
	each approach, and a brief example is given. The example shows how
	to apply these triggering approaches without the modification of
	existing components, but instead through the insertion of triggered
	buffers between legacy components. © Springer-Verlag London Limited
	2010.},
  affiliation = {Department of Electrical and Computer Engineering, University of Arizona,
	1230 E. Speedway Blvd., Bldg. #104, Tucson, AZ 85721-0104, United
	States; Department of Electrical and Computer Engineering, Utah State
	University, 4120 Old Main Hill, Logan, UT 84322-4120, United States},
  author_keywords = {Distributed real-time systems; Embedded systems; Giotto; Logical execution
	time; Model transformations},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-79952247440&partnerID=40&md5=f08f1ac1e37232bc1ab9e6c936874484}
}

@ARTICLE{Sprinkle2004291,
  author = {Sprinkle, J.a , Karsai, G.b },
  title = {A domain-specific visual language for domain model evolution},
  journal = {Journal of Visual Languages and Computing},
  year = {2004},
  volume = {15},
  pages = {291-307},
  number = {3-4},
  note = {cited By (since 1996) 40},
  abstract = {Domain-specific visual languages (DSVLs) are concise and useful tools
	that allow the rapid development of the behavior and/or structure
	of applications in well-defined domains. These languages are typically
	developed specifically for a domain, and have a strong cohesion to
	the domain concepts, which often appear as primitives in the language.
	The strong cohesion between DSVL language primitives and the domain
	is a benefit for development by domain experts, but can be a drawback
	when the domain evolves-even when that evolution appears to be insignificant.
	This paper presents a domain-specific visual language developed expressly
	for the evolution of domain-specific visual languages, and uses concepts
	from graph rewriting to specify and carry out the transformation
	of the models built using the original DSVL. © 2004 Elsevier Ltd.
	All rights reserved.},
  affiliation = {University of California, 333 Cory Hall, Berkeley, CA 94720, United
	States; Inst. for Software Integrated Syst., Vanderbilt University,
	2015 Terrace Place, Nashville, TN 37203, United States},
  author_keywords = {Domain evolution; Domain-specific language; Graph rewriting; Metamodeling;
	XSL},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-3242725264&partnerID=40&md5=ed9529dcb4242ad91ed414667ee4dc81}
}

@ARTICLE{Sprinkle201057,
  author = {Sprinkle, J.a , Rumpe, B.b , Vangheluwe, H.c , Karsai, G.d },
  title = {Metamodelling: State of the art and research challenges},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2010},
  volume = {6100 LNCS},
  pages = {57-76},
  note = {cited By (since 1996) 0},
  abstract = {This chapter discusses the current state of the art, and emerging
	research challenges, for metamodelling. In the state-of-the-art review
	on metamodelling, we review approaches, abstractions, and tools for
	metamodelling, evaluate them with respect to their expressivity,
	investigate what role(s) metamodels may play at run-time and how
	semantics can be assigned to metamodels and the domain-specific modeling
	languages they could define. In the emerging challenges section on
	metamodelling we highlight research issues regarding the management
	of complexity, consistency, and evolution of metamodels, and how
	the semantics of metamodels impacts each of these. © 2010 Springer-Verlag.},
  affiliation = {University of Arizona, Tucson, AZ, United States; RWTH Aachen University,
	Germany; McGill University, Montreal, QC, Canada; Vanderbilt University,
	Nashville, TN, United States},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-78449247669&partnerID=40&md5=d82328138fb4e81a1d6d1754595fcf55}
}

@ARTICLE{Steensgaard-Madsen1999661,
  author = {Steensgaard-Madsen, J.},
  title = {HTEL: A HyperText Expression Language},
  journal = {Software - Practice and Experience},
  year = {1999},
  volume = {29},
  pages = {661-675},
  number = {8},
  note = {cited By (since 1996) 0},
  abstract = {In general, an expression language provides a means to indicate non-constant
	values in expressions. It includes operations to combine values,
	but these will normally disappear when the expression is evaluated.
	HTEL is an expression language to produce HTML-documents. It is presented
	to stimulate a discussion about the structure of hypertext expression
	languages. The operations have been chosen in agreement with what
	is strongly suggested, but not defined, by the HTML-standard. The
	HTEL-interpreter can be used for cgi-programs, i.e. to describe reactions
	when data from a `form' in an HTML-document has been submitted. A
	special tool has been used to build the HTEL-interpreter, as an example
	belonging to a family of interpreters for domain-specific languages.
	Members of that family have characteristics that are closely related
	to structural patterns found in the mark-ups of HTML. HTEL should
	also be seen as a substantial example to witness the applicability
	and relevance of the principles that are applied in the tool used
	for constructing its interpreter.},
  affiliation = {Department of Information Technology, Computer Systems, DTU Building
	344, DK 2800, Lyngby, Denmark},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-0344672308&partnerID=40&md5=9c616c3215f3cd94cef60829333f9f6e}
}

@ARTICLE{Stefanescu2009313,
  author = {Stefanescu, A.a , Wieczorek, S.a , Kirshin, A.b },
  title = {MBT4Chor: A model-based testing approach for service choreographies},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2009},
  volume = {5562 LNCS},
  pages = {313-324},
  note = {cited By (since 1996) 3},
  abstract = {Service choreographies describe the global communication protocols
	between services and testing these choreographies is an important
	task in the context of service-oriented architectures (SOA). Formal
	modeling of service choreographies makes a model-based testing (MBT)
	approach feasible. In this paper we present an MBT approach for SOA
	integration testing based on SAP proprietary choreography models
	called Message Choreography Models (MCM). In our approach, MCMs are
	translated into executable UML models using Java as action language.
	These UML models are used by a UML model execution engine developed
	by IBM for test generation and model debugging. We describe the achievements
	and challenges of our approach based on first experimental evaluation
	conducted at SAP. © 2009 Springer Berlin Heidelberg.},
  affiliation = {SAP Research, CEC Darmstadt, Bleichstr. 8, Darmstadt 64283, Germany;
	IBM Haifa Research Lab, Haifa University, Mount Carmel, Haifa 31905,
	Israel},
  author_keywords = {Choreography Modeling; Domain Specific Language; Model Transformation;
	Model-Based Testing; Service Integration; SOA},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-71049173291&partnerID=40&md5=954ab809dc0210d9d389956ed37900db}
}

@CONFERENCE{Stefanescu201012,
  author = {Stefanescu, A.a , Wieczorek, S.a , Wendland, M.-F.b },
  title = {Using the UML testing profile for enterprise service choreographies},
  year = {2010},
  pages = {12-19},
  note = {cited By (since 1996) 1},
  abstract = {In this paper we present an approach of using model-driven technologies
	for testing of service component interactions. We report on an industrial
	experiment with a novel combination of existing UML standards, i.e.,
	the UML Testing Profile (U2TP), in conjunction with proprietary domain
	specific languages (DSLs). Many model-based testing (MBT) approaches
	use the UML 2 standard, but very few of them use also U2TP. Moreover,
	in practice UML coexists with DSLs which makes the overall integration
	not easy. We present our experiences and challenges of a U2TP-enabled
	MBT approach for a DSL for enterprise service choreographies, which
	describe the communication protocols between service components.
	The proposed workflow directly translates choreographies into UML
	models augmented with U2TP stereotypes, which are further loaded
	into our FOKUS!MBT tool chain. The tool provides an implementation
	of the U2TP standalone meta-model along with test case and test data
	generators to describe a holistic test process within one dedicated
	meta-model for testing concerns. © 2010 IEEE.},
  affiliation = {SAP Research, Darmstadt, Germany; Fraunhofer FOKUS, Berlin, Germany},
  art_number = {5598074},
  document_type = {Conference Paper},
  journal = {Proceedings - 36th EUROMICRO Conference on Software Engineering and
	Advanced Applications, SEAA 2010},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-78449303537&partnerID=40&md5=93f25d0607817a4979c6056fbed93168}
}

@ARTICLE{Steil201158,
  author = {Steil, D.A.a b , Pate, J.R.c , Kraft, N.A.c , Smith, R.K.c , Dixon,
	B.c , Ding, L.c , Parrish, A.c },
  title = {Patrol routing expression, execution, evaluation, and engagement},
  journal = {IEEE Transactions on Intelligent Transportation Systems},
  year = {2011},
  volume = {12},
  pages = {58-72},
  number = {1},
  note = {cited By (since 1996) 0},
  abstract = {Recommended patrol routes can be used by organizations such as police
	agencies, emergency medical responders, and taxi services whose agents
	patrol roadway segments at proper times to assist or deter their
	target events. The creation of optimal complementary patrol routes
	for multiple agents targeting temporal event hotspots and minimizing
	travel distance is an NP-hard combinatorial problem that belongs
	to a class of problems known as the vehicle routing problem with
	time windows (VRPTW). Traffic safety patrol routing problems share
	many characteristics of VRPTW problems but differ in ways that prevent
	the application of existing solutions. In our approach, nondeterministic
	patrol routing algorithms are used to specify the movements of simulated
	mobile agents on a roadway system. Nondeterminism is critical in
	the traffic safety patrol routing domain, as rigidity and predictability
	can negatively impact the effectiveness of law enforcement agents'
	efforts.This paper addresses the problem of expressing, executing,
	evaluating, and engaging patrol routing algorithms that target event
	hotspots on roadways. The patrol algorithms are first expressed using
	Turn, which is our extensible domain-specific language (DSL) created
	for this purpose. Algorithms specified using Turn syntax are then
	executed in a custom simulation environment. Utilizing predefined
	metrics, users evaluate the resulting patrol routes to ensure that
	the criteria of interest in a given patrol context are met. Acceptable
	patrol routes are then engaged by end users via a web-based geographic
	information system (GIS) portal. To demonstrate the applicability
	and efficacy of our approach, we present two illustrative case studies.
	© 2010 IEEE.},
  affiliation = {Department of Computer Science, Harding University, Searcy, AR 72149-0764,
	United States; Center for Advanced Public Safety, University of Alabama,
	Tuscaloosa, AL 35487-0290, United States; Department of Computer
	Science, University of Alabama, Tuscaloosa, AL 35487-0290, United
	States},
  art_number = {5559450},
  author_keywords = {Automobile crash response; patrol routing algorithm; patrol simulation;
	vehicle routing},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-79952071553&partnerID=40&md5=6fadab052de9bf85860b12887a656e09}
}

@CONFERENCE{Stephenson200753,
  author = {Stephenson, Z., McDermid, J.},
  title = {Using model checking to validate style-specific architectural refactoring
	patterns},
  year = {2007},
  pages = {53-62},
  note = {cited By (since 1996) 0},
  abstract = {When developing a new domain-specific architectural style, there can
	be uncertainty about the feasibility of using that style. In particular,
	the HADES architectural style contains refactoring patterns intended
	to remove undesirable scheduling features such as deadlock and livelock,
	but these patterns have not yet been fully validated. We report on
	the translation between the HADES structure and the input languages
	for two popular model checkers (SPIN and NuSMV) to help validate
	these patterns. We found model checking to be a valuable asset in
	confirming the presence of undesirable features.},
  affiliation = {High-Integrity Systems Engineering Group, Department of Computer Science,
	University of York, Heslington, York YO10 5DD, United Kingdom},
  art_number = {4402764},
  document_type = {Conference Paper},
  journal = {Proceedings - International Conference on Software Engineering},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-47749098529&partnerID=40&md5=582072a505fff2d3080fd0fdc0d29082}
}

@ARTICLE{Strasser20104687,
  author = {Strasser, T., Peters, T., Jagle, H., Zrenner, E., Wilke, R.},
  title = {An integrated domain specific language for post-processing and visualizing
	electrophysiological signals in Java.},
  journal = {Conference proceedings : ... Annual International Conference of the
	IEEE Engineering in Medicine and Biology Society. IEEE Engineering
	in Medicine and Biology Society. Conference},
  year = {2010},
  volume = {2010},
  pages = {4687-4690},
  note = {cited By (since 1996) 0},
  abstract = {Electrophysiology of vision - especially the electroretinogram (ERG)
	- is used as a non-invasive way for functional testing of the visual
	system. The ERG is a combined electrical response generated by neural
	and non-neuronal cells in the retina in response to light stimulation.
	This response can be recorded and used for diagnosis of numerous
	disorders. For both clinical practice and clinical trials it is important
	to process those signals in an accurate and fast way and to provide
	the results as structured, consistent reports. Therefore, we developed
	a freely available and open-source framework in Java (http://www.eye.uni-tuebingen.de/project/idsI4sigproc).
	The framework is focused on an easy integration with existing applications.
	By leveraging well-established software patterns like pipes-and-filters
	and fluent interfaces as well as by designing the application programming
	interfaces (API) as an integrated domain specific language (DSL)
	the overall framework provides a smooth learning curve. Additionally,
	it already contains several processing methods and visualization
	features and can be extended easily by implementing the provided
	interfaces. In this way, not only can new processing methods be added
	but the framework can also be adopted for other areas of signal processing.
	This article describes in detail the structure and implementation
	of the framework and demonstrate its application through the software
	package used in clinical practice and clinical trials at the University
	Eye Hospital Tuebingen one of the largest departments in the field
	of visual electrophysiology in Europe.},
  affiliation = {Institute for Ophthalmic Research, Centre for Ophthalmology, University
	of Tuebingen, Germany.},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-79953159867&partnerID=40&md5=16ad91bfef3fdf90c91ee22dc8daf538}
}

@CONFERENCE{Strembeck201164,
  author = {Strembeck, M.},
  title = {Testing policy-based systems with scenarios},
  year = {2011},
  pages = {64-71},
  note = {cited By (since 1996) 0},
  abstract = {Policy-based systems consist of interacting software artifacts and,
	at first glance, can be tested as any other software system. In a
	policy-based system, however, the behavior of system entities may
	change dynamically and frequently, depending on the policy rules
	governing this behavior. Therefore, policy-based systems demand for
	a testing approach that especially allows for the testing of dynamically
	changing system behavior. Thus, testing of policy rules has to check
	if the behavior that is actually enforced by a set of policies, conforms
	to the intended behavior of the corresponding system entities. Scenarios
	are an important means to specify behavior of software entities.
	In this paper, we introduce an approach to test policy-based systems
	with scenarios, and present an (embedded) domain-specific language
	for scenario-based testing.},
  affiliation = {Institute of Information Systems, New Media Lab., Vienna University
	of Economics and Business (WU Vienna), Austria},
  author_keywords = {Policy-based systems; Scenario-based testing},
  document_type = {Conference Paper},
  journal = {Proceedings of the 10th IASTED International Conference on Software
	Engineering, SE 2011},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-79958156394&partnerID=40&md5=c06d3c5b9d035788b066c1eda2beb7c4}
}

@ARTICLE{Strembeck20091253,
  author = {Strembeck, M.a , Zdun, U.b },
  title = {An approach for the systematic development of domain-specific languages},
  journal = {Software - Practice and Experience},
  year = {2009},
  volume = {39},
  pages = {1253-1292},
  number = {15},
  note = {cited By (since 1996) 8},
  abstract = {Bullding tailored software systems for a particular application domain
	is a complex task. For this reason, domain-specific languages (DSLs)
	receive a constantly growing attention in recent years. So far the
	main focus of DSL research is on case studies and experience reports
	for the development of individual DSLs, design approaches and implementation
	techniques for DSLs, and the integration of DSLs with other software
	development approaches on a technical level. In this paper, we identify
	and describe the different activities that we conduct when engineering
	a DSL, and describe how these activities can be combined in order
	to define a tailored DSL engineering process. Our research results
	are based on the experiences we gained from multiple different DSL
	development projects and prototyping experiments. Copyright © 2009
	John Wiley & Sons, Ltd.},
  affiliation = {Institute of Information Systems, New Media Lab., Vienna University
	of Economics and Business (WU Vienna), Austria; Distributed Systems
	Group, Information Systems Institute, Vienna University of Technology,
	Austria},
  author_keywords = {Applied software engineering; Domain-specific languages; Language
	engineering; Model-driven software development},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-70349874815&partnerID=40&md5=bbc52db4e313c96d4c85dd13670e61ce}
}

@ARTICLE{Striegnitz20097,
  author = {Striegnitz, J.a , Davis, K.b },
  title = {Multiparadigm programming in Object-Oriented languages: Current research:
	Report on the workshop MPOOL08 at ECOOP 2008},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2009},
  volume = {5475 LNCS},
  pages = {7-17},
  note = {cited By (since 1996) 0},
  abstract = {While OO has become ubiquitously employed for design, implementation,
	and even conceptualization, many practitioners recognize the concomitant
	need for other programming paradigms according to problem domain.
	Nevertheless, the choice of a programming paradigm is strongly influenced
	by the supporting programming language facilities. In turn, choice
	of programming language is usually highly constrained by practical
	considerations. We seek answers to the question of how to address
	the need for other programming paradigms, or even domain specific
	languages, in the general context of OO languages. It is clear that
	this field is active and fluid: novel, disparate approaches and techniques
	are still being discovered or invented, and this very novelty adds
	a significant element of intellectual entertainment. This article
	describes the cross section of research efforts reported at the workshop
	on Multiparadigm Programming in Object-Oriented Languages held at
	the 2008 European Conference on Object-Oriented Programming. © 2009
	Springer Berlin Heidelberg.},
  affiliation = {University of Applied Sciences Regensburg, Regensburg 93053, Germany;
	Los Alamos National Laboratory, Los Alamos NM 87545, United States},
  author_keywords = {C# 3.0; CLOS; Closures; Delegates; Design patterns; Eiffel; Extension
	methods; Function objects; Functional programming; Java 7; Multiparadigm
	programming; Object-oriented programming; OCaml; Open classes; Scala;
	Smalltalk},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-69849095468&partnerID=40&md5=fbf766b71ff58161e219edea87dd6e3c}
}

@ARTICLE{Störrle20113,
  author = {Störrle, H.},
  title = {VMQL: A visual language for ad-hoc model querying},
  journal = {Journal of Visual Languages and Computing},
  year = {2011},
  volume = {22},
  pages = {3-29},
  number = {1},
  note = {cited By (since 1996) 0},
  abstract = {In large scale model based development, analysis level models are
	more like knowledge bases than engineering artifacts. Their effectiveness
	depends, to a large degree, on the ability of domain experts to retrieve
	information from them ad-hoc. For large scale models, however, existing
	query facilities are inadequate. The visual model query language
	(VMQL) is a novel approach that uses the respective modeling language
	of the source model as the query language, too. The semantics of
	VMQL is defined formally based on graphs, so that query execution
	can be defined as graph matching. VMQL has been applied to several
	visual modeling languages, implemented, and validated in small case
	studies, and several controlled experiments. © 2010 Elsevier Ltd.},
  affiliation = {Department of Informatics and Mathematical Modeling, Technical University
	of Denmark, Richard Petersens Plads, 2800 Lyngby, Denmark},
  author_keywords = {Domain specific languages (DSL); End user modelers; Model querying;
	Object constraint language (OCL); Unified modeling language (UML)},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-79651472391&partnerID=40&md5=8b71f6a6bfbdb44676db7b00ec992f1b}
}

@CONFERENCE{Stürmer2009653,
  author = {Stürmer, G., Mangler, J., Schikuta, E.},
  title = {A domain specific language and workflow execution engine to enable
	dynamic workflows},
  year = {2009},
  pages = {653-658},
  note = {cited By (since 1996) 0},
  abstract = {Abstract-Workflow engines [1][2][3] often being based on WS-BPEL,
	currently rely on a mix of recovery / modification strategies [4]
	that are either part of the workflow description, part of the workflow
	engine, or realized as plugins to the workflow engine. To foster
	the development of distributed cloud-based workflow engines and novel
	repair algorithms, workflow engines have to be modularized in order
	to overcome the static and inflexible APIs provided by these workflow
	engines. Dynamic features gained by a modularization include the
	creation of external modules to monitor as well as modify a workflow
	to provide error handling in conjunction with Service Level Agreement
	(SLA) constraints. The aim of this paper is to present a flexible
	Workflow Execution Engine to facilitate the development of a new
	dynamic infrastructure to realize dynamic workflow engines with a
	focus on cloud-based environments.},
  affiliation = {Faculty of Computer Science, University of Vienna, Austria},
  art_number = {5207863},
  document_type = {Conference Paper},
  journal = {Proceedings - 2009 IEEE International Symposium on Parallel and Distributed
	Processing with Applications, ISPA 2009},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-70449486855&partnerID=40&md5=2319a0b584b40c67132b8394f0aacafa}
}

@ARTICLE{Su2006523,
  author = {Su, H.a , Hemingway, G.a , Chen, K.b , Koo, T.J.c },
  title = {Model-based tool-chain infrastructure for automated analysis of embedded
	systems},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2006},
  volume = {4218 LNCS},
  pages = {523-537},
  note = {cited By (since 1996) 1},
  abstract = {In many safety-critical applications of embedded systems, the system
	dynamics exhibits hybrid behaviors. To enable automatic analysis
	of these embedded systems, many analysis tools have been developed
	based on hybrid automata model. These tools are constructed by their
	own domain-specific modeling languages (DSMLs) but they are different
	in various aspects. To enable meaningful semantic interpretation
	of DSMLs, we propose an infrastructure for semantic anchoring that
	facilitates the transformational specification of DSML semantics.
	In the semantic anchoring infrastructure, the semantics of a DSML
	can be anchored to a well-defined semantic unit, which captures the
	operational semantics of hybrid automaton, via model transformation.
	The Abstract State Machine (ASM) is used as the underlying formal
	framework for the semantic unit. The semantics of a DSML is defined
	by specifying the transformation between the abstract syntax metamodel
	of the DSML and that of the semantic unit. The infrastructure can
	also enable model exchange among DSMLs while referring to the common
	semantic unit. Hence, hybrid automata based DSMLs can be integrated
	to form a meaningful tool chain by deploying this proposed infrastructure.
	In this paper, we demonstrate how effective the tool-chain infrastructure
	is by considering a practical case study involving the hybrid automata
	DSMLs, HyVisual and ReachLab. © Springer-Verlag Berlin Heidelberg
	2006.},
  affiliation = {Department of Electrical Engineering and Computer Science, Vanderbilt
	University, Nashville, TN, United States; Motorola Labs., Motorola
	Inc., Schaumburg, IL, United States; Departments of Electronics Engineering
	and Computer Science, Shantou University, Shantou, Guangdong, China},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-33845214899&partnerID=40&md5=3aea0fec6b273ae22c6b9c473096d9c4}
}

@CONFERENCE{Subramonian20044273,
  author = {Subramonian, V., Gill, C.},
  title = {A generative programming framework for adaptive middleware},
  year = {2004},
  volume = {37},
  pages = {4273-4282},
  note = {cited By (since 1996) 0},
  abstract = {Component middleware technologies such as the CORBA Component Model
	(CCM), J2EE, and .NET, were developed to address many limitations
	like interdependencies between services and object interfaces, limited
	re-use, of first-generation middleware technologies such as CORBA
	2.x, XML, and SOAP. These component technologies have addressed a
	wide range of application domains, but unfortunately for distributed
	real-time and embedded (DRE) systems, the focus of these technologies
	has been primarily on functional and not quality of service (QoS)
	properties. Research on QoS-aware component models such as the CIAO
	project shows that there is a fundamental difference between configuration
	of functional and QoS properties even within such a unified component
	model: the dominant decomposition of functional properties is essentially
	object-oriented, while the dominant decomposition of QoS properties
	is essentially aspect-oriented. In this paper, we describe how a
	focus on aspect frameworks for configuring QoS properties both complements
	and extends QoS-aware component models. This paper makes three main
	contributions to the state of the art in DRE systems middleware.
	First, it describes a simple but representative problem for configuring
	QoS aspects that cut across architectural layers, system and distribution
	boundaries, which motivates our focus on aspect frameworks. Second,
	it provides a formalization of that problem using first order logic
	- Infrastructure Configuration Logic - which both guides the design
	of aspect configuration infrastructure, and offers a way to connect
	these techniques with model-integrated computing approaches to further
	reduce the programming burden on DRE system developers. Third, it
	describes alternative mechanisms to ensure correct configuration
	of the aspects involved, and notes the phases of the DRE system lifecycle
	at which each such configuration mechanism is most appropriate.},
  affiliation = {Dept. of Comp. Sci. and Engineering, Washington University, St. Louis,
	MO},
  art_number = {STASS04},
  author_keywords = {Adaptive and reflective middleware; First order logic; Generative
	programming; System aspects},
  document_type = {Conference Paper},
  journal = {Proceedings of the Hawaii International Conference on System Sciences},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-12344316718&partnerID=40&md5=4e2abc5116e12cf67c3c485b0f38a0a4}
}

@CONFERENCE{Sugiki2010322,
  author = {Sugiki, A.a , Kato, K.a , Ishii, Y.b , Taniguchi, H.b , Hirooka,
	N.b },
  title = {Kumoi: A high-level scripting environment for collective virtual
	machines},
  year = {2010},
  pages = {322-329},
  note = {cited By (since 1996) 0},
  abstract = {We have designed and implemented a scripting environment called "Kumoi"
	for managing collective VMs in a large-scale data center. Kumoi is
	unlike other scripting environments because it exploits strong typing
	with type inference and high-level description. Kumoi introduces
	several advancements, including treating virtual machines as first-class
	objects and decoupling the scripting model and its execution for
	hiding as many details as possible. We implemented Kumoi as an embedded
	domain-specific language based on Scala along with distributed agents
	running on each physical machine. Evaluation using example scripts
	showed that an administrator can more concisely write the instructions
	for performing complex VM lifecycle management tasks. Use of this
	environment should improve management efficiency and agility. © 2010
	IEEE.},
  affiliation = {Department of Computer Science, University of Tsukuba, Tsukuba, Japan;
	Fujisoft Inc., Yokohama, Japan},
  art_number = {5695619},
  author_keywords = {Cloud computing; Clusters; Data center; Management shells; Virtual
	machines},
  document_type = {Conference Paper},
  journal = {Proceedings of the International Conference on Parallel and Distributed
	Systems - ICPADS},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-79951748157&partnerID=40&md5=0521d3698b43293d7ee7030fb4f0fe82}
}

@CONFERENCE{Sujeeth2011609,
  author = {Sujeeth, A.K.a , Lee, H.a , Brown, K.J.a , Chafi, H.a , Wu, M.a ,
	Atreya, A.R.a , Olukotun, K.a , Rompf, T.b , Odersky, M.b },
  title = {OptiML: An implicitly parallel domain-specific language for machine
	learning},
  year = {2011},
  pages = {609-616},
  note = {cited By (since 1996) 1},
  abstract = {As the size of datasets continues to grow, machine learning applications
	are becoming increasingly limited by the amount of available computational
	power. Taking advantage of modern hardware requires using multiple
	parallel programming models targeted at different devices (e.g. CPUs
	and GPUs). However, programming these devices to run efficiently
	and correctly is difficult, error-prone, and results in software
	that is harder to read and maintain. We present OptiML, a domain-specific
	language (DSL) for machine learning. OptiML is an implicitly parallel,
	expressive and high performance alternative to MATLAB and C++. OptiML
	performs domain-specific analyses and optimizations and automatically
	generates CUDA code for GPUs. We show that OptiML outperforms explicitly
	parallelized MATLAB code in nearly all cases. Copyright 2011 by the
	author(s)/owner(s).},
  affiliation = {Stanford University, 353 Serra St., Stanford, CA 94305, United States;
	École Polytechnique Fédérale de Lausanne (EPFL), CH-1015 Lausanne,
	Switzerland},
  document_type = {Conference Paper},
  journal = {Proceedings of the 28th International Conference on Machine Learning,
	ICML 2011},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-80053441759&partnerID=40&md5=eaf32ef5f40c14a86b660a7ae3dbe3cb}
}

@CONFERENCE{Sulistyo20096,
  author = {Sulistyo, S., Prinz, A.},
  title = {Recursive modeling for completed code generation},
  year = {2009},
  pages = {6},
  note = {cited By (since 1996) 0},
  abstract = {Model-Driven Development is promising to software development because
	it can reduce the complexity and cost of developing large software
	systems. The basic idea is the use of different kinds of models during
	the software development process, transformations between them, and
	automatic code generation at the end of the development. But unlike
	the structural parts, fully-automated code generation from the behavior
	parts is still hard, if it works at all, restricted to specific application
	areas using a domain specific language, DSL. This paper proposes
	an approach to model the behavior parts of a system and to embed
	them into the structural models. The underlying idea is recursive
	refinements of activity elements in an activity diagram. With this,
	the detail generated code depends on the depth at which the refinements
	are done, i.e. if the lowest level of activities is mapped into activities
	executors, the completed code can be obtained. © 2009 ACM.},
  affiliation = {University of Agder, Groosveien 36, 4876 Grimstad, Norway},
  author_keywords = {Activity executor; Code generation; MDD; Recursive modeling},
  document_type = {Conference Paper},
  journal = {ACM International Conference Proceeding Series},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-70350694411&partnerID=40&md5=a55a2d7ac75a7ea6d906b0febe479b8d}
}

@ARTICLE{Sun2009178,
  author = {Sun, Y.a , Demirezen, Z.a , Jouault, F.b , Tairas, R.a , Gray, J.a
	},
  title = {A model engineering approach to tool interoperability},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2009},
  volume = {5452},
  pages = {178-187},
  note = {cited By (since 1996) 2},
  abstract = {The integration of various tools is a common requirement throughout
	the software development process. It is often desirable to consult
	several tools that perform similar functionalities in the same domain
	to obtain different perspectives and results to assist design and
	maintenance decisions. In many cases, tool interoperability requires
	the generalization of tool-specific data, which necessitates homogenizing
	the data such that intellectual assets can be shared through a common
	framework (e.g., the integration of results from various clone detection
	tools). This tool demonstration summary presents a software language
	engineering solution technique that uses Model-Driven Engineering
	to address tool interoperability. A specific focus of the paper is
	a demonstration of model transformation applied to the task of homogenizing
	different data formats among similar tools. The challenges of tool
	integration are discussed in the paper, along with a detailed case
	study that highlights the benefits of applying a model transformation
	solution to tool interoperability.},
  affiliation = {Department of Computer and Information Sciences, University of Alabama
	at Birmingham; AtlanMod (INRIA and EMN), Nantes, France},
  author_keywords = {AMMA; Domain-specific languages; Model engineering; Model transformation;
	Tool interoperability},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-67649986888&partnerID=40&md5=e41263ca1efc7f554539b0cb25368e84}
}

@CONFERENCE{Suzuki201167,
  author = {Suzuki, I.a , Tsunoda, K.a b , Hishiyama, R.a },
  title = {Game description language and frameworks for Langrid gaming},
  year = {2011},
  pages = {67-73},
  note = {cited By (since 1996) 0},
  abstract = {Langrid Gaming, which provides multilingual communication for gaming
	simulations using translation services provided on the Language Grid,
	is a useful educational tool and can contribute to the resolution
	of international social conflicts. This tool has been enhanced on
	the basis of the experience and know-how obtained from the participants'
	comments and suggestions. However, the object and the model object
	of the gaming tool are usually defined as Java or PHP objects, which
	makes it difficult for non-programmers to develop a new game. In
	this study, we propose a framework to implement various types of
	Langrid Gaming easily. In particular, we designed a new domain specific
	language (DSL) called 'Karina' to describe targeted games, and implemented
	a translator to convert Karina script into CGI programs. This script
	development environment makes game building easy and simplifies the
	development procedures, regardless of whether the gaming developer
	is a programmer or not. © 2011 ACM.},
  affiliation = {Graduate School of Creative Science and Engineering, Waseda Univercity,
	3-4-1 Okubo, Shinjuku-Ku, Tokyo, Japan; Nippon Telegraph and Telephone
	Corporation (NTT), Japan},
  author_keywords = {gaming simulation; intercultural collaboration; language grid},
  document_type = {Conference Paper},
  journal = {SIGDOC'11 - Proceedings of the 29th ACM International Conference
	on Design of Communication},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-80054782605&partnerID=40&md5=ef9290f18c2275f32f1609e37ef46455}
}

@ARTICLE{Svendsen2011253,
  author = {Svendsen, A.a b , Haugen, Ø.a , Møller-Pedersen, B.b },
  title = {Analyzing variability: Capturing semantic ripple effects},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2011},
  volume = {6698 LNCS},
  pages = {253-269},
  note = {cited By (since 1996) 0},
  abstract = {This paper shows how to incrementally analyze how variability described
	in the Common Variability Language (CVL) affects the semantics of
	a model in a domain-specific language (DSL). CVL is a generic language
	for modeling variability. Using Alloy for definition of semantics
	we perform analysis to capture the elements in the model, which are
	semantically affected by applying the variabilities specified by
	the CVL model. An extension to the CVL editor is provided to automate
	the analysis. To illustrate the approach, we combine CVL with the
	Train Control Language (TCL) to capture how the semantics of TCL
	models are affected when applying CVL to them. We show how the analysis
	can be applied e.g., for testing. © 2011 Springer-Verlag.},
  affiliation = {SINTEF, Blindern, 0314 Oslo, Norway; Department of Informatics, University
	of Oslo, Blindern, 0316 Oslo, Norway},
  author_keywords = {Alloy; Common Variability Language; Language composition; model analysis;
	semantic modifications; Train Control Language},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-79959279684&partnerID=40&md5=ac09d3f0b0232bc54ec3d6e1aca7ceb0}
}

@CONFERENCE{Svendsen2010245,
  author = {Svendsen, A.a b , Møller-Pedersen, B.b , Haugen, Ø.a , Endresen,
	J.c , Carlson, E.c },
  title = {Formalizing train control language: Automating analysis of train
	stations},
  year = {2010},
  volume = {114},
  pages = {245-256},
  note = {cited By (since 1996) 0},
  abstract = {The Train Control Language (TCL) is a domain-specific language that
	allows automation of the production of interlocking source code.
	From a graphical editor a model of a train station is created. This
	model can then be transformed to other representations, e.g. an interlocking
	table and functional blocks, keeping the representations internally
	consistent. Formal methods are mathematical techniques for precisely
	expressing a system, contributing to the reliability and robustness
	of the system through analysis. Traditionally, applying formal methods
	involves a high cost. This paper presents a formalization of TCL,
	including its behavior expressed in the constraint solving language
	Alloy. We show how analysis of station models can be performed automatically.
	Analysis, such as simulation of a station, searching for dangerous
	train movements and deadlocks, is used to illustrate the approach.
	© 2010 WIT Press.},
  affiliation = {SINTEF, Norway; University of Oslo, Norway; ABB, Norway},
  author_keywords = {alloy; domain specific language (DSL); interlocking; model analysis;
	Train Control Language (TCL)},
  document_type = {Conference Paper},
  journal = {WIT Transactions on the Built Environment},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-78649439783&partnerID=40&md5=cff6bf3f141ce977c15400028e4f6f8e}
}

@ARTICLE{Svendsen2008128,
  author = {Svendsen, A.b , Olsen, G.K.b , Endresen, J.a , Moen, T.a , Carlson,
	E.a , Alme, K.-J.a , Haugen, Ø.b },
  title = {The future of train signaling},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2008},
  volume = {5301 LNCS},
  pages = {128-142},
  note = {cited By (since 1996) 4},
  abstract = {Producing the source code for a railway interlocking system based
	on the description of a station has traditionally been a multistage
	manual process. We show how this process can be automated and made
	less error-prone by introducing model-driven development (MDD). This
	paper addresses the experience of developing a Domain Specific Language
	(DSL) to describe railway stations, Train Control Language (TCL),
	and tools to support this language. In the railroad domain where
	there are extreme safety requirements, it is essential to show that
	consistency and completeness can be assured. We address how the model
	is used to generate several different representations for different
	purposes. We look at advantages and challenges with our approach,
	and we discuss improvements to existing technologies to support our
	case better. © 2008 Springer-Verlag Berlin Heidelberg.},
  affiliation = {ABB, Bergerveien 12, Billingstad 1375, Norway; SINTEF, Forskningsveien
	1, Oslo, Norway},
  author_keywords = {DSL; Interlocking; Model-driven development; MoSiS; Signaling; Train},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-56649097179&partnerID=40&md5=a405227819b9ddc54ec2b2909c4e89ea}
}

@CONFERENCE{Svensson20102065,
  author = {Svensson, J., Claessen, K., Sheeran, M.},
  title = {GPGPU kernel implementation and refinement using Obsidian},
  year = {2010},
  volume = {1},
  number = {1},
  pages = {2065-2074},
  note = {cited By (since 1996) 2},
  abstract = {Obsidian is a domain specific language for data-parallel programming
	on graphics processors (GPUs). It is embedded in the functional programming
	language Haskell. The user writes code using constructs familiar
	from Haskell (like map and reduce), recursion and some specially
	designed combinators for combining GPU programs. NVIDIA CUDA code
	is generated from these high level descriptions, and passed to the
	nvcc compiler [1]. Currently, we consider only the generation of
	single kernels, and not their coordination. This paper is focussed
	on how the user should work with Obsidian, starting with an obviously
	correct (or welltested) description of the required function, and
	refining it by the introduction of constructs to give finer control
	of the computation on the GPU. For some combinators, this approach
	results in CUDA code with satisfactory performance, promising increased
	productivity, as the high level descriptions are short and uncluttered.
	But for other combinators, the performance of generated code is not
	yet satisfactory. Ways to tackle this problem and plans to integrate
	Obsidian with another higher-level embedded language for GPU programming
	in Haskell are briefly discussed.},
  affiliation = {CSE Dept., Chalmers University of Technology, Gothenburg, Sweden},
  author_keywords = {Data-parallel; Embedded language; GPUs; Haskell},
  document_type = {Conference Paper},
  journal = {Procedia Computer Science},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-78650298274&partnerID=40&md5=891d2bb8e2e9b441d39ae3119bc6ca83}
}

@ARTICLE{Svensson2011156,
  author = {Svensson, J., Sheeran, M., Claessen, K.},
  title = {Obsidian: A domain specific embedded language for parallel programming
	of graphics processors},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2011},
  volume = {5836 LNCS},
  pages = {156-173},
  note = {cited By (since 1996) 0},
  abstract = {We present a domain specific language, embedded in Haskell, for general
	purpose parallel programming on GPUs. Our intention is to explore
	the use of connection patterns in parallel programming. We briefly
	present our earlier work on hardware generation, and outline the
	current state of GPU architectures and programming models. Finally,
	we present the current status of the Obsidian project, which aims
	to make GPU programming easier, without relinquishing detailed control
	of GPU resources. Both a programming example and some details of
	the implementation are presented. This is a report on work in progress.
	© 2011 Springer-Verlag.},
  affiliation = {Chalmers University of Technology, Göteborg, Sweden},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-80053995458&partnerID=40&md5=e7d010f1b74ee67d48ef9b8c8084c47c}
}

@CONFERENCE{Swint2005144,
  author = {Swint, G.S.a , Pu, C.a , Jung, G.a , Yan, W.a , Koh, Y.a , Wu, Q.a
	, Consel, C.b , Sahai, A.c , Moriyama, K.d },
  title = {Clearwater: Extensible, flexible, modular code generation},
  year = {2005},
  pages = {144-153},
  note = {cited By (since 1996) 5},
  abstract = {Distributed applications typically interact with a number of heterogeneous
	and autonomous components that evolve independently. Methodical development
	of such applications can benefit from approaches based on domain-specific
	languages (DSLs). However, the evolution and customization of heterogeneous
	components introduces significant challenges to accommodating the
	syntax and semantics of a DSL in addition to the heterogeneous platforms
	on which they must run. In this paper, we address the challenge of
	implementing code generators for two such DSLs that are flexible
	(resilient to changes in generators or input formats), extensible
	(able to support multiple output targets and multiple input variants),
	and modular (generated code can be re-written). Our approach, Clearwater,
	leverages XML and XSLT standards: XML supports extensibility and
	mutability for in-progress specification formats, and XSLT provides
	flexibility and extensibility for multiple target languages. Modularity
	arises from using XML meta-tags in the code generator itself, which
	supports controlled addition, subtraction, or replacement to the
	generated code via XML-weaving. We discuss the use of our approach
	and show its advantages in two non-trivial code generators: the Infopipe
	Stub Generator (ISG) to support distributed flow applications, and
	the Automated Composable Code Translator to support automated distributed
	application deployment. As an example, the ISG accepts as input an
	XML description and generates output for C, C++, or Java using a
	number of communications platforms such as sockets and publish-subscribe.
	Copyright 2005 ACM.},
  affiliation = {Georgia Institute of Technology, 801 Atlantic Drive, Atlanta, GA 30332-0280,
	United States; INRIA/LaBRI, Bordeaux, France; HP Laboratories, Palo
	Alto, CA, United States; Sony Corp., Tokyo, Japan},
  author_keywords = {AXpect; Clearwater; Code generation; DSL; Infopipes; ISG},
  document_type = {Conference Paper},
  journal = {20th IEEE/ACM International Conference on Automated Software Engineering,
	ASE 2005},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-47249140751&partnerID=40&md5=041a8ea2e12b95a5713f03f99c2ee191}
}

@ARTICLE{Szugyi2011461,
  author = {Szugyi, Z., Sinkovics, Á., Pataki, N., Porkoláb, Z.},
  title = {C++ metastring library and its applications},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2011},
  volume = {6491 LNCS},
  pages = {461-480},
  note = {cited By (since 1996) 0},
  abstract = {C++ template metaprogramming is an emerging direction of generative
	programming: with proper template definitions we can enforce the
	C++ compiler to execute algorithms at compilation time. Template
	metaprograms have become essential part of today's C++ programs of
	industrial size; they provide code adoptions, various optimizations,
	DSL embedding, etc. Besides the compilation time algorithms, template
	metaprogram data-structures are particularly important. From simple
	typelists to more advanced STL-like data types there are a variety
	of such constructs. Interesting enough, until recently string, as
	one of the most widely used data type of programming, has not been
	supported. Although, boost::mpl::string is an advance in this area,
	it still lacks the most fundamental string operations. In this paper,
	we analysed the possibilities of handling string objects at compilation
	time with a metastring library. We created a C++ template metaprogram
	library that provides the common string operations, like creating
	sub-strings, concatenation, replace, and similar. To provide real-life
	use-cases we implemented two applications on top of our Metastring
	library. One use case utilizes compilation time inspection of input
	in the domain of pattern matching algorithms, thus we are able to
	select the more optimal search method at compilation time. The other
	use-case implements safePrint, a type-safe version of printf - a
	widely investigated problem. We present both the performance improvements
	and extended functionality we have achieved in the applications of
	our Metastring library. © 2011 Springer-Verlag.},
  affiliation = {Department of Programming Languages and Compilers, Eötvös Loránd University,
	Pazmany Peter setany 1/C, H-1117 Budapest, Hungary},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-79251538628&partnerID=40&md5=df3c97422670745ea87dbf43143fa697}
}

@ARTICLE{Sánchez20111008,
  author = {Sánchez, P., Jiménez, M., Rosique, F., Álvarez, B., Iborra, A.},
  title = {A framework for developing home automation systems: From requirements
	to code},
  journal = {Journal of Systems and Software},
  year = {2011},
  volume = {84},
  pages = {1008-1021},
  number = {6},
  note = {cited By (since 1996) 1},
  abstract = {This article presents an integrated framework for the development
	of home automation systems following the model-driven approach. By
	executing model transformations the environment allows developers
	to generate executable code for specific platforms. The tools presented
	in this work help developers to model home automation systems by
	means of a domain specific language which is later transformed into
	code for home automation specific platforms. These transformations
	have been defined by means of graph grammars and template engines
	extended with traceability capabilities. Our framework also allows
	the models to be reused for different applications since a catalogue
	of requirements is provided. This framework enables the development
	of home automation applications with techniques for improving the
	quality of both the process and the models obtained. In order to
	evaluate the benefits of the approach, we conducted a survey among
	developers that used the framework. The analysis of the outcome of
	this survey shows which conditions should be fulfilled in order to
	increase reusability. © 2011 Elsevier Inc. All rights reserved.},
  affiliation = {Systems and Electronic Engineering Division (DSIE), Technical University
	of Cartagena, Campus Muralla del Mar s/n, 30202, Cartagena, Spain},
  author_keywords = {Code generation; Home automation; Model driven},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-79953698410&partnerID=40&md5=83829231ed67efb69cdae2c507ab70da}
}

@ARTICLE{Sánchez20102957,
  author = {Sánchez, Ó., Molina, F., García-Molina, J., Toval, A.},
  title = {Modelsec: A generative architecture for model-driven security},
  journal = {Journal of Universal Computer Science},
  year = {2010},
  volume = {15},
  pages = {2957-2980},
  number = {15},
  note = {cited By (since 1996) 0},
  abstract = {Increasingly, the success of software systems depends largely on how
	their security requirements are satisfied. However, developers are
	challenged in implementing these requirements, mainly because of
	the gap between the specification and implementation, and the technical
	complexities of the current software infrastructures. Recently, Model-Driven
	Security has emerged as a new software development area aimed at
	overcoming these difficulties. This new paradigm takes advantage
	of the benefits of the model driven software development techniques
	for modeling and implementing security concerns. Following this trend,
	this paper proposes a model driven security approach named ModelSec
	that offers a generative architecture for managing security requirements,
	from the requirement elicitation to the implementation stage. This
	architecture automatically generates security software artifacts
	(e.g. security rules) by means of a model transformation chain composed
	of two-steps. Firstly, a security infrastructure dependent model
	is derived from three models, which express the security restrictions,
	the design decisions and the information needed on the target platform.
	Then, security software artifacts are produced from the previously
	generated model. A Domain-Specific Language for security requirements
	management has been built, which is based on a metamodel specifically
	designed for this purpose. An application example that illustrates
	the approach and the Eclipse tools implemented to support it are
	also shown. © J.UCS.},
  affiliation = {University of Murcia, Murcia, Spain},
  author_keywords = {Model driven engineering; Model driven security; Requirements engineering;
	Requirements metamodelling},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-73149125546&partnerID=40&md5=7007401ff3b8698972f496ce1bdb7cf1}
}

@CONFERENCE{Sánchez2009119,
  author = {Sánchez, Ó., Molina, F., Molina, J.G., Toval, A.},
  title = {A model driven approach for generating code from security requirements},
  year = {2009},
  pages = {119-126},
  note = {cited By (since 1996) 0},
  abstract = {Nowadays, Information Systems are present in numerous areas and they
	usually contain data with special security requirements. However,
	these requirements do not often receive the attention that they deserve
	and, on many occasions, they are not considered or are only considered
	when the system development has finished. On the other hand, the
	use of model driven approaches has recently demonstrated to offer
	numerous benefits. This paper tries to align the use of a model driven
	development paradigm with the consideration of security requirements
	from early stages of software development (such as requirements elicitation).
	With this aim, a security requirements metamodel that formalizes
	the definition of this kind of requirements is proposed. Based on
	this metamodel, a Domain Specific Language (DSL) has been built which
	allows both the construction of requirements models with security
	features and the automatic generation of other software artefacts
	from them. An application example that illustrates the approach is
	also shown.},
  affiliation = {Departament of Informatic and Systems, University of Murcia, Spain},
  document_type = {Conference Paper},
  journal = {Security in Information Systems - Proceedings of the 7th International
	Workshop on Security in Information Systems - WOSIS 2009 In Conjunction
	with ICEIS 2009},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-74549117758&partnerID=40&md5=dacebc15c34ee1170624745f80f1e55b}
}

@CONFERENCE{Sérot2011130,
  author = {Sérot, J., Berry, F., Ahmed, S.},
  title = {Implementing stream-processing applications on FPGAs: A DSL-based
	approach},
  year = {2011},
  pages = {130-137},
  note = {cited By (since 1996) 0},
  abstract = {We introduce CAPH, a new domain-specific language (DSL) suited to
	the implementation of stream-processing applications on field programmable
	gate arrays (FPGA). CAPH relies upon the actor/dataflow model of
	computation. Applications are described as networks of purely dataflow
	actors exchanging tokens through unidirectional channels. The behavior
	of each actor is defined as a set of transition rules using pattern
	matching. The CAPH suite of tools currently comprises a reference
	interpreter and a compiler producing both SystemC and synthetizable
	VHDL code. We describe the implementation, with a preliminary version
	of the compiler, of a simple real-time motion detection application
	on a FPGA-based smart camera platform. The language reference manual
	and a prototype compiler are available from http://wwwlasmea.univ-bpclermont.
	fr/Personnel/Jocelyn.Serot/caph.html. © 2011 IEEE.},
  affiliation = {LASMEA, Universite Blaise Pascal, CNRS, Clermont-Ferrand, France},
  art_number = {6044796},
  document_type = {Conference Paper},
  journal = {Proceedings - 21st International Conference on Field Programmable
	Logic and Applications, FPL 2011},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-80455129855&partnerID=40&md5=d76e9193225d64f20e79efae487fd14a}
}

@ARTICLE{Süß2006291,
  author = {Süß, J.G., McComb, T., Kim, S.-K., Wildman, L., Watson, G.},
  title = {MDA-based Re-engineering with object-Z},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2006},
  volume = {4199 LNCS},
  pages = {291-305},
  note = {cited By (since 1996) 1},
  abstract = {This paper describes a practical application of MDA and reverse engineering
	based on a domain-specific modelling language. A well defined metamodel
	of a domain-specific language is useful for verification and validation
	of associated tools. We apply this approach to SIFA, a security analysis
	tool. SIFA has evolved as requirements have changed, and it has no
	metamodel. Hence, testing SIFA's correctness is difficult. We introduce
	a formal metamodelling approach to develop a well-defined metamodel
	of the domain. Initially, we develop a domain model in EMF by reverse
	engineering the SIFA implementation. Then we transform EMF to Object-Z
	using model transformation. Finally, we complete the Object-Z model
	by specifying system behavior. The outcome is a well-defined metamodel
	that precisely describes the domain and the security properties that
	it analyses. It also provides a reliable basis for testing the current
	SIFA implementation and forward engineering its successor. © Springer-Verlag
	Berlin Heidelberg 2006.},
  affiliation = {Information Technology and Electrical Engineering, University of Queensland,
	St. Lucia, 4072, Australia},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-33750334003&partnerID=40&md5=42e2866496189874473382c4f8e4fa54}
}

@ARTICLE{Taentzer200898,
  author = {Taentzer, G.a , Crema, A.b , Schmutzler, R.b , Ermel, C.b },
  title = {Generating domain-specific model editors with complex editing commands},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2008},
  volume = {5088 LNCS},
  pages = {98-103},
  note = {cited By (since 1996) 1},
  abstract = {Domain specific modeling languages are of increasing importance for
	the development of software and other systems. Meta tools are needed
	to support rapid development of domain-specific solutions. Using
	the Eclipse Graphical Modeling Framework (GMF), modeling languages
	are defined by providing a meta model using the MOF/EMF approach.
	Up to now, GMF provides basic editing commands only. It does not
	support the definition of complex editing commands which would allow
	e.g. to insert a complex structure into a diagram in one step. As
	practical tool support for the design and generation of visual editors
	with complex editing operations based on graph transformation, an
	extended version of GMF has been developed and is presented in this
	paper. © 2008 Springer Berlin Heidelberg.},
  affiliation = {Philipps-Universität Marburg, Germany; Technische Universität Berlin,
	Germany},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-56749186157&partnerID=40&md5=f2a48e40330cab3c4495da1774a60f7f}
}

@CONFERENCE{Tagiew2009587,
  author = {Tagiew, R.},
  title = {Towards a framework for management of strategic interaction},
  year = {2009},
  pages = {587-590},
  note = {cited By (since 1996) 2},
  abstract = {Our research aim is to construct a software framework and associated
	language for definition, providing and recording of strategic interactions
	between real-world agents, human and artificial respectively. In
	this paper we present an example of such interaction, which is used
	to show designed and partially implemented concepts. We use FIPA
	based framework for our multi-agent system. The investigated scenario
	is a repeated two player zero sum symmetric matrix game. We also
	conducted a study and analyzed the data.},
  affiliation = {Institute for Computer Science, TU Bergakademie, Freiberg, Germany},
  author_keywords = {Domain-specific languages; Game theory; Human behavior; Multi-agent
	architecture},
  document_type = {Conference Paper},
  journal = {ICAART 2009 - Proceedings of the 1st International Conference on
	Agents and Artificial Intelligence},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-70349454208&partnerID=40&md5=1bcadacbbeada595144a273c543dc9f9}
}

@CONFERENCE{Taha2008,
  author = {Taha, W.},
  title = {Domain-specific languages},
  year = {2008},
  pages = {XXV-XXVIII},
  note = {cited By (since 1996) 0},
  abstract = {Recently, there has been a growing interest in what have come to be
	known as domain-specific languages (DSLs). This paper introduces
	a definition for DSLs, explains how DSLs can have a far-reaching
	impact on our lives, and discusses why DSLs are here to stay. © 2008
	IEEE.},
  affiliation = {Department of Computer Science, Rice University, Houston, TX 77005,
	United States},
  art_number = {4772953},
  document_type = {Conference Paper},
  journal = {2008 International Conference on Computer Engineering and Systems,
	ICCES 2008},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-67649528551&partnerID=40&md5=0d381ea137c0a89b6419da2e027f1d5c}
}

@ARTICLE{Taha2008260,
  author = {Taha, W.},
  title = {A gentle introduction to multi-stage programming, part II},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2008},
  volume = {5235 LNCS},
  pages = {260-290},
  note = {cited By (since 1996) 0},
  abstract = {As domain-specific languages (DSLs) permeate into mainstream software
	engineering, there is a need for economic methods for implementing
	languages. Following up on a paper with a similar title, this paper
	focuses on dynamically typed languages, covering issues ranging from
	parsing to defining and staging an interpreter for an interesting
	subset of Dr. Scheme. Preliminary experimental results indicate that
	the speedups reported in previous work for smaller languages and
	with smaller benchmarks are maintained. © 2008 Springer Berlin Heidelberg.},
  affiliation = {Department of Computer Science, Rice University, Houston, TX, United
	States},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-57049138811&partnerID=40&md5=5e14209b71d8493f0b1dd7d333c2629b}
}

@ARTICLE{Tairas2009332,
  author = {Tairas, R.a , Mernik, M.b , Gray, J.a },
  title = {Using ontologies in the domain analysis of domain-specific languages},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2009},
  volume = {5421},
  pages = {332-342},
  note = {cited By (since 1996) 5},
  abstract = {The design stage of domain-specific language development, which includes
	domain analysis, has not received as much attention compared to the
	subsequent stage of language implementation. This paper investigates
	the use of ontology in domain analysis for the development of a domain-specific
	language. The standard process of ontology development is investigated
	as an aid to determine the pertinent information regarding the domain
	(e.g., the conceptualization of the domain and the common and variable
	elements of the domain) that should be modeled in a language for
	the domain. Our observations suggest that ontology assists in the
	initial phase of domain understanding and can be combined with further
	formal domain analysis methods during the development of a domain-specific
	language.},
  affiliation = {University of Alabama at Birmingham, Birmingham, Alabama, AL, United
	States; University of Maribor, Maribor, Slovenia},
  author_keywords = {Domain analysis; Domain-Specific languages; Ontology},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-67650115226&partnerID=40&md5=cd83b40c7191ca1b1d9586b061bf5685}
}

@CONFERENCE{Talaga201171,
  author = {Talaga, P.G., Chapin, S.J.},
  title = {Guaranteeing strong (X)HTML compliance for dynamic Web applications},
  year = {2011},
  pages = {71-79},
  note = {cited By (since 1996) 0},
  abstract = {We report on the embedding of a domain specific language, (X)HTML,
	into Haskell and demonstrate how this superficial context-free language
	can be represented and rendered to guarantee World Wide Web Consortium
	(W3C) compliance. Compliance of web content is important for the
	health of the Internet, accessibility, visibility, and reliable search.
	While tools exist to verify web content is compliant according to
	the W3C, few systems guarantee that all dynamically produced content
	is compliant. We present CH-(X)HTML, a library for generating compliant
	(X)HTML content for all dynamic content by using Haskell to encode
	the non-trivial syntax of (X)HTML set forth by the W3C. Any compliant
	document can be represented with this library, while a compilation
	or run-time error will occur if non-compliant markup is attempted.
	To demonstrate our library we present examples and performance measurements.},
  affiliation = {Syracuse University, Syracuse, NY, United States},
  author_keywords = {Haskell; W3C compliance; Web development},
  document_type = {Conference Paper},
  journal = {WEBIST 2011 - Proceedings of the 7th International Conference on
	Web Information Systems and Technologies},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-80052562836&partnerID=40&md5=35fb3b0cce6d50e5c4fea592672d4635}
}

@CONFERENCE{Talby2009154,
  author = {Talby, D.},
  title = {The perceived value of authoring and automating acceptance tests
	using a model driven development toolset},
  year = {2009},
  pages = {154-157},
  note = {cited By (since 1996) 0},
  abstract = {One approach to applying keyword driven testing in a model-driven
	development environment is by defining a domain specific language
	for test cases. The toolset then provides test editors, versioning,
	validation, reporting and hyperlinks across models - in addition
	to enabling automated test execution. This case study evaluates the
	effectiveness of such a solution as perceived by two teams of professional
	testers, who used it to test several products over a two year period.
	The results suggest that in addition to the expected benefits of
	automation, the solution reduces the time and effort required to
	write tests, maintain tests and plan the test authoring and execution
	efforts - at the expense of requiring longer training and a higher
	bar for recruiting testers.},
  affiliation = {Hebrew University of Jerusalem},
  art_number = {5069055},
  document_type = {Conference Paper},
  journal = {Proceedings of the 2009 ICSE Workshop on Automation of Software Test,
	AST 2009},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-70349673934&partnerID=40&md5=d5404ee22188319025682f62fa54db47}
}

@ARTICLE{Talia2010357,
  author = {Talia, D.a , Naumov, L.b },
  title = {Parallel cellular programming for emergent computation},
  journal = {Understanding Complex Systems},
  year = {2010},
  volume = {2010},
  pages = {357-384},
  note = {cited By (since 1996) 0},
  abstract = {The main goal of programming languages and tools has always been to
	make the programmer more productive and the programming task more
	effective. Appropriate programming languages and tools may drastically
	reduce the costs for building new applications as well as for maintaining
	existing ones. It is well known that programming languages can greatly
	increase programmer?s productivity by allowing the programmer to
	write high-scalable, generic, readable and maintainable code. Also,
	new domain specific languages, such as CA languages, can be used
	to enhance different aspects of software engineering. The development
	of these languages is itself a significant software engineering task,
	requiring a considerable investment of time and resources. Domain-specific
	languages have been used in various domains and the outcomes have
	clearly illustrated the advantages of domain specific-languages over
	general purpose languages in areas such as productivity, reliability,
	and flexibility. The main goal of the paper is answering the following
	question: How does one program emergent systems through cellular
	automata on parallel computers? We think that it is very important
	for an effective use of cellular automata for computational science
	on parallel machines to develop and use high-level programming languages
	and tools that are based on the cellular computation paradigm. These
	languages may provide a powerful tool for researchers and engineers
	that need to implement real-life applications on parallel machines
	using a fine-grain approach. This approach allows designers to concentrate
	on "how to model a problem" rather than on architectural details
	as occurs when people use low-level languages that have not been
	specifically designed to express fine-grained parallel cellular computations.
	In a sense, parallel cellular languages provide a high-level paradigm
	for finegrain computer modeling and simulation. While efforts in
	sequential computer languages design focused on how to express sequential
	data, objects and operations, here the focus is on finding out what
	parallel cellular objects and operations are the ones we should want
	to define. Parallel cellular programming emerged as a response to
	these needs. © 2010 Springer-Verlag Berlin Heidelberg.},
  affiliation = {DEIS, University of Calabria, Calabria, Rende, Italy; Faculty of Science,
	Computational Science Group, University of Amsterdam, Sciencepark
	107, Amsterdam 1098 XG, Netherlands},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-77954233754&partnerID=40&md5=f4f7fbc3d33ca3c7ee0fd498801742a7}
}

@CONFERENCE{Tambe200947,
  author = {Tambe, S., Dabholkar, A., Gokhale, A.},
  title = {Fault-tolerance for component-based systems - An automated middleware
	specialization approach},
  year = {2009},
  pages = {47-54},
  note = {cited By (since 1996) 1},
  abstract = {General-purpose middleware, by definition, cannot readily support
	domain-specific semantics without significant manual efforts in specializing
	the middleware. This paper presents GRAFT (GeneRative Aspects for
	Fault Tolerance), which is a model-driven, automated, and aspects-based
	approach for specializing general-purpose middleware with failure
	handling and recovery semantics imposed by a domain. Model-driven
	techniques are used to specify the special fault tolerance requirements,
	which are then transformed into middleware-level code artifacts using
	generative programming. Since the resulting fault tolerance semantics
	often crosscut the middleware architecture, GRAFT uses aspect-oriented
	programming to weave them into the original fabric of the general-purpose
	middleware. We evaluate the capabilities of GRAFT using a representative
	case study. © 2009 IEEE.},
  affiliation = {Dept. of EECS, Vanderbilt University, Nashville, United States},
  art_number = {5231976},
  author_keywords = {Aspects; Fault tolerance; Generative programming; Middleware specialization;
	Model-based},
  document_type = {Conference Paper},
  journal = {Proceedings of the 2009 IEEE International Symposium on Object/Component/Service-Oriented
	Real-Time Distributed Computing, ISORC 2009},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-70350612837&partnerID=40&md5=8fa0a02bbd1b505da8acaae68cd06843}
}

@ARTICLE{Tambe2009100,
  author = {Tambe, S., Gokhale, A.},
  title = {LEESA: Embedding strategic and xpath-like object structure traversals
	in C++},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2009},
  volume = {5658 LNCS},
  pages = {100-124},
  note = {cited By (since 1996) 0},
  abstract = {Traversals of heterogeneous object structures are the most common
	operations in schema-first applications where the three key issues
	are (1) separation of traversal specifications from type-specific
	actions, (2) expressiveness and reusability of traversal specifications,
	and (3) supporting structure-shy traversal specifications that require
	minimal adaptation in the face of schema evolution. This paper presents
	Language for Embedded quEry and traverSAl (LEESA), which provides
	a generative programming approach to address the above issues. LEESA
	is an object structure traversal language embedded in C++. Using
	C++ templates, LEESA combines the expressiveness of XPath's axes-oriented
	traversal notation with the genericity and programmability of Strategic
	Programming. LEESA uses the object structure meta-information to
	statically optimize the traversals and check their compatibility
	against the schema. Moreover, a key usability issue of domain-specific
	error reporting in embedded DSL languages has been addressed in LEESA
	through a novel application of Concepts, which is an upcoming C++
	standard (C++0x) feature. We present a quantitative evaluation of
	LEESA illustrating how it can significantly reduce the development
	efforts of schema-first applications. © IFIP International Federation
	for Information Processing 2009.},
  affiliation = {Electrical Engineering and Computer Science Department, Vanderbilt
	University, Nashville, TN, United States},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-69149111086&partnerID=40&md5=faeae76c11a7267fd5464a089d1be15c}
}

@CONFERENCE{Tambe2007127,
  author = {Tambe, S.a , Balasubramanian, J.a , Gokhale, A.a , Damiano, T.b },
  title = {MDDPro: Model-driven dependability provisioning in enterprise distributed
	real-time and embedded systems},
  year = {2007},
  volume = {4526 LNCS},
  pages = {127-144},
  note = {cited By (since 1996) 2},
  abstract = {Service oriented architecture (SOA) design principles are increasingly
	being adopted to develop distributed real-time and embedded (DRE)
	systems, such as avionics mission computing, due to the availability
	of real-time component middleware platforms. Traditional approaches
	to fault tolerance that rely on replication and recovery of a single
	server or a single host do not work in this paradigm since the fault
	management schemes must now account for the timely and simultaneous
	failover of groups of entities while improving system availability
	by minimizing the risk of simultaneous failures of replicated entities.
	This paper describes MDDPro, a model-driven dependability provisioning
	tool for DRE systems. MDDPro provides intuitive modeling abstractions
	to specify failover requirements of DRE systems at different granularities.
	MDDPro enables plugging in different replica placement algorithms
	to improve system availability. Finally, its generative capabilities
	automate the deployment and configuration of the DRE system on the
	underlying platforms. © Springer-Verlag Berlin Heidelberg 2007.},
  affiliation = {Vanderbilt University, Nashville, TN, United States; MITRE Corporation},
  author_keywords = {Dependability design tools; Generative programming; Model-driven engineering;
	Real-time SOA systems},
  document_type = {Conference Paper},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-34548055972&partnerID=40&md5=c28af03584a4d57bace581fa3c72aa7b}
}

@CONFERENCE{Tanaka2010356,
  author = {Tanaka, M., Tatebe, O.},
  title = {Pwrake: A parallel and distributed flexible workflow management tool
	for wide-area data intensive computing},
  year = {2010},
  pages = {356-359},
  note = {cited By (since 1996) 1},
  abstract = {This paper proposes Pwrake, a parallel and distributed flexible workflow
	management tool based on Rake, a domain specific language for building
	applications in the Ruby programming language. Rake is a similar
	tool to make and ant. It uses a Rakefile that is equivalent to a
	Makefile in make, but written in Ruby. Due to a flexible and extensible
	language feature, Rake would be a powerful workflow management language.
	The Pwrake extends Rake to manage distributed and parallel workflow
	executions that include remote job submission and management of parallel
	executions. This paper discusses the design and implementation of
	the Pwrake, and demonstrates its power of language and extensibility
	of the system using a practical e-Science data-intensive workflow
	in astronomical data analysis on the Gfarm file system as a case
	study. Extending a scheduling algorithm to be aware of file locations,
	20% of speed up is observed using 8 nodes (32 cores) in a PC cluster.
	Using two PC clusters located in different institutions, the file
	location aware scheduling shows scalable speedup. The extensible
	Pwrake is a promising workflow management tool even for wide-area
	data analysis. © Copyright 2010 ACM.},
  affiliation = {University of Tsukuba, 1-1-1 Tennodai, Tsukuba Ibaraki 3058577, Japan},
  author_keywords = {File system; Performance evaluation; Workflow},
  document_type = {Conference Paper},
  journal = {HPDC 2010 - Proceedings of the 19th ACM International Symposium on
	High Performance Distributed Computing},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-78650032755&partnerID=40&md5=2fe464fe4192ee67e8a382d65889ac4c}
}

@CONFERENCE{Tang2009436,
  author = {Tang, X.a , Luo, X.b , Mi, X.a , Yuan, X.c , Chen, D.d },
  title = {DSL route: An efficient integration solution for message routing},
  year = {2009},
  pages = {436-437},
  note = {cited By (since 1996) 0},
  abstract = {As the core of current enterprise integration solution, messaging
	systems provide important functionalities for reliable message delivery
	and complicated service routing. This paper introduces a domain specific
	language (DSL) route to improve current messaging solution. DSL route
	provides fluent and graceful route definition. With DSL routes, the
	integration solutions are more agile and configurable since enterprise
	integration patterns (EIPs) are naturally supported in DSL route
	model. © 2009 IEEE.},
  affiliation = {School of Software, Shanghai Jiao Tong University, China; Digital
	Content Computing and Semantic Grid Group, Shanghai University, China;
	School of Mechanical and Dynamics Engineering, Shanghai Jiao Tong
	University, China; Shanghai Key Lab. of Advanced Manufacturing Environment,
	China Telecom Shanghai Branch, China},
  art_number = {5370324},
  document_type = {Conference Paper},
  journal = {SKG 2009 - 5th International Conference on Semantics, Knowledge,
	and Grid},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-77649299412&partnerID=40&md5=12fc5919b53fceb59e68d5a0d59e2b8a}
}

@CONFERENCE{Tang2011117,
  author = {Tang, Y.a b , Chowdhury, R.A.b e , Kuszmaul, B.C.b c , Luk, C.-K.b
	d , Leiserson, C.E.f },
  title = {The pochoir stencil compiler},
  year = {2011},
  pages = {117-128},
  note = {cited By (since 1996) 0},
  abstract = {A stencil computation repeatedly updates each point of a d-dimensional
	grid as a function of itself and its near neighbors. Parallel cache-efficient
	stencil algorithms based on "trapezoidal decompositions" are known,
	but most programmers find them difficult to write. The Pochoir stencil
	compiler allows a programmer to write a simple specification of a
	stencil in a domain-specific stencil language embedded in C++ which
	the Pochoir compiler then translates into high-performing Cilk code
	that employs an efficient parallel cache-oblivious algorithm. Pochoir
	supports general d-dimensional stencils and handles both periodic
	and aperiodic boundary conditions in one unified algorithm. The Pochoir
	system provides a C++ template library that allows the user's stencil
	specification to be executed directly in C++ without the Pochoir
	compiler (albeit more slowly), which simplifies user debugging and
	greatly simplified the implementation of the Pochoir compiler itself.
	A host of stencil benchmarks run on a modern multicore machine demonstrates
	that Pochoir outperforms standard parallelloop implementations, typically
	running 2-10 times faster. The algorithm behind Pochoir improves
	on prior cache-efficient algorithms on multidimensional grids by
	making "hyperspace" cuts, which yield asymptotically more parallelism
	for the same cache efficiency. © 2011 ACM.},
  affiliation = {Department of Computer Science, Fudan University, China; MIT Computer
	Science and Artificial Intelligence Laboratory, Cambridge, MA 02139,
	United States; Tokutek, Inc., United States; Intel Corporation, United
	States; Boston University, United States; Department of Computer
	Science and Engineering, MIT Computer Science and Artificial Intelligence
	Laboratory, Cambridge, MA 02139, United States},
  author_keywords = {C++; cache-oblivious algorithm; cilk; compiler; embedded domain-specific
	language; multicore; parallel computation; stencil computation; trapezoidal
	decomposition},
  document_type = {Conference Paper},
  journal = {Annual ACM Symposium on Parallelism in Algorithms and Architectures},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-79959673844&partnerID=40&md5=8c6d8c8ed09b54886b2e37aa7d3c5c62}
}

@ARTICLE{Tanriöver2011448,
  author = {Tanriöver, Ö.Ö.a , Bilgen, S.b },
  title = {A framework for reviewing domain specific conceptual models},
  journal = {Computer Standards and Interfaces},
  year = {2011},
  volume = {33},
  pages = {448-464},
  number = {5},
  note = {cited By (since 1996) 0},
  abstract = {Conceptual models are used in understanding and communicating the
	domain of interest during analysis phase of system development. As
	they are used in early phases, errors and omissions may propagate
	to later phases and may be very costly to correct. This paper proposes
	a framework for evaluating conceptual models when represented in
	a domain specific language based on UML constructs. The framework
	describes the main aspects to be considered when conceptual models
	are represented in a domain specific language, presents a classification
	of semantic issues and some evaluation indicators. The indicators
	can, in principle, identify situations in the models where inconsistencies
	or incompleteness might occur. Whether these are real concerns might
	depend on domain semantics, hence these are semantic, not syntactic
	checks. The use of the proposed review framework is illustrated in
	the context of two conceptual models in a domain specific notation,
	KAMA. With reviews based on the framework, it is possible to spot
	semantic issues which are not noticed by case tools and help the
	analyst to identify more information about the domain. © 2011 Elsevier
	B.V.},
  affiliation = {Information Management Department, Banking Regulation and Supervision
	Agency, Atatürk BulvarI 191/B, Kavakhdere, 06680, Ankara, Turkey;
	Electrical and Electronics Engineering Department, Middle East Technical
	University, 06531, Ankara, Turkey},
  author_keywords = {Conceptual model evaluation; Domain specific model; UML inspection},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-79955593533&partnerID=40&md5=1cd02395c3e1793f3d160a88e1ece012}
}

@CONFERENCE{Tatlock2010,
  author = {Tatlock, Z., Lerner, S.},
  title = {Bringing extensibility to verified compilers},
  year = {2010},
  pages = {111-121},
  note = {cited By (since 1996) 1},
  abstract = {Verified compilers, such as Leroy's CompCert, are accompanied by a
	fully checked correctness proof. Both the compiler and proof are
	often constructed with an interactive proof assistant. This technique
	provides a strong, end-to-end correctness guarantee on top of a small
	trusted computing base. Unfortunately, these compilers are also challenging
	to extend since each additional transformation must be proven correct
	in full formal detail. At the other end of the spectrum, techniques
	for compiler correctness based on a domain-specific language for
	writing optimizations, such as Lerner's Rhodium and Cobalt, make
	the compiler easy to extend: the correctness of additional transformations
	can be checked completely automatically. Unfortunately, these systems
	provide a weaker guarantee since their end-to-end correctness has
	not been proven fully formally. We present an approach for compiler
	correctness that provides the best of both worlds by bridging the
	gap between compiler verification and compiler extensibility. In
	particular, we have extended Leroy's CompCert compiler with an execution
	engine for optimizations written in a domain specific and proved
	that this execution engine preserves program semantics, using the
	Coq proof assistant. We present our CompCert extension, XCert, including
	the details of its execution engine and proof of correctness in Coq.
	Furthermore, we report on the important lessons learned for making
	the proof development manageable. © 2010 ACM.},
  affiliation = {University of California, San Diego, CA, United States},
  author_keywords = {compiler optimization; correctness; extensibility},
  document_type = {Conference Paper},
  journal = {Proceedings of the ACM SIGPLAN Conference on Programming Language
	Design and Implementation (PLDI)},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-77954715631&partnerID=40&md5=8f1dbde48d1f8401916c4cc82d9271cb}
}

@ARTICLE{Tatlock2010111,
  author = {Tatlock, Z., Lerner, S.},
  title = {Bringing extensibility to verified compilers},
  journal = {ACM SIGPLAN Notices},
  year = {2010},
  volume = {45},
  pages = {111-121},
  number = {6},
  note = {cited By (since 1996) 0},
  abstract = {Verified compilers, such as Leroy's CompCert, are accompanied by a
	fully checked correctness proof. Both the compiler and proof are
	often constructed with an interactive proof assistant. This technique
	provides a strong, end-to-end correctness guarantee on top of a small
	trusted computing base. Unfortunately, these compilers are also challenging
	to extend since each additional transformation must be proven correct
	in full formal detail. At the other end of the spectrum, techniques
	for compiler correctness based on a domain-specific language for
	writing optimizations, such as Lerner's Rhodium and Cobalt, make
	the compiler easy to extend: The correctness of additional transformations
	can be checked completely automatically. Unfortunately, these systems
	provide a weaker guarantee since their end-to-end correctness has
	not been proven fully formally. We present an approach for compiler
	correctness that provides the best of both worlds by bridging the
	gap between compiler verification and compiler extensibility. In
	particular, we have extended Leroy's CompCert compiler with an execution
	engine for optimizations written in a domain specific language and
	proved that this execution engine preserves program semantics, using
	the Coq proof assistant. We present our CompCert extension, XCert,
	including the details of its execution engine and proof of correctness
	in Coq. Furthermore, we report on the important lessons learned for
	making the proof development manageable. Copyright © 2010 ACM.},
  affiliation = {University of California, San Diego, United States},
  author_keywords = {Compiler Optimization; Correctness; Extensibility},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-77957601104&partnerID=40&md5=3237a0ec9c5283863e446969174123f3}
}

@CONFERENCE{Teiken20101411,
  author = {Teiken, Y.a , Brüggemann, S.a , Appelrath, H.-J.b },
  title = {Interchangeable consistency constraints for public health care systems},
  year = {2010},
  pages = {1411-1416},
  note = {cited By (since 1996) 1},
  abstract = {Severe data quality problems exist in most public health care systems
	and inconsistent data sets often occur. Consistency constraints can
	be used to define valid and invalid data. Existing solutions of such
	constraints like rule systems are often difficult to maintain, not
	human-readable, and of a bad quality like containing contradictory
	rules. With In-DaQu we present an approach that allows domain experts
	to easily create and maintain consistency constraints using an introduced
	domain-specific language. These constraints are being stored in an
	ontology, which allows for an automated inconsistency detection in
	the defined rules themselves. We identified several scenarios in
	which consistency constraints can be interchanged and exchanged between
	different participants. The approach has been successfully evaluated
	in the cancer registry of Lower Saxony. © 2010 ACM.},
  affiliation = {OFFIS - Institute for Information Technology, Escherweg 2, Oldenburg,
	Germany; University of Oldenburg, Ammerländer Herrstr. 144-118, Oldenburg,
	Germany},
  author_keywords = {consistency constraints; domain ontologies; domain specific modeling;
	knowledge representation; medical informatics},
  document_type = {Conference Paper},
  journal = {Proceedings of the ACM Symposium on Applied Computing},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-77954691430&partnerID=40&md5=d623b0647a00e4ae7946ec2590e6e073}
}

@CONFERENCE{Teiken2010337,
  author = {Teiken, Y.a , Rohde, M.a , Appelrath, H.-J.b },
  title = {Model-driven ad hoc data integration in the context of a population-based
	Cancer Registry},
  year = {2010},
  volume = {1},
  pages = {337-343},
  note = {cited By (since 1996) 0},
  abstract = {The major task of a population-based Cancer Registry (CR) is the identification
	of risk groups and factors. This analysis makes use of data about
	the social background of the population. The integration of that
	data is not intended for the routine processes at the CR. Therefore,
	this process must be performed by data warehouse experts that results
	in high cost. This paper proposes an approach, which allows epidemiologists
	and physicians at the CR to realize this ad hoc data integration
	on their own. We use model driven software design (MDSD) with a domain
	specific language (DSL), which allows the epidemiologists and physicians
	to describe the data to be integrated in a known language. This description
	or rather model is used to create an extension of the existing data
	pool and a web service and web application for data integration.
	The end user can do the integration on his/her own which results
	in a very cost-efficient way of ad hoc data integration.},
  affiliation = {OFFIS Institute for Information Technology, Escherweg 2, 26121 Oldenburg,
	Germany; Department of Computing, University of Oldenburg, Ammerländer
	Herrstr. 144-118, Oldenburg, Germany},
  author_keywords = {Data analysis; Data integration; Data management; Epidemiology; MDSD;
	Model driven software development},
  document_type = {Conference Paper},
  journal = {ICSOFT 2010 - Proceedings of the 5th International Conference on
	Software and Data Technologies},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-78751523081&partnerID=40&md5=08c2ba0f2a9d9c38ca265ced2ed83907}
}

@CONFERENCE{Temate2010743,
  author = {Temate, S., Broto, L., Tchana, A., Hagimont, D.},
  title = {A high level approach for generating model's graphical editors},
  year = {2010},
  pages = {743-749},
  note = {cited By (since 1996) 0},
  abstract = {Domain Specific Languages (DSL) are increasingly used in software
	engineering and other domains. The result is an increasing need of
	appropriate DSL's tools, especially platform for building, editors
	and runtime associated with DSLs. Different experiences show that
	existent DSL tools are generally not user friendly enough, or simply
	unadapted for the generation of graphical DSL editors. In this paper
	we present a higher level and effortless framework for generating
	graphical DSL editors. This framework was designed and experienced
	in the context of an autonomic management system based on a component
	model. © 2011 IEEE.},
  affiliation = {IRIT/ENSEEIHT, Institut National Polytechnique de Toulouse, France},
  art_number = {5945329},
  author_keywords = {autonomic computing; languages; model-driven engineering},
  document_type = {Conference Paper},
  journal = {Proceedings - 2011 8th International Conference on Information Technology:
	New Generations, ITNG 2011},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-80051508472&partnerID=40&md5=755dbf968838208e0b84155771a02a8d}
}

@CONFERENCE{Temprado-Battad2010427,
  author = {Temprado-Battad, B., Sarasa-Cabezuelo, A., Sierra, J.-L.},
  title = {Managing the production and evolution of e-learning tools with attribute
	grammars},
  year = {2010},
  pages = {427-431},
  note = {cited By (since 1996) 0},
  abstract = {Many e-learning tools are based on domain-specific languages (DSLs)
	targeted to the educational domain. Thus, methods and techniques
	from the programming language community can help in developing these
	tools. In this paper, we show how attribute grammars, a well-known
	declarative specification method for the syntax and semantics of
	programming languages, can facilitate the production and subsequent
	evolution of e-learning tools. We also describe how we produced and
	extended 〈e-Tutor〉, a courseware system supporting an XML-based DSL,
	by using XLOP (XML Language-Oriented Processing), a meta-tool supporting
	attribute grammars for the development of XML processing applications.
	© 2010 IEEE.},
  affiliation = {Dpto. Ingeniería del Software e Inteligencia Artificial, Fac. Informática,
	Universidad Complutense de Madrid, 28040 Madrid, Spain},
  art_number = {5572413},
  author_keywords = {Attribute grammars; Domain-specific languages; E-learning tools; Tutoring
	systems; XML processing},
  document_type = {Conference Paper},
  journal = {Proceedings - 10th IEEE International Conference on Advanced Learning
	Technologies, ICALT 2010},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-78049268528&partnerID=40&md5=3bb5c3d650395b4d023a3475e26062a5}
}

@ARTICLE{Terfloth2008127,
  author = {Terfloth, K., Schiller, J.},
  title = {Ruling networks with RDL: A domain-specific language to task wireless
	sensor networks},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2008},
  volume = {5321 LNCS},
  pages = {127-134},
  note = {cited By (since 1996) 0},
  abstract = {Events are a fundamental concept in computer science with decades
	of research contributing to enable precise specification and efficient
	processing. New as well as evolving application domains nevertheless
	call for adaptation of successful concepts to meet intrinsic challenges
	provided by the target environment. A representative of such a new
	area for application are wireless sensor networks, pushing the need
	for event handling onto the bare metal of embedded devices. In this
	paper, we motivate the deployment of reactive rules in wireless sensor
	networks and describe our rule-based language RDL. Since our goal
	is to provide a high level of abstraction for node-level tasking,
	we will especially focus on recent additions to the language that
	support modularity to achieve a better encapsulation of concerns.
	© 2008 Springer Berlin Heidelberg.},
  affiliation = {Institute of Mathematics and Computer Science, Takustr. 9, 14195 Berlin,
	Germany},
  author_keywords = {Domain-specific language; FACTS; RDL; Reactive rules},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-57349137731&partnerID=40&md5=9c38168b569ab710aba397e632e76a7c}
}

@ARTICLE{Terfloth2008236,
  author = {Terfloth, K., Schiller, J.},
  title = {Self-sustained routing for event Diffusion in wireless sensor networks},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2008},
  volume = {5321 LNCS},
  pages = {236-241},
  note = {cited By (since 1996) 0},
  abstract = {Wireless sensor networks have the potential to become a scalable,
	low-cost and highly flexible tool for distributed monitoring and/or
	event recognition: Embedded devices that coordinate themselves via
	wireless communication to implement a common, distributed application
	are already seeing first industrial adaption in e.g. home automation,
	personal health or environmental monitoring. Despite of their valuable
	properties they put a high burden upon application development since
	critical issues such as a general resource scarcity, the unreliable
	communication medium and the management of distribution are often
	visible throughout the protocol stack to ensure efficient utilization.
	In the demo, we will show how our middleware framework FACTS helps
	to alleviate problems in implementation of both system- and application-level
	code. Providing a rule-based, domain-specific language, FACTS is
	especially suited to express event-driven tasks. Therefore, we will
	showcase how to efficiently program a self-sustained routing protocol
	forwarding relevant events to dedicated sink nodes with only a handful
	of rules. © 2008 Springer Berlin Heidelberg.},
  affiliation = {Institute of Mathematics and Computer Science, Takustr. 9, Berlin
	14195, Germany},
  author_keywords = {Domain-specific language; FACTS; Middleware; Routing; Rules; Wireless
	sensor networks},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-57349116969&partnerID=40&md5=26a48538ecbb34e0fe499a9537f8c864}
}

@ARTICLE{Terrel201178,
  author = {Terrel, A.R.},
  title = {From equations to code: Automated scientific computing},
  journal = {Computing in Science and Engineering},
  year = {2011},
  volume = {13},
  pages = {78-82},
  number = {2},
  note = {cited By (since 1996) 0},
  abstract = {Using domain-specific languages, scientific codes can let users work
	directly with equations and benefit from optimizations not available
	with general compilers. © 2011 IEEE.},
  affiliation = {Texas Advanced Computing Center, University of Texas at Austin, United
	States},
  art_number = {5725239},
  author_keywords = {Automated computing; code optimization; domain-specific languages;
	scientific computing},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-79952605821&partnerID=40&md5=54af0cb6017f80863caa2eda3170cc1c}
}

@ARTICLE{Thibault2000161,
  author = {Thibault, S.a c , Consel, C.a d , Lawall, J.L.b e , Marlet, R.a f
	, Muller, G.a },
  title = {Static and dynamic program compilation by interpreter specialization},
  journal = {Higher-Order and Symbolic Computation},
  year = {2000},
  volume = {13},
  pages = {161-178},
  number = {3},
  note = {cited By (since 1996) 18},
  abstract = {Interpretation and run-time compilation techniques are increasingly
	important because they can support heterogeneous architectures, evolving
	programming languages, and dynamically-loaded code. Interpretation
	is simple to implement, but yields poor performance. Run-time compilation
	yields better performance, but is costly to implement. One way to
	preserve simplicity but obtain good performance is to apply program
	specialization to an interpreter in order to generate an efficient
	implementation of the program automatically. Such specialization
	can be carried out at both compile time and run time. Recent advances
	in program-specialization technology have significantly improved
	the performance of specialized interpreters. This paper presents
	and assesses experiments applying program specialization to both
	bytecode and structured-language interpreters. The results show that
	for some general-purpose bytecode languages, specialization of an
	interpreter can yield speedups of up to a factor of four, while specializing
	certain structured-language interpreters can yield performance comparable
	to that of an implementation in a general-purpose language, compiled
	using an optimizing compiler.},
  affiliation = {COMPOSE Group, IRISA/INRIA, Campus de Beaulieu, 35042 Rennes Cedex,
	France; Computer Science Department, Boston University, 111 Cummington
	St., Boston, MA 02215, United States; Gn. Mt. Computing Systems,
	Inc., So. Burlington, VT, United States; LaBRI/ENSERB, 351 cours
	de la Libération, F-33405 Talence Cedex, France; DIKU, University
	of Copenhagen, Universitetsparken 1, 2100 Copenhagen East, Denmark;
	Trusted Logic, 5 rue Bailliage, 78000 Versailles, France},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-0034266915&partnerID=40&md5=4a5c5470fbf64c53cafa067c5c982715}
}

@ARTICLE{Thibault1999363,
  author = {Thibault, S.A., Marlet, R., Consel, C.},
  title = {Domain-specific languages: From design to implementation application
	to video device drivers generation},
  journal = {IEEE Transactions on Software Engineering},
  year = {1999},
  volume = {25},
  pages = {363-377},
  number = {3},
  note = {cited By (since 1996) 34},
  abstract = {Domain-Specific languages (DSL) have many potential advantages in
	terms of software engineering ranging from increased productivity
	to the application of formal methods. Although they have been used
	in practice for decades, there has been little study of methodology
	or implementation tools for the DSL approach. In this paper, we present
	our DSL approach and its application to a realistic domain: the generation
	of video display device drivers. The presentation focuses on the
	validation of our proposed framework for domain-specific languages,
	from design to implementation. The framework leads to a flexible
	design and structure, and provides automatic generation of efficient
	implementations of DSL programs. Additionally, we describe an example
	of a complete DSL for video display adaptors and the benefits of
	the DSL approach for this application. This demonstrates some of
	the generally claimed benefits of using DSLs: increased productivity,
	higher-level abstraction, and easier verification. This DSL has been
	fully implemented with our approach and is available. Compose project
	URL: http://www.irisa.fr/compose/gal.},
  affiliation = {IRISA/INRIA, Université de Rennes 1, Campus Universitaire de Beaulieu,
	35042 Rennes cedex, France},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-0032594217&partnerID=40&md5=4150f3177488bbf78c98356636f0f884}
}

@CONFERENCE{Thibault1998135,
  author = {Thibault, Scott, Consel, Charles, Muller, Gilles},
  title = {Safe and efficient active network programming},
  year = {1998},
  pages = {135-143},
  note = {cited By (since 1996) 13},
  abstract = {Active networks are aimed at incorporating programmability into the
	network to achieve extensibility. One approach to obtaining extensibility
	is to download router programs into network nodes. This programmability
	is critical to allow multipoint distributed systems to adapt to network
	conditions and individual clients' needs. Although promising, this
	approach raises critical issues such as safety to achieve reliability
	despite the complexity of a distributed system, security to protect
	shared resources, and efficiency to maximize usage of bandwidth.
	This paper proposes the use of a domain-specific language, PLAN-P,
	to address all of the above issues. To address safety and security,
	we give examples of properties of PLAN-P programs that can be automatically
	checked due to the use of a restricted language. For efficiency,
	we show that an automatically generated run-time compiler for PLAN-P
	produces code which outperforms an equivalent compiled Java program.
	Additionally, we present performance results on a real application
	(learning bridge) where we obtain 100% of the maximum possible throughput.},
  affiliation = {Universite de Rennes 1},
  document_type = {Conference Paper},
  journal = {Proceedings of the IEEE Symposium on Reliable Distributed Systems},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-0032308043&partnerID=40&md5=676c23a6cf4175c7e44fc45ef3c615af}
}

@CONFERENCE{Thibault1999234,
  author = {Thibault, Scott, Marant, Jerome, Muller, Gilles},
  title = {Adapting distributed applications using extensible networks},
  year = {1999},
  pages = {234-243},
  note = {cited By (since 1996) 6},
  abstract = {Active networks have been proposed to allow the dynamic extension
	of network behavior by downloading application-specific protocols
	(ASPs) into network routers. In this paper, we demonstrate feasibility
	of the use of ASPs in an active network for the adaptation of distributed
	software components. We have implemented three examples which show
	that ASPs can be used to easily extend distributed applications,
	and furthermore, that such adaptation can be safe, portable and efficient.
	Safety and efficiency is obtained by implementing the ASPs in PLAN-P,
	a domain-specific language and run-time system for active networking.
	The presented examples illustrate three different applications: (i)
	audio broadcasting with bandwidth adaptation in routers, (ii) an
	extensible HTTP server with load-balancing facilities, (iii) a multipoint
	MPEG server derived from a point-to-point server.},
  affiliation = {IRISA/INRIA, Rennes, France},
  document_type = {Article},
  journal = {Proceedings - International Conference on Distributed Computing Systems},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-0032663586&partnerID=40&md5=c32af44c51be1a4dbd2a5b818240876a}
}

@CONFERENCE{Thiemann200319,
  author = {Thiemann, P.},
  title = {XML Templates and Caching in WASH},
  year = {2003},
  pages = {19-26},
  note = {cited By (since 1996) 1},
  abstract = {Caching of documents is an important concern on the Web. It is a major
	win in all situations where bandwidth is limited. Unfortunately,
	the increasing spread of dynamically generated documents seriously
	hampers traditional caching techniques in browsers and on proxy servers.
	WASH/CGI is a Haskell-based domain specific language for creating
	interactive Web applications. The Web pages generated by a WASH/CGI
	application are highly dynamic and cannot be cached with traditional
	means. We show how to implement the dynamic caching scheme of the
	BigWig language in the context of WASH/CGI. The main issue in BigWig's
	caching scheme is the distinction between fixed parts (that should
	be cached) and variable parts (that need not be cached) of a document.
	Since BigWig is a standalone domain-specific language, its compiler
	can perform the distinction as part of its static analysis. Hence,
	the challenge in our implementation is to obtain the same information
	without involving the compiler. To this end, we extend WASH/CGI's
	document language by mode annotations and define the translation
	of the resulting annotated document language into JavaScript. To
	alleviate the awkwardness of programming directly in annotated language,
	we have defined a surface syntax in the style of HSP (Haskell Server
	Pages).},
  affiliation = {Universität Freiburg, Germany},
  author_keywords = {Annotated Languages; Caching; Web Programming},
  document_type = {Conference Paper},
  journal = {Proceedings of the 2003 ACM SIGPLAN Haskell Workshop},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-1542537985&partnerID=40&md5=a9751a81fe1b21ad5b413ae70d337c85}
}

@ARTICLE{Thiemann2002241,
  author = {Thiemann, P.},
  title = {Programmable type systems for domain specific languages},
  journal = {Electronic Notes in Theoretical Computer Science},
  year = {2002},
  volume = {76},
  pages = {241-259},
  note = {cited By (since 1996) 1},
  abstract = {A language with a programmable type system is vital for the construction
	of an embedded domain specific language (EDSL). Driven by the requirements
	posed by the implementation of an EDSL for server-side Web scripting,
	we examine two major of extensions to the type system of the host
	language, Haskell. We show that a component that ensures the generation
	of correct HTML documents can take good advantage of type-level functions,
	as implemented using functional logic overloading. We further show
	that a function that ensures the consistency of data submitted to
	a Web script with the data expected by the script is less awkward
	to use in the presence of lambda expressions in the type language.
	In both cases we assess the guarantees obtained by the use of the
	typing and explore alternative solutions. © 2002 Published by Elsevier
	Science B.V.},
  affiliation = {Institut für Informatik, Universität Freiburg, Georges-Köhler-Allee
	079, D-79110 Freiburg, Germany},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-16244403782&partnerID=40&md5=7f5a369472c189d39dc77aa5d9b5111b}
}

@ARTICLE{Thiemann2002435,
  author = {Thiemann, P.},
  title = {A typed representation for HTML and XML documents in Haskell},
  journal = {Journal of Functional Programming},
  year = {2002},
  volume = {12},
  pages = {435-468},
  number = {4-5},
  note = {cited By (since 1996) 17},
  abstract = {We define a family of embedded domain specific languages for generating
	HTML and XML documents. Each language is implemented as a combinator
	library in Haskell. The generated HTML/XML documents are guaranteed
	to be well-formed. In addition, each library can guarantee that the
	generated documents are valid XML documents to a certain extent (for
	HTML only a weaker guarantee is possible). On top of the libraries,
	Haskell serves as a meta language to define parameterized documents,
	to map structured documents to HTML/XML, to define conditional content,
	or to define entire web sites. The combinator libraries support element-transforming
	style, a programming style that allows programs to have a visual
	appearance similar to HTML/XML documents, without modifying the syntax
	of Haskell.},
  affiliation = {Universität Freiburg, Freiburg, Germany},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-0036058181&partnerID=40&md5=60b1ac5ab962c990c4c596ea783a70b1}
}

@ARTICLE{Thiemann1999483,
  author = {Thiemann, P.},
  title = {Combinators for program generation},
  journal = {Journal of Functional Programming},
  year = {1999},
  volume = {9},
  pages = {483-525},
  number = {5},
  note = {cited By (since 1996) 18},
  abstract = {We present a general method to transform a compositional specification
	of a specializer for a functional programming language into a set
	of combinators that can be used to perform the same specialization
	more efficiently. The main transformation steps are the transition
	to higher-order abstract syntax and untagging. All transformation
	steps are proved correct. The resulting combinators can be implemented
	in any functional language, typed or untyped, pure or impure. They
	may also be considered as forming a domain-specific language for
	meta-programming. We demonstrate the generality of the method by
	applying it to several specializers of increasing strength. We demonstrate
	its efficiency by comparing it with a traditional specialization
	system based on self-application.},
  affiliation = {Institut für Informatik, Universität Freiburg, Universitatsgelande
	Flugplatz, D-79110 Freiburg, Germany},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-0000055491&partnerID=40&md5=6cf3a7826f2b0f2238416b0dd8fa5263}
}

@ARTICLE{Thiemann20051,
  author = {Thiemann, P.a b },
  title = {An embedded domain-specific language for type-safe server-side web
	scripting},
  journal = {ACM Transactions on Internet Technology},
  year = {2005},
  volume = {5},
  pages = {1-46},
  number = {1},
  note = {cited By (since 1996) 12},
  abstract = {WASH/CGI is an embedded domain-specific language for server-side Web
	scripting. Due to its reliance on the strongly typed, purely functional
	programming language Haskell as a host language, it is highly flexible
	and - at the same time - it provides extensive guarantees due to
	its pervasive use of type information. WASH/CGI can be structured
	into a number of sublanguages addressing different aspects of the
	application. The document sublanguage provides tools for the generation
	of parameterized XHTML documents and forms. Its typing guarantees
	that almost all generated documents are valid XHTML documents. The
	session sublanguage provides a session abstraction with a transparent
	notion of session state and allows the composition of documents and
	Web forms to entire interactive scripts. Both are integrated with
	the widget sublanguage which describes the communication (parameter
	passing) between client and server. It imposes a simple type discipline
	on the parameters that guarantees that forms posted by the client
	are always understood by the server. That is, the server never asks
	for data not submitted by the client and the data submitted by the
	client has the type requested by the server. In addition, parameters
	are received in their typed internal representation, not as strings.
	Finally, the persistence sublanguage deals with managing shared state
	on the server side as well as individual state on the client side.
	It presents shared state as an abstract data type, where the script
	can control whether it wants to observe mutations due to concurrently
	executing scripts. It guarantees that states from different interaction
	threads cannot be confused. © 2005 ACM.},
  affiliation = {Universität Freiburg, Germany; Institut für Informatik, Albert-Ludwigs-Univ.
	Freiburg, Georges-Köhler-Allee 079, D-79110 Freiburg, Germany},
  author_keywords = {Interactive Web services; Web programming},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-16244406191&partnerID=40&md5=600aaabd81ab278b4acaac6449aa1a4a}
}

@ARTICLE{Thomas200415,
  author = {Thomas, D.a b },
  title = {MDA: Revenge of the modelers or UML Utopia?},
  journal = {IEEE Software},
  year = {2004},
  volume = {21},
  pages = {15-17},
  number = {3},
  note = {cited By (since 1996) 34},
  abstract = {Software industry uses Unified Modeling Language for many information
	technology applications. Metadata provides semantics to support OMG's
	Model Driven Architecture including decision tables, XML and middleware.
	Domain-oriented programming and domain-specific languages are useful
	computer-aided software engineering to build automated code generates
	for Itanium processor.},
  affiliation = {Carleton University, Ottawa, Ont., Canada; University of Queensland,
	Brisbane, QLD, Australia},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-3042578525&partnerID=40&md5=e2a5a35ccdd3e5f6c64e22094bf13143}
}

@ARTICLE{Thomas20047,
  author = {Thomas, D.a b c },
  title = {The elusive search for business frameworks},
  journal = {Journal of Object Technology},
  year = {2004},
  volume = {3},
  pages = {7-13},
  number = {1},
  note = {cited By (since 1996) 0},
  abstract = {The business framework to enable businesses to achieve software reusability
	are discussed. The reusability reduces time and expense of development
	and increase the quality of work. It is stated that implementation
	of rich domain meta models is needed to cope with the variety and
	complexity of business frameworks. The business frameworks require
	the combined skills of framework engineering, domain analysis, and
	business engineering. It is also stated that the process of solving
	a business problem is simplified by the use of customized business
	framework.},
  affiliation = {Bedarra Corp.; Carleton University; University of Queensland},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-2942726240&partnerID=40&md5=bce19158499686d998802c309fde3bd8}
}

@CONFERENCE{Thomas20032,
  author = {Thomas, D., Barry, B.M.},
  title = {Model driven development - The case for domain oriented programming},
  year = {2003},
  pages = {2-7},
  note = {cited By (since 1996) 7},
  abstract = {In this paper, we offer an alternative vision for domain driven development
	(3D). Our approach is model driven and emphasizes the use of generic
	and specific domain oriented programming (DOP) languages. DOP uses
	strong specific languages, which directly incorporate domain abstractions,
	to allow knowledgeable end users to succinctly express their needs
	in the form of an application computation. Most domain driven development
	(3D) approaches and techniques are targeted at professional software
	engineers and computer scientists. We argue that DOP offers a promising
	alternative. Specifically we are focused on empowering application
	developers who have extensive domain knowledge as well as sound foundations
	in their professions, but may not be formally trained in computer
	science. We provide a brief survey of DOP experiences, which show
	that many of the best practices such as patterns, refactoring, and
	pair programming are naturally and ideally practiced in a Model Driven
	Development (MDD) setting. We compare and contrast our DOP with other
	popular approaches, most of which are deeply rooted in the OO community.
	Finally we highlight challenges and opportunities in the design and
	implementation of such languages.},
  affiliation = {Bedarra Research Labs., 1 Stafford Rd., Ottawa, ON K2H 1B9, Canada},
  author_keywords = {Domain Driven Development; Domain Specific Languages; End User Programming;
	Model Driven Development; Programming By Professional End Users},
  document_type = {Conference Paper},
  journal = {Proceedings of the Conference on Object-Oriented Programming Systems,
	Languages, and Applications, OOPSLA},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-3042655839&partnerID=40&md5=7ba6b6036286a89ca38f30bfeb8ec9c7}
}

@CONFERENCE{Thomas200797,
  author = {Thomas, D.B., Luk, W.},
  title = {A domain specific language for reconfigurable path-based monte carlo
	simulations},
  year = {2007},
  pages = {97-104},
  note = {cited By (since 1996) 4},
  abstract = {FPGAs have been successfully used to accelerate many computationally
	bound applications, such as high-performance Monte-Carlo simulations,
	but the amount of programmer effort required in development, testing,
	and tuning is also very high, requiring a new custom design for each
	application. This paper presents Contessa, a pure-functional continuation-based
	language for describing path-based Monte-Carlo simulations, and a
	completely automated method for turning platform-independent Contessa
	programs into high-performance hardware implementations. Our approach
	exploits the large degree of thread-based parallelism available in
	Monte-Carlo simulations, allowing data-dependent control-flow and
	loop-carried dependencies to be expressed, while retaining high-performance.
	The Contessa toolchain is evaluated using five different simulation
	kernels, in comparison to both software and manually described hardware.
	When compared to an existing FPGA implementation, Contessa requires
	a quarter of the Handel-C source-code length, and doubles the clock
	rate to over 300MHz while requiring a similar number of resources,
	and also provides a 35 times speedup over a C++ implementation using
	an Opteron 2.2GHz. © 2007 IEEE.},
  affiliation = {Imperial College London, United Kingdom},
  art_number = {4439237},
  document_type = {Conference Paper},
  journal = {ICFPT 2007 - International Conference on Field Programmable Technology},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-50149095123&partnerID=40&md5=85e5083f3b9db2538f5420d958161b2a}
}

@CONFERENCE{Tilevich2010293,
  author = {Tilevich, E.a , Eugster, P.b },
  title = {Programming support innovations for emerging distributed applications
	(PSI EtA - Ψη): A SPLASH 2010 workshop summary},
  year = {2010},
  pages = {293-294},
  note = {cited By (since 1996) 0},
  abstract = {Distribution has become a necessity for the majority of computing
	domains, but developing distributed applications remains a highly
	delicate and complex task. Several emerging distributed computing
	and application domains, including cloud computing, service-oriented
	computing, stream processing, sensor networks, and context-aware
	computing, pose unprecedented challenges to the programmer. Applications
	in these domains can deliver tangible benefits to the user once they
	enter the mainstream of industrial software development. What is
	hindering the wide adoption and use of these applications is the
	prevalence of ad-hoc programming practices in their software development
	process. The goal of this workshop is to explore programming support
	innovations that can address the incongruence between the advanced
	programming requirements of emerging distributed applications and
	the current state of the art of their programming support. To that
	end, the workshop will provide a venue for free and open discussions
	among academic researchers and industry practitioners of distributed
	applications.},
  affiliation = {Virginia Tech., United States; Purdue University, United States},
  author_keywords = {Advanced separation of concerns; Cloud computing; Code generators;
	Component technologies; Context-aware computing; Cyber-physical systems;
	Data-intensive computing; Distributed computing; Domain specific
	languages; Extensible languages; Geo-spatial systems; Middleware
	systems; Product-line architectures; Program transformation systems;
	Programming frameworks; Programming support; Sensor networks; Service-oriented
	computing; Stream processing},
  document_type = {Conference Paper},
  journal = {Proceedings of the ACM International Conference Companion on Object
	Oriented Programming Systems Languages and Applications Companion,
	SPLASH '10},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-78650086359&partnerID=40&md5=a2072b068249539f84b2c6053812a743}
}

@CONFERENCE{Timbermont2008,
  author = {Timbermont, S.a , Adams, B.b , Haupt, M.c },
  title = {Towards a DSAL for object layout in virtual machines},
  year = {2008},
  note = {cited By (since 1996) 0},
  abstract = {High-level language virtual machine implementations offer a challenging
	domain for modularization, not only because they are inherently complex,
	but also because efficiency is not likely to be traded for modularity.
	The central data structure used throughout the VM, the object layout,
	cannot be succinctly modularised by current aspect technology, as
	provisions for static crosscutting are not fine-grained enough. This
	position paper motivates the need for a declarative, domain-specific
	language for handling the tangled object layout concern. Based on
	observations in real-world VM implementations, we propose such a
	language, D4OL. It combines a two-level layout mapping, constraints
	and an engine to divide responsibilities between VM component and
	VM developers. We consider a domain-specific language like D4OL a
	necessary complement to behavioural aspect languages in order to
	modularize VM implementations. © 2008 ACM.},
  affiliation = {Vrije Universiteit Brussel, Belgium; Ghent University, Belgium; Hasso-Plattner-Institut,
	University of Potsdam, Germany},
  art_number = {5},
  author_keywords = {Domain-specific aspect language; Object layout; Virtual machine},
  document_type = {Conference Paper},
  journal = {DSAL'08: Proceedings of the 2008 AOSD Workshop on Domain-specific
	Aspect Languages},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-65249164030&partnerID=40&md5=b2184f8f35ed64de6e5e822eecb30ddd}
}

@CONFERENCE{Tobin-Hochstadt2011132,
  author = {Tobin-Hochstadt, S.a , St-Amour, V.a , Culpepper, R.b , Flatt, M.b
	, Felleisen, M.a },
  title = {Languages as libraries},
  year = {2011},
  pages = {132-141},
  note = {cited By (since 1996) 0},
  abstract = {Programming language design benefits from constructs for extending
	the syntax and semantics of a host language. While C's string-based
	macros empower programmers to introduce notational shorthands, the
	parser-level macros of Lisp encourage experimentation with domain-specific
	languages. The Scheme programming language improves on Lisp with
	macros that respect lexical scope. The design of Racket - -a descendant
	of Scheme - -goes even further with the introduction of a full-fledged
	interface to the static semantics of the language. A Racket extension
	programmer can thus add constructs that are indistinguishable from
	"native" notation, large and complex embedded domain-specific languages,
	and even optimizing transformations for the compiler backend. This
	power to experiment with language design has been used to create
	a series of sub-languages for programming with first-class classes
	and modules, numerous languages for implementing the Racket system,
	and the creation of a complete and fully integrated typed sister
	language to Racket's untyped base language. This paper explains Racket's
	language extension API via an implementation of a small typed sister
	language. The new language provides a rich type system that accommodates
	the idioms of untyped Racket. Furthermore, modules in this typed
	language can safely exchange values with untyped modules. Last but
	not least, the implementation includes a type-based optimizer that
	achieves promising speedups. Although these extensions are complex,
	their Racket implementation is just a library, like any other library,
	requiring no changes to the Racket implementation. © 2011 ACM.},
  affiliation = {Northeastern University, United States; University of Utah, United
	States},
  author_keywords = {extensible languages; macros; modules; typed racket},
  document_type = {Conference Paper},
  journal = {Proceedings of the ACM SIGPLAN Conference on Programming Language
	Design and Implementation (PLDI)},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-79959888171&partnerID=40&md5=3dc69b01acc3ab63c2ff6f1375e159a4}
}

@CONFERENCE{Tolvanen2011,
  author = {Tolvanen, J.-P.},
  title = {MetaEdit+: Domain-specific modeling environment for product lines},
  year = {2011},
  note = {cited By (since 1996) 0},
  abstract = {This demonstration shows how Domain-Specific Modeling languages and
	related generators are used in product line development. First with
	practical examples we describe how languages and generators are defined
	with MetaEdit+ tool. We also describe how modern tools support evolution
	of the product line by updating the languages and models once the
	product line evolves. Demonstration ends with discussion on industry
	experiences from various product line companies. Copyright © 2011
	ACM.},
  affiliation = {MetaCase, Ylistönmäentie 31, FI-40500 Jyväskylä, Finland},
  art_number = {2019195},
  author_keywords = {Code generation; Domain-specific language; Domain-specific modeling;
	Language workbench},
  document_type = {Conference Paper},
  journal = {ACM International Conference Proceeding Series},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-80052674704&partnerID=40&md5=1ee1eb17ba0c7f29160d0ab0cd1ee1b9}
}

@ARTICLE{Tolvanen2011393,
  author = {Tolvanen, J.-P.},
  title = {Creating domain-specific modelling languages that work: Hands-on},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2011},
  volume = {6698 LNCS},
  pages = {393-394},
  note = {cited By (since 1996) 0},
  abstract = {A horrible lie exists in our industry today: it says that defining
	a graphical DSL is difficult and time intensive. In this tutorial,
	we will lay bare this fallacy and demonstrate how simple and quick
	it is to create domain-specific modelling languages and their generators.
	Through a hands-on approach, we define a modelling language and related
	generators in a few hours. More than just a technical exercise, we
	will show how this reflects industry experiences in various domains
	and companies. © 2011 Springer-Verlag.},
  affiliation = {MetaCase, Ylistönmäentie 31, FI-40500 Jyväskylä, Finland},
  author_keywords = {code generation; domain-specific language; Domain-specific modelling;
	language workbench; metamodeling},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-79959191884&partnerID=40&md5=3581766cc2d23e2de1e3f8488124cf42}
}

@ARTICLE{Tolvanen2006436,
  author = {Tolvanen, J.-P.},
  title = {Implementing domain-specific modeling languages and generators},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2006},
  volume = {4039 LNCS},
  pages = {436},
  note = {cited By (since 1996) 0},
  abstract = {Domain-Specific Modeling (DSM) languages provide a viable solution
	for improving development productivity by raising the level of abstraction
	beyond coding. With DSM, the models are made up of elements representing
	concepts that are part of the domain world, not the code world. These
	languages follow domain abstractions, and semantics, allowing developers
	- and depending on the domain even end-users - to perceive themselves
	as working directly with domain concepts. In many cases, full final
	product code can be automatically generated from these high-level
	specifications with domain-specific code generators. This tutorial
	introduces DSM and looks at how it differs from modeling languages
	like UML that focus more on the level of the code world. This is
	followed by real-life examples of DSM from various fields of software
	product development. We will illustrate language creation by analyzing
	20+ real-world DSM cases. The main part of the tutorial addresses
	the guidelines for implementing DSM: how to identify the necessary
	language constructs; how to make the metamodel to formalize language
	specification; and different ways of building code generation. Participants
	will be able to try their hand and learn these skills in practice
	in group exercises. © Springer-Verlag Berlin Heidelberg 2006.},
  affiliation = {MetaCase, Ylistönmäentie 31, FI-40500, Jyväskylä, Finland},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-33746216315&partnerID=40&md5=cfc3b6b7be50653c8d61ba9bf07840d5}
}

@CONFERENCE{Tolvanen2006690,
  author = {Tolvanen, J.-P.},
  title = {MetaEdit+: Integrated modeling and metamodeling environment for domain-specific
	languages},
  year = {2006},
  volume = {2006},
  pages = {690-691},
  note = {cited By (since 1996) 1},
  abstract = {Domain-Specific Modeling (DSM) raises the level of abstraction beyond
	programming by specifying the solution directly using domain concepts.
	In many cases, the final products can be generated from these high-level
	specifications. This automation is possible because both the language
	and generators need fit the requirements of only one company and
	domain.This demonstration illustrates DSM by showing real world cases
	from various fields of software development. These cases describe
	how DSM, giving first class support for modeling, can prevent incorrect
	or unwanted designs at the early stages of development, and how full
	code can be generated from the modeler's point of view. Second part
	of the demonstration will show in an interactive manner both the
	design side and the use side of DSM languages and generators. Using
	MetaEdit+ tool for metamodeling, we define a DSM for a given domain
	and apply it to generate full code from high-level models.},
  affiliation = {MetaCase, Ylistonmaentie 31, FI-40500 Jyvaskyla, Finland},
  art_number = {1176676},
  author_keywords = {Code generators; Domain-specific modeling; Metamodel},
  document_type = {Conference Paper},
  journal = {Proceedings of the Conference on Object-Oriented Programming Systems,
	Languages, and Applications, OOPSLA},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-34248353082&partnerID=40&md5=20d277cb00d3d17f89494009a1924245}
}

@CONFERENCE{Tolvanen2011358,
  author = {Tolvanen, J.-P., Kelly, S.},
  title = {Creating domain-specific modeling languages for product lines},
  year = {2011},
  pages = {358},
  note = {cited By (since 1996) 0},
  abstract = {This tutorial teaches how to define Domain-Specific Modeling languages
	for product lines: how to identify domain concepts and capture them
	in the language specification, how to enforce the architecture and
	coding rules, what options are available for code generation, and
	what are the industry experiences from companies. The tutorial includes
	exercises allowing participants to apply the language definition
	skills learned. © 2011 IEEE.},
  affiliation = {MetaCase, Jyväskylä, Finland},
  art_number = {6030092},
  author_keywords = {code generation; domain-specific language; domain-specific modeling;
	DSL; language workbench; metamodeling; modeling},
  document_type = {Conference Paper},
  journal = {Proceedings - 15th International Software Product Line Conference,
	SPLC 2011},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-80054064553&partnerID=40&md5=4f512b5fe133221d73dc909b17022437}
}

@CONFERENCE{Tolvanen2009819,
  author = {Tolvanen, J.-P., Kelly, S.},
  title = {MetaEdit+: Defining and using integrated domain-specific modeling
	languages},
  year = {2009},
  pages = {819-820},
  note = {cited By (since 1996) 0},
  abstract = {With MetaEdit+ you can build Domain-Specific Modeling languages and
	tools - without having to write a single line of code. This demonstration
	shows how different domain-specific languages (DSLs) can be integrated
	with high-level metamodels, how languages can be created iteratively
	while automatically updating existing models, and how multiple modelers
	can work together seamlessly.},
  affiliation = {MetaCase, Ylistonmentie 31, FI-40500 Jyvaskyla, Finland},
  author_keywords = {Code generation; Domain-specific languages; Domain-specific modeling;
	Language workbench; Metamodeling},
  document_type = {Conference Paper},
  journal = {Proceedings of the Conference on Object-Oriented Programming Systems,
	Languages, and Applications, OOPSLA},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-72249095680&partnerID=40&md5=00d004d3b476786f106c7b9131a808be}
}

@ARTICLE{Tolvanen2005198,
  author = {Tolvanen, J.-P., Kelly, S.},
  title = {Defining Domain-Specific Modeling languages to automate product derivation:
	Collected experiences},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2005},
  volume = {3714 LNCS},
  pages = {198-209},
  note = {cited By (since 1996) 9},
  abstract = {Domain-Specific Modeling offers a language-based approach to raise
	the level of abstraction in order to speed up development work and
	set variation space already at specification and design phase. In
	this paper we identify approaches that are applied for defining languages
	that enable automated variant derivation. This categorization is
	based on analyzing over 20 industrial cases of DSM language definition.
	© Springer-Verlag Berlin Heidelberg 2005.},
  affiliation = {MetaCase, Tlistönmaäentie 31, FI-40500 Jyvaäskylä, Finland},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-33646181211&partnerID=40&md5=ea27f6838002d8fcc5543ae7e4e1042a}
}

@CONFERENCE{Tolvanen2009707,
  author = {Tolvanen, J.-P.a , Gray, J.b , Rossi, M.c , Sprinkle, J.d },
  title = {The 9th OOPSLA workshop on domain-specific modeling},
  year = {2009},
  pages = {707-708},
  note = {cited By (since 1996) 0},
  abstract = {Domain-Specific Modeling raises the level of abstraction beyond programming
	by specifying the solution directly using visual models to express
	domain concepts. In many cases, final products can be generated automatically
	from these high-level specifications. This automation is possible
	because both the language and generators fit the requirements of
	only one domain. This paper introduces Domain-Specific Modeling and
	describes the related 2-day workshop (25th and 26th October 2009).},
  affiliation = {MetaCase, Ylistonmentie 31, FI-40500 Jyvaskyla, Finland; University
	of Alabama at Birmingham, 1300 University Blvd., Birmingham, AL 35294,
	United States; Helsinki School of Economics, FIN-00100 Helsinki,
	Finland; University of Arizona, ECE Department, 1230 E. Speedway
	Blvd., Tucson, AZ, United States},
  author_keywords = {Code generation; Domain-specific languages; Metamodeling; Modeling
	languages},
  document_type = {Conference Paper},
  journal = {Proceedings of the Conference on Object-Oriented Programming Systems,
	Languages, and Applications, OOPSLA},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-72249104545&partnerID=40&md5=4399d5cadb02a389154e0a27b222bb75}
}

@CONFERENCE{Tolvanen2007747,
  author = {Tolvanen, J.-P.a , Gray, J.b , Rossi, M.c , Sprinkle, J.d },
  title = {The 7th OOPSLA workshop on domain-specific modeling},
  year = {2007},
  pages = {747-748},
  note = {cited By (since 1996) 0},
  abstract = {Domain-Specific Modeling raises the level of abstraction beyond programming
	by specifying the solution directly using visual models to express
	domain concepts. In many cases, final products can be generated automatically
	from these high-level specifications. This automation is possible
	because both the language and generators fit the requirements of
	only one domain. This paper introduces Domain-Specific Modeling and
	describes the related 2-day workshop (21st and 22nd October).},
  affiliation = {MetaCase, Ylistonmentie 31, FIN-40500 Jyvaskyla, Finland; University
	of Alabama at Birmingham, 1300 University Blvd., Birmingham, AL 35294,
	United States; Helsinki School of Economics, FIN-00100 Helsinki,
	Finland; University of California, Berkeley, 337 Cory Hall, Berkeley,
	CA 94720, United States},
  author_keywords = {Code generation; Domain-specific languages; Metamodeling; Modeling
	languages},
  document_type = {Conference Paper},
  journal = {Proceedings of the Conference on Object-Oriented Programming Systems,
	Languages, and Applications, OOPSLA},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-42149135377&partnerID=40&md5=682c34326362b53ebe447e4c54bfefef}
}

@CONFERENCE{Tolvanen200392,
  author = {Tolvanen, J.-P.a , Rossi, M.b },
  title = {MetaEdit+: Defining and using domain-specific modeling languages
	and code generators},
  year = {2003},
  pages = {92-93},
  note = {cited By (since 1996) 16},
  abstract = {MetaEdit+ is an environment that allows building modeling tools and
	generators fitting to application domains, without having to write
	a single line of code. The capability to define modeling tools and
	generators is relevant as it provides the ability to raise the abstraction
	of design work from code to domain concepts, and a raise in abstraction
	leads to an imminent raise in productivity, as illustrated by the
	past years' experiences. In domain-specific modeling and MetaEdit+,
	one expert defines a domain-specific language as a metamodel containing
	the domain concepts and rules, and specifies the mapping from that
	to code in a domain-specific code generator. For the method implementation,
	MetaEdit+ provides a metamodeling language and tool suite for defining
	the method concepts, their properties, associated rules, symbols,
	checking reports, and generators. Once the expert defines a modeling
	method, or even a partial prototype, the rest of the team can start
	to use it in MetaEdit+ to make models with the modeling language
	and the required code is automatically generated from those models.
	Based on the metamodel, MetaEdit+ automatically provides CASE tool
	functionality: diagramming editors, browsers, generators, multiuser/project/platform
	support, etc. The MetaEdit+ demo will focus on showing how the domainspecific
	languages and generators are made; complete with several examples
	of domain-specific methods and related code generators.},
  affiliation = {MetaCase Consulting, Ylistonmaentie 31, FIN-40500 Jyvaskyla, Finland;
	Helsinki School of Economics, FIN-00100 Helsinki, Finland},
  author_keywords = {Code generators; Domain-specific modeling; Metamodel},
  document_type = {Conference Paper},
  journal = {Proceedings of the Conference on Object-Oriented Programming Systems,
	Languages, and Applications, OOPSLA},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-79951647741&partnerID=40&md5=4175a13a35429b43285a8aa64c65494a}
}

@CONFERENCE{Tolvanen2006622,
  author = {Tolvanen, J.-P.a , Sprinkle, J.b , Gray, J.c },
  title = {The 6th OOPSLA workshop on domain-specific modeling},
  year = {2006},
  volume = {2006},
  pages = {622-623},
  note = {cited By (since 1996) 1},
  abstract = {Domain-Specific Modeling raises the level of ion beyond programming
	by specifying the solution directly using visual models to express
	domain concepts. In many cases, final products can be generated automatically
	from these high-level specifications. This automation is possible
	because both the language and generators fit the requirements of
	only one domain. This paper introduces Domain-Specific Modeling and
	describes the related workshop.},
  affiliation = {MetaCase, Ylistonmentie 31, FIN-40500 Jyvaskyla, Finland; University
	of California, Berkeley, 337 Cory Hall, Berkeley, CA 94720, United
	States; University of Alabama at Birmingham, 1300 University Blvd.,
	Birmingham, AL 35294, United States},
  art_number = {1176638},
  author_keywords = {Code generation; Domain-specific languages; Metamodeling; Modeling
	languages},
  document_type = {Conference Paper},
  journal = {Proceedings of the Conference on Object-Oriented Programming Systems,
	Languages, and Applications, OOPSLA},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-34248349135&partnerID=40&md5=9c748cd45b848dbd4ee16f8d5ff1d905}
}

@CONFERENCE{Tolvanen2011317,
  author = {Tolvanen, J.-P.a , Sprinkle, J.b , Rossi, M.c , Gray, J.d },
  title = {The 11th workshop on domain-specific modeling},
  year = {2011},
  pages = {317-318},
  note = {cited By (since 1996) 0},
  abstract = {Domain-Specific Modeling (DSM) raises the level of abstraction beyond
	programming by specifying the solution directly using visual models
	to express domain concepts. In many cases, final products can be
	generated automatically from these high-level specifications. This
	automation is possible because both the language and generators fit
	the requirements of only one domain. This paper introduces DSM and
	describes the related 2-day workshop at SPLASH 2011 (23-24 October
	2011, Portland, OR).},
  affiliation = {MetaCase, Ylistonmaentie 31, FI-40500 Jyvaskyla, Finland; ECE Department,
	University of Arizona, 1230 E. Speedway Blvd., Tucson, AZ, United
	States; School of Economics, Aalto University, Runeberginkatu 22-24,
	FI-00100 Helsinki, Finland; University of Alabama, Box 870290, Tuscaloosa,
	AL 35487, United States},
  author_keywords = {Code generation; Domain- Specific languages; Metamodeling; Modeling
	languages},
  document_type = {Conference Paper},
  journal = {SPLASH'11 Compilation - Proceedings of OOPSLA'11, Onward! 2011, GPCE'11,
	DLS'11, and SPLASH'11 Companion},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-81355135377&partnerID=40&md5=e1230fb29d519a3970729c092dcb3cfc}
}

@CONFERENCE{Tolvanen2010269,
  author = {Tolvanen, J.-P.a , Sprinkle, J.b , Rossi, M.c , Kelly, S.a },
  title = {The 10th workshop on domain-specific modeling},
  year = {2010},
  pages = {269-270},
  note = {cited By (since 1996) 0},
  abstract = {Domain-Specific Modeling raises the level of abstraction beyond programming
	by specifying the solution directly using visual models to express
	domain concepts. In many cases, final products can be generated automatically
	from these high-level specifications. This automation is possible
	because both the language and generators fit the requirements of
	only one domain. This paper introduces Domain-Specific Modeling and
	describes the related 2-day workshop (17th and 18th October 2010).},
  affiliation = {MetaCase, Ylistonmaentie 31, FI-40500 Jyvaskyla, Finland; University
	of Arizona, ECE Department, 1230 E. Speedway Blvd., Tucson, AZ, United
	States; Aalto University, School of Economics, Runeberginkatu 22-24,
	FI-00100 Helsinki, Finland},
  author_keywords = {Code generation; Domain-specific languages; Metamodeling; Modeling
	languages},
  document_type = {Conference Paper},
  journal = {Proceedings of the ACM International Conference Companion on Object
	Oriented Programming Systems Languages and Applications Companion,
	SPLASH '10},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-78650084172&partnerID=40&md5=6e97f207eeef43f3fbec27bc0a643efb}
}

@ARTICLE{Toronto201189,
  author = {Toronto, N., McCarthy, J.},
  title = {From Bayesian notation to pure racket via discrete measure-theoretic
	probability in λZFC},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2011},
  volume = {6647 LNCS},
  pages = {89-104},
  note = {cited By (since 1996) 0},
  abstract = {Bayesian practitioners build models of the world without regarding
	how difficult it will be to answer questions about them. When answering
	questions, they put off approximating as long as possible, and usually
	must write programs to compute converging approximations. Writing
	the programs is distracting, tedious and error-prone, and we wish
	to relieve them of it by providing languages and compilers. Their
	style constrains our work: the tools we provide cannot approximate
	early. Our approach to meeting this constraint is to 1) determine
	their notation's meaning in a suitable theoretical framework; 2)
	generalize our interpretation in an uncomputable, exact semantics;
	3) approximate the exact semantics and prove convergence; and 4)
	implement the approximating semantics in Racket (formerly PLT Scheme).
	In this way, we define languages with at least as much exactness
	as Bayesian practitioners have in mind, and also put off approximating
	as long as possible. In this paper, we demonstrate the approach using
	our preliminary work on discrete (countably infinite) Bayesian models.
	© 2011 Springer-Verlag.},
  affiliation = {PLT at Brigham Young University, Provo, UT, United States},
  author_keywords = {Domain-specific languages; Probability theory; Semantics},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-80054098175&partnerID=40&md5=fec1c4c43fef01338f3ce115d5283cde}
}

@CONFERENCE{Tran2011407,
  author = {Tran, H.a , Holmes, T.a , Oberortner, E.a , Mulo, E.a , Cavalcante,
	A.B.b , Serafinski, J.b , Tluczek, M.b , Birukou, A.c , Daniel, F.c
	, Silveira, P.c , Zdun, U.d , Dustdar, S.a },
  title = {An end-to-end framework for business compliance in process-driven
	SOAs},
  year = {2011},
  pages = {407-414},
  note = {cited By (since 1996) 0},
  abstract = {It is significant for companies to ensure their businesses conforming
	to relevant policies, laws, and regulations as the consequences of
	infringement can be serious. Unfortunately, the divergence and frequent
	changes of different compliance sources make it hard to systematically
	and quickly accommodate new compliance requirements due to the lack
	of an adequate methodology for system and compliance engineering.
	In addition, the difference of perception and expertise of multiple
	stakeholders involving in system and compliance engineering further
	complicates the analyzing, implementing, and assessing of compliance.
	For these reasons, in many cases, business compliance today is reached
	on a per-case basis by using ad hoc, hand-crafted solutions for specific
	rules to which they must comply. This leads in the long run to problems
	regarding complexity, understandability, and maintainability of compliance
	concerns in a SOA. To address the aforementioned challenges, we present
	in this invited paper a comprehensive SOA business compliance software
	framework that enables a business to express, implement, monitor,
	and govern compliance concerns. © 2010 IEEE.},
  affiliation = {Distributed Systems Group, Institute of Information Systems, Vienna
	University of Technology, Austria; Telcordia, Poland; University
	of Trento, Italy; Software Architecture Group, Department of Distributed
	and Multimedia Systems, University of Vienna, Austria},
  art_number = {5715316},
  author_keywords = {Business compliance; Domain-specific languages; Event processing;
	Governance dashboard; Model-driven development; Process-driven SOA;
	Runtime monitoring; Viewbased},
  document_type = {Conference Paper},
  journal = {Proceedings - 12th International Symposium on Symbolic and Numeric
	Algorithms for Scientific Computing, SYNASC 2010},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-79952529989&partnerID=40&md5=aca5c59d8600d34baf8c98626b1a38f0}
}

@CONFERENCE{Tranoris20111140,
  author = {Tranoris, C.},
  title = {Adopting the DSM paradigm: Defining federation scenarios through
	resource brokers for experimentally driven research},
  year = {2011},
  pages = {1140-1147},
  note = {cited By (since 1996) 0},
  abstract = {Federation scenarios for experimentally driven research usually involve
	resources offered by a diverse pool of organizations. Federation
	can be done by a resource broker, which has no resources of its own.
	Instead the broker matches customer's requested services and providers
	resources based on the SLA required by the end-user. The end-user
	has no knowledge that the broker does not control the resources.
	This work considers the concepts of modeling and meta-modeling to
	define a resource broker and to specify federation scenarios by applying
	the Domain Specific Modeling (DSM) paradigm. Moreover, we acknowledge
	the fact that resource models already exist and we adopt model to
	model transformations. We argue that defining a resource broker meta-model,
	focusing on the federation domain and applying DSM practices is necessary
	in order to: i) create formal description of a resource broker and
	its resource providers with its offered services and resources, ii)
	have valid, comprehensible and unambiguous configurations that support
	federation scenarios, iii) simplify the combination of services and
	resources from third parties that are non-conformant to the meta-model
	and iv) have common definitions and understanding by the resource
	federation domain, thus being efficient and practicable. We present
	a family of Domain Specific Languages (DSLs) having the meta-model
	as their abstract syntax, for defining model entities, describing
	a resource broker and federation scenarios between organizations.
	Additionally, prototype tooling supports the DSLs and the proposed
	framework. © 2011 IEEE.},
  affiliation = {Electrical and Computing Engineering dept., University of Patras,
	Patras, Greece},
  art_number = {5990574},
  author_keywords = {Domain Specific Lanuages; Domain Specific Modeling; experimentally
	driven research; federation; Future Internet; Resource Brokers},
  document_type = {Conference Paper},
  journal = {Proceedings of the 12th IFIP/IEEE International Symposium on Integrated
	Network Management, IM 2011},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-80052697960&partnerID=40&md5=1f83c75f6a7d31ceb3489435333d9d45}
}

@ARTICLE{Tratt2008,
  author = {Tratt, L.},
  title = {Domain specific language implementation via compile-time meta-programming},
  journal = {ACM Transactions on Programming Languages and Systems},
  year = {2008},
  volume = {30},
  number = {6},
  note = {cited By (since 1996) 10},
  abstract = {Domain specific languages (DSLs) are mini-languages that are increasingly
	seen as being a valuable tool for software developers and non-developers
	alike. DSLs must currently be created in an ad-hoc fashion, often
	leading to high development costs and implementations of variable
	quality. In this article, I show how expressive DSLs can be hygienically
	embedded in the Converge programming language using its compile-time
	meta-programming facility, the concept of DSL blocks, and specialised
	error reporting techniques. By making use of pre-existing facilities,
	and following a simple methodology, DSL implementation costs can
	be significantly reduced whilst leading to higher quality DSL implementations.
	© 2008 ACM.},
  affiliation = {Bournemouth University, Poole, Dorset, BH12 5BB, United Kingdom},
  art_number = {31},
  author_keywords = {Compile-time meta-programming; Domain specific languages; Syntax extension},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-56349147876&partnerID=40&md5=502728a9aba24ccbcf9d480d9bbb5a6e}
}

@ARTICLE{Tratt2008425,
  author = {Tratt, L.},
  title = {Evolving a DSL implementation},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2008},
  volume = {5235 LNCS},
  pages = {425-441},
  note = {cited By (since 1996) 0},
  abstract = {Domain Specific Languages (DSLs) are small languages designed for
	use in a specific domain. DSLs typically evolve quite radically throughout
	their lifetime, but current DSL implementation approaches are often
	clumsy in the face of such evolution. In this paper I present a case
	study of an DSL evolving in its syntax, semantics, and robustness,
	implemented in the Converge language. This shows how real-world DSL
	implementations can evolve along with changing requirements. © 2008
	Springer Berlin Heidelberg.},
  affiliation = {Bournemouth University, Poole, Dorset BH12 5BB, United Kingdom},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-57049102870&partnerID=40&md5=c50c5be34d239bdbd068c3c1eec112af}
}

@ARTICLE{Troya2010296,
  author = {Troya, J., Rivera, J.E., Vallecillo, A.},
  title = {On the specification of non-functional properties of systems by observation},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2010},
  volume = {6002 LNCS},
  pages = {296-309},
  note = {cited By (since 1996) 0},
  abstract = {Domain specific languages play a cornerstone role in Model-Driven
	Engineering (MDE) for representing models and metamodels. So far,
	most of the MDE community efforts have focused on the specification
	of the functional properties of systems. However, the correct and
	complete specification of some of their non-functional properties
	is critical in many important distributed application domains, such
	as embedded systems, multimedia applications or e-commerce services.
	In this paper we present an approach to specify QoS requirements,
	based on the observation of the system actions and of the state of
	its objects. We show how this approach can be used to extend languages
	which specify behavior in terms of rules, and how QoS characteristics
	can be easily expressed and reused across models. We show as well
	how this approach enables the specification of other important properties
	of systems, such as automatic reconfiguration of the system when
	some of the QoS properties change. © Springer-Verlag Berlin Heidelberg
	2010.},
  affiliation = {GISUM, Atenea Research Group, Universidad de Málaga, Spain},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-78650373253&partnerID=40&md5=144cd074329efe9a1bfa0f5bac884f82}
}

@CONFERENCE{Trujillo2007105,
  author = {Trujillo, S.a , Azanza, M.b , Diaz, O.b },
  title = {Generative metaprogramming},
  year = {2007},
  pages = {105-114},
  note = {cited By (since 1996) 3},
  abstract = {Recent advances in Software Engineering have reduced the cost of coding
	programs at the expense of increasing the complexity of program synthesis,
	i.e. metaprograms, which when executed, will synthesize a target
	program. The traditional cycle of configuring-linking-compiling,
	now needs to be supplemented with additional transformation steps
	that refine and enhance an initial specification until the target
	program is obtained. So far, these synthesis processes are based
	on error-prone, hand-crafted scripting. To depart from this situation,
	this paper addresses generative metaprogramming, i.e. the generation
	of program-synthesis metaprograms from declarative specifications.
	To this end, we explore (i) the (meta) primitives for program synthesis,
	(ii) the architecture that dictates how these primitives can be intertwined,
	and (iii) the declarative specification of the metaprogram from which
	the code counterpart is generated. Copyright © 2007 ACM.},
  affiliation = {IKERLAN Research Centre, Mondragon, Spain; ONEKIN Research Group,
	University of the Basque Country, San Sebastian, Spain},
  author_keywords = {Feature oriented model-driven development; Generative metaprogramming;
	Generative programming; Metaprogramming; Software product lines},
  document_type = {Conference Paper},
  journal = {GPCE'07 - Proceedings of the Sixth International Conference on Generative
	Programming and Component Engineering},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-38849093782&partnerID=40&md5=435cf1526a201c7f31b3e27d70bac126}
}

@ARTICLE{Truşcan200949,
  author = {Truşcan, D.a , Lundkvist, T.a , Alanen, M.b , Sandström, K.c , Porres,
	I.a , Lilius, J.a },
  title = {MDE for SoC design},
  journal = {Innovations in Systems and Software Engineering},
  year = {2009},
  volume = {5},
  pages = {49-64},
  number = {1},
  note = {cited By (since 1996) 1},
  abstract = {We employ the principles of model-driven engineering to assist the
	design of system-on-chip (SoC) architectures. As a concrete example,
	we look at the MICAS architecture, for which we propose a graphical
	specification language, defined via metamodeling techniques, that
	models the architecture at different abstraction levels. Model transformations
	are defined to support the refinement of MICAS specification towards
	implementation. In addition, several libraries are put in place,
	to enable reuse and automation throughout the design process. Tool
	support for editing the specifications, enforcing their consistency,
	and for running the transformations is provided via the Coral modeling
	framework. The approach shows that model-driven engineering can be
	seen as an enabler in providing computer-aided software engineering
	(CASE) tool support and automation for the development of SoC architectures.
	© Springer-Verlag London Limited 2009.},
  affiliation = {Department of Information Technologies, Åbo Akademi University, Joukahaisenkatu
	3-5B, Turku 20520, Finland; Ixonos Plc, Hitsaajankatu 24, Helsinki
	00811, Finland; Nokia Research Centre, Itämerenkatu 11 - 13, Helsinki
	00180, Finland},
  author_keywords = {Domain-specific language; Metamodel; Model transformation; Model-driven
	engineering; Systemon chip},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-63049097430&partnerID=40&md5=5cb1d58da6cd0c1632db40775f23cbc9}
}

@CONFERENCE{Tundrea2008193,
  author = {Tundrea, E.},
  title = {SmartModels - An MDE platform for the management of software product
	lines},
  year = {2008},
  volume = {3},
  pages = {193-199},
  note = {cited By (since 1996) 1},
  abstract = {In software engineering everything evolves very fast: user requirements,
	technologies, methodologies and applications. Can we foresight and
	strengthen our approaches to build software to confront these more
	and more complex challenges? While there are key issues to solve,
	it is also noteworthy to know that we are very close to exciting
	innovations. Software Product Lines (SPL) - modeling technology together
	with source-code generative tools seem to make it easier to manage
	diverse environments with complex, constantly changing relationships.
	In the context of SPL, this paper presents an approach - SmartModels
	[1] [2], validated by a prototype - SmartFactory. It reviews the
	state-of-the-art of SmartModels briefly introducing its principles,
	basic entities and main elements when defining a business-model.
	It also addresses the Meta-Object Protocol (MOP) which lays the foundation
	of SmartModels' mechanism to fill the gap between the semantics and
	the reification of a model entity. ©2008 IEEE.},
  affiliation = {Politehnica University of Timisoara},
  art_number = {4588910},
  author_keywords = {Generative programming; Model; Prototype; Software factory; Software
	product lines},
  document_type = {Conference Paper},
  journal = {2008 IEEE International Conference on Automation, Quality and Testing,
	Robotics, AQTR 2008 - THETA 16th Edition - Proceedings},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-51949105272&partnerID=40&md5=834554977606f2f2ff70d7e3c122da6c}
}

@ARTICLE{Uzuner200813,
  author = {Uzuner, O.a , Sibanda, T.C.b , Luo, Y.a , Szolovits, P.b },
  title = {A de-identifier for medical discharge summaries},
  journal = {Artificial Intelligence in Medicine},
  year = {2008},
  volume = {42},
  pages = {13-35},
  number = {1},
  note = {cited By (since 1996) 6},
  abstract = {Objective: Clinical records contain significant medical information
	that can be useful to researchers in various disciplines. However,
	these records also contain personal health information (PHI) whose
	presence limits the use of the records outside of hospitals. The
	goal of de-identification is to remove all PHI from clinical records.
	This is a challenging task because many records contain foreign and
	misspelled PHI; they also contain PHI that are ambiguous with non-PHI.
	These complications are compounded by the linguistic characteristics
	of clinical records. For example, medical discharge summaries, which
	are studied in this paper, are characterized by fragmented, incomplete
	utterances and domain-specific language; they cannot be fully processed
	by tools designed for lay language. Methods and results: In this
	paper, we show that we can de-identify medical discharge summaries
	using a de-identifier, Stat De-id, based on support vector machines
	and local context (F-measure = 97% on PHI). Our representation of
	local context aids de-identification even when PHI include out-of-vocabulary
	words and even when PHI are ambiguous with non-PHI within the same
	corpus. Comparison of Stat De-id with a rule-based approach shows
	that local context contributes more to de-identification than dictionaries
	combined with hand-tailored heuristics (F-measure = 85%). Comparison
	with two well-known named entity recognition (NER) systems, SNoW
	(F-measure = 94%) and IdentiFinder (F-measure = 36%), on five representative
	corpora show that when the language of documents is fragmented, a
	system with a relatively thorough representation of local context
	can be a more effective de-identifier than systems that combine (relatively
	simpler) local context with global context. Comparison with a Conditional
	Random Field De-identifier (CRFD), which utilizes global context
	in addition to the local context of Stat De-id, confirms this finding
	(F-measure = 88%) and establishes that strengthening the representation
	of local context may be more beneficial for de-identification than
	complementing local with global context. © 2007 Elsevier B.V. All
	rights reserved.},
  affiliation = {University at Albany, State University of New York, Draper 114, 135
	Western Avenue, Albany, NY 12222, United States; Massachusetts Institute
	of Technology, Computer Science and Artificial Intelligence Laboratory,
	32 Vassar Street, Cambridge, MA 02139, United States},
  author_keywords = {Automatic de-identification of narrative patient records; Dictionaries;
	Local lexical context; Local syntactic context; Sentential global
	context; Syntactic information for de-identification},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-37649006666&partnerID=40&md5=fd829cde136a967c9166b7381b0336c9}
}

@CONFERENCE{Vachharajani2004,
  author = {Vachharajani, M., Vachharajani, N., August, D.I.},
  title = {The liberty structural specification language: A high-level modeling
	language for component reuse},
  year = {2004},
  pages = {195-206},
  note = {cited By (since 1996) 11},
  abstract = {Rapid exploration of the design space with simulation models is essential
	for quality hardware systems research and development. Despite striking
	commonalities across hardware systems, designers routinely fail to
	achieve high levels of reuse across models constructed in existing
	general-purpose and domain-specific languages. This lack of reuse
	adversely impacts hardware system design by slowing the rate at which
	ideas are evaluated. This paper presents an examination of existing
	languages to reveal their fundamental limitations regarding reuse
	in hardware modeling. With this understanding, a solution is described
	in the context of the design and implementation of the Liberty Structural
	Specification Language (LSS), the input language for a publicly available
	high-level digital-hardware modeling tool called the Liberty Simulation
	Environment. LSS is the first language to enable low-overhead reuse
	by simultaneously supporting static inference based on hardware structure
	and flexibility via parameterizable structure. Through LSS, this
	paper also introduces a new type inference algorithm and a new programming
	language technique, called use-based specialization, which, in a
	manner analogous to type inference, customizes reusable components
	by statically inferring structural properties that otherwise would
	have had to have been specified manually.},
  affiliation = {Department of Computer Science, Princeton University, Princeton, NJ
	08544},
  author_keywords = {Component reuse; Liberty Simulation Environment (LSE); Liberty Structural
	Specification (LSS); Simulator construction; Structural modeling;
	Type inference; Use-based specialization},
  document_type = {Conference Paper},
  journal = {Proceedings of the ACM SIGPLAN Conference on Programming Language
	Design and Implementation (PLDI)},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-8344233415&partnerID=40&md5=9599a889dcd1714055678abc3096444b}
}

@ARTICLE{Vachharajani2004195,
  author = {Vachharajani, M., Vachharajani, N., August, D.I.},
  title = {The liberty structural specification language: A high-level modeling
	language for component reuse},
  journal = {ACM SIGPLAN Notices},
  year = {2004},
  volume = {39},
  pages = {195-206},
  number = {6},
  note = {cited By (since 1996) 3},
  abstract = {Rapid exploration of the design space with simulation models is essential
	for quality hardware systems research and development. Despite striking
	commonalities across hardware systems, designers routinely fail to
	achieve high levels of reuse across models constructed in existing
	general-purpose and domain-specific languages. This lack of reuse
	adversely impacts hardware system design by slowing the rate at which
	ideas are evaluated. This paper presents an examination of existing
	languages to reveal their fundamental limitations regarding reuse
	in hardware modeling. With this understanding, a solution is described
	in the context of the design and implementation of the Liberty Structural
	Specification Language (LSS), the input language for a publicly available
	high-level digital-hardware modeling tool called the Liberty Simulation
	Environment. LSS is the first language to enable low-overhead reuse
	by simultaneously supporting static inference based on hardware structure
	and flexibility via parameterizable structure. Through LSS, this
	paper also introduces a new type inference algorithm and a new programming
	language technique, called use-based specialization, which, in a
	manner analogous to type inference, customizes reusable components
	by statically inferring structural properties that otherwise would
	have had to have been specified manually.},
  affiliation = {Departments of Computer Science, Princeton University, Princeton,
	NJ 08544},
  author_keywords = {Component reuse; Liberty Simulation Environment (LSE); Liberty Structural
	Specification (LSS); Simulator construction; Structural modeling;
	Type inference; Use-based specialization},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-4544234210&partnerID=40&md5=41e898e85b7819d9364d8b095142e641}
}

@CONFERENCE{Vajda2010389,
  author = {Vajda, A.a , Eker, J.b },
  title = {Return to the language forrest: The case for DSL oriented software
	engineering},
  year = {2010},
  pages = {389-392},
  note = {cited By (since 1996) 0},
  abstract = {In this position paper we argue for a radical departure from today's
	approach to software engineering, centered on target-specific tools
	and general processes such as modeling and agile practices. The old
	principle of right tool for each problem shall be applied to software
	engineering as well: to address ever higher complexity, we need to
	raise dramatically the level of abstraction; as general solutions
	all largely failed, we need to focus on problem domain specific approaches.
	Instead of focusing on the platform paradigm (von Neumann and derived
	architectures), we need to focus on each of the problem domains,
	by creating a language or modeling environment specific to each domain
	that can be used by domain experts with very limited software or
	hardware competence, while putting the platform mapping in the target-specific
	compiler, developed by platform experts. This approach to software
	engineering will require a new approach to ways of working as well
	as research into new technologies. Copyright 2010 ACM.},
  affiliation = {Ericsson Software Research, Finland; Ericsson Research, Sweden},
  author_keywords = {Domain specific languages; Software engineering methods},
  document_type = {Conference Paper},
  journal = {Proceedings of the FSE/SDP Workshop on the Future of Software Engineering
	Research, FoSER 2010},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-79951650315&partnerID=40&md5=16d3ed5c84d7b9292c1aac81a70cf829}
}

@CONFERENCE{Vajk200931,
  author = {Vajk, T.a , Kereskényi, R.b , Levendovszky, T.b , Lédeczi, Á.b },
  title = {Raising the abstraction of domain-specific model translator development},
  year = {2009},
  pages = {31-37},
  note = {cited By (since 1996) 1},
  abstract = {Model-based development methodologies are gaining ground as software
	applications are getting more and more complex while the pressure
	to decrease time-to-market continually increase. Domain-specific
	modeling tools that support system analysis, simulation, and automatic
	code generation can increase productivity. However, most domain-specific
	model translators are still manually written. This paper presents
	a technique that automatically generates a domain-specific application
	programming interface from the same metamodels that are used to define
	the domain-specific modeling language itself. This facilitates the
	creation of domain-specific model translators by providing a high-level
	abstraction hiding all the cumbersome modeling tool-specific implementation
	details from the developer. The approach is illustrated using the
	Generic Modeling Environment and the Microsoft .NET C# language.
	© 2009 IEEE.},
  affiliation = {Department of Automation and Applied Informatics, Budapest University
	of Technology and Economics, Budapest, Hungary; Institute for Software
	Integrated Systems, Vanderbilt University, Nashville, United States},
  art_number = {4839229},
  author_keywords = {Code generation; Domain-specific modeling; Metamodeling; Translator},
  document_type = {Conference Paper},
  journal = {Proceedings of the International Symposium and Workshop on Engineering
	of Computer Based Systems},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-67650230058&partnerID=40&md5=928b94bba4294a84565407ea26908af6}
}

@CONFERENCE{Valiente2010378,
  author = {Valiente, M.-C.a , Rodríguez, D.a , Vicente-Chicote, C.b },
  title = {Defining the semantics of it service management models using OWL
	and SWRL},
  year = {2010},
  pages = {378-381},
  note = {cited By (since 1996) 0},
  abstract = {Service management is a set of specialized organizational capabilities
	that provide value to customers in the form of services. Many organizations
	are aware of the need to adopt best practices in order to create
	an effective IT Service Management (ITSM) for enabling Business and
	IT integration. However, the reuse and interchange of service models
	is still quite limited in the area of IT service support due to the
	problems in connecting with natural language. In this context, this
	paper presents the ITIL-based Service Management Model aimed at capturing
	ITSM best practices by means of a formal ontology-based business
	DSL (Domain-Specific Language). We show how this DSL can be formally
	represented adopting the Web Ontology Language (OWL) and the Semantic
	Web Rule Language (SWRL). This ontology will precisely define the
	semantics associated to IT service management models, enabling different
	tools to interchange them without ambiguities. These models will
	be defined just in terms of the business logic, without any architectural
	or platform-specific consideration. That is, according to the OMG's
	four-layered architecture, the proposed model could be placed at
	a CIM level.},
  affiliation = {Computer Science Department, University of Alcalá, Polytechnic Building,
	Ctra. Barcelona km. 33.6, 28871 Alcalá de Henares (Madrid), Spain;
	Departamento de Tecnologías de la Informacion y Las Comunicaciones,
	Universidad Politécnica de Cartagena, 30202 Cartagena (Murcia), Spain},
  author_keywords = {ITIL; ITSM; Knowledge representation; Ontologies; OWL; Service process
	modelling; SWRL},
  document_type = {Conference Paper},
  journal = {KEOD 2010 - Proceedings of the International Conference on Knowledge
	Engineering and Ontology Development},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-78651414877&partnerID=40&md5=2e8eead6cdc7655783a9f4f9457fc042}
}

@ARTICLE{Vallecillo2010305,
  author = {Vallecillo, A.},
  title = {On the combination of domain specific modeling languages},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2010},
  volume = {6138 LNCS},
  pages = {305-320},
  note = {cited By (since 1996) 2},
  abstract = {Domain Specific Modeling Languages (DSMLs) are essential elements
	in Model-based Engineering. Each DSML allows capturing certain properties
	of the system, while abstracting other properties away. Nowadays
	DSMLs are mostly used in silos to solve specific problems. However,
	there are many occasions when multiple DSMLs need to be combined
	to design systems in a modular way. In this paper we discuss some
	scenarios of use and several mechanisms for DSML combination. We
	propose a general framework for combining DSMLs that subsumes them,
	based on the concept of viewpoint unification, and its realization
	using model-driven techniques. © 2010 Springer-Verlag.},
  affiliation = {GISUM/Atenea Research Group, Universidad de Málaga, Spain},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-77954651006&partnerID=40&md5=69128f1fb1da6c0376d674c28925a3d7}
}

@CONFERENCE{VanAmstel201048,
  author = {Van Amstel, M., Van Den Brand, M., Engelen, L.},
  title = {An exercise in iterative domain-specific language design},
  year = {2010},
  pages = {48-57},
  note = {cited By (since 1996) 0},
  abstract = {We describe our experiences with the process of designing a domain-specific
	language (DSL) and corresponding model transformations. The simultaneous
	development of the language and the transformations has lead to an
	iterative evolution of the DSL. We identified four main influences
	on the evolution of our DSL: the problem domain, the target platforms,
	model quality, and model transformation quality. Our DSL is aimed
	at modeling the structure and behavior of distributed communicating
	systems. Simultaneously with the development of our DSL, we implemented
	three model transformations to different formalisms: one for simulation,
	one for execution, and one for verification. Transformations to each
	of these formalisms were implemented one at the time, while preserving
	the validity of the existing ones. The DSL and the formalisms for
	simulation, execution, and verification have different semantic characteristics.
	We also implemented a number of model transformations that bridge
	the semantic gaps between our DSL and each of the three formalisms.
	In this paper, we describe our development process and how the aforementioned
	influences have caused our DSL to evolve. © 2010 ACM.},
  affiliation = {Eindhoven University of Technology, P.O. Box 513, 5600 MB Eindhoven,
	Netherlands},
  document_type = {Conference Paper},
  journal = {ACM International Conference Proceeding Series},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-78649995956&partnerID=40&md5=26b48453bfe010ee14b55e414d060bdd}
}

@CONFERENCE{VanAmstel2011120,
  author = {Van Amstel, M.F., Van Den Brand, M.G.J., Engelen, L.J.P.},
  title = {Using a DSL and fine-grained model transformations to explore the
	boundaries of model verification},
  year = {2011},
  pages = {120-127},
  note = {cited By (since 1996) 0},
  abstract = {Traditionally, the state-space explosion problem in model checking
	is handled by applying abstractions and simplifications to the model
	that needs to be verified. In this paper, we propose a model-driven
	engineering approach that works the other way around. Instead of
	making a concrete model more abstract, we propose to refine an abstract
	model to make it more concrete. We propose to use fine-grained model
	transformations to enable model checking of models that are as close
	to the implementation model as possible. We applied our approach
	in a case study. The results show that it is possible to validate
	models that are more concrete when fine-grained transformations are
	applied. © 2011 IEEE.},
  affiliation = {Eindhoven University of Technology, P.O. Box 513, 5600 MB, Eindhoven,
	Netherlands},
  art_number = {6004513},
  author_keywords = {Domain-specific language; Model checking; Model transformation; Model-driven
	engineering; Verification},
  document_type = {Conference Paper},
  journal = {2011 5th International Conference on Secure Software Integration
	and Reliability Improvement - Companion, SSIRI-C 2011},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-80052983115&partnerID=40&md5=469fcbdf0ab6d0f9f5798f19412e8e96}
}

@CONFERENCE{VanAmstel201163,
  author = {Van Amstel, M.F., Van Den Brand, M.G.J., Engelen, L.J.P.},
  title = {Using a DSL and fine-grained model transformations to explore the
	boundaries of model verification - Extended abstract},
  year = {2011},
  pages = {63-66},
  note = {cited By (since 1996) 0},
  abstract = {Traditionally, the state-space explosion problem in model checking
	is handled by applying abstractions and simplifications to the model
	that needs to be verified. In this paper, we propose a model-driven
	engineering approach that works the other way around. Instead of
	making a concrete model more abstract, we propose to refine an abstract
	model to make it more concrete. We propose to use fine-grained model
	transformations to enable model checking of models that are as close
	to the implementation model as possible. We applied our approach
	in a case study. The results show that models that are more concrete
	can be validated when fine-grained transformations are applied. ©
	2011 IEEE.},
  affiliation = {Eindhoven University of Technology, P.O. Box 513, 5600 MB, Eindhoven,
	Netherlands},
  art_number = {5954391},
  author_keywords = {Domain-specific language; Model checking; Model transformation; Model-driven
	engineering; Verification},
  document_type = {Conference Paper},
  journal = {Proceedings - 4th IEEE International Conference on Software Testing,
	Verification, and Validation Workshops, ICSTW 2011},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-80051633742&partnerID=40&md5=0430ef74a7589ad9be1d4c52488e74d8}
}

@ARTICLE{VanBaelen201063,
  author = {Van Baelen, S.a , Weigert, T.b , Ober, I.c , Espinoza, H.d , Ober,
	I.c },
  title = {Model based architecting and construction of embedded systems (ACES-MB
	2009)},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2010},
  volume = {6002 LNCS},
  pages = {63-67},
  note = {cited By (since 1996) 0},
  abstract = {The second ACES-MB workshop brought together researchers and practitioners
	interested in model-based software engineering for real-time embedded
	systems, with a particular focus on the use of models for architecture
	description and domain-specific design, and for capturing non-functional
	constraints. Eleven presenters proposed contributions on domain-specific
	languages for embedded systems, the Architecture Analysis and Design
	Language (AADL), analysis and formalization, semantics preservation
	issues, and variability and reconfiguration. In addition, a lively
	group discussion tackled the issue of combining models from different
	Domain Specific Modeling Languages (DSMLs). This report presents
	an overview of the presentations and fruitful discussions that took
	place during the ACES-MB 2009 workshop. © Springer-Verlag Berlin
	Heidelberg 2010.},
  affiliation = {K.U.Leuven - DistriNet, Belgium; Missouri University of Science and
	Technology, United States; University of Toulouse - IRIT, France;
	CEA - LIST, France},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-78650396120&partnerID=40&md5=0f1a8d738daf7afc44e518ed443057d9}
}

@CONFERENCE{VanCutsem20073,
  author = {Van Cutsem, T., Mostinckx, S., Boix, E.G., Dedecker, J., De Meuter,
	W.},
  title = {AmbientTalk: Object-oriented event-driven programming in mobile ad
	hoc networks},
  year = {2007},
  pages = {3-12},
  note = {cited By (since 1996) 23},
  abstract = {In this paper, we describe AmbientTalk: a domain-specific language
	for orchestrating service discovery and composition in mobile ad
	hoc networks. AmbientTalk is a distributed object-oriented language
	whose actor-based, event-driven concurrency model makes it highly
	suitable for composing service objects across a mobile network. The
	language is a so-called ambient-oriented programming language which
	treats network partitions as a normal mode of operation. We describe
	AmbientTalk's object model, concurrency model and distributed communication
	model in detail. We also highlight influences from other languages
	and middleware that have shaped AmbientTalk's design. © 2007 IEEE.},
  affiliation = {Programming Technology Lab., Vrije Universiteit Brussel, Brussels,
	Belgium},
  art_number = {4396972},
  document_type = {Conference Paper},
  journal = {Proceedings - International Conference of the Chilean Computer Science
	Society, SCCC},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-47349087479&partnerID=40&md5=57e2de825472710a549ce37fd3d8b241}
}

@ARTICLE{VanCutsem200980,
  author = {Van Cutsem, T., Mostinckx, S., De Meuter, W.},
  title = {Linguistic symbiosis between event loop actors and threads},
  journal = {Computer Languages, Systems and Structures},
  year = {2009},
  volume = {35},
  pages = {80-98},
  number = {1},
  note = {cited By (since 1996) 1},
  abstract = {In modern programming languages, concurrency control can be traced
	back to one of two different schools: actor-based message passing
	concurrency and thread-based shared-state concurrency. This paper
	describes a linguistic symbiosis between two programming languages
	with such different concurrency models. More specifically, we describe
	a novel symbiosis between actors represented as event loops on the
	one hand and threads on the other. This symbiosis ensures that the
	invariants of the actor-based concurrency model are not violated
	by engaging in symbiosis with multithreaded programs. The proposed
	mapping is validated by means of a concrete symbiosis between AmbientTalk,
	a flexible, domain-specific language for writing distributed programs
	and Java, a conventional object-oriented language. This symbiosis
	allows the domain-specific language to reuse existing software components
	written in a multithreaded language without sacrificing the beneficial
	event-driven properties of the actor concurrency model. © 2008 Elsevier
	Ltd. All rights reserved.},
  affiliation = {Programming Technology Lab, Vrije Universiteit Brussel, Brussels,
	Belgium},
  author_keywords = {Actors; AmbientTalk; Events; Futures; Linguistic symbiosis; Threads},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-51649125887&partnerID=40&md5=24e84bad49a59c4754fa91c543ad3d86}
}

@CONFERENCE{VanCutsem2007222,
  author = {Van Cutsem, T., Mostinckx, S., De Meuter, W.},
  title = {Linguistic symbiosis between actors and threads},
  year = {2007},
  volume = {286},
  pages = {222-248},
  note = {cited By (since 1996) 0},
  abstract = {We describe a linguistic symbiosis between AmbientTalk, a flexible,
	domain-specific language for writing distributed programs and Java,
	a conventional object-oriented language. This symbiosis allows concerns
	related to distribution (service discovery, asynchronous communication,
	failure handling) to be handled in the domain-specific language,
	while still enabling the reuse of existing software components written
	in a conventional language. The symbiosis is novel in the sense that
	a mapping is defined between the concurrency models of both languages.
	AmbientTalk employs an inherently event-driven model based on actors,
	while conventional object-oriented languages employ a concurrency
	model based on threads. The contribution of this paper is a linguistic
	symbiosis which ensures that the invariants of the event-driven concurrency
	model are not violated by engaging in symbiosis with multi-threaded
	programs.},
  affiliation = {Programming Technology Lab., Vrije Universiteit Brussel, Brussels,
	Belgium},
  author_keywords = {actors; AmbientTalk; events; linguistic symbiosis; threads},
  document_type = {Conference Paper},
  journal = {ACM International Conference Proceeding Series},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-77954428729&partnerID=40&md5=c8ce6e350707a5a4c939f004feff3f59}
}

@CONFERENCE{VanDenBergh200781,
  author = {Van Den Bergh, J., Huypens, S., Coninx, K.},
  title = {Towards model-driven development of staged participatory multimedia
	events},
  year = {2007},
  volume = {4323 LNCS},
  pages = {81-94},
  note = {cited By (since 1996) 2},
  abstract = {The industry nowadays is showing an increasing interest towards an
	extended interactive television experience, called participation
	television. This increasing interactivity brings the creation of
	such television events closer to the creation of regular software
	as we know it for personal computers and mobile devices. In this
	paper we report on our work in model-driven development of one kind
	of such interactive television shows, staged participatory multimedia
	events. More specifically, this work reports on the domain-specific
	language we created to model these events and the generation of abstract
	prototypes. These interactive prototypes are built using web-languages
	and can be used to perform early evaluation. © Springer-Verlag Berlin
	Heidelberg 2007.},
  affiliation = {Hasselt University, Transnationale Universiteit Limburg, Expertise
	Centre for Digital Media, Wetenschapspark 2, 3590 Diepenbeek, Belgium},
  document_type = {Conference Paper},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-35449000040&partnerID=40&md5=3143ca5c45dc1ff198ef37ae1d7001ec}
}

@CONFERENCE{VanDenBergh201131,
  author = {Van Den Bergh, J., Luyten, K., Coninx, K.},
  title = {CAP3: Context-sensitive abstract user interface specification},
  year = {2011},
  pages = {31-40},
  note = {cited By (since 1996) 1},
  abstract = {Despite the fact many proposals have been made for abstractuser interface
	models it was not given a detailed context in which it should or
	could be used in a user-centered design process. This paper presents
	a clear role for the abstract user interface model in user-centered
	and model-based development, provides an overview of the stakeholders
	that may create and/or use abstract user interface models and presents
	a modular abstract user interface modeling language, CAP3, that makes
	relations with other models explicit and builds on the foundation
	of existing abstract user interface models. The proposed modeling
	notation is supported by a tool and applied to some case studies
	from literature and in some projects. It is also validated based
	on state-of-the-art knowledge on domain-specific modeling languages
	and visual notations and some case studies. Copyright 2011 ACM.},
  affiliation = {Hasselt University -tUL, IBBT, Expertise Centre for Digital Media,
	Wetenschapspark 2, 3590 Diepenbeek, Belgium},
  author_keywords = {Abstract user interface; CAP3; Graphical notation; Modeling language;
	User interface design},
  document_type = {Conference Paper},
  journal = {Proceedings of the 2011 SIGCHI Symposium on Engineering Interactive
	Computing Systems, EICS 2011},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-79960189739&partnerID=40&md5=a2dc56d95d747b04ef1464eceadcb558}
}

@CONFERENCE{VanDenBos2011671,
  author = {Van Den Bos, J.a , Van Der Storm, T.b },
  title = {Bringing domain-specific languages to digital forensics},
  year = {2011},
  pages = {671-680},
  note = {cited By (since 1996) 0},
  abstract = {Digital forensics investigations often consist of analyzing large
	quantities of data. The software tools used for analyzing such data
	are constantly evolving to cope with a multiplicity of versions and
	variants of data formats. This process of customization is time consuming
	and error prone. To improve this situation we present Derric, a domain-specific
	language (DSL) for declaratively specifying data structures. This
	way, the specification of structure is separated from data processing.
	The resulting architecture encourages customization and facilitates
	reuse. It enables faster development through a division of labour
	between investigators and software engineers. We have performed an
	initial evaluation of Derric by constructing a data recovery tool.
	This so-called carver has been automatically derived from a declarative
	description of the structure of JPEG files. We compare it to existing
	carvers, and show it to be in the same league both with respect to
	recovered evidence, and runtime performance. © 2011 ACM.},
  affiliation = {Netherlands Forensic Institute, Laan van Ypenburg 6, 2497 GB, Den
	Haag, Netherlands; Centrum Wiskunde and Informatica, Science Park
	123, 1098 XG, Amsterdam, Netherlands},
  author_keywords = {data description languages; digital forensics; domain-specific languages;
	model-driven engineering},
  document_type = {Conference Paper},
  journal = {Proceedings - International Conference on Software Engineering},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-79959861136&partnerID=40&md5=9c2d8b50c76411434c016a97597ca156}
}

@ARTICLE{VanDenBrand2002334,
  author = {Van Den Brand, M.G.J., Heering, J., Klint, P., Olivier, P.A.},
  title = {Compiling language definitions: The ASF+SDF compiler},
  journal = {ACM Transactions on Programming Languages and Systems},
  year = {2002},
  volume = {24},
  pages = {334-368},
  number = {4},
  note = {cited By (since 1996) 77},
  abstract = {The ASF+SDF Meta-Environment is an interactive language development
	environment whose main application areas are definition and implementation
	of domain-specific languages, generation of program analysis and
	transformation tools, and production of software renovation tools.
	It uses conditional rewrite rules to define the dynamic semantics
	and other tool-oriented aspects of languages, so the effectiveness
	of the generated tools is critically dependent on the quality of
	the rewrite rule implementation. The ASF+SDF rewrite rule compiler
	generates C code, thus taking advantage of C's portability and the
	sophisticated optimization capabilities of current C compilers as
	well as avoiding potential abstract machine interface bottlenecks.
	It can handle large (10,000+ rule) language definitions and uses
	an efficient run-time storage scheme capable of handling large (1,000,000+
	node) terms. Term storage uses maximal subterm sharing (hash-consing),
	which turns out to be more effective in the case of ASF+SDF than
	in Lisp or SML. Extensive benchmarking has shown the time and space
	performance of the generated code to be as good as or better than
	that of the best current rewrite rule and functional language compilers.},
  affiliation = {Department of Software Engineering, CWI, Kruislaan 413, 1098 SJ Amsterdam,
	Netherlands},
  author_keywords = {D.3.1 [Programming Languages]: Formal Definitions and Theory - Semantics;
	D.3.2 [Programming Languages]: Language Classifications - Specialized
	application languages; D.3.4 [Programming Languages]: Processors
	- Code generation; compilers; optimization},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-0038895765&partnerID=40&md5=2ecd4dcf2984a8bcbfd1143b042b41f0}
}

@ARTICLE{VanDenBrand2009207,
  author = {Van Den Brand, M.G.J., Van Der Meer, A.P., Serebrenik, A.},
  title = {Type checking evolving languages with MSOS},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2009},
  volume = {5700 LNCS},
  pages = {207-226},
  note = {cited By (since 1996) 0},
  abstract = {Evolution of programming languages requires co-evolution of static
	analysis tools designed for these languages. Traditional approaches
	to static analysis, e.g., those based on Structural Operational Semantics
	(SOS), assume, however, that the syntax and the semantics of the
	programming language under consideration are fixed. Language modification
	is, therefore, likely to cause redevelopment of the analysis techniques
	and tools. Moreover, the redevelopment cost can discourage the language
	engineers from improving the language design. To address the co-evolution
	problem we suggest to base static analyses on modular structural
	operational semantics (MSOS). By using an intrinsically modular formalism,
	type rules can be added, removed or modified easily. We illustrate
	our approach by developing an MSOS-based type analysis technique
	for Chi, a domain specific language for hybrid systems engineering.
	© 2009 Springer Berlin Heidelberg.},
  affiliation = {Technische Universiteit Eindhoven, P.O. Box 513 Den Dolech 2, Eindhoven,
	MB 5600, Netherlands},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-70350416639&partnerID=40&md5=89e64a6188e53aedfc19667b0f2d4208}
}

@CONFERENCE{VanDenBrand2010,
  author = {Van Den Brand, M.G.J., Van Der Meer, A.P., Serebrenik, A., Hofkamp,
	A.T.},
  title = {Formally specified type checkers for domain specific languages: Experience
	report},
  year = {2010},
  note = {cited By (since 1996) 0},
  abstract = {An important part of the usability of a programming or specification
	language lies in the presence of supporting tools that are provided
	with the language, e.g., type checkers, debuggers and simulators.
	Development of such tools for domain-specific languages imposes a
	number of specific evolve-ability requirements. Our contribution
	is twofold: First, we present an MSOS-based approach to automatic
	generation of formally specified type checkers for domain-specific
	languages. Second, we report on the application of our approach to
	Chi, a high level specification language for describing concurrent
	systems. The resulting type checker has been successfully integrated
	in the tool chain of the Chi language. © ACM 2010.},
  affiliation = {Eindhoven University of Technology, P.O. Box 513, 5600 MB Eindhoven,
	Netherlands},
  art_number = {12},
  author_keywords = {Code generation; DSL; MSOS; Type systems},
  document_type = {Conference Paper},
  journal = {Proceedings of the 10th Workshop on Language Descriptions, Tools
	and Applications, LDTA 2010},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-78649801636&partnerID=40&md5=e2a1ec9a610c4be88ae97ad23cf837a5}
}

@ARTICLE{VanDenBrand2005161,
  author = {Van Den Brand, M.G.J.a b , Cornelissen, B.a , Olivier, P.A.a , Vinju,
	J.J.a },
  title = {TIDE: A generic debugging framework - Tool demonstration},
  journal = {Electronic Notes in Theoretical Computer Science},
  year = {2005},
  volume = {141},
  pages = {161-165},
  number = {4 SPEC. ISS.},
  note = {cited By (since 1996) 2},
  abstract = {A language specific interactive debugger is one of the tools that
	we expect in any mature programming environment. We present applications
	of TIDE: a generic debugging framework that is related to the ASF+SDF
	Meta-Environment. TIDE can be applied to different levels of debugging
	that occur in language design. Firstly, TIDE was used to obtain a
	full-fledged debugger for language specifications based on term rewriting.
	Secondly, TIDE can be instantiated for any other programming language,
	including but not limited to domain specific languages that are defined
	and implemented using ASF+SDF. We demonstrate the common debugging
	interface, and indicate the amount of effort needed to instantiate
	new debuggers based on TIDE. © 2005 Elsevier B.V. All rights reserved.},
  affiliation = {Department of Software Engineering, Centrum voor Wiskunde en Informatica,
	Kruislaan 413, NL-1098 SJ Amsterdam, Netherlands; Institute for Information
	Technology, Hogeschool Van Amsterdam, Weesperzijde 190, NL-1097 DZ
	Amsterdam, Netherlands},
  author_keywords = {Generic debugging; Language specifications; Rewriting},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-28444442764&partnerID=40&md5=088f393f0ceabb652f27a5cc6f1049ab}
}

@ARTICLE{VanDeursen199875,
  author = {Van Deursen, A.a , Klint, P.a b },
  title = {Little languages: Little maintenance?},
  journal = {Journal of Software Maintenance and Evolution},
  year = {1998},
  volume = {10},
  pages = {75-92},
  number = {2},
  note = {cited By (since 1996) 37},
  abstract = {So-called little, or domain-specific languages (DSLs), have the potential
	to make software maintenance simpler: domain experts can directly
	use the DSL to make required routine modifications. On the negative
	side, however, more substantial changes may become more difficult:
	such changes may involve altering the domain-specific language. This
	will require compiler technology knowledge, which not every commercial
	enterprise has easily available. Based on experience taken from industrial
	practice, we discuss the role of DSLs in software maintenance, the
	dangers introduced by using them, and techniques for controlling
	the risks involved. © 1998 John Wiley & Sons, Ltd.},
  affiliation = {CWI, P.O. Box 94079, 1090 GB, Amsterdam, Netherlands; University of
	Amsterdam, Kruislaan 403, 1098 SJ, Amsterdam, Netherlands},
  author_keywords = {Component coordination; Domain-specific language; Interest rate products;
	Language prototyping; Software generation; Software maintenance},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-0032021536&partnerID=40&md5=7e82f87edeafd12de791f85ae8ab689e}
}

@ARTICLE{VanWyk201039,
  author = {Van Wyk, E., Bodin, D., Gao, J., Krishnan, L.},
  title = {Silver: An extensible attribute grammar system},
  journal = {Science of Computer Programming},
  year = {2010},
  volume = {75},
  pages = {39-54},
  number = {1-2},
  note = {cited By (since 1996) 6},
  abstract = {Attribute grammar specification languages, like many domain-specific
	languages, offer significant advantages to their users, such as high-level
	declarative constructs and domain-specific analyses. Despite these
	advantages, attribute grammars are often not adopted to the degree
	that their proponents envision. One practical obstacle to their adoption
	is a perceived lack of both domain-specific and general purpose language
	features needed to address the many different aspects of a problem.
	Here we describe Silver, an extensible attribute grammar specification
	system, and show how it can be extended with general purpose features
	such as pattern matching and domain-specific features such as collection
	attributes and constructs for supporting data-flow analysis of imperative
	programs. The result is an attribute grammar specification language
	with a rich set of language features. Silver is implemented in itself
	by a Silver attribute grammar and utilizes forwarding to implement
	the extensions in a cost-effective manner. © 2009 Elsevier B.V. All
	rights reserved.},
  affiliation = {Department of Computer Science and Engineering, University of Minnesota,
	Minneapolis, MN, United States},
  author_keywords = {Attribute grammars; Extensible compilers; Extensible languages; Forwarding;
	Silver attribute grammar system},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-70450237104&partnerID=40&md5=346a6dfe5196ac1d5df6897ab24a03b1}
}

@ARTICLE{VanWyk2008103,
  author = {Van Wyk, E., Bodin, D., Gao, J., Krishnan, L.},
  title = {Silver: an Extensible Attribute Grammar System},
  journal = {Electronic Notes in Theoretical Computer Science},
  year = {2008},
  volume = {203},
  pages = {103-116},
  number = {2},
  note = {cited By (since 1996) 9},
  abstract = {Attribute grammar specification languages, like many domain specific
	languages, offer significant advantages to their users, such as high-level
	declarative constructs and domain-specific analyses. Despite these
	advantages, attribute grammars are often not adopted to the degree
	that their proponents envision. One practical obstacle to their adoption
	is a perceived lack of both domain-specific and general purpose language
	features needed to address the many different aspects of a problem.
	Here we describe Silver, an extensible attribute grammar specification
	language, and show how it can be extended with general purpose features
	such as pattern matching and domain specific features such as collection
	attributes and constructs for supporting data-flow analysis of imperative
	programs. The result is an attribute grammar specification language
	with a rich set of language features. Silver is implemented in itself
	by a Silver attribute grammar and utilizes forwarding to implement
	the extensions in a cost-effective manner. © 2008 Elsevier B.V. All
	rights reserved.},
  affiliation = {Department of Computer Science and Engineering, University of Minnesota,
	Minneapolis, MN, United States},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-41349111686&partnerID=40&md5=42b7587e4126ef3b615dd7fcc0451ac4}
}

@CONFERENCE{VanWyk2006728,
  author = {Van Wyk, E., Krishnan, L., Bodin, D., Johnson, E.},
  title = {Adding domain-specific and general purpose language features to Java
	with the Java language extender},
  year = {2006},
  volume = {2006},
  pages = {728-729},
  note = {cited By (since 1996) 1},
  abstract = {The Java Language Extender is a compiler-generator tool that allows
	programmers to create new domain-adapted languages by importing a
	set of domain-specific language extensions into an extensible specification
	of Java 1.4. Language extensions define the syntax, semantic analysis,
	and optimizations of new language constructs. Java and the language
	extensions are specified as attribute grammar fragments written in
	Silver, an attribute grammar language supporting forwarding and higher-order
	attributes. Programmers need no implementation-level knowledge of
	the language extensions and the Silver tools automatically compose
	the programmer-selected extensions and the Java host language specification.
	We demonstrate several language extensions. One embeds the SQL database
	query language into Java and statically checks for syntax and type
	errors in SQL queries. Other extensions for the domain of computational
	geometry provide transformations that simplify the writing of efficient
	and robust geometric algorithms. General purpose extensions include
	Java 1.5 features such as the for-each loop and auto-boxing and unboxing
	and features from Pizza such as pattern matching.},
  affiliation = {Department of Computer Science and Engineering, University of Minnesota,
	United States},
  art_number = {1176696},
  author_keywords = {Attribute grammars; Extensible languages; Forwarding},
  document_type = {Conference Paper},
  journal = {Proceedings of the Conference on Object-Oriented Programming Systems,
	Languages, and Applications, OOPSLA},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-34248375231&partnerID=40&md5=3be18193abe5affb2bf6b936a34c4927}
}

@ARTICLE{VanWyk2007575,
  author = {Van Wyk, E., Krishnan, L., Bodin, D., Schwerdfeger, A.},
  title = {Attribute grammar-based language extensions for java},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2007},
  volume = {4609 LNCS},
  pages = {575-599},
  note = {cited By (since 1996) 22},
  abstract = {This paper describes the ableJ extensible language framework, a tool
	that allows one to create new domain-adapted languages by importing
	domain-specific language extensions into an extensible implementation
	of Java 1.4. Language extensions may define the syntax, semantic
	analysis, and optimizations of new language constructs. Java and
	the language extensions are specified as higher-order attribute grammars.
	We describe several language extensions and their implementation
	in the framework. For example, one extension embeds the SQL database
	query language into Java and statically checks for syntax and type
	errors in SQL queries. The tool supports the modular specification
	of composable language extensions so that programmers can import
	into Java the unique set of extensions that they desire. When extensions
	follow certain restrictions, they can be composed without requiring
	any implementation-level knowledge of the language extensions. The
	tools automatically compose the selected extensions and the Java
	host language specification. © Springer-Verlag Berlin Heidelberg
	2007.},
  affiliation = {Department of Computer Science and Engineering, University of Minnesota,
	Minneapolis, MN 55455, United States},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-38149076049&partnerID=40&md5=2b694bb28fdc499b7070bb84044d15b5}
}

@CONFERENCE{VanWyk200763,
  author = {Van Wyk, E.R., Schwerdfeger, A.C.},
  title = {Context-aware scanning for parsing extensible languages},
  year = {2007},
  pages = {63-72},
  note = {cited By (since 1996) 5},
  abstract = {This paper introduces new parsing and context-aware scanning algorithms
	in which the scanner uses contextual information to disambiguate
	lexical syntax. The parser uses a slightly modified LR-style algorithm
	that passes to the scanner the set of valid symbols that the scanner
	may return at that point in parsing. This set is those terminals
	whose entries in the parse table for the current parse state are
	shift, reduce, or accept, but not error. The scanner then only returns
	tokens in this set. An analysis is given that can statically verify
	that the scanner will never return more than one token for a single
	input. Context-aware scanning is especially useful when parsing and
	scanning extensible languages in which domain specific languages
	can be embedded. It has been used in extensible versions of Java
	1.4 and ANSI C. We illustrate this approach with a declarative specification
	of a subset of Java and extensions that embed SQL queries and Boolean
	expression tables into Java. Copyright © 2007 ACM.},
  affiliation = {Department of Computer Science and Engineering, University of Minnesota,
	Minneapolis, MN, United States},
  author_keywords = {Context-aware scanning; Extensible languages},
  document_type = {Conference Paper},
  journal = {GPCE'07 - Proceedings of the Sixth International Conference on Generative
	Programming and Component Engineering},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-38849168071&partnerID=40&md5=2cc3ad3eff5f7667b35cb00247b976f2}
}

@CONFERENCE{Vanderbauwhede2010141,
  author = {Vanderbauwhede, W.a , Margala, M.b , Chalamalasetti, S.R.b , Purohit,
	S.b },
  title = {A C++-embedded domain-specific language for programming the MORA
	soft processor array},
  year = {2010},
  pages = {141-148},
  note = {cited By (since 1996) 2},
  abstract = {MORA is a novel platform for high-level FPGA programming of streaming
	vector and matrix operations, aimed at multimedia applications. It
	consists of soft array of pipelined low-complexity SIMD processors-in-memory
	(PIM). We present a Domain-Specific Language (DSL) for high-level
	programming of the MORA soft processor array. The DSL is embedded
	in C++, providing designers with a familiar language framework and
	the ability to compile designs using a standard compiler for functional
	testing before generating the FPGA bitstream using the MORA toolchain.
	The paper discusses the MORA-C++ DSL and the compilation route into
	the assembly for the MORA machine and provides examples to illustrate
	the programming model and performance. © 2010 IEEE.},
  affiliation = {Dept. of Computing Science, University of Glasgow, Glasgow, United
	Kingdom; Dept. of Electrical and Computer Engineering, University
	of Massachusetts at Lowell, Lowell, MA, United States},
  art_number = {5540750},
  author_keywords = {Domain-Specific language; Multimedia processing; Reconfigurable processor;
	Soft processor array},
  document_type = {Conference Paper},
  journal = {Proceedings of the International Conference on Application-Specific
	Systems, Architectures and Processors},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-77955948453&partnerID=40&md5=c3e0d3761893b1acf0316c5db03f4697}
}

@ARTICLE{Vasudevan2011103,
  author = {Vasudevan, N.a , Tratt, L.b },
  title = {Comparative study of DSL tools},
  journal = {Electronic Notes in Theoretical Computer Science},
  year = {2011},
  volume = {264},
  pages = {103-121},
  number = {5},
  note = {cited By (since 1996) 0},
  abstract = {An increasingly wide range of tools based on different approaches
	are being used to implement Domain Specific Languages (DSLs), yet
	there is little agreement as to which approach is, or approaches
	are, the most appropriate for any given problem. We believe this
	can in large part be explained by the lack of understanding within
	the DSL community. In this paper we aim to increase the understanding
	of the relative strengths and weaknesses of four approaches by implementing
	a common DSL case study. In addition, we present a comparative study
	of the four approaches. © 2011 Elsevier B.V. All rights reserved.},
  affiliation = {Bournemouth University, Poole Dorset, BH12 5BB, United Kingdom; Middlesex
	University, Burroughs, Hendon, London, NW4 4BT, United Kingdom},
  author_keywords = {Domain Specific Languages; Parsing; Program Transformation},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-79960237830&partnerID=40&md5=36565c722e7ed5099e7abbe42183d00d}
}

@ARTICLE{Vazquez2009147,
  author = {Vazquez, M.a , Chagoyen, M.b c , Pascual-Montano, A.b },
  title = {Named entity recognition and normalization: A domain-specific language
	approach},
  journal = {Advances in Soft Computing},
  year = {2009},
  volume = {49},
  pages = {147-155},
  note = {cited By (since 1996) 0},
  abstract = {We present, RNer, a tool that performs Named Entity Recognition and
	Normalization of gene and protein mentions on biomedical text. The
	tool we present not only offers a complete solution to the problem,
	but it does so by providing easily configurable framework, that abstracts
	the algorithmic details from the domain specific. Configuration and
	tuning for particular tasks is done using domain specific languages,
	clearer and more succinct, yet equally expressive that general purpose
	languages. An evaluation of the system is carried using the BioCreative
	datasets. © 2009 Springer-Verlag Berlin Heidelberg.},
  affiliation = {Departamento de Ingeniería del Software e Inteligencia Artificial;
	Dpto. Arquitectura de Computadores, Universidad Complutense de Madrid,
	Madrid, Spain; Biocomputing Unit, Centro Nacional de Biotecnología,
	CSIC, Madrid, Spain},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-58149113016&partnerID=40&md5=97ca0fa954ea5af16fe2287ef96803b9}
}

@CONFERENCE{Veldhuizen2007115,
  author = {Veldhuizen, T.L.},
  title = {Parsimony principles for software components and metalanguages},
  year = {2007},
  pages = {115-122},
  note = {cited By (since 1996) 0},
  abstract = {Software is a communication system. The usual topic of communication
	is program behavior, as encoded by programs. Domain-specific libraries
	are codebooks, domain-specific languages are coding schemes, and
	so forth. To turn metaphor into method, we adapt tools from information
	theory - the study of efficient communication - to probe the efficiency
	with which languages and libraries let us communicate programs. In
	previous work we developed an information-theoretic analysis of software
	reuse in problem domains. This new paper uses information theory
	to analyze tradeoffs in the design of components, generators, and
	metalanguages. We seek answers to two questions: (1) How can we judge
	whether a component is over- or under-generalized? Drawing on minimum
	description length principles, we propose that the best component
	yields the most succinct representation of the use cases. (2) If
	we view a programming language as an assemblage of metalanguages,
	each providing a complementary style of abstraction, how can these
	metalanguages aid or hinder us in efficiently describing software?
	We describe a complex triangle of interactions between the power
	of an abstraction mechanism, the amount of reuse it enables, and
	the cognitive difficulty of its use. Copyright © 2007 ACM.},
  affiliation = {Electrical and Computer Engineering, University of Wateroo, Canada},
  author_keywords = {Design; Theory},
  document_type = {Conference Paper},
  journal = {GPCE'07 - Proceedings of the Sixth International Conference on Generative
	Programming and Component Engineering},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-38849101492&partnerID=40&md5=1e91476ae62c016d9877154e15c70d34}
}

@CONFERENCE{Verbaere2006172,
  author = {Verbaere, M., Ettinger, R., De Moor, O.},
  title = {JunGL: A scripting language for refactoring},
  year = {2006},
  volume = {2006},
  pages = {172-181},
  note = {cited By (since 1996) 20},
  abstract = {Refactorings are behaviour-preserving program transformations, typically
	for improving the structure of existing code. A few of these transformations
	have been mechanised in interactive development environments. Many
	more refactorings have been proposed, and it would be desirable for
	programmers to script their own refactorings. Implementing such source-to-source
	transformations, however, is quite complex: even the most sophisticated
	development environments contain significant bugs in their refactoring
	tools. We present a domain-specific language for refactoring, named
	JunGL. It manipulates a graph representation of the program: all
	information about the program, including ASTs for its compilation
	units, variable binding, control flow and so on is represented in
	a uniform graph format. The language is a hybrid of a functional
	language (in the style of ML) and a logic query language (akin to
	Datalog). JunGL furthermore has a notion of demand-driven evaluation
	for constructing computed information in the graph, such as control
	flow edges. Borrowing from earlier work on the specification of compiler
	optimisations, JunGL uses socalled 'path queries' to express dataflow
	properties. We motivate the design of JunGL via a number of nontrivial
	refactorings, and describe its implementation on the .NET platform.
	Copyright 2006 ACM.},
  affiliation = {Programming Tools Group, University of Oxford, United Kingdom},
  author_keywords = {Language workbenches; Refactoring; Scripting language; Source code
	transformation},
  document_type = {Conference Paper},
  journal = {Proceedings - International Conference on Software Engineering},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-34247132712&partnerID=40&md5=988dfa41981efe55b7767bcf6db7aa89}
}

@CONFERENCE{Vermolen201183,
  author = {Vermolen, S.D., Wachsmuth, G., Visser, E.},
  title = {Generating database migrations for evolving web applications},
  year = {2011},
  pages = {83-92},
  note = {cited By (since 1996) 0},
  abstract = {WebDSL is a domain-specific language for the implementation of dynamic
	web applications with a rich data model. It provides developers with
	object-oriented data modeling concepts but abstracts over implementation
	details for persisting application data in relational databases.
	When the underlying data model of an application evolves, persisted
	application data has to be migrated. While implementing migration
	at the database level breaks the abstractions provided by WebDSL,
	an implementation at the data model level requires to intermingle
	migration with application code. In this paper, we present a domain-specific
	language for the coupled evolution of data models and application
	data. It allows to specify data model evolution as a separate concern
	at the data model level and can be compiled to migration code at
	the database level. Its linguistic integration with WebDSL enables
	static checks for evolution validity and correctness. Copyright ©
	2011 ACM.},
  affiliation = {Delft University of Technology, Netherlands},
  author_keywords = {Data migration; Domain specific language; Evolution; Web application},
  document_type = {Conference Paper},
  journal = {GPCE'11 - Proceedings of the 10th International Conference on Generative
	Programming and Component Engineering},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-81455135806&partnerID=40&md5=52792c7bfeb66e7c198abbe90f58470f}
}

@CONFERENCE{Verwaest2011959,
  author = {Verwaest, T.a , Lungu, M.a , Nierstrasz, O.a , Bruni, C.b },
  title = {Flexible object layouts: Enabling lightweight language extensions
	by intercepting slot access},
  year = {2011},
  pages = {959-972},
  note = {cited By (since 1996) 0},
  abstract = {Programming idioms, design patterns and application libraries often
	introduce cumbersome and repetitive boilerplate code to a software
	system. Language extensions and external DSLs (domain specific languages)
	are sometimes introduced to reduce the need for boilerplate code,
	but they also complicate the system by introducing the need for language
	dialects and inter-language mediation. To address this, we propose
	to extend the structural reflective model of the language with object
	layouts, layout scopes and slots. Based on the new reflective language
	model we can 1) provide behavioral hooks to object layouts that are
	triggered when the fields of an object are accessed and 2) simplify
	the implementation of state-related language extensions such as stateful
	traits. By doing this we show how many idiomatic use cases that normally
	require boilerplate code can be more effectively supported. We present
	an implementation in Smalltalk, and illustrate its usage through
	a series of extended examples. Copyright is held by the author /
	owner(s).},
  affiliation = {Software Composition Group, University of Bern, Switzerland; RMoD,
	INRIA Lille - Nord Europe, France},
  author_keywords = {Metaobject protocol; Smalltalk; Structural reflection; Traits},
  document_type = {Conference Paper},
  journal = {Proceedings of the Conference on Object-Oriented Programming Systems,
	Languages, and Applications, OOPSLA},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-81455135734&partnerID=40&md5=1f7164ae8b2cbc4f816b115d5d93bd17}
}

@ARTICLE{Vicente-Chicote2007393,
  author = {Vicente-Chicote, C., Losilla, F., Álvarez, B., Iborra, A., Sanchez,
	P.},
  title = {Applying MDE to the development of flexible and reusable wireless
	sensor networks},
  journal = {International Journal of Cooperative Information Systems},
  year = {2007},
  volume = {16},
  pages = {393-412},
  number = {3-4},
  note = {cited By (since 1996) 4},
  abstract = {Wireless Sensor Networks (WSN) are a very promising research field
	since they are applicable in many different areas. Current proposals
	for WSN system development are mainly focused on implementation issues
	and rarely use a Software Engineering methodology to support their
	development life cycle. The Model-Driven Engineering (MDE) approach
	can be used as a solution to this by allowing designers to model
	their systems at different abstraction levels, providing them with
	automatic model transformations to incrementally refine abstract
	models into more concrete ones. In this vein, this paper presents
	an MDE approach to WSN application development. Three levels of abstraction
	have been defined which allow designers to build: (1) domain-specific
	models, (2) component-based architecture descriptions, and (3) platform-specific
	models. Automatic model transformations between these three abstraction
	levels have been designed and, in order to demonstrate the viability
	of the proposal, a real WSN application has been developed using
	the implemented tools. © World Scientific Publishing Company.},
  affiliation = {División de Sistemas e Ingeniería Electrónica, Universidad Politécnica
	de Cartagena, Edificio Antigones, Plaza del Hospital 1, 30202 Cartagena,
	Spain},
  author_keywords = {Component-based software architecture; Domain specific languages;
	Eclipse platform; Model-driven engineering; Wireless sensor networks},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-36749005662&partnerID=40&md5=6d9de6dbb0e3abe1ae1af52bddb7041d}
}

@CONFERENCE{Videira2006302,
  author = {Videira, C., Ferreira, D., Da Silva, A.R.},
  title = {A linguistic patterns approach for requirements specification},
  year = {2006},
  pages = {302-309},
  note = {cited By (since 1996) 5},
  abstract = {Despite the efforts made to overcome the problems associated with
	the development of information systems, we must consider that it
	is still an immature activity, with negative consequences in time,
	budget and quality. One of the root causes for this situation is
	the fact that many projects do not follow a structured, standard
	and systematic approach, like the methodologies and best practices
	proposed by Software Engineering. In this paper, we present a requirements
	specification language, called ProjectlTRSL, based on the identification
	of the most frequently used linguistic patterns in requirements documents,
	written in natural language. To guarantee the consistency of the
	written requirements and the integration with generative programming
	tools, the requirements are analyzed by parsing tools, and immediately
	validated according with the syntactic and semantic rules of the
	language. © 2006 IEEE.},
  affiliation = {INESC-ID, Universidade Autónoma de Lisboa, Institute Superior Técnico},
  art_number = {1690153},
  document_type = {Conference Paper},
  journal = {Proceedings - 32nd Euromicro Conference on Software Engineering and
	Advanced Applications, SEAA},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-34547460792&partnerID=40&md5=2c5f7a921251f66d4ba671bf7a062b7f}
}

@CONFERENCE{Viera2009,
  author = {Viera, M.a , Swierstra, S.D.b , Swierstra, W.c },
  title = {Attribute grammars fly first-class how to do aspect oriented programming
	in Haskell},
  year = {2009},
  pages = {245-256},
  note = {cited By (since 1996) 3},
  abstract = {Attribute Grammars (AGs), a general-purpose formalism for describing
	recursive computations over data types, avoid the trade-off which
	arises when building software incrementally: should it be easy to
	add new data types and data type alternatives or to add new operations
	on existing data types? However, AGs are usually implemented as a
	pre-processor, leaving e.g. type checking to later processing phases
	and making interactive development, proper error reporting and debugging
	difficult. Embedding AG into Haskell as a combinator library solves
	these problems. Previous attempts at embedding AGs as a domain-specific
	language were based on extensible records and thus exploiting Haskell's
	type system to check the well-formedness of the AG, but fell short
	in compactness and the possibility to abstract over oft occurring
	AG patterns. Other attempts used a very generic mapping for which
	the AG well-formedness could not be statically checked. We present
	a typed embedding of AG in Haskell satisfying all these requirements.
	The key lies in using HList-like typed heterogeneous collections
	(extensible polymorphic records) and expressing AG well-formedness
	conditions as type-level predicates (i.e., typeclass constraints).
	By further type-level programming we can also express common programming
	patterns, corresponding to the typical use cases of monads such as
	Reader, Writer and State. The paper presents a realistic example
	of type-class-based type-level programming in Haskell. Copyright
	© 2009 ACM.},
  affiliation = {Instituto De Computación, Universidad De La República, Montevideo,
	Uruguay; Department of Computer Science, Utrecht University, Utrecht,
	Netherlands; Chalmers University of Technology, Göteborg, Sweden},
  author_keywords = {Attribute grammars; Class system; Haskell; HList; Lazy evaluation;
	Type-level programming},
  document_type = {Conference Paper},
  journal = {Proceedings of the ACM SIGPLAN International Conference on Functional
	Programming, ICFP},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-70450191581&partnerID=40&md5=a296e7ff33832bf29d019a0b4e13232f}
}

@ARTICLE{Viera2009245,
  author = {Viera, M.a , Swierstra, S.D.b , Swierstra, W.c },
  title = {Attribute grammars fly first-class: How to do aspect oriented programming
	in haskell},
  journal = {ACM SIGPLAN Notices},
  year = {2009},
  volume = {44},
  pages = {245-256},
  number = {9},
  note = {cited By (since 1996) 1},
  abstract = {Attribute Grammars (AGs), a general-purpose formalism for describing
	recursive computations over data types, avoid the trade-off which
	arises when building software incrementally: should it be easy to
	add new data types and data type alternatives or to add new operations
	on existing data types? However, AGs are usually implemented as a
	pre-processor, leaving e.g. type checking to later processing phases
	and making interactive development, proper error reporting and debugging
	difficult. Embedding AG into Haskell as a combinator library solves
	these problems. Previous attempts at embedding AGs as a domain-specific
	language were based on extensible records and thus exploiting Haskell's
	type system to check the well-formedness of the AG, but fell short
	in compactness and the possibility to abstract over oft occurring
	AG patterns. Other attempts used a very generic mapping for which
	the AG well-formedness could not be statically checked. We present
	a typed embedding of AG in Haskell satisfying all these requirements.
	The key lies in using HList-like typed heterogeneous collections
	(extensible polymorphic records) and expressing AG well-formedness
	conditions as type-level predicates (i.e., typeclass constraints).
	By further type-level programming we can also express common programming
	patterns, corresponding to the typical use cases of monads such as
	Reader, Writer and State. The paper presents a realistic example
	of type-class-based type-level programming in Haskell. ©2009 ACM.},
  affiliation = {Instituto de Computacíon, Universidad de la Reṕublica, Montevideo,
	Uruguay; Department of Computer Science, Utrecht University, Utrecht,
	Netherlands; Chalmers University of Technology, Göteborg, Sweden},
  author_keywords = {Attribute grammars; Class system; Haskell; Hlist; Lazy evaluation;
	Type-level programming},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-70350437618&partnerID=40&md5=ec0ef679d920574653edd875254daa74}
}

@CONFERENCE{Vignaga2010115,
  author = {Vignaga, A.},
  title = {Typing textual entities and M2T/T2M transformations in a model management
	environment},
  year = {2010},
  pages = {115-122},
  note = {cited By (since 1996) 0},
  abstract = {Global Model Management (GMM) is a model-based approach for managing
	large sets of interrelated heterogeneous and complex MDE artifacts.
	Such artifacts are usually represented as models, however as many
	Domain Specific Languages have a textual concrete syntax, GMM also
	supports textual entities and model-to-text/text-to-model transformations
	which are projectors that bridge the MDE technical space and the
	Grammarware technical space. As the transformations supported by
	GMM are executable artifacts, typing is critical for preventing type
	errors during execution. We proposed the cGMM calculus which formalizes
	the notion of typing in GMM. In this work, we extend cGMM with new
	types and rules for supporting textual entities and projectors. With
	such an extension, those artifacts may participate in transformation
	compositions addressing larger transformation problems. We illustrate
	the new constructs in the context of an interoperability case study.
	© 2010 IEEE.},
  affiliation = {MaTE, Computer Science Department, Universidad de Chile, Santiago,
	Chile},
  art_number = {5532356},
  author_keywords = {Global model management; Model transformation; Model-driven engineering;
	Textual concrete syntax; Type System},
  document_type = {Conference Paper},
  journal = {Proceedings - International Conference of the Chilean Computer Science
	Society, SCCC},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-77955953170&partnerID=40&md5=673bb9165ab91e5f4c067b01a5b727fe}
}

@CONFERENCE{Villanueva-Peña2007129,
  author = {Villanueva-Peña, P.E.a , Kunz, T.b },
  title = {GP-pro: The generative programming protocol generator for routing
	in mobile ad hoc networks},
  year = {2007},
  pages = {129-131},
  note = {cited By (since 1996) 0},
  abstract = {Routing in mobile ad hoc networks (MANETs) where network topology
	is highly dynamic is not a trivial task. Routing protocols have been
	profoundly researched but only three of them have reached the RFC
	status (AODV[7], OLSR[5] and TBPRF[O]). On the other hand, the constantly
	increasing network requirements in terms of bandwidth, robustness,
	reliability and quality of service for a broad range of multiplatform
	scenarios demand for fast development and implementation of routing
	protocols that satisfy specific user and network requirements. However,
	current practices for protocol development and implementation are
	costly error-prone and time-consuming, especially when existing knowledge
	is not properly reused. Generative Programming is an attractive solution
	that makes use of reusable components and is also empowered with
	the knowledge to automatically assemble them. This paper discusses
	the design and development of the GP-Pro protocol generator (based
	on generative programming), for automatic generation of ad hoc routing
	protocols, according to user requirements expressed by means of a
	specification language. GP-Pro is designed to be extensible, with
	the explicit goal of generating a large number of different protocols
	by different component combinations. GP-Pro addresses the generation
	of proactive, reactive and position-based routing protocols. © 2006
	IEEE.},
  affiliation = {SITE, University of Ottawa, Ottawa, ON K1N 6N5, Canada; SCE, Carleton
	University, Ottawa, ON K1S 5B6, Canada},
  art_number = {4068269},
  author_keywords = {Automatic generation; Domain engineering; Generative programming;
	Mobile ad hoc networks (MANETs); Routing protocols},
  document_type = {Conference Paper},
  journal = {2006 2nd IEEE Workshop on Wireless Mesh Networks, WiMESH 2006},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-43949112306&partnerID=40&md5=a1649f5daa49e25a26130916db879105}
}

@ARTICLE{Virirakis2003456,
  author = {Virirakis, L.},
  title = {GENETICA: A Computer Language that Supports General Formal Expression
	with Evolving Data Structures},
  journal = {IEEE Transactions on Evolutionary Computation},
  year = {2003},
  volume = {7},
  pages = {456-481},
  number = {5},
  note = {cited By (since 1996) 1},
  abstract = {This paper presents a general problem-solving method combining the
	principles of artificial intelligence and evolutionary computation.
	The problem-solving method is based on the computer language GENETICA,
	which stands for "Genetic Evolution of Novel Entities Through the
	Interpretation of Composite Abstractions." GENETICAs programming
	environment includes a computational system that evolves data abstractions,
	viewed as genotypes of data generation scenarios for a GENETICA program,
	with respect to either confirmation or optimization goals. A problem
	can be formulated as a GENETICA program, while the solution is represented
	as a data structure resulting from an evolved data generation scenario.
	This approach to problem solving offers: 1) generality, since it
	concerns virtually any problem stated in formal logic; 2) effectiveness,
	since formally expressed problem-solving knowledge can be incorporated
	in the problem statement; and 3) creativity, since unpredictable
	solutions can be obtained by evolved data structures. It is shown
	that domain specific languages, including genetic programming ones,
	that inherit GENETICAs features can be developed in GENETICA. The
	language G-CAD, specialized to problem solving in the domain of architectural
	design, is presented as a case study followed by experimental results.},
  affiliation = {Natl. Technical University of Athens, Athens 11362, Greece},
  author_keywords = {Evolutionary designing; Formal logic; Genetic algorithms; Genetic
	programming (GP); Problem solving},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-0142165037&partnerID=40&md5=354cc171bc41fddfa6da026f20fa799d}
}

@ARTICLE{Visser2008291,
  author = {Visser, E.},
  title = {WebDSL: A case study in domain-specific language engineering},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2008},
  volume = {5235 LNCS},
  pages = {291-373},
  note = {cited By (since 1996) 16},
  abstract = {The goal of domain-specific languages (DSLs) is to increase the productivity
	of software engineers by abstracting from low-level boilerplate code.
	Introduction of DSLs in the software development process requires
	a smooth workflow for the production of DSLs themselves. This requires
	technology for designing and implementing DSLs, but also a methodology
	for using that technology. That is, a collection of guidelines, design
	patterns, and reusable DSL components that show developers how to
	tackle common language design and implementation issues. This paper
	presents a case study in domain-specific language engineering. It
	reports on a project in which the author designed and built WebDSL,
	a DSL for web applications with a rich data model, using several
	DSLs for DSL engineering: SDF for syntax definition and Stratego/XT
	for code generation. The paper follows the stages in the development
	of the DSL. The contributions of the paper are three-fold. (1) A
	tutorial in the application of the specific SDF and Stratego/XT technology
	for building DSLs. (2) A description of an incremental DSL development
	process. (3) A domain-specific language for web-applications with
	rich data models. The paper concludes with a survey of related approaches.
	© 2008 Springer Berlin Heidelberg.},
  affiliation = {Software Engineering Research Group, Delft University of Technology},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-56649083315&partnerID=40&md5=35dc0ec769930c977b1974d0a5724ab3}
}

@ARTICLE{Voellmy2011235,
  author = {Voellmy, A., Hudak, P.},
  title = {Nettle: Taking the sting out of programming network routers},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2011},
  volume = {6539 LNCS},
  pages = {235-249},
  note = {cited By (since 1996) 0},
  abstract = {We describe a language-centric approach to solving the complex, low-level,
	and error-prone problem of network control. Specifically, we have
	designed a domain-specific language called Nettle, embedded in Haskell,
	that allows programming OpenFlow networks in an elegant, declarative
	style. Nettle is based on the principles of functional reactive programming
	(FRP), and as such has both continuous and discrete abstractions,
	each of which is leveraged in the design. We have implemented Nettle
	and tested it on real OpenFlow switches. We demonstrate our methodology
	by writing several non-trivial OpenFlow controllers. © 2011 Springer-Verlag.},
  affiliation = {Yale University, United States},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-79551600395&partnerID=40&md5=9374c4858cc5cffbe3edc6b3a85bcb0d}
}

@ARTICLE{Voelter201032,
  author = {Voelter, M.},
  title = {Embedded software development with projectional language workbenches},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2010},
  volume = {6395 LNCS},
  pages = {32-46},
  number = {PART 2},
  note = {cited By (since 1996) 0},
  abstract = {This paper describes a novel approach to embedded software development.
	Instead of using a combination of C code and modeling tools, we propose
	an approach where modeling and programming is unified using projectional
	language workbenches. These allow the incremental, domain-specific
	extension of C and a seamless integration between the various concerns
	of an embedded system. The paper does not propose specific extensions
	to C in the hope that everybody will use them; rather, the paper
	illustrates the benefits of domain specific extension using projectional
	editors. In the paper we describe the problems with the traditional
	approach to embedded software development and how the proposed approach
	can solve them. The main part of the paper describes our modular
	embedded language, a proof-of-concept implementation of the approach
	based on JetBrains MPS. We implemented a set of language extensions
	for embedded programming, such as state machines, tasks, type system
	extensions as well as a domain specific language (DSL) for robot
	control. The language modules are seamlessly integrated, leading
	to a very efficient way for implementing embedded software. © 2010
	Springer-Verlag.},
  affiliation = {Independent/itemis, Oetztaler Strasse 38, 70327 Stuttgart, Germany},
  author_keywords = {code generation; domain-specific languages; embedded systems; language
	extension; projectional editing},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-78349292668&partnerID=40&md5=148506bcf6e7fe9b61d129edff4e4c2a}
}

@CONFERENCE{Voelter201041,
  author = {Voelter, M.},
  title = {Implementing feature variability for models and code with projectional
	language workbenches},
  year = {2010},
  pages = {41-48},
  note = {cited By (since 1996) 1},
  abstract = {Product line engineering deals with managing and implementing the
	variability among a set of related products. We distinguish between
	two kinds of variability: configuration and customization. Customization
	variability can be described using programming language code or creative
	construction DSLs, whereas configuration variability is described
	using configuration based approaches, such as feature models. Many
	product lines have both kinds of variability, and they need to be
	integrated efficiently. This paper describes an approach for product
	line engineering using projectional language workbenches. These represent
	code and models with the same fundamental technology, enabling the
	mixing of models and code. They make the tight integration between
	several domain-specific languages possible and simple. Since they
	can store arbitrary information in models, it is possible to overlay
	configuration variability over customization variability (i.e. apply
	feature model-based configuration to code and models). Because of
	the projectional approach to editing, programs can be shown with
	or without the dependencies on feature models, they can even be rendered
	(and edited) for a specific variant. This approach leads to highly
	integrated and productive tools for product line development. The
	paper explains the approach, outlines the implementation of a prototype
	tool based on Jetbrains MPS and illustrates the benefits using a
	small product line for embedded systems. © 2010 ACM.},
  affiliation = {Independent/itemis, Oetztaler Strasse 38, 70327 Stuttgart, Germany},
  art_number = {1868695},
  author_keywords = {domain-specific languages; feature modeling; language composition;
	product line engineering},
  document_type = {Conference Paper},
  journal = {Proceedings of the 2nd International Workshop on Feature-Oriented
	Software Development, FOSD'10},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-78751688676&partnerID=40&md5=09ef67730d49a56fcc0bfa95ce800e5f}
}

@CONFERENCE{Voelter201170,
  author = {Voelter, M.a , Visser, E.b },
  title = {Product line engineering using domain-specific languages},
  year = {2011},
  pages = {70-79},
  note = {cited By (since 1996) 0},
  abstract = {This paper investigates the application of domain-specific languages
	in product line engineering (PLE). We start by analyzing the limits
	of expressivity of feature models. Feature models correspond to context-free
	grammars without recursion, which prevents the expression of multiple
	instances and references. We then show how domain-specific languages
	(DSLs) can serve as a middle ground between feature modeling and
	programming. They can be used in cases where feature models are too
	limited, while keeping the separation between problem space and solution
	space provided by feature models. We then categorize useful combinations
	between configuration with feature model and construction with DSLs
	and provide an integration of DSLs into the conceptual framework
	of PLE. Finally we show how use of a consistent, unified formalism
	for models, code, and configuration can yield important benefits
	for managing variability and trace ability. We illustrate the concepts
	with several examples from industrial case studies. © 2011 IEEE.},
  affiliation = {Itemis, Stuttgart, Germany; Delft University of Technology, Delft,
	Netherlands},
  art_number = {6030048},
  document_type = {Conference Paper},
  journal = {Proceedings - 15th International Software Product Line Conference,
	SPLC 2011},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-80054058367&partnerID=40&md5=21abaa56b549bcddf8a571217859ab95}
}

@CONFERENCE{Voigtlaender2009,
  author = {Voigtländer, J.},
  title = {Bidirectionalization for free! (pearl)},
  year = {2009},
  pages = {165-176},
  note = {cited By (since 1996) 10},
  abstract = {A bidirectional transformation consists of a function get that takes
	a source (document or value) to a view and a function put that takes
	an updated view and the original source back to an updated source,
	governed by certain consistency conditions relating the two functions.
	Both the database and programming language communities have studied
	techniques that essentially allow a user to specify only one of get
	and put and have the other inferred automatically. All approaches
	so far to this bidirectionalization task have been syntactic in nature,
	either proposing a domain-specific language with limited expressiveness
	but built-in (and composable) backward components, or restricting
	get to a simple syntactic form from which some algorithm can synthesize
	an appropriate definition for put. Here we present a semantic approach
	instead. The idea is to take a general-purpose language, Haskell,
	and write a higher-order function that takes (polymorphic) get-functions
	as arguments and returns appropriate put-functions. All this on the
	level of semantic values, without being willing, or even able, to
	inspect the definition of get, and thus liberated from syntactic
	restraints. Our solution is inspired by relational parametricity
	and uses free theorems for proving the consistency conditions. It
	works beautifully. Copyright© 2009 ACM.},
  affiliation = {Technische Universität Dresden, 01062 Dresden, Germany},
  author_keywords = {Generic programming; Program transformation; Viewupdate problem},
  document_type = {Conference Paper},
  journal = {Conference Record of the Annual ACM Symposium on Principles of Programming
	Languages},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-67649837203&partnerID=40&md5=77e092588e6da8640b676fea639a1fb9}
}

@ARTICLE{Voigtländer2009165,
  author = {Voigtländer, J.},
  title = {Bidirectionalization for free! (pearl)},
  journal = {ACM SIGPLAN Notices},
  year = {2009},
  volume = {44},
  pages = {165-176},
  number = {1},
  note = {cited By (since 1996) 3},
  abstract = {A bidirectional transformation consists of a function get that takes
	a source (document or value) to a view and a function put that takes
	an updated view and the original source back to an updated source,
	governed by certain consistency conditions relating the two functions.
	Both the database and programming language communities have studied
	techniques that essentially allow a user to specify only one of get
	and put and have the other inferred automatically. All approaches
	so far to this bidirectionalization task have been syntactic in nature,
	either proposing a domain-specific language with limited expressiveness
	but built-in (and composable) backward components, or restricting
	get to a simple syntactic form from which some algorithm can synthesize
	an appropriate definition for put. Here we present a semantic approach
	instead. The idea is to take a general-purpose language, Haskell,
	and write a higher-order function that takes (polymorphic) get-functions
	as arguments and returns appropriate put-functions. All this on the
	level of semantic values, without being willing, or even able, to
	inspect the definition of get, and thus liberated from syntactic
	restraints. Our solution is inspired by relational parametricity
	and uses free theorems for proving the consistency conditions. It
	works beautifully.},
  affiliation = {Technische Universität Dresden, 01062 Dresden, Germany},
  author_keywords = {Generic programming; Program transformation; Viewupdate problem},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-70350339813&partnerID=40&md5=3b0a7f6ecc46fb5d9ff16ec1d897881f}
}

@ARTICLE{Vokáč2005492,
  author = {Vokáč, M.a , Glattetre, J.M.b },
  title = {Using a domain-specific language and custom tools to model a multi-tier
	service-oriented application - Experiences and challenges},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2005},
  volume = {3713 LNCS},
  pages = {492-506},
  note = {cited By (since 1996) 1},
  abstract = {A commercial Customer Relationship Management application of approx.
	1.5 MLOC of C++ code is being reimplemented, in stages, as a service-oriented,
	multi-tier application in C# on Microsoft NET. We have chosen to
	use a domain-specific language both to model the external service-oriented
	interfaces, and to manage the transition to the internal, object-oriented
	implementation. Generic UML constructs such as class diagrams do
	not capture enough semantics to model these concepts. By defining
	a UML Profile that incorporates the concepts we wish to model, we
	have in effect created a Domain-Specific Language for our application.
	The models are edited using Rational XDE, but we have substituted
	our own code generator. This generator is a relatively generic text-substitution
	engine, which takes a template text and performs substitutions based
	on the model. The generator uses reflection to convert the UML and
	Profile concepts into substitution tags, which are in turn used in
	the template text. In this way, we can translate the semantics of
	the model into executable code, WSDL or other formats in a flexible
	way. We have successfully used this approach on a prototype scale,
	and are now transitioning to full-scale development. © Springer-Verlag
	Berlin Heidelberg 2005.},
  affiliation = {Simula Research Laboratory, P.O. Box 134, 1325 Lysaker, Norway; SuperOffice
	ASA / ICT Norway, Drammensveien 211, 0212 Oslo, Norway},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-33646205040&partnerID=40&md5=3f67101f4ed7885096892de29a204530}
}

@ARTICLE{Volz2010120,
  author = {Volz, B., Dornstauder, S.},
  title = {Implementing domain specific process modelling},
  journal = {Communications in Computer and Information Science},
  year = {2010},
  volume = {69 CCIS},
  pages = {120-132},
  note = {cited By (since 1996) 0},
  abstract = {Business process modelling becomes more productive when modellers
	can use process modelling languages which optimally fit to the application
	domain. This requires the proliferation and management of domain
	specific modelling languages and modelling tools. In this paper we
	address the issue of providing domain specific languages in a systematic
	and structural way without having to implement modelling tools for
	each domain specific language separately. Our approach is based on
	a two dimensional meta modelling stack. © 2010 Springer-Verlag.},
  affiliation = {Department of Applied Computer Science IV, University of Bayreuth,
	Bayreuth, Germany},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-78650725147&partnerID=40&md5=18215c4098e0c48b8bda1e1e317a3ef0}
}

@CONFERENCE{Vorobyeva2011941,
  author = {Vorobyeva, O.P., Cherkashin, E.A., Ipatov, S.A., Paramonov, V.V.},
  title = {Information modeling of business processes in X-ray fluorescent analysis},
  year = {2011},
  pages = {941-944},
  note = {cited By (since 1996) 0},
  abstract = {The article is devoted to the formalization of investigation processes
	of substances by means of the X-ray fluorescence analysis (XRF).
	The research is aimed at solving the problem of automation of the
	analytical investigations in the XRF, which suppose to increases
	the productivity of the analyst and the accuracy of determining the
	concentration of elements in samples. Decomposition of information
	processes has been represented in the IDEF0 standard as a hierarchy
	of the core activities. Based on the decomposition the information
	model of the domain is developed. The model is represented as UML-diagrams
	adapted to MDA (Model Driven Architecture) based generative programming
	tools. These tools allow one to transform the model automatically
	into a skeleton of information system for XRF techniques automation.
	© 2011 MIPRO.},
  affiliation = {Institute for System Dynamics and Control Theory, Irkutsk, Russian
	Federation},
  art_number = {5967191},
  document_type = {Conference Paper},
  journal = {MIPRO 2011 - 34th International Convention on Information and Communication
	Technology, Electronics and Microelectronics - Proceedings},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-80052300148&partnerID=40&md5=f67012614c697e457905d3a33323045f}
}

@ARTICLE{Voronenko2008407,
  author = {Voronenko, Y., Franchetti, F., De Mesmay, F., Püschel, M.},
  title = {System demonstration of spiral: Generator for high-performance linear
	transform libraries},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2008},
  volume = {5140 LNCS},
  pages = {407-412},
  note = {cited By (since 1996) 0},
  abstract = {We demonstrate Spiral, a domain-specific library generation system.
	Spiral generates high performance source code for linear transforms
	(such as the discrete Fourier transform and many others) directly
	from a problem specification. The key idea underlying Spiral is to
	perform automatic reasoning and optimizations at a high abstraction
	level using the mathematical, declarative domain-specific languages
	SPL and ∑-SPL and a rigorous rewriting framework. Optimization includes
	various forms of parallelization. Even though Spiral provides complete
	automation, its generated libraries often run faster than any existing
	hand-written code. © 2008 Springer-Verlag Berlin Heidelberg.},
  affiliation = {Department of Electrical and Computer Engineering, Carnegie Mellon
	University, 5000 Forbes Ave, Pittsburgh, PA 15213, United States},
  author_keywords = {Automatic performance tuni; Discrete Fourier transform; Domain-specific
	language; FFT; Linear transform; Matrix algebra; Multithreading;
	Program generation; Rewriting; SIMD vector instructions},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-51049114948&partnerID=40&md5=abf80a3fbc9614ce1a892b5651a02447}
}

@ARTICLE{Voss2001,
  author = {Voss, M.J., Eigenmann, R.},
  title = {High-level adaptive program optimization with ADAPT},
  journal = {SIGPLAN Notices (ACM Special Interest Group on Programming Languages)},
  year = {2001},
  volume = {36},
  pages = {93-102},
  number = {7},
  note = {cited By (since 1996) 11},
  abstract = {Compile-time optimization is often limited by a lack of target machine
	and input data set knowledge. Without this information, compilers
	may be forced to make conservative assumptions to preserve correctness
	and to avoid performance degradation. In order to cope with this
	lack of information at compile-time, adaptive and dynamic systems
	can be used to perform optimization at runtime when complete knowledge
	of input and machine parameters is available. This paper presents
	a compiler-supported high-level adaptive optimization system. Users
	describe, in a domain specific language, optimizations performed
	by stand-alone optimization tools and backend compiler flags, as
	well as heuristics for applying these optimizations dynamically at
	runtime. The ADAPT compiler reads these descriptions and generates
	application-specific runtime systems to apply the heuristics. To
	facilitate the usage of existing tools and compilers, overheads are
	minimized by decoupling optimization from execution. Our system,
	ADAPT, supports a range of paradigms proposed recently, including
	dynamic compilation, parameterization and runtime sampling. We demonstrate
	our system by applying several optimization techniques to a suite
	of benchmarks on two target machines. ADAPT is shown to consistently
	outperform statically generated executables, improving performance
	by as much as 70%. Copyright 2001 ACM.},
  affiliation = {Sch. of Elec. and Comp. Engineering, Purdue University, West Lafayette,
	IN, United States},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-17644389586&partnerID=40&md5=c4f579da324f8fe89ca33a50a527648f}
}

@CONFERENCE{Voss200193,
  author = {Voss, M.J., Eigenmann, R.},
  title = {High-level adaptive program optimization with ADAPT},
  year = {2001},
  pages = {93-102},
  note = {cited By (since 1996) 21},
  abstract = {Compile-time optimization is often limited by a lack of target machine
	and input data set knowledge. Without this information, compilers
	may be forced to make conservative assumptions to preserve correctness
	and to avoid performance degradation. In order to cope with this
	lack of information at compile-time, adaptive and dynamic systems
	can be used to perform optimization at runtime when complete knowledge
	of input and machine parameters is available. This paper presents
	a compiler-supported high-level adaptive optimization system. Users
	describe, in a domain specific language, optimizations performed
	by stand-alone optimization tools and backend compiler flags, as
	well as heuristics for applying these optimizations dynamically at
	runtime. The ADAPT compiler reads these descriptions and generates
	application-specific runtime systems to apply the heuristics. To
	facilitate the usage of existing tools and compilers, overheads are
	minimized by decoupling optimization from execution. Our system,
	ADAPT, suppor ts a range of paradigms proposed recently, including
	dynamic compilation, parameterization and runtime sampling. We demonstrate
	our system by applying several optimization techniques to a suite
	of benchmarks on two target machines. ADAPT is shown to consistently
	outperform statically generated executables, improving performance
	by as much as 70%.},
  affiliation = {Sch. of Electrical and Computer Eng., Purdue University, West Lafayette,
	IN, United States},
  document_type = {Conference Paper},
  journal = {Proceedings of the ACM SIGPLAN Symposium on Principles and Practice
	of Parallel Programming, PPOPP},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-0034819518&partnerID=40&md5=f00179321ab72c01479b489cb907ba57}
}

@CONFERENCE{Völter2011353,
  author = {Völter, M.},
  title = {DSLs for product lines: Approaches, tools, experiences},
  year = {2011},
  pages = {353},
  note = {cited By (since 1996) 0},
  abstract = {Domain-Specific Languages are languages narrowly focused on a particular
	problem domain. Compared to feature models they are more expressive,
	but possibly not as easy to use. Compared to source code, they are
	usually simpler, more targeted and hence easier to use - although
	not quite as flexible. DSLs can play an important role in PLE, filling
	the gap between configuration via feature models and low-level programming.
	This tutorial covers approaches, tools and experiences of using DSLs
	in PLE. I will start with briefly introducing DSLs and their role
	in PLE. We will then look at a real-world DSL that has been used
	to describe a product line of electrical devices. We will then spend
	some time extending a DSL built with Eclipse Xtext to get some hands-on
	tool experience. Then we will look at another DSL, one for robot
	control, that integrates nicely with feature models. We will then
	finally spend some time extending a DSL build with JetBrains MPS,
	before we wrap up the tutorial. © 2011 IEEE.},
  affiliation = {Itemis, Stuttgart, Germany},
  art_number = {6030088},
  author_keywords = {domain-specific languages; feature models; language extension; PLE},
  document_type = {Conference Paper},
  journal = {Proceedings - 15th International Software Product Line Conference,
	SPLC 2011},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-80054073351&partnerID=40&md5=0e86b98de199472449844cfeb6742710}
}

@ARTICLE{Völter201056,
  author = {Völter, M.},
  title = {Architecture as language},
  journal = {IEEE Software},
  year = {2010},
  volume = {27},
  pages = {56-64},
  number = {2},
  note = {cited By (since 1996) 3},
  abstract = {Software architecture is an important aspect of software, although
	developers don't have a good way of expressing it. This leads to
	architecture being hard to understand, discuss, document, analyze,
	and implement consistently in large systems or teams. This article
	explains how and why to use domain-specific languages (DSLs) to describe
	software architecture. Architects develop a DSL that expresses the
	desired architecture directly, often in real time during architecture
	definition; they can then use this DSL to precisely describe systems
	based on the architecture. Because the DSL is formal and therefore
	tool processable, analyses can be conducted on the models and code
	generation can be used to consistently implement the architecture
	in code. © 2010 IEEE.},
  affiliation = {Itemis, Germany},
  art_number = {5420798},
  author_keywords = {Domain-specific languages; Model-driven development; Software architecture;
	Software development},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-77649248566&partnerID=40&md5=74d0750c8a52e476976443975296e73c}
}

@CONFERENCE{Völter2010301,
  author = {Völter, M.a , Visser, E.b },
  title = {Language extension and composition with language workbenches},
  year = {2010},
  pages = {301-304},
  note = {cited By (since 1996) 0},
  abstract = {Domain-specific languages (DSLs) provide high expressive power focused
	on a particular problem domain. They provide linguistic abstractions
	and specialized syntax specifically designed for a domain, allowing
	developers to avoid boilerplate code and low-level implementation
	details. Language workbenches are tools that integrate all aspects
	of the definition of domain-specific or general-purpose software
	languages and the creation of a programming environment from such
	a definition. To count as a language workbench, a tool needs to satisfy
	basic requirements for the integrated definition of syntax, semantics,
	and editor services, and preferably also support language extension
	and composition. Within these requirements there is ample room for
	variation in the design of a language workbench. In this tutorial,
	we give an introduction to the state of the art in textual DSLs and
	language workbenches. We discuss the main requirements and variation
	points in the design of language workbenches, and describe two points
	in the design space using two state-of-the-art language workbenches.
	Spoofax is an example of a parser-based language workbench, while
	MPS represents language workbenches based on projectional editors.},
  affiliation = {Independent/Itemis, Germany; Delft University of Technology, Netherlands},
  author_keywords = {Domain-specific language; Eclipse; IDE; Language workbench; Meta-tooling;
	MPS; Parsing; Projectional editing; SDF; SGLR; Spoofax; Stratego;
	Textual language},
  document_type = {Conference Paper},
  journal = {Proceedings of the ACM International Conference Companion on Object
	Oriented Programming Systems Languages and Applications Companion,
	SPLASH '10},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-78650085881&partnerID=40&md5=1e54d021bc6c9bda227ea88693053929}
}

@ARTICLE{Wada2005584,
  author = {Wada, H., Suzuki, J.},
  title = {Modeling Turnpike frontend system: A model-driven development framework
	leveraging UML metamodeling and attribute-oriented programming},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2005},
  volume = {3713 LNCS},
  pages = {584-600},
  note = {cited By (since 1996) 4},
  abstract = {This paper describes and empirically evaluates a new model-driven
	development framework, called Modeling Turnpike (or mTurnpike). It
	allows developers to model and program domain-specific concepts (ideas
	and mechanisms specific to a particular business or technology domain)
	and to transform them to the final (compilable) source code. By leveraging
	UML metamodeling and attribute-oriented programming, mTurnpike provides
	an abstraction to represent domain-specific concepts at the modeling
	and programming layers simultaneously. The mTurnpike frontend system
	transforms domain-specific concepts from the modeling layer to programming
	layer, and vise versa, in a seamless manner. Its backend system combines
	domain-specific models and programs, and transforms them to the final
	(compilable) source code. This paper focuses on the frontend system
	of mTurnpike, and describes its design, implementation and performance
	implications. In order to demonstrate how to exploit mTurnpike in
	application development, this paper also shows a development process
	using an example DSL (domain specific language) to specify service-oriented
	distributed systems. © Springer-Verlag Berlin Heidelberg 2005.},
  affiliation = {Department of Computer Science, University of Massachusetts, Boston},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-33646192044&partnerID=40&md5=6445d5170c1ac47b53b7fe0bbc5c77fd}
}

@CONFERENCE{Wagelaar2004304,
  author = {Wagelaar, D.},
  title = {Towards a context-driven development framework for Ambient intelligence},
  year = {2004},
  volume = {24},
  pages = {304-309},
  note = {cited By (since 1996) 3},
  abstract = {Portable and embedded devices form an increasingly large group of
	computers, often referred to as Ambient Intelligence (Ami). This
	new variety in computing platforms will cause a corresponding diversity
	in software/hardware platforms and other context factors. Component-based
	middleware platforms offer a uniform environment for software, but
	they do not take away specific context differences, such as hardware
	resources, user identity/role and logical/physical location. Specialised
	component versions and/or configurations have to be made for each
	computing context if that computing context is to be used to its
	full extent. This is because the fine differences between component
	versions cannot be separated into finer components with the current
	component models. Aspect-oriented programming and generative programming
	technologies can be used to provide the fine-grained modularity that
	is necessary. In addition, the diversity of component-based platforms
	themselves form an extra reason for different component versions.
	We propose using a context-driven framework for the development of
	Ami components, which is based upon a gradual refinement mechanism.
	This refinement mechanism can cope with the course-grained differences
	between component models as well as the fine-grained differences
	between computing configurations.},
  affiliation = {System and Software Engineering Lab., Vrije Universiteit Brussel,
	Pleinlaan 2, 1050 Brussel, Belgium},
  document_type = {Conference Paper},
  journal = {Proceedings - International Conference on Distributed Computing Systems},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-3042596813&partnerID=40&md5=1a236269668c36bab8dbe86a304be369}
}

@CONFERENCE{Waite200618,
  author = {Waite, W.M., Jarrahian, A., Jackson, M.H., Diwan, A.},
  title = {Design and implementation of a modern compiler course},
  year = {2006},
  pages = {18-22},
  note = {cited By (since 1996) 1},
  abstract = {Current literature states that the undergraduate curriculum can no
	longer afford the luxury of a traditional compiler construction course.
	Nevertheless, there is an increasing need for an understanding of
	how to design and implement domain-specific languages. This paper
	presents a modern course in compiler construction, designed to provide
	a student with the capability of quickly constructin robust processors
	for a variety of language-related applications.},
  affiliation = {University of Colorado, Boulder, CO 80309, United States},
  author_keywords = {Abstraction; Course pedagogy; Curriculum issues; Programming languages/paradigms;
	Student culture; Tools},
  document_type = {Conference Paper},
  journal = {Working Group Reports on ITiCSE on Innovation and Technology in Computer
	Science Education 2006},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-34548357054&partnerID=40&md5=4a10d63b03723b09b117af9456da7559}
}

@ARTICLE{Walkingshaw2009310,
  author = {Walkingshaw, E., Erwig, M.},
  title = {Varying domain representations in hagl extending the expressiveness
	of a dsl for experimental game theory},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2009},
  volume = {5658 LNCS},
  pages = {310-334},
  note = {cited By (since 1996) 0},
  abstract = {Experimental game theory is an increasingly important research tool
	in many fields, providing insight into strategic behavior through
	simulation and experimentation on game theoretic models. Unfortunately,
	despite relying heavily on automation, this approach has not been
	well supported by tools. Here we present our continuing work on Hagl,
	a domain-specific language embedded in Haskell, intended to drastically
	reduce the development time of such experiments and support a highly
	explorative research style. In this paper we present a fundamental
	redesign of the underlying game representation in Hagl. These changes
	allow us to better utilize domain knowledge by allowing different
	classes of games to be represented differently, exploiting existing
	domain representations and algorithms. In particular, we show how
	this supports analytical extensions to Hagl, and makes strategies
	for state-based games vastly simpler and more efficient. © IFIP International
	Federation for Information Processing 2009.},
  affiliation = {School of Electrical Engineering and Computer Science, Oregon State
	University, Corvallis, OR 97331, United States},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-69049111850&partnerID=40&md5=96f110f9ddced1b1373feb8105ef189d}
}

@ARTICLE{Walkingshaw2009645,
  author = {Walkingshaw, E., Erwig, M.},
  title = {A domain-specific language for experimental game theory},
  journal = {Journal of Functional Programming},
  year = {2009},
  volume = {19},
  pages = {645-661},
  number = {6},
  note = {cited By (since 1996) 0},
  abstract = {Experimental game theory is increasingly important for research in
	many fields. Unfortunately, it is poorly supported by computer tools.
	We have created Hagl, a domain-specific language embedded in Haskell,
	to reduce the development time of game-theoretic experiments and
	make the definition and exploration of games and strategies simple
	and fun. © 2009 Cambridge University Press.},
  affiliation = {School of Electrical Engineering and Computer Science, Oregon State
	University, Corvallis, OR 97331, United States},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-74349106393&partnerID=40&md5=5796a42e1b1b3ee3f5858ef743bbab3b}
}

@ARTICLE{Walter2009148,
  author = {Walter, T.a b , Ebert, J.a },
  title = {Combining DSLs and ontologies using metamodel integration},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2009},
  volume = {5658 LNCS},
  pages = {148-169},
  note = {cited By (since 1996) 4},
  abstract = {This paper reports on a case study where the domain specific language
	BEDSL for the description of network devices for computer networks
	is combined with the feature description language FODA used for defining
	the variability structure of product lines. Furthermore, annotations
	by fragments of the web ontology language OWL can be added. In essence,
	the approach is a three-way integration, which regards two documents
	written in BEDSL and FODA, respectively, and semantic OWL-annotations
	as three equally important views of the system under discussion.
	The integration of languages is done on the level of their metamodels.
	The standard metamodel of OWL 2 is merged with two self-developed
	metamodels for the respective domain specific languages. The merge
	is loss-free, i.e. the resulting merged model still contains all
	information from its parts. Thus, the BEDSL part can be used to visualize
	the network model, the FODA part still defines the feature structure
	of the corresponding product line and the OWL part can be extracted
	and fed into an OWL tool to assert the semantic conditions. © IFIP
	International Federation for Information Processing 2009.},
  affiliation = {Institute for Software Technology, University of Koblenz-Landau, Universitätsstrasse
	1, Koblenz 56070, Germany; ISWeb - Information Systems and Semantic
	Web, Institute for Computer Science, University of Koblenz-Landau,
	Universitätsstrasse 1, Koblenz 56070, Germany},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-69049090928&partnerID=40&md5=0220c8af8224e10e1dcd04d6a2d82585}
}

@ARTICLE{Walter2010321,
  author = {Walter, T.a b , Parreiras, F.S.a , Staab, S.a , Ebert, J.b },
  title = {Joint language and domain engineering},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2010},
  volume = {6138 LNCS},
  pages = {321-336},
  note = {cited By (since 1996) 2},
  abstract = {In domain-specific development model-driven development environments
	play an important role. Most of these environments only provide support
	for language engineering, but do not consider the second dimension
	which is concerned with domain engineering. In this paper, we join
	the concerns of language engineering and domain engineering towards
	a new comprehensive approach of domain-specific development. It allows
	domain designers to build domain models containing both, types and
	instances, and it allows language designers for defining language
	metamodels. Furthermore, based on the integrated description logics
	the environment provides services for productive modeling in domain
	and language engineering. © 2010 Springer-Verlag.},
  affiliation = {Institute for Web Science and Technology, University of Koblenz-Landau,
	Universitätsstrasse 1, Koblenz 56070, Germany; Institute for Software
	Technology, University of Koblenz-Landau, Universitätsstrasse 1,
	Koblenz 56070, Germany},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-77954654786&partnerID=40&md5=88b697ea87572e00c99b4bc9c165d0ce}
}

@ARTICLE{Walter2009408,
  author = {Walter, T.a b , Silva Parreiras, F.a , Staab, S.a },
  title = {OntoDSL: An ontology-based framework for domain-specific languages},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2009},
  volume = {5795 LNCS},
  pages = {408-422},
  note = {cited By (since 1996) 6},
  abstract = {Domain-specific languages (DSLs) are high-level and should provide
	abstractions and notations for better understanding and easier modeling
	of applications of a special domain. Current shortcomings of DSLs
	include learning curve and formal semantics. This paper reports on
	a novel approach that allows the use of ontologies to describe DSLs.
	The formal semantics of OWL together with reasoning services allow
	for addressing constraint definition, progressive evaluation, suggestions,
	and debugging. The approach integrates existing metamodels, concrete
	syntaxes and a query language. A scenario in which domain models
	for network devices are created illustrates the development environment.
	© 2009 Springer Berlin Heidelberg.},
  affiliation = {ISWeb - Information Systems and Semantic Web, Institute for Computer
	Science, University of Koblenz-Landau, Universitaetsstrasse 1, Koblenz
	56070, Germany; Institute for Software Technology, University of
	Koblenz-Landau, Universitätsstrasse 1, Koblenz 56070, Germany},
  author_keywords = {Domain-Specific Languages; Ontologies; Reasoning Services; Technical
	Space},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-77249101726&partnerID=40&md5=798eb740ae7d41a5bf2a648ab5e13cd0}
}

@ARTICLE{Wampler201020,
  author = {Wampler, D.a , Clark, T.b },
  title = {Guest editors' introduction: Multiparadigm programming},
  journal = {IEEE Software},
  year = {2010},
  volume = {27},
  pages = {20-24},
  number = {5},
  note = {cited By (since 1996) 0},
  abstract = {The guest editors of this special issue on multiparadigm programming
	explore the field's recent explosive growth and how the articles
	(plus email roundtable) they've selected for this issue exemplify
	its current status. © 2006 IEEE.},
  affiliation = {DRW Holdings, United States; School of Engineering and Information
	Sciences, Middlesex University, London, United Kingdom},
  art_number = {5551015},
  author_keywords = {domain-specific languages; functional programming; multiparadigm programming;
	object-oriented programming},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-77956043007&partnerID=40&md5=2ac8373ca16a63a9ccff77a9018fc7ea}
}

@CONFERENCE{Wan2006,
  author = {Wan, V., Hain, T.},
  title = {Strategies for language model web-data collection},
  year = {2006},
  volume = {1},
  pages = {I1069-I1072},
  note = {cited By (since 1996) 3},
  abstract = {This paper presents an analysis of the use of textual information
	collected from the internet via a search engine for the purpose of
	building domain specific language models. A framework to analyse
	the effect of search query formulation on the resulting web-data
	language model performance in an evaluation is developed. The framework
	gives rise to improved methods of selecting n-gram search engine
	queries, which return documents that make better domain specific
	language models. © 2006 IEEE.},
  affiliation = {Department of Computer Science, University of Sheffield, United Kingdom},
  art_number = {1660209},
  document_type = {Conference Paper},
  journal = {ICASSP, IEEE International Conference on Acoustics, Speech and Signal
	Processing - Proceedings},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-33947697215&partnerID=40&md5=4b3fdec68b92bbdf5a876af643e1d754}
}

@CONFERENCE{Wan2000,
  author = {Wan, Z., Hudak, P.},
  title = {Functional reactive programming from first principles},
  year = {2000},
  pages = {242-252},
  note = {cited By (since 1996) 17},
  abstract = {Functional Reactive Programming, or FRP, is a general framework for
	programming hybrid systems in a high-level, declarative manner. The
	key ideas in FRP are its notions of behaviors and events. Behaviors
	are time-varying, reactive values, while events are time-ordered
	sequences of discrete-time event occurrences. FRP is the essence
	of Fran, a domain-specific language embedded in Haskell for programming
	reactive animations, but FRP is now also being used in vision, robotics
	and other control systems applications. In this paper we explore
	the formal semantics of FRP and how it relates to an implementation
	based on streams that represent (and therefore only approximate)
	continuous behaviors. We show that, in the limit as the sampling
	interval goes to zero, the implementation is faithful to the formal,
	continuous semantics, but only when certain constraints on behaviors
	are observed. We explore the nature of these constraints, which vary
	amongst the FRP primitives. Our results show both the power and limitations
	of this approach to language design and implementation. As an example
	of a limitation, we show that streams are incapable of representing
	instantaneous predicate events over behaviors.},
  affiliation = {Yale University, Department of Computer Science, PO Box 208285, New
	Haven, CT 06520, United States},
  document_type = {Conference Paper},
  journal = {Proceedings of the ACM SIGPLAN Conference on Programming Language
	Design and Implementation (PLDI)},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-0034449844&partnerID=40&md5=b46f022194d56472fa2484502a9db5f2}
}

@ARTICLE{Wan2000242,
  author = {Wan, Z., Hudak, P.},
  title = {Functional reactive programming from first principles},
  journal = {SIGPLAN Notices (ACM Special Interest Group on Programming Languages)},
  year = {2000},
  volume = {35},
  pages = {242-251},
  number = {5},
  note = {cited By (since 1996) 5},
  abstract = {Functional Reactive Programming, or FRP, is a general framework for
	programming hybrid systems in a high-level, declarative manner. The
	key ideas in FRP are its notions of behaviors and events. Behaviors
	are time-varying, reactive values, while events are time-ordered
	sequences of discrete-time event occurrences. FRP is the essence
	of Fran, a domain-specific language embedded in Haskell for programming
	reactive animations, but FRP is now also being used in vision, robotics
	and other control systems applications. In this paper we explore
	the formal semantics of FRP and how it relates to an implementation
	based on streams that represent (and therefore only approximate)
	continuous behaviors. We show that, in the limit as the sampling
	interval goes to zero, the implementation is faithful to the formal,
	continuous semantics, but only when certain constraints on behaviors
	are observed. We explore the nature of these constraints, which vary
	amongst the FRP primitives. Our results show both the power and limitations
	of this approach to language design and implementation. As an example
	of a limitation, we show that streams are incapable of representing
	instantaneous predicate events over behaviors. Copyright 2000 ACM.},
  affiliation = {Yale University, Department of Computer Science, PO Box 208285, New
	Haven, CT 06520, United States},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-17144411174&partnerID=40&md5=097bce63e453a1e4946a7ab4fca7c8dd}
}

@ARTICLE{Wang200961,
  author = {Wang, A.a , Basu, P.b , Loo, B.T.a , Sokolsky, O.a },
  title = {Declarative network verification},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2009},
  volume = {5418 LNCS},
  pages = {61-75},
  note = {cited By (since 1996) 0},
  abstract = {In this paper, we present our initial design and implementation of
	a declarative network verifier (DNV). DNV utilizes theorem proving,
	a well established verification technique where logic-based axioms
	that automatically capture network semantics are generated, and a
	user-driven proof process is used to establish network correctness
	properties. DNV takes as input declarative networking specifications
	written in the Network Datalog (NDlog) query language, and maps that
	automatically into logical axioms that can be directly used in existing
	theorem provers to validate protocol correctness. DNV is a significant
	improvement compared to existing use case of theorem proving which
	typically require several man-months to construct the system specifications.
	Moreover, NDlog, a high-level specification, whose semantics are
	precisely compiled into DNV without loss, can be directly executed
	as implementations, hence bridging specifications, verification,
	and implementation. To validate the use of DNV, we present case studies
	using DNV in conjunction with the PVS theorem prover to verify routing
	protocols, including eventual properties of protocols in dynamic
	settings. © 2009 Springer Berlin Heidelberg.},
  affiliation = {Computer and Information Sciences Department, University of Pennsylvania,
	3330 Walnut Street, Philadelphia, PA 19104-6389; Network Research
	Group, BBN Technologies, 10 Moulton Street, Cambridge, MA 02138,
	United States},
  author_keywords = {Declarative networking; Domain-specific languages; Network protocol
	verification; Theorem proving},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-70350657041&partnerID=40&md5=7a6c3f0d881d1f4b817c83a01a61158c}
}

@CONFERENCE{Wang20061773,
  author = {Wang, B.-Y.},
  title = {Modeling and analyzing applications with domain-specific languages
	by reflective rewriting: A study},
  year = {2006},
  volume = {2},
  pages = {1773-1778},
  note = {cited By (since 1996) 0},
  abstract = {In this paper, we propose to model and analyze applications with domain-specific
	languages by reflection. We argue that both tasks can be significantly
	simplified by using a reflective modeling language. To make our arguments,
	we model and analyze a model checker in the reflective language Maude.
	The simplicity of our methodology suggests our methodology is useful
	for such applications. Copyright 2006 ACM.},
  affiliation = {Institute of Information Science, Academia Sinica, Taipei, 115, Taiwan},
  document_type = {Conference Paper},
  journal = {Proceedings of the ACM Symposium on Applied Computing},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-33751051520&partnerID=40&md5=243a79902282051ea35c26f0da175be2}
}

@CONFERENCE{Wang2010609,
  author = {Wang, C.a , Wang, X.-G.a , Liu, J.a , Tian, M.a , Wang, Z.-X.b },
  title = {Object modeling language for C4ISR capability requirement analysis},
  year = {2010},
  volume = {3},
  pages = {609-613},
  note = {cited By (since 1996) 0},
  abstract = {the paper suggests a meta-ontology for C4ISR capability conceptualization.
	Under which, by taking advantage of the UML profile mechanism, the
	paper defines a domain-specific modeling language for C4ISR capability
	requirement. The abstract syntax, concrete syntax and formal semantic
	of the modeling language have been discussed in the paper. A case
	study of C4ISR architectural simulation modeling is provided to demonstrate
	the availability and applicability of the language. © 2010 IEEE.},
  affiliation = {Institute of Communication Engineering, PLA University of Science
	and Technology, Nanjing, China; Institute of Command Automation,
	PLA University of Science and Technology, Nanjing, China},
  art_number = {5565130},
  author_keywords = {Architectural modeling; C4ISR capability; Domain-specific modeling;
	UML},
  document_type = {Conference Paper},
  journal = {Proceedings - 2010 3rd IEEE International Conference on Computer
	Science and Information Technology, ICCSIT 2010},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-77958567831&partnerID=40&md5=b91ccbe5e6500e03e9a129358d53396a}
}

@CONFERENCE{Wang2007329,
  author = {Wang, J.a b , Feng, Z.a b , Zhao, F.a b },
  title = {Research on pattern language for agent-based application},
  year = {2007},
  pages = {329-334},
  note = {cited By (since 1996) 2},
  abstract = {Agent-based computing has received more and more attention in the
	development of distribute systems for dynamic and open network, and
	it has also become a promising paradigm for software engineering.
	To develop robust, maintainable Multi-agent System, an Agent Pattern
	Language named APL has been proposed in the light of Generative Programming
	and engineering disciplines for grammarware, in accompany with a
	single agent architecture based on blackboard. With a Business Process
	Management application scenario, the paper describes how the APL
	language is used to describe the data type and components like knowledge
	Sources and so on, then a parser for APL parses APL files and generate
	executable code for Agent which run on JADE. By this way, systems
	based on agent can be developed fast and Multi-agent system can be
	constructed in a top-down manner. Then not only the productivity
	for the development agent-base system is improved, but flexibility
	and reusability of the system are also enhanced.},
  affiliation = {School of Computer Science and Technology, Tianjin University; School
	of Computer Science, Tianjin University, China},
  author_keywords = {APL; Blackboard; Generative programming; Grammarware; JADE; MAS},
  document_type = {Conference Paper},
  journal = {Fourth International Conference on Information Technology and Applications,
	ICITA 2007},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-36448974895&partnerID=40&md5=ec2045ec9e452edeb8cc648920c9a7c7}
}

@CONFERENCE{Wang2007,
  author = {Wang, P.H.a , Collins, J.D.a , Chinya, G.N.a , Jiang, H.b , Tian,
	X.c , Girkar, M.c , Yang, N.Y.b , Lueh, G.-Y.b , Wang, H.a },
  title = {EXOCHI: Architecture and programming environment for a heterogeneous
	multi-core multithreaded system},
  year = {2007},
  pages = {156-166},
  note = {cited By (since 1996) 20},
  abstract = {Future mainstream microprocessors will likely integrate specialized
	accelerators, such as GPUs, onto a single die to achieve better performance
	and power efficiency. However, it remains a keen challenge to program
	such a heterogeneous multicore platform, since these specialized
	accelerators feature ISAs and functionality that are significantly
	different from the general purpose CPU cores. In this paper, we present
	EXOCHI: (1) Exoskeleton Sequencer(EXO), an architecture to represent
	heterogeneous acceleratorsas ISA-based MIMD architecture resources,
	and a shared virtual memory heterogeneous multithreaded program execution
	model that tightly couples specialized accelerator cores with generalpurpose
	CPU cores, and (2) C for Heterogeneous Integration(CHI), an integrated
	C/C++ programming environment that supports accelerator-specific
	inline assembly and domain-specific languages. The CHI compiler extends
	the OpenMP pragma for heterogeneous multithreading programming, and
	produces a single fat binary with code sections corresponding to
	different instruction sets. The runtime can judiciously spread parallel
	computation across the heterogeneous cores to optimize performance
	and power. We have prototyped the EXO architecture on a physical
	heterogeneous platform consisting of an Intel Core 2 Duo processor
	and an 8-core 32-thread Intel Graphics Media Accelerator X3000. In
	addition, we have implemented the CHI integrated programming environment
	with the Intel C++ Compiler, runtime toolset, and debugger. On the
	EXO prototype system, we have enhanced a suite of production-quality
	media kernels for video and image processing to utilize the accelerator
	through the CHI programming interface, achieving significant speedup
	(1.41X to10.97X) over execution on the IA32 CPU alone. Copyright
	© 2007 ACM.},
  affiliation = {Microarchitecture Research Lab., Microprocessor Technology Labs, Intel
	Corporation; Graphics Architecture, Chipset Group, Intel Corporation;
	Intel Compiler Lab., Software Solutions Group, Intel Corporation},
  author_keywords = {GPU; Heterogeneous multi-cores; OpenMP},
  document_type = {Conference Paper},
  journal = {Proceedings of the ACM SIGPLAN Conference on Programming Language
	Design and Implementation (PLDI)},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-35448978324&partnerID=40&md5=967cb4072efafd3517f9188d5837fa11}
}

@ARTICLE{Wang2007156,
  author = {Wang, P.H.a , Collins, J.D.a , Chinya, G.N.a , Jiang, H.b , Tian,
	X.c , Girkar, M.c , Yang, N.Y.b , Lueh, G.-Y.b , Wang, H.a },
  title = {Exochi: Architecture and programming environment for a heterogeneous
	multi-core multithreaded system},
  journal = {ACM SIGPLAN Notices},
  year = {2007},
  volume = {42},
  pages = {156-166},
  number = {6},
  note = {cited By (since 1996) 12},
  abstract = {Future mainstream microprocessors will likely integrate specialized
	accelerators, such as GPUs, onto a single die to achieve better performance
	and power efficiency. However, it remains a keen challenge to program
	such a heterogeneous multi-core platform, since these specialized
	accelerators feature ISAs and functionality that are significantly
	different from the general purpose CPU cores. In this paper, we present
	EXOCHI: (1) Exoskeleton Sequencer (EXO), an architecture to represent
	heterogeneous accelerators as ISA-based MIMD architecture resources,
	and a shared virtual memory heterogeneous multithreaded program execution
	model that tightly couples specialized accelerator cores with general
	purpose CPU cores, and (2) C for Heterogeneous Integration (CHI),
	an integrated C/C++ programming environment that supports accelerator-specific
	inline assembly and domain-specific languages. The CHI compiler extends
	the OpenMP pragma for heterogeneous multithreading programming, and
	produces a single fat binary with code sections corresponding to
	different instruction sets. The runtime can judiciously spread parallel
	computation across the heterogeneous cores to optimize performance
	and power. We have prototyped the EXO architecture on a physical
	heterogeneous platform consisting of an Intel® Core™ 2 Duo processor
	and an 8-core 32-thread Intel® Graphics Media Accelerator X3000.
	In addition, we have implemented the CHI integrated programming environment
	with the Intel® C++ Compiler, runtime toolset, and debugger. On the
	EXO prototype system, we have enhanced a suite of production-quality
	media kernels for video and image processing to utilize the accelerator
	through the CHI programming interface, achieving signi.cant speedup
	(1.41X to 10.97X) over execution on the IA32 CPU alone. © 2007 ACM.},
  affiliation = {Microarchitecture Research Lab, Microprocessor Technology Labs, Intel
	Corporation; Graphics Architecture, Chipset Group, Intel Corporation;
	Intel Compiler Lab, Software Solutions Group, Intel Corporation},
  author_keywords = {GPU; Heterogeneous multi-cores; OpenMP},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-67650085808&partnerID=40&md5=58b43d1021d4703c65f23c3107727ec0}
}

@CONFERENCE{Wang20051419,
  author = {Wang, Q., Gupta, G.},
  title = {Rapidly prototyping implementation infrastructure of Domain Specific
	Languages: A semantics-based approach},
  year = {2005},
  volume = {2},
  pages = {1419-1426},
  note = {cited By (since 1996) 2},
  abstract = {Domain Specific Languages (DSLs) are high level languages designed
	for solving problems in a particular domain, and have been suggested
	as means for developing reliable software systems. However, designing
	of a domain specific language is a difficult task. The design of
	a domain specific language will evolve as it is used more and more
	and experienced is gained by its designers. Being able to rapidly
	develop the implementation infrastructure (interpreter, compiler,
	debugger, profiler, etc.) of a domain specific language is thus of
	utmost importance so that as the language evolves, the implementation
	infrastructure can keep pace. In this paper we present a framework
	for automatically generating interpreters, compilers, debuggers,
	and profilers from semantic specification of a domain specific language.
	We illustrate our approach via the SCR language, a language used
	by the US defense department for developing control systems. Copyright
	2005 ACM.},
  affiliation = {Applied Logic, Programming-Languages and System Lab, Department of
	Computer Science, University of Texas, Dallas},
  author_keywords = {Domain Specific Languages; Horn Logical Semantics},
  document_type = {Conference Paper},
  journal = {Proceedings of the ACM Symposium on Applied Computing},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-33644507080&partnerID=40&md5=dc73c11914d665e010693962dadaf862}
}

@CONFERENCE{Wang200653,
  author = {Wang, S.a , Birla, S.K.a , Neema, S.b },
  title = {A modeling language for vehicle motion control behavioral specification},
  year = {2006},
  pages = {53-59},
  note = {cited By (since 1996) 1},
  abstract = {Error-free engineering of high integrity applications such as vehicle
	motion control (VMC) requires unambiguous behavioral specification.
	As system engineering progresses from requirements modeling to functional
	design, to system implementation on a distributed platform, the specifications
	of the system artifacts and work products must be transferred across
	different engineering environments and stages in models without loss
	of semantics. Modeling environments currently available for industrial
	use, with their native modeling languages, do not provide the capability
	of unambiguous behavior modeling across tools and engineering stages.
	In this paper, we identify certain fundamental requirements for high
	integrity systems and show that these requirements are not satisfied
	in current and proposed international standards, and two commercial
	modeling tools. A modeling language for VMC behavioral specification,
	eFSM, is proposed as a candidate for standardization and for adoption
	by the community in this domain. The language is based on a general
	mathematical modeling framework and an extended finite state machine
	paradigm. It adds unambiguous semantics essential to the VMC behavioral
	specification. An experimental prototype of the eFSM has been developed
	and evaluated relative to the requirements for modeling high integrity
	systems. Copyright 2006 ACM.},
  affiliation = {General Motors Corporation, Warren, MI 48090, United States; Vanderbilt
	University, Nashville, TN 37203, United States},
  author_keywords = {behavior modeling; domain-specific modeling language; high integrity
	systems; requirements specification},
  document_type = {Conference Paper},
  journal = {Proceedings - International Conference on Software Engineering},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-77953501693&partnerID=40&md5=196b9d4129ab09746028aaadf6b5f61a}
}

@ARTICLE{Wang2011174,
  author = {Wang, Y., Gaspes, V.},
  title = {A library for processing ad hoc data in Haskell: Embedding a data
	description language},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2011},
  volume = {5836 LNCS},
  pages = {174-191},
  note = {cited By (since 1996) 0},
  abstract = {Ad hoc data formats, i.e. semistructured non-standard data formats,
	are pervasive in many domains that need software tools - bioinformatics,
	demographic surveys, geophysics and network software are just a few.
	Building tools becomes easier if parsing and other standard input-output
	processing can be automated. Modern approaches for dealing with ad
	hoc data formats consist of domain specific languages based on type
	systems. Compilers for these languages generate data structures and
	parsing functions in a target programming language in which tools
	and applications are then written. We present a monadic library in
	Haskell that implements a data description language. Using our library,
	Haskell programmers have access to data description primitives that
	can be used for parsing and that can be integrated with other libraries
	and application programs without the need of yet another compiler.
	© 2011 Springer-Verlag.},
  affiliation = {Halmstad University, Sweden},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-80053964182&partnerID=40&md5=26af484947dde2d0d8c434279d88b094}
}

@CONFERENCE{Wang201163,
  author = {Wang, Y., Gaspes, V.},
  title = {An embedded language for programming protocol stacks in embedded
	systems},
  year = {2011},
  pages = {63-72},
  note = {cited By (since 1996) 1},
  abstract = {Protocol stack specifications are well-structured documents that follow
	a number of conventions and notations that have proven very useful
	for the design and dissemination of communication protocols. Protocol
	stack implementations on the other hand, are done in low-level languages,
	using error-prone programming techniques resulting in programs that
	are difficult to relate to the specifications, difficult to maintain,
	modify, extend and reuse. To overcome these problems we propose a
	domain-specific language that provides abstractions close to the
	notations used in protocol specifications. From descriptions in our
	language we generate C programs that can be integrated with other
	systems software. The language provides constructs to describe packet
	formats, including physical layout, constraints and dependencies.
	It also provides constructs for state machines and for layering protocols
	into stacks. Experiments show that the C programs we generate are
	comparable in performance and binary size to hand-crafted C programs.
	© 2011 ACM.},
  affiliation = {CERES, Halmstad University, Sweden},
  author_keywords = {Domain-specific language; Embedded compilation; Embedded network software},
  document_type = {Conference Paper},
  journal = {PERM'11 - Proceedings of the 20th ACM SIGPLAN Workshop on Partial
	Evaluation and Program Manipulation},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-79952120257&partnerID=40&md5=8222e0bf8a3a4d26fe19e0c114f109e3}
}

@ARTICLE{Wang2010183,
  author = {Wang, Y., Gaspes, V.},
  title = {A domain-specific language approach to protocol stack implementation},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2010},
  volume = {5937 LNCS},
  pages = {183-185},
  note = {cited By (since 1996) 0},
  abstract = {This paper describes a domain-specific language embedded in Haskell,
	IPS, for the implementation of protocol stacks for embedded systems.
	IPS profits from Haskell's features and generates C implementations
	by embedded compilation. © 2010 Springer-Verlag.},
  affiliation = {CERES, Halmstad University, Halmstad SE-30251, Sweden},
  author_keywords = {Communication software; DSL; Network programming},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-77749295469&partnerID=40&md5=107d8e1f9f8cdaffb38037ae55d3a83c}
}

@CONFERENCE{Wang2009127,
  author = {Wang, Y., Gaspes, V.},
  title = {A domain specific approach to network software architecture assuring
	conformance between architecture and code},
  year = {2009},
  pages = {127-132},
  note = {cited By (since 1996) 0},
  abstract = {Network software is typically organized according to a layered architecture
	that is well understood. However, writing correct and efficient code
	that conforms with the architecture still remains a problem. To overcome
	this problem we propose to use a domain specific language based approach.
	The architectural constraints are captured in a domain specific notation
	that can be used as a source for automatic program generation. Conformance
	with the architecture is thus assured by construction. Knowledge
	from the domain allows us to generate efficient code. In addition,
	this approach enforces reuse of both code and designs, one of the
	major concerns in software architecture. In this paper, we illustrate
	our approach with PADDLE, a tool that generates packet processing
	code from packet descriptions. To describe packets we use a domain
	specific language of dependent types that includes packet overlays.
	From the description we generate C libraries for packet processing
	that are easy to integrate with other parts of the code. We include
	an evaluation of our tool. © 2009 IEEE.},
  affiliation = {Halmstad University, CERES, Halmstad, Sweden},
  art_number = {5205221},
  author_keywords = {Dependent types; Network software; Program generation; Software architecture},
  document_type = {Conference Paper},
  journal = {Proceedings - 2009 4th International Conference on Digital Telecommunications,
	ICDT 2009},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-70449602416&partnerID=40&md5=9a9b460ef4fb85a4b6b8ae2cf26c0203}
}

@CONFERENCE{Wang2010,
  author = {Wang, Y., Zhou, L., Zheng, Q., Zhang, Z., Wu, G.},
  title = {An approach of code generation based on Model Integrated Computing},
  year = {2010},
  volume = {15},
  pages = {v15114-v15117},
  note = {cited By (since 1996) 0},
  abstract = {Model Integrated Computing (MIC) is a theory of domain-specific modeling,
	using meta-model as a domain-specific modeling language (DSML), and
	constructing a component library for domain model. DSML abstracts
	the commonness and individuality in a domain, the developer employs
	it to construct domain model to represent the system. The final cross-platform
	code is automatically generated by code interpreter. In this paper,
	we propose an approach for designing code interpreter, it can transform
	domain model into a Platform Independent Model (PIM), and parsing
	PIM through code template, finally generating the code. This approach
	can shorten development time, promote reusability of code, improve
	work efficiency, and accomplish system rapidly. © 2010 IEEE.},
  affiliation = {School of Computer Science, Hangzhou Dianzi University, Hangzhou,
	China},
  art_number = {5622538},
  author_keywords = {Code generation; Domain model; MIC; Model interpreter},
  document_type = {Conference Paper},
  journal = {ICCASM 2010 - 2010 International Conference on Computer Application
	and System Modeling, Proceedings},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-78649616590&partnerID=40&md5=05ac913ac122fabea3cdd2fc3a5e1daf}
}

@CONFERENCE{Wang201133,
  author = {Wang, Z.a , Dong, Q.a , He, H.a , Fu, F.b },
  title = {Imprecise domain-specific modeling for C4ISR capability requirements
	analysis},
  year = {2011},
  pages = {33-38},
  note = {cited By (since 1996) 0},
  abstract = {The paper proposes an approach to model the uncertain and vague requirements
	information of the C4ISR capability requirements. It suggests that
	C4ISR requirements elicitation be initiated with capability meta
	concept framework (CMCF) construction according to the Meta-Model
	of DoDAF. With the semantic confinement of CMCF, the approach extends
	the Fuzzy-UML and declares a C4ISR domain-specific modeling language
	(C4ISR DSL). Compared with classic UML and Fuzzy-UML, the C4ISR DSL
	is more specialized in C4ISR domain knowledge elicitation and reuse.
	The experiment shows the modeling language can better express both
	precise and vague concepts of the C4ISR capability model. © 2011
	IEEE.},
  affiliation = {Institute of Command Automation, PLA University of Science and Technology,
	China; Chongqing Communication Institute, China},
  art_number = {5765205},
  document_type = {Conference Paper},
  journal = {2011 International Conference on Information Science and Technology,
	ICIST 2011},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-79957807740&partnerID=40&md5=6235a999277efb0a9a0d53eece2ff8dc}
}

@CONFERENCE{Wang2008197,
  author = {Wang, Z.a , Herkersdorf, A.a , Merenda, S.b , Tautschnig, M.c },
  title = {A model driven development approach for implementing reactive systems
	in hardware},
  year = {2008},
  pages = {197-202},
  note = {cited By (since 1996) 1},
  abstract = {To deal with the increasing complexity of digital systems, the model
	driven development approach has proven to be beneficial. This paper
	presents a model driven hardware design process that is dedicated
	to reactive embedded systems. The approach is based on the component
	language (COLA), a synchronous data flow language with formal semantics.
	COLA follows the hypothesis of perfect synchrony. Models thus do
	not assume specific timing properties and remain deterministic as
	long as data flow requirements are retained. This is an essential
	feature for modeling safety-critical systems. Further, the well-defined
	semantics not only allows that the resulting models can be formally
	reasoned about, but is also the key to translation to domain-specific
	languages. This paper describes the approach of translating the models
	to VHDL descriptions from their graphical representations. As COLA
	is well-adapted to both data flow description and control automata,
	the generated VHDL code can be synthesized to very efficient FPGA
	circuits, comparable to that synthesized from hand-written VHDL code
	according to our case study. © 2008 IEEE.},
  affiliation = {Lehrstuhl für Integrierte Systeme, Technische Universität München,
	Arcisstraße 21, 80290 München, Germany; Institut für Informatik,
	Technische Universität München, Boltzmannstraße 3, 85748 Garching,
	Germany; Formal Methods in Systems Engineering, Technische Universität
	Darmstadt, Hochschulstraße 10, 64289 Darmstadt, Germany},
  art_number = {4641445},
  document_type = {Conference Paper},
  journal = {Proceedings - 2008 Forum on Specification, Verification and Design
	Languages, FDL'08},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-67650683690&partnerID=40&md5=74c383ed55dfdfe745d26ecbabeeab30}
}

@ARTICLE{Warburton200917,
  author = {Warburton, R., Kalvala, S.},
  title = {From specification to optimisation: An architecture for optimisation
	of java bytecode},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2009},
  volume = {5501 LNCS},
  pages = {17-31},
  note = {cited By (since 1996) 0},
  abstract = {We present the architecture of the Rosser toolkit that allows optimisations
	to be specified in a domain specific language, then compiled and
	deployed towards optimising object programs. The optimisers generated
	by Rosser exploit model checking to apply dataflow analysis to programs
	to find optimising opportunities. The transformational language is
	derived from a formal basis and consequently can be proved sound.
	We validate the technique by comparing the application of optimisers
	generated by our system against hand-written optimisations using
	the Java based Scimark 2.0 benchmark. © 2009 Springer Berlin Heidelberg.},
  affiliation = {University of Warwick, Coventry, United Kingdom},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-70350635967&partnerID=40&md5=34bc91c3da19d1e307a11257325d8381}
}

@CONFERENCE{Ward2005233,
  author = {Ward, M., Zedan, H.},
  title = {METAWSL and meta-transformations in the FermaT transformation system},
  year = {2005},
  volume = {1},
  pages = {233-238},
  note = {cited By (since 1996) 1},
  abstract = {A program transformation is an operation which can be applied to any
	program (satisfying the transformations applicability conditions)
	and returns a semantically equivalent program. In the FermaT transformation
	system program transformations are carried out in a wide spectrum
	language, called WSL, and the transformations themselves are written
	in an extension of WSL called METAWSL which was specifically designed
	to be a domain-specific language for writing program transformations.
	As a result, FermdT is capable of transforming its own source code
	via metatransformations. This paper introduces METAWSL and describes
	some applications of meta-transformations in the FermaT system. ©
	2005 IEEE.},
  affiliation = {Software Technology Research Laboratory, De Montfort University, Leicester,
	United Kingdom},
  art_number = {1510025},
  document_type = {Conference Paper},
  journal = {Proceedings - International Computer Software and Applications Conference},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-34248570448&partnerID=40&md5=22a9276476d662e43e194f35fd4f2a6f}
}

@ARTICLE{Warmer2007194,
  author = {Warmer, J.},
  title = {A model driven software factory using domain specific languages},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2007},
  volume = {4530 LNCS},
  pages = {194-203},
  note = {cited By (since 1996) 3},
  abstract = {This paper describes the development of the SMART-Microsoft Software
	Factory. This factory is a fully model driven factory that makes
	extensive use of the Microsoft DSL Tools and is bases on the Microsoft
	Service Oriented Architecture. We describe the process used for developing
	the factory and share the experience gained in the first projects
	in which this factory has been used. The first project has 73% of
	the delivered code being generated. © Springer-Verlag Berlin Heidelberg
	2007.},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-37149003724&partnerID=40&md5=f44f5f16d12bbcc5a8e9c525cea515e5}
}

@CONFERENCE{Weaver2008197,
  author = {Weaver, C.},
  title = {Coordinated queries: A domain specific language for exploratory development
	of multiview visualizations},
  year = {2008},
  pages = {197-200},
  note = {cited By (since 1996) 0},
  abstract = {The development of information visualization user interfaces suffers
	from a persistent gap between toolkit-based programming and interactive
	design, between the visualization experts who build tools and the
	information experts who cultivate analytic utility. Coordinated Queries
	is a declarative language for live design of information visualization
	user interfaces. The combination of a visualization specific language
	with an extensive library of views and queries gives designers flexible,
	yet precise control over the appearance and behavior of data in response
	to interaction. Through live, integrated editing of essentially infinite
	variations on well-known patterns of visual data representation and
	multiple view coordination, it is practical to iteratively grow and
	vary visualizations much more quickly than by traditional means,
	thereby facilitating open-ended visual exploration and analysis in
	a variety of domains. © 2008 IEEE.},
  affiliation = {Pennsylvania State University, GeoVISTA Center, Department of Geography,
	University Park, PA 16802, United States},
  art_number = {4639085},
  document_type = {Conference Paper},
  journal = {Proceedings - 2008 IEEE Symposium on Visual Languages and Human-Centric
	Computing, VL/HCC 2008},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-56349126205&partnerID=40&md5=7c643fd5aeac4110d2da7afe47d41b6d}
}

@CONFERENCE{Weaver2007473,
  author = {Weaver, P., Kimmell, G., Frisby, N., Alexander, P.},
  title = {Modular and generic programming with InterpreterLib},
  year = {2007},
  pages = {473-476},
  note = {cited By (since 1996) 2},
  abstract = {Modular monadic semantics (MMS) is a well-known technique for structuring
	modular denotational semantic definitions. Families of language constructs
	are independently defined using syntactic functors and semantic algebras
	that can be combined in a mix-and-match fashion to create complete
	language definitions. We introduce InterpreterLib, a Haskell library
	that implements and extends MMS techniques for writing composable
	analyses. In addition to modular analyses composition, InterpreterLib
	provides algebra combinators, explicit algebra semantics, preprocessors
	for boiler plate generation and generic programming techniques adapted
	to language analysis. The key benefits of these features are reliability,
	increased code reuse via modularity and the ability to rapidly retarget
	component analyses. Copyright 2007 ACM.},
  affiliation = {Information and Telecommunication Technology Center, Electrical Engineering
	and Computer Science Department, University of Kansas, 2335 Irving
	Hill Road, Lawrence, KS 66044, United States},
  author_keywords = {generative programming; generic programming; modular monadic semantics},
  document_type = {Conference Paper},
  journal = {ASE'07 - 2007 ACM/IEEE International Conference on Automated Software
	Engineering},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-63149198388&partnerID=40&md5=6e59cec2e3d10f843d56fa3ae878b342}
}

@CONFERENCE{Wei200939,
  author = {Wei, T., Zhang, R., Su, X., Chen, S., Li, L.},
  title = {GaussianScriptEditor: An editor for Gaussian scripting language for
	grid environment},
  year = {2009},
  pages = {39-44},
  note = {cited By (since 1996) 0},
  abstract = {More and more chemists carry out scientific research using computation.
	In this process, computational chemistry software has played a very
	important role. Among these computational chemistry software, Gaussian
	is very prominent. The most essential user interface of Gaussian
	is scripting language, but software-oriented scripting language is
	a great burden to chemists. Meanwhile, chemists are increasingly
	using grid environment to do scientific research. So, it is significant
	to build a user-friendly and chemist-oriented Gaussian scripting
	language editing environment in grid. In this paper, we introduce
	GaussianScriptEditor to solve these problems. GaussianScriptEditor
	is on the basis of grid platform and its implementation is related
	to Domain Specific Language (DSL), knowledge in computational chemistry,
	technology of compiling, ANTLR and DLTK. © 2009 IEEE.},
  affiliation = {Engineering Research Center of Open Source Software and Real-time
	Systems, Ministry of Education, School of Information Science and
	Engineering, Lanzhou University, Lanzhou, Gansu, 730000, China},
  art_number = {5280146},
  author_keywords = {ANTLR; DLTK; Editor; Grid; Virtualization},
  document_type = {Conference Paper},
  journal = {8th International Conference on Grid and Cooperative Computing, GCC
	2009},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-72349092086&partnerID=40&md5=6fe93dad96b7c2d58558a4936c27264d}
}

@CONFERENCE{Weirich2011,
  author = {Weirich, S.a , Yorgey, B.A.a , Sheard, T.b },
  title = {Binders UNBOUND},
  year = {2011},
  pages = {333-345},
  note = {cited By (since 1996) 0},
  abstract = {Implementors of compilers, program refactorers, theorem provers, proof
	checkers, and other systems that manipulate syntax know that dealing
	with name binding is difficult to do well. Operations such as α-equivalence
	and capture-avoiding substitution seem simple, yet subtle bugs often
	go undetected. Furthermore, their implementations are tedious, requiring
	" boilerplate" code that must be updated whenever the object language
	definition changes. Many researchers have therefore sought to specify
	binding syntax declaratively, so that tools can correctly handle
	the details behind the scenes. This idea has been the inspiration
	for many new systems (such as Beluga, Delphin, FreshML, FreshOCaml,
	Cαml, FreshLib, and Ott) but there is still room for improvement
	in expressivity, simplicity and convenience. In this paper, we present
	a new domain-specific language, UNBOUND, for specifying binding structure.
	Our language is particularly expressive-it supports multiple atom
	types, pattern binders, type annotations, recursive binders, and
	nested binding (necessary for telescopes, a feature found in dependently-typed
	languages). However, our specification language is also simple, consisting
	of just five basic combinators. We provide a formal semantics for
	this language derived from a locally nameless representation and
	prove that it satisfies a number of desirable properties. We also
	present an implementation of our binding specification language as
	a GHC Haskell library implementing an embedded domain specific language
	(EDSL). By using Haskell type constructors to represent binding combinators,
	we implement the EDSL succinctly using datatype-generic programming.
	Our implementation supports a number of features necessary for practical
	programming, including flexibility in the treatment of user-defined
	types, besteffort name preservation (for error messages), and integration
	with Haskell's monad transformer library. Copyright © 2011 ACM.},
  affiliation = {University of Pennsylvania, United States; Portland State University,
	United States},
  author_keywords = {Generic programming; Haskell; Name binding; Patterns},
  document_type = {Conference Paper},
  journal = {Proceedings of the ACM SIGPLAN International Conference on Functional
	Programming, ICFP},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-80054069455&partnerID=40&md5=f2462c3cb588f1843ef2ff055e88eb33}
}

@ARTICLE{Weirich2011333,
  author = {Weirich, S.a , Yorgey, B.A.a , Sheard, T.b },
  title = {Binders unbound},
  journal = {ACM SIGPLAN Notices},
  year = {2011},
  volume = {46},
  pages = {333-345},
  number = {9},
  note = {cited By (since 1996) 0},
  abstract = {Implementors of compilers, program refactorers, theorem provers, proof
	checkers, and other systems that manipulate syntax know that dealing
	with name binding is difficult to do well. Operations such as λ-equivalence
	and capture-avoiding substitution seem simple, yet subtle bugs often
	go undetected. Furthermore, their implementations are tedious, requiring
	" boilerplate" code that must be updated whenever the object language
	definition changes. Many researchers have therefore sought to specify
	binding syntax declaratively, so that tools can correctly handle
	the details behind the scenes. This idea has been the inspiration
	for many new systems (such as Beluga, Delphin, FreshML, FreshOCaml,
	Cαml, FreshLib, and Ott) but there is still room for improvement
	in expressivity, simplicity and convenience. In this paper, we present
	a new domain-specific language, UNBOUND, for specifying binding structure.
	Our language is particularly expressive-it supports multiple atom
	types, pattern binders, type annotations, recursive binders, and
	nested binding (necessary for telescopes, a feature found in dependently-typed
	languages). However, our specification language is also simple, consisting
	of just five basic combinators. We provide a formal semantics for
	this language derived from a locally nameless representation and
	prove that it satisfies a number of desirable properties. We also
	present an implementation of our binding specification language as
	a GHC Haskell library implementing an embedded domain specific language
	(EDSL). By using Haskell type constructors to represent binding combinators,
	we implement the EDSL succinctly using datatype-generic programming.
	Our implementation supports a number of features necessary for practical
	programming, including flexibility in the treatment of user-defined
	types, besteffort name preservation (for error messages), and integration
	with Haskell's monad transformer library. Copyright © 2011 ACM.},
  affiliation = {University of Pennsylvania, United States; Portland State University,
	United States},
  author_keywords = {Generic programming; Haskell; Name binding; Patterns},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-80053342657&partnerID=40&md5=6103b48a9f4c37e1d9ed890bf84818c1}
}

@ARTICLE{Weisemöller200847,
  author = {Weisemöller, I., Schürr, A.},
  title = {A comparison of standard compliant ways to define domain specific
	languages},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2008},
  volume = {5002 LNCS},
  pages = {47-58},
  note = {cited By (since 1996) 1},
  abstract = {Domain specific languages are of increasing importance for today's
	software development processes. Their area of application ranges
	from process modeling over architecture description and system design
	to behavioral specification and simulation. There are numerous approaches
	for the definition and implementation of DSLs. Among others, the
	OMG offers UML profiles as a lightweight extension of a predefined
	multi-purpose language and MOF as a metamodeling language, which
	can be used to define DSLs from scratch. This contribution investigates
	various approaches to define DSLs, focusing on architectural description
	languages as an example. Besides the usage of UML profiles and the
	definition of an entirely new language with MOF, the adaption of
	the UML based on a metamodel extension is also considered. As a consequence
	of the shortcomings depicted for the different approaches, we suggest
	to combine UML profiles and metamodeling in order to compensate their
	weaknesses and take advantage of their benefits. © 2008 Springer-Verlag
	Berlin Heidelberg.},
  affiliation = {Real-Time Systems Lab., Technische Universität Darmstadt, Darmstadt
	D-64283, Germany},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-47749114630&partnerID=40&md5=ea0ec8e94d3d65d0a55969e46acfe313}
}

@CONFERENCE{Weissman2009889,
  author = {Weissman, C.D.a , Bobrowski, S.b },
  title = {The design of the force.com multitenant internet application development
	platform},
  year = {2009},
  pages = {889-896},
  note = {cited By (since 1996) 15},
  abstract = {Force.com is the preeminent on-demand application development platform
	in use today, supporting some 55,000+ organizations. Individual enterprises
	and commercial software-as-a-service (SaaS) vendors trust the platform
	to deliver robust, reliable, Internet-scale applications. To meet
	the extreme demands of its large user population, Force.com's foundation
	is a metadata-driven software architecture that enables multitenant
	applications. The focus of this paper is multitenancy, a fundamental
	design approach that can dramatically improve SaaS application management.
	This paper defines multitenancy, explains its benefits, and demonstrates
	why metadata-driven architectures are the premier choice for implementing
	multitenancy. © 2009 ACM.},
  affiliation = {CTO, Salesforce.com, San Francisco, CA 94105, United States; Salesforce.com},
  author_keywords = {Domain specific language; Flex schema; Multi-tenancy; Object-relational
	mapping; Query optimization},
  document_type = {Conference Paper},
  journal = {SIGMOD-PODS'09 - Proceedings of the International Conference on Management
	of Data and 28th Symposium on Principles of Database Systems},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-70849107902&partnerID=40&md5=2ce2417aae6eb644069faffde0df0e1a}
}

@CONFERENCE{Welicki2007787,
  author = {Welicki, L.a , Yoder, J.W.b , Wirfs-Brock, R.c , Johnson, R.E.d },
  title = {Towards a pattern language for adaptive object models},
  year = {2007},
  pages = {787-788},
  note = {cited By (since 1996) 0},
  abstract = {An Adaptive Object-Model is a system that represents classes, attributes,
	relationships, and behavior as metadata. Consequently, the object
	model is adaptable; when the descriptive information is modified,
	the system immediately reflects those changes. This architectural
	style makes a heavy use of patterns and all the attempts to document
	it have been done using patterns. Nevertheless, the patterns used
	to document AOMs are written using different templates and styles.
	Also many of the patterns have not been written yet or are incomplete.
	This poster session will present a more comprehensive and homogeneous
	pattern language for describing this kind of architectural style
	with the ultimate goal being to facilitate the creation of these
	types of systems.},
  affiliation = {ONO (Cableuropa S.A.U.), Madrid, Spain; Refactory, Urbana, IL, United
	States; Wirfs-Brock and Associates, Sherwood, OR, United States;
	University of Illinois at Urbana-Champaign, Urbana, IL, United States},
  author_keywords = {Adaptive object models; Business modeling; Domain modeling; Domain
	specific languages; Object-models; Pattern language; Patterns; Software
	engineering},
  document_type = {Conference Paper},
  journal = {Proceedings of the Conference on Object-Oriented Programming Systems,
	Languages, and Applications, OOPSLA},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-42149158222&partnerID=40&md5=178a01efcf4bc175aa7bddc78314a788}
}

@CONFERENCE{Wenzel2008831,
  author = {Wenzel, S., Kelter, U.},
  title = {Analyzing model evolution},
  year = {2008},
  pages = {831-834},
  note = {cited By (since 1996) 4},
  abstract = {Model-driven development leads to development processes in which a
	large number of different versions of models are produced. We present
	FAME, a tool environment which enables fine-grained analysis of the
	version history of a model. The tool is generic in the sense that
	it can work with various model types including UML and domain-specific
	languages.},
  affiliation = {Software Engineering Group, University of Siegen, Germany},
  author_keywords = {History analysis; Metrics; Model-driven development; Tracing},
  document_type = {Conference Paper},
  journal = {Proceedings - International Conference on Software Engineering},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-57349092142&partnerID=40&md5=0a1b2b2f511c30677d1f8e7f3e38b31c}
}

@ARTICLE{White200947,
  author = {White, J.a , Hill, J.H.a , Gray, J.b , Tambe, S.a , Gokhale, A.S.a
	, Schmidt, D.C.a },
  title = {Improving domain-specific language reuse with software product line
	techniques},
  journal = {IEEE Software},
  year = {2009},
  volume = {26},
  pages = {47-53},
  number = {4},
  note = {cited By (since 1996) 6},
  abstract = {Developing a domain-specific language (DSL) or a composition of DSLs
	to model a system concern, such as deploying and configuring software
	components to meet real-time scheduling constraints, is time consuming.
	Ideally, developers should be able to reuse DSLs and DSL compositions
	across projects to amortize development effort. Reusing DSLs is hard,
	however, because they're often designed to precisely describe a single
	domain or concern. A new approach uses techniques from software product
	lines (SPLs) to improve the reusability of a DSL, DSL composition,
	or supporting tool by providing traceability of language concepts
	to DSL design. A case study of four DSLs demonstrates the need for-and
	benefits of-applying SPL reuse techniques to DSLs. © 2009 IEEE.},
  affiliation = {Vanderbilt University's Electrical Engineering, Computer Science Department,
	Nashville, TN, United States; Computer anf Information Sciences Department,
	University of Alabama at Birmingham, Birmingham, AL, United States},
  author_keywords = {Adaptation model; Aerospace electronics; Data mining; Domain analysis;
	Domain hierarchy; Domain-specific languages; DSL; Feature models;
	Probability density function; Real time systems; Reuse; Software;
	Software engineering; Software product lines},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-67650445765&partnerID=40&md5=b612f0dc911cb5b4fb9983b40e99fc64}
}

@CONFERENCE{Whitsitt2011251,
  author = {Whitsitt, S., Sprinkle, J.},
  title = {Message modeling for the Joint Architecture for Unmanned Systems
	(JAUS)},
  year = {2011},
  pages = {251-259},
  note = {cited By (since 1996) 0},
  abstract = {The Joint Architecture for Unmanned Systems (JAUS) is a standard for
	sensing, control, and computational communication of components for
	unmanned systems. This paper presents a modeling environment capable
	of producing a domain-specific prototype of the software necessary
	for intercomputer communications. A metamodel is used to provide
	the domain-specific modeling language to model both the messages
	used in JAUS, and the shell interfaces for components that transmit
	and receive those messages. The produced artifacts are C and C++
	code that can be used in unmanned systems and simulations of such
	systems, including tests that validate the structure and behavior
	of the generated code. The generated code is compatible with standard
	JAUS implementations, and is validated using the OpenJAUS open source
	API and framework. Future work describes the second spiral of features
	and behaviors (currently in the design phase). The case study and
	test environment for the software generated by this project is an
	autonomous ground vehicle, modeled on a Ford Escape Hybrid that is
	used in laboratory experiments. © 2011 IEEE.},
  affiliation = {Department of Electrical and Computer Engineering, University of Arizona,
	Tucson, AZ, United States},
  art_number = {5934826},
  author_keywords = {Autonomous vehicles; Code generation; JAUS; Metamodeling; Model-based
	design; Unmanned systems},
  document_type = {Conference Paper},
  journal = {Proceedings - 18th IEEE International Conference and Workshops on
	Engineering of Computer-Based Systems, ECBS 2011},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-80051975879&partnerID=40&md5=fec560972c45f7bfcb57767caa10031a}
}

@CONFERENCE{Wieczorek2010292,
  author = {Wieczorek, S., Stefanescu, A., Roth, A.},
  title = {Model-driven service integration testing - A case study},
  year = {2010},
  pages = {292-297},
  note = {cited By (since 1996) 0},
  abstract = {This paper presents a case study for the modeling and model-based
	testing (MBT) of enterprise service choreographies. Our proposed
	MBT approach uses proprietary models called Message Choreography
	Models (MCM) as test models. The case study illustrates how MCM-based
	service integration testing allows to formalize design decisions
	and enables full integration into an existing industrial test infrastructure
	by using the concepts of domain specific languages and model transformations.
	Further, the MBT tools integrated into the testing framework have
	been compared based on one concrete use case. © 2010 IEEE.},
  affiliation = {SAP Research, Darmstadt, Germany},
  art_number = {5655567},
  author_keywords = {Case study; Enterprise systems; Model-based testing; Service choreographies;
	Service-oriented architecture},
  document_type = {Conference Paper},
  journal = {Proceedings - 7th International Conference on the Quality of Information
	and Communications Technology, QUATIC 2010},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-78751504082&partnerID=40&md5=4af1b798f8825d08009cd78125db4a55}
}

@CONFERENCE{Wien2010,
  author = {Wien, T.a , Reichenbach, F.a , Carlson, E.a , Stålhane, T.b },
  title = {Reducing development costs in industrial safety projects with CESAR},
  year = {2010},
  note = {cited By (since 1996) 0},
  abstract = {The demand for high Safety levels in industrial applications is growing.
	New certification and documentation requirements increase the product
	cost significantly. New or improved methods for high level specification
	and design may help to do part of the development process more automatically.
	In the CESAR project ABB, NTNU and SINTEF investigates if the Boiler
	Plate and Domain Specific Language approach for specification can
	be used to facilitate automatic generation of safety code and help
	to automatically document the process as required for safety authorization.
	©2010 IEEE.},
  affiliation = {ABB Corporate Research, Norway; NTNU, 7491, Trondheim, Norway},
  art_number = {5641070},
  document_type = {Conference Paper},
  journal = {Proceedings of the 15th IEEE International Conference on Emerging
	Technologies and Factory Automation, ETFA 2010},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-78650525969&partnerID=40&md5=8ba11c92d299c002c11383da438a3da3}
}

@ARTICLE{Wienands2009453,
  author = {Wienands, C., Golm, M.},
  title = {Anatomy of a visual domain-specific language project in an industrial
	context},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2009},
  volume = {5795 LNCS},
  pages = {453-467},
  note = {cited By (since 1996) 0},
  abstract = {Domain-specific languages (DSL) are specialized modeling languages
	targeting a narrow domain. In this paper, we present the results
	of a research project on visual DSLs set in an industrial context,
	using the domain of elevator controllers. After domain analysis and
	inception of new, abstract modeling concepts a language prototype
	was developed, considering aspects such as usability, combination
	of visual and textual DSLs, and performance of generated code. We
	describe the challenges encountered during the project, such as defining
	a user-friendly concrete syntax or tool limitations, and analyze
	them in retrospective. The paper concludes with several metrics to
	support the findings. © 2009 Springer Berlin Heidelberg.},
  affiliation = {Siemens Corporate Research, 755 College Rd East, Princeton, NJ 08540,
	United States},
  author_keywords = {Code generation; Domain-specific language; Textual; Visual},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-77249109992&partnerID=40&md5=11234c74b93a8f236fbce4af6bc9d8ef}
}

@ARTICLE{Wile2004265,
  author = {Wile, D.},
  title = {Lessons learned from real DSL experiments},
  journal = {Science of Computer Programming},
  year = {2004},
  volume = {51},
  pages = {265-290},
  number = {3},
  note = {cited By (since 1996) 9},
  abstract = {Over the years, our group, led by Bob Balzer, designed and implemented
	three domain-specific languages for use in real applications. Each
	was invented to "showcase" DSL language design and implementation
	technology that was the focus of our then-current research. Each
	of these was actually a prototype for what would have taken more
	time to engineer and polish before putting into practice. Although
	each effort was essentially successful, none of the languages was
	ever followed up with the subsequent engineering efforts that we
	expected or at least hoped for. Herein I elaborate where these language
	efforts succeeded and where they failed, gleaning lessons for others
	who take the somewhat risky step of committing to develop a DSL for
	a particular user community. © 2004 Elsevier B.V. All rights reserved.},
  affiliation = {Teknowledge Corporation, 4640 Admirality Way, Marina del Rey, CA 90292,
	United States},
  author_keywords = {Domain-specific language; Experience report; Graphical language; Lessons
	learned; Program generation},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-2442541287&partnerID=40&md5=99af0d6e448ab3fc106c68943d1982f7}
}

@ARTICLE{Wile2003209,
  author = {Wile, D.S.},
  title = {Revealing component properties through architectural styles},
  journal = {Journal of Systems and Software},
  year = {2003},
  volume = {65},
  pages = {209-214},
  number = {3},
  note = {cited By (since 1996) 4},
  abstract = {An underlying assumption in even using the phrase "component certification
	and system prediction" is that an understanding of individual components'
	properties will lead to an understanding of a system's properties
	by some form of compositional reasoning. Unfortunately, standard
	analytical composition techniques suffer from two problems: (1) they
	require that the internal structure of components be revealed in
	order to reason about them and (2) they deal clumsily with properties
	that require analysis of patterns of interaction. Here, based on
	the observation that a formal software architecture description itself
	is a constructive composition mechanism, I illustrate how the use
	of software architecture styles can sometimes alleviate the first
	problem and solve the latter. © 2002 Elsevier Science Inc. All rights
	reserved.},
  affiliation = {Teknowledge Corporation, 4640 Admiralty Way, Marina del Rey, CA 90292,
	United States},
  author_keywords = {Analytical composition; Architecture style; Components; Constructive
	composition; Domain-specific languages; Software architecture},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-0037507572&partnerID=40&md5=be7a7c631972c3c0544137e3ee6e7f29}
}

@CONFERENCE{Wile1997472,
  author = {Wile, David S.},
  title = {Abstract syntax from concrete syntax},
  year = {1997},
  pages = {472-480},
  note = {cited By (since 1996) 17},
  abstract = {Modern Software Engineering practice advocates the development of
	domain-specific specification languages to characterize formally
	the idioms of discourse and jargon of specific problem domains. With
	poorly-understood domains it is best to construct an abstract syntax
	to characterize the domain concepts and abstractions before developing
	a concrete syntax. Often, however, a good concrete syntax exists
	a priori: sometimes in sophisticated formal languages characterizing
	(often mathematical) domains but more often in miniature, legacy-code
	languages, sorely in need of reverse engineering. In such cases,
	it is necessary to derive an appropriate abstract syntax - or its
	first cousin, an object-oriented model - from the concrete syntax.
	This report describes a transformation process that produces a good
	abstract representation from a low-level concrete syntax specification.},
  affiliation = {Univ of Southern California, Marina del Rey, United States},
  document_type = {Conference Paper},
  journal = {Proceedings - International Conference on Software Engineering},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-0030615524&partnerID=40&md5=e6f5e7ff2e8565214f141015fff3280f}
}

@ARTICLE{Wilke2010361,
  author = {Wilke, C., Thiele, M., Wende, C.},
  title = {Extending variability for OCL interpretation},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2010},
  volume = {6394 LNCS},
  pages = {361-375},
  number = {PART 1},
  note = {cited By (since 1996) 0},
  abstract = {In recent years, OCL advanced from a language used to constrain UML
	models to a constraint language that is applied to various modelling
	languages. This includes Domain Specific Languages (DSLs) and meta-modelling
	languages like MOF or Ecore. Consequently, it is rather common to
	provide variability for OCL parsers to work with different modelling
	languages. A second variability dimension relates to the technical
	space that models are realised in. Current OCL interpreters do not
	support such variability as their implementation is typically bound
	to a specific technical space like Java, Ecore, or a specific model
	repository. In this paper we propose a generic adaptation architecture
	for OCL that hides models and model instances behind well-defined
	interfaces. We present how the implementation of such an architecture
	for DresdenOCL enables reuse of the same OCL interpreter for various
	technical spaces and evaluate our approach in three case studies.
	© 2010 Springer-Verlag.},
  affiliation = {Technische Universität Dresden, Department of Computer Science, Institute
	for Software and Multimedia Technology, Germany},
  author_keywords = {Adaptation; Constraint Interpretation; MDSD; Modelling; OCL; OCL Infrastructure;
	OCL Tool; Technological Spaces; Variability},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-78349272824&partnerID=40&md5=c8ca46a73c656461936e643e2c2161dc}
}

@ARTICLE{Williams2011112,
  author = {Williams, J.R., Poulding, S., Rose, L.M., Paige, R.F., Polack, F.A.C.},
  title = {Identifying desirable game character behaviours through the application
	of evolutionary algorithms to model-driven engineering metamodels},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2011},
  volume = {6956 LNCS},
  pages = {112-126},
  note = {cited By (since 1996) 0},
  abstract = {This paper describes a novel approach to the derivation of model-driven
	engineering (MDE) models using metaheuristic search, and illustrates
	it using a specific engineering problem: that of deriving computer
	game characters with desirable properties. The character behaviour
	is defined using a human-readable domain-specific language (DSL)
	that is interpreted using MDE techniques. We apply the search to
	the underlying MDE metamodels, rather than the DSL directly, and
	as a result our approach is applicable to a wide range of MDE models.
	An implementation developed using the Eclipse Modeling Framework,
	the most widely-used toolset for MDE, is evaluated. The results demonstrate
	not only the derivation of characters with the desired properties,
	but also the identification of unexpected features of the behavioural
	description language and the game itself. © 2011 Springer-Verlag.},
  affiliation = {Department of Computer Science, University of York, United Kingdom},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-80052897216&partnerID=40&md5=c11eb6691be833f17bbe385ffe23fec4}
}

@CONFERENCE{Wills2005311,
  author = {Wills, A.C.a , Kelly, S.b },
  title = {Agile development with Domain Specific Languages scaling up Agile
	- Is Domain-Specific Modeling the key?},
  year = {2005},
  volume = {3556},
  pages = {311-314},
  note = {cited By (since 1996) 0},
  abstract = {This workshop will investigate the application of Domain Specific
	Languages within Agile development. A Domain Specific Language (DSL)
	is designed to express the requirements and solutions of a particular
	business or architectural domain. SQL, GUI designers, workflow languages
	and regular expressions are familiar examples. In recent years, Domain-Specific
	Modeling has yielded spectacular productivity improvements in domains
	such as telephony and embedded systems. By creating graphical or
	textual languages specific to the needs of an individual project
	or product line within one company, DSM offers maximum agility. With
	current tools, creating a language and related tool support is fast
	enough to make DSM a realistic possibility for projects of all sizes.
	© Springer-Verlag Berlin Heidelberg 2005.},
  affiliation = {Microsoft; MetaCase},
  document_type = {Conference Paper},
  journal = {Lecture Notes in Computer Science},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-26444464829&partnerID=40&md5=380282da81ac7e9b11249e341963d712}
}

@ARTICLE{Winter2009219,
  author = {Winter, V.a , Kniesel, G.b , Siy, H.a , Zand, M.a },
  title = {Making aspect-orientation accessible through syntax-based language
	composition},
  journal = {IET Software},
  year = {2009},
  volume = {3},
  pages = {219-237},
  number = {3},
  note = {cited By (since 1996) 0},
  abstract = {A generic syntax-based approach is presented by which a fixed set
	of aspect-oriented features belonging to an aspect language family
	LA can be applied to a domain-specific language (DSL). The approach
	centres on the construction of a grammar in which a predefined and
	fixed set of abstract join points and join point environments are
	linked with their concrete counterparts within the DSL. This connection
	enables the behaviour of static weaving to be expressed in a generic
	manner. The resulting framework is one in which aspect orientation
	is accessible to non-experts across a wide spectrum of abstractions.
	© The Institution of Engineering and Technology 2009.},
  affiliation = {Department of Computer Science, University of Nebraska at Omaha, Omaha,
	NE 68182, United States; Department of Computer Science III, University
	of Bonn, Römerstrassse 164, Bonn D-53117, Germany},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-67449167734&partnerID=40&md5=2e3dc506e9fcaac5e6b1f414f3bb689c}
}

@CONFERENCE{Winter2007185,
  author = {Winter, V.L., Mametjanov, A.},
  title = {Generative programming techniques for Java library migration},
  year = {2007},
  pages = {185-196},
  note = {cited By (since 1996) 0},
  abstract = {Embedded systems can be viewed as scaled-down versions of their stand-alone
	counterparts. In many cases, the software abstractions and libraries
	for embedded systems can be derived from libraries for stand-alone
	systems. One such example is the Java library for Java Virtual Machines.
	An embedded system does not always support all features as in the
	case of an embedded JVM that does not support floating-point operations.
	In such cases, an existing library needs to be migrated to the embedded
	platform. Libraries are large collections of code and manual migration
	is a daunting task. In this paper, we provide an automated approach
	to the library migration problem using program transformations. The
	solution developed in this paper enables rapid adaptation and re-targeting
	of Java libraries in the presence of evolving libraries and evolving
	embedded platforms. Copyright © 2007 ACM.},
  affiliation = {University of Nebraska, Omaha, United States},
  author_keywords = {HATS; Java libraries; Program transformation; Strategic programming;
	TL},
  document_type = {Conference Paper},
  journal = {GPCE'07 - Proceedings of the Sixth International Conference on Generative
	Programming and Component Engineering},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-38849207676&partnerID=40&md5=c8389975fd8caf8122d94b9afddcf400}
}

@CONFERENCE{Witherell2011506,
  author = {Witherell, P., Narayanan, A., Lee, J.H.},
  title = {Using metamodels to improve product models and facilitate inferencing},
  year = {2011},
  pages = {506-513},
  note = {cited By (since 1996) 0},
  abstract = {Increasing information requirements are causing domain models to become
	more complex and difficult to manage. Domain-specific languages are
	developed with consideration for domain experts, and therefore are
	meant to be domain-friendly. However, their effectiveness in domain-specific
	models, when developed for knowledge management applications, is
	often limited by their expressiveness and implementation. In this
	paper we discuss current domain modeling practices, specifically
	the use of OWL (Web Ontology Language) and SWRL (Semantic Web Rule
	Language) within the context of product development, and how they
	often do not consider their intended application. To address this,
	we (1) recommend a set of best practices to account for domain context
	while promoting application-specific domain modeling; (2) propose
	that a metamodel be used to incorporate these practices early on
	in domain modeling and review how similar information has been represented
	in the past; and (3) discuss what factors should be considered in
	the development of such a metamodel in the future. © 2011 IEEE.},
  affiliation = {National Institute of Standards and Technology, Gaithersburg, MD 20899,
	United States},
  art_number = {6061365},
  document_type = {Conference Paper},
  journal = {Proceedings - 5th IEEE International Conference on Semantic Computing,
	ICSC 2011},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-81255178537&partnerID=40&md5=7763f3fd4012bab5e82b2e167996848c}
}

@CONFERENCE{Wouters2011215,
  author = {Wouters, L.a , Gervais, M.-P.b },
  title = {xOWL an executable modeling language for domain experts},
  year = {2011},
  pages = {215-224},
  note = {cited By (since 1996) 0},
  abstract = {Nowadays, modeling complex domains such those involving the description
	of human behaviors is still a challenge. An answer is to apply the
	Domain Specific Languages principle, which advocates that Domain
	Experts should model themselves their knowledge in order to avoid
	misunderstanding or loss of information during the knowledge elicitation
	phase. But Domain Experts must then be provided a modeling language
	enabling them to describe such complex domains. Moreover, in order
	to help them build models, immediate feedbacks would have to be available
	so that they can revise their modeling choices in earlier steps.
	Model execution is a way to address this issue. We provide xOWL,
	a language that can be used as a backend for multiple domain-specific
	syntaxes enabling Domain Experts to model themselves the structural
	as well as behavioral knowledge of their domain. xOWL comes with
	an interpreter integrated in an environment offering models executability
	in such way that Domain Experts can work in an iterative and incremental
	way using a trial and error approach. The implemented prototype is
	currently in use at EADS. © 2011 IEEE.},
  affiliation = {European Aeronautic Defence and Space Company, EADS Innovation Works,
	Suresnes, France; Laboratoire D'Informatique de Paris 6 (LIP6), Université
	Paris Ouest, Paris, France},
  art_number = {6037575},
  author_keywords = {Executable models; Model-driven development; Semantic web},
  document_type = {Conference Paper},
  journal = {Proceedings - IEEE International Enterprise Distributed Object Computing
	Workshop, EDOC},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-80054923524&partnerID=40&md5=ab9a5212f4e899c01d26ac9fd88dbbf2}
}

@CONFERENCE{Wu2006772,
  author = {Wu, H.},
  title = {Grammar-driven generation of domain-specific language tools},
  year = {2006},
  volume = {2006},
  pages = {772-773},
  note = {cited By (since 1996) 1},
  abstract = {Domain-specific languages (DSLs) assist an end-user programmer in
	writing programs using idioms that are closer to the abstractions
	found in a specific problem domain. Language testing tool support
	for DSLs is lacking when compared to the capabilities provided in
	standard general purpose languages (e.g., Java and C++). For example,
	support for debugging a program written in a DSL is often nonexistent.
	This research abstract describes a grammar-driven technique to build
	a testing tool generation framework through automated transformation
	of existing DSL grammars. The modified grammars generate the hooks
	needed to interface with a supporting infrastructure written for
	an Integrated Development Environment that assists in debugging,
	testing, and profiling a DSL program.},
  affiliation = {Department of Computer and Information Science, University of Alabama
	at Birmingham, Birmingham, AL 35294-1170, United States},
  art_number = {1176718},
  author_keywords = {Debugging; DSLs; Grammar; Mapping; Testing},
  document_type = {Conference Paper},
  journal = {Proceedings of the Conference on Object-Oriented Programming Systems,
	Languages, and Applications, OOPSLA},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-34248383639&partnerID=40&md5=c2562686970a26fd0f174fc2a482870c}
}

@CONFERENCE{Wu2005436,
  author = {Wu, H., Gray, J.},
  title = {Automated generation of testing tools for domain-specific languages},
  year = {2005},
  pages = {436-439},
  note = {cited By (since 1996) 2},
  abstract = {Domain-specific languages (DSLs) assist a domain expert (or end-user)
	in writing a software program using idioms that are closer to the
	abstractions found in a specific problem domain. Language tool support
	for DSLs is lacking, however, when compared to the capabilities provided
	for standard general purpose languages (e.g., Java and C++). For
	example, support for debugging and testing a program written in a
	DSL is often nonexistent. A DSL grammar serves as the primary artifact
	for defining DSLs from a higher level of abstraction. This paper
	describes an investigation into a grammar-driven technique to build
	a testing tool from existing DSL grammars. The DSL grammars are used
	to generate the hooks needed to interface with a supporting infrastructure
	written for an Integrated Development Environment (IDE) that assists
	in debugging and testing a program written in a DSL. We describe
	a DSL framework that we have implemented to generate DSL testing
	tools (e.g., debugger and test engine). This framework demonstrates
	the feasibility and applicability of using the information derived
	from DSL grammars and existing software components and services to
	support end-user debugging and testing in a domain friendly programming
	environment. Copyright 2005 ACM.},
  affiliation = {Department of Computer and Information Science, University of Alabama
	at Birmingham, Birmingham, AL, 35294-1170, United States},
  author_keywords = {Debugging; Domain-specific languages; Grammar; Testing},
  document_type = {Conference Paper},
  journal = {20th IEEE/ACM International Conference on Automated Software Engineering,
	ASE 2005},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-67650226397&partnerID=40&md5=5768252b4856ad10eef9f3436ea7c58c}
}

@ARTICLE{Wu2009125,
  author = {Wu, H.a , Gray, J.a , Mernik, M.b },
  title = {Unit testing for domain-specific languages},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2009},
  volume = {5658 LNCS},
  pages = {125-147},
  note = {cited By (since 1996) 0},
  abstract = {Domain-specific languages (DSLs) offer several advantages by providing
	idioms that are similar to the abstractions found in a specific problem
	domain. However, a challenge is that tool support for DSLs is lacking
	when compared to the capabilities offered in general-purpose languages
	(GPLs), such as Java and C++. For example, support for unit testing
	a DSL program is absent and debuggers for DSLs are rare. This limits
	the ability of a developer to discover the existence of software
	errors and to locate them in a DSL program. Currently, software developers
	using a DSL are generally forced to test and debug their DSL programs
	using available GPL tools, rather than tools that are informed by
	the domain abstractions at the DSL level. This reduces the utility
	of DSL adoption and minimizes the benefits of working with higher
	abstractions, which can bring into question the suitability of using
	DSLs in the development process. This paper introduces our initial
	investigation into a unit testing framework that can be customized
	for specific DSLs through a reusable mapping of GPL testing tool
	functionality. We provide examples from two different DSL categories
	that serve as case studies demonstrating the possibilities of a unit
	testing engine for DSLs. © IFIP International Federation for Information
	Processing 2009.},
  affiliation = {Department of Computer and Information Sciences, University of Alabama
	at Birmingham, Birmingham, AL, United States; Faculty of Electrical
	Engineering and Computer Science, University of Maribor, Maribor,
	Slovenia},
  author_keywords = {Domain-specific languages; Tool generation; Unit testing},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-69049117368&partnerID=40&md5=d86d54a57c5e7eb055f48a1feadf2943}
}

@ARTICLE{Wu20081073,
  author = {Wu, H.a , Gray, J.a , Mernik, M.b },
  title = {Grammar-driven generation of domain-specific language debuggers},
  journal = {Software - Practice and Experience},
  year = {2008},
  volume = {38},
  pages = {1073-1103},
  number = {10},
  note = {cited By (since 1996) 12},
  abstract = {Domain-specific languages (DSLs) assist a software developer (or end-user)
	in writing a program using idioms that are similar to the abstractions
	found in a specific problem domain. Tool support for DSLs is lacking
	when compared with the capabilities provided for standard general-purpose
	languages (GPLs), such as Java and C++. For example, support for
	debugging a program written in a DSL is often non-existent. The lack
	of a debugger at the proper abstraction level limits an end-user's
	ability to discover and locate faults in a DSL program. This paper
	describes a grammar-driven technique to build a debugging tool generation
	framework from existing DSL grammars. The DSL grammars are used to
	generate the hooks needed to interface with a supporting infrastructure
	constructed for an integrated development environment that assists
	in debugging a program written in a DSL. The contribution represents
	a coordinated approach to bring essential software tools (e.g. debuggers)
	to different types of DSLs (e.g. imperative, declarative, and hybrid).
	This approach hides from the end-users the accidental complexities
	associated with expanding the focus of a language environment to
	include debuggers. The research described in this paper addresses
	a long-term goal of empowering end-users with development tools for
	particular DSL problem domains at the proper level of abstraction
	without depending on a specific GPL. Copyright © 2007 John Wiley
	& Sons, Ltd.},
  affiliation = {Department of Computer and Information Sciences, University of Alabama
	at Birmingham, Birmingham, AL 35294-1170, United States; Faculty
	of Electrical Engineering and Computer Science, University of Maribor,
	2000 Maribor, Slovenia},
  author_keywords = {Debugging; DSL; GPL; Grammars; Program environments-integrated environments},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-49749118357&partnerID=40&md5=c01c478c863887aa6dfac1e36ab1996b}
}

@CONFERENCE{Wu20051370,
  author = {Wu, H.a , Gray, J.a , Roychoudhury, S.a , Mernik, M.b },
  title = {Weaving a debugging aspect into domain-specific language grammars},
  year = {2005},
  volume = {2},
  pages = {1370-1374},
  note = {cited By (since 1996) 13},
  abstract = {A common trend in programming language specification is to generate
	various tools (e.g., compiler, editor, profiler, and debugger) from
	a grammar. In such a generative approach, it is desirable to have
	the definition of a programming language be modularized according
	to specific concerns specified in the grammar. However, it is often
	the case that the corresponding properties of the generated tools
	are scattered and tangled across the language specification. In this
	paper, separation of concerns within a programming language specification
	is demonstrated by considering debugging support within a domain-specific
	language (DSL). The paper first describes the use of AspectJ to weave
	the debugging semantics into the code created by a parser generator.
	The paper outlines several situations when the use of AspectJ is
	infeasible at separating language specification properties. To accommodate
	such situations, a second approach is presented that weaves the debugging
	support directly into a grammar specification using a program transformation
	engine. A case study for a simple DSL is presented to highlight the
	benefits of weaving across language specifications defined by grammars.
	Copyright 2005 ACM.},
  affiliation = {Department of Computer and Information Sciences, University of Alabama
	at Birmingham, Birmingham, AL 35294-1170, United States; Faculty
	of Electrical Engineering and Computer Science, University of Maribor,
	2000 Maribor, Slovenia},
  author_keywords = {AOSD; Debugging; DSLs; Grammarware},
  document_type = {Conference Paper},
  journal = {Proceedings of the ACM Symposium on Applied Computing},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-33644512390&partnerID=40&md5=6dca27ad6ddfb179f4ee4b07f2a16698}
}

@ARTICLE{Wu201016,
  author = {Wu, X.a , Bryant, B.R.b , Gray, J.b , Mernik, M.c },
  title = {Component-based LR parsing},
  journal = {Computer Languages, Systems and Structures},
  year = {2010},
  volume = {36},
  pages = {16-33},
  number = {1},
  note = {cited By (since 1996) 1},
  abstract = {A language implementation with proper compositionality enables a compiler
	developer to divide-and-conquer the complexity of building a large
	language by constructing a set of smaller languages. Ideally, these
	small language implementations should be independent of each other
	such that they can be designed, implemented and debugged individually,
	and later be reused in different applications (e.g., building domain-specific
	languages). However, the language composition offered by several
	existing parser generators resides at the grammar level, which means
	all the grammar modules need to be composed together and all corresponding
	ambiguities have to be resolved before generating a single parser
	for the language. This produces tight coupling between grammar modules,
	which harms information hiding and affects independent development
	of language features. To address this problem, we have developed
	a novel parsing algorithm that we call Component-based LR (CLR) parsing,
	which provides code-level compositionality for language development
	by producing a separate parser for each grammar component. In addition
	to shift and reduce actions, the algorithm extends general LR parsing
	by introducing switch and return actions to empower the parsing action
	to jump from one parser to another. Our experimental evaluation demonstrates
	that CLR increases the comprehensibility, reusability, changeability
	and independent development ability of the language implementation.
	Moreover, the loose coupling among parser components enables CLR
	to describe grammars that contain LR parsing conflicts or require
	ambiguous token definitions, such as island grammars and embedded
	languages. © 2009 Elsevier Ltd. All rights reserved.},
  affiliation = {Bank of America Corporation, CH20, 4500 Park Granada, Calabasas, CA
	91302, United States; The University of Alabama at Birmingham, Department
	of Computer and Information Sciences, 115A Campbell Hall, 1300 University
	Boulevard, Birmingham, AL 35294-1170, United States; University of
	Maribor, Faculty of Electrical Engineering and Computer Science,
	Smetanova ulica 17, 2000 Maribor, Slovenia},
  author_keywords = {Component-based software development; LR parsing; Parser generator},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-70349114226&partnerID=40&md5=23bd7e65f88e7f1e6561cdb51da3ef25}
}

@CONFERENCE{Wu201112,
  author = {Wu, X.a , Mueller, F.a , Pakin, S.b },
  title = {Automatic generation of executable communication specifications from
	parallel applications},
  year = {2011},
  pages = {12-21},
  note = {cited By (since 1996) 1},
  abstract = {Portable parallel benchmarks are widely used and highly effective
	for (a) the evaluation, analysis and procurement of high-performance
	computing (HPC) systems and (b) quantifying the potential benefits
	of porting applications for new hardware platforms. Yet, past techniques
	to synthetically parametrized hand-coded HPC benchmarks prove insufficient
	for today's rapidly-evolving scientific codes particularly when subject
	to multi-scale science modeling or when utilizing domain-specific
	libraries. To address these problems, this work contributes novel
	methods to automatically generate highly portable and customizable
	communication benchmarks from HPC applications. We utilize ScalaTrace,
	a lossless, yet scalable, parallel application tracing framework
	to collect selected aspects of the run-time behavior of HPC applications,
	including communication operations and execution time, while abstracting
	away the details of the computation proper. We subsequently generate
	benchmarks with identical run-time behavior from the collected traces.
	A unique feature of our approach is that we generate benchmarks in
	CONCEPTUAL, a domain-specific language that enables the expression
	of sophisticated communication patterns using a rich and easily understandable
	grammar yet compiles to ordinary C+MPI. Experimental results demonstrate
	that the generated benchmarks are able to preserve the run-time behavior
	- including both the communication pattern and the execution time
	- -of the original applications. Such automated benchmark generation
	is particularly valuable for proprietary, export-controlled, or classified
	application codes: when supplied to a third party, our auto-generated
	benchmarks ensure performance fidelity but without the risks associated
	with releasing the original code. This ability to automatically generate
	performance-accurate benchmarks from parallel applications is novel
	and without any precedence, to our knowledge. © 2011 ACM.},
  affiliation = {North Carolina State University, United States; Los Alamos National
	Laboratory, United States},
  author_keywords = {application-specific benchmark generation; communication; conceptual;
	domain-specific languages; performance; scalatrace; trace compression},
  document_type = {Conference Paper},
  journal = {Proceedings of the International Conference on Supercomputing},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-79959604811&partnerID=40&md5=7beb6bd13bb90084e9a0397f70c04e38}
}

@CONFERENCE{Wu201193,
  author = {Wu, Y.a , Hernandez, F.a , Clarke, P.J.a , France, R.b },
  title = {A DSML for coordinating user-centric communication services},
  year = {2011},
  pages = {93-102},
  note = {cited By (since 1996) 0},
  abstract = {Rapid advances in electronic communication devices and technologies
	have resulted in a shift in the way communication applications are
	being developed. The emerging development strategies provide end-users
	with a greater ability to manipulate the underlying communication
	technologies by providing the appropriate level of abstraction, referred
	to as user-centric communication. In communication-intensive domains
	such as telemedicine and disaster management, the user-centric communication
	strategies still lack the ability to coordinate the various communication
	services in collaborative processes. In this paper, we present a
	domain-specific modeling language (DSML), Workflow Communication
	Modeling Language (WF-CML), that supports the rapid realization of
	collaborative user-centric communication applications. WF-CML is
	an extension of CML with communication specific abstractions of workflow
	concepts. To realize WF-CML models the dynamic synthesis process
	in the Communication Virtual Machine (CVM) prototype was extended
	to coordinate the negotiation and media transfer processes based
	on events generated during the collaboration. We also present a comparative
	study to show the advantage of using WF-CML over a general-purpose
	workflow language and execution environment. © 2011 IEEE.},
  affiliation = {School of Computing and Information Sciences, Florida International
	University, Miami, FL 33199, United States; Department of Computer
	Science, Colorado State University, Fort Collins, CO 80532, United
	States},
  art_number = {6032329},
  author_keywords = {Communication; Domain-specific modeling; Model-driven development;
	Workflow models},
  document_type = {Conference Paper},
  journal = {Proceedings - International Computer Software and Applications Conference},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-80055007131&partnerID=40&md5=fb041c879f02e6f89dd501a741eba018}
}

@ARTICLE{Wuille2011101,
  author = {Wuille, P.a , Schrijvers, T.b },
  title = {Parameterized models for on-line and off-line use},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2011},
  volume = {6559 LNCS},
  pages = {101-118},
  note = {cited By (since 1996) 0},
  abstract = {The Monadic Constraint Programming framework leverages Haskell's rich
	static type system and powerful abstraction mechanisms to implement
	an embedded domain specific language (EDSL) for constraint programming.
	In this paper we show how the same constraint model expressed in
	the EDSL can be processed in various modes by external constraint
	solvers. We distinguish between on-line and off-line use of solvers.
	In off-line mode, the model is not solved; instead it is compiled
	to lower-level code that will search for solutions when compiled
	and run. For on-line use, the search can be handled by either the
	framework or in the external solver. Off-line mode requires recompilation
	after each change to the model. To avoid repeated recompilation,
	we separate model from data by means of parameters that need not
	be known at compile time. Parametrization poses several challenges,
	which we resolve by embedding the EDSL more deeply. © 2011 Springer-Verlag.},
  affiliation = {Dept. of Computer Science, K.U. Leuven, Belgium; Dept. of Applied
	Mathematics and Computer Science, Universiteit Gent, Belgium},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-79957606076&partnerID=40&md5=9e6a88da90065a0932ffea368ecab15e}
}

@ARTICLE{Wüest2011100,
  author = {Wüest, D., Glinz, M.},
  title = {Flexible sketch-based requirements modeling},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2011},
  volume = {6606 LNCS},
  pages = {100-105},
  note = {cited By (since 1996) 0},
  abstract = {[Context and motivation] Requirements engineers and stakeholders like
	to create informal, sketchy models in order to communicate ideas
	and to make them persistent. They prefer pen and paper over current
	software modeling tools, because the former allow for any kind of
	sketches and do not break the creative flow. [Question/problem] To
	facilitate requirements management, engineers then need to manually
	transform the sketches into more formal models of requirements. This
	is a tedious, time-consuming task. Furthermore, there is a risk that
	the original intentions of the sketched models and informal annotations
	get lost in the transition. [Principal ideas/results] We present
	the idea for a seamless, tool-supported transition from informal,
	sketchy drafts to more formal models such as UML diagrams. Our approach
	uses an existing sketch recognizer together with a dynamic library
	of modeling symbols. This library can be augmented and modified by
	the user anytime during the sketching/modeling process. Thus, an
	engineer can start sketching without any restrictions, and can add
	both syntax and semantics later. Or the engineer can define a domain-specific
	modeling language with any degree of formality and adapt it on the
	fly. [Contribution] In this paper we describe how our approach combines
	the advantages of modeling with the freedom and ease of sketching
	in a way other modeling tools cannot provide. © 2011 Springer-Verlag
	Berlin Heidelberg.},
  affiliation = {Department of Informatics, University of Zurich, Switzerland},
  author_keywords = {adaptable formalization; requirements modeling; Requirements sketching},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-79953079234&partnerID=40&md5=9b38120eb6aad53a32391c86ef0a3617}
}

@CONFERENCE{Xi2010,
  author = {Xi, Q., Walker, D.},
  title = {A context-free markup language for semi-structured text},
  year = {2010},
  pages = {221-232},
  note = {cited By (since 1996) 1},
  abstract = {An ad hoc data format is any nonstandard, semi-structured data format
	for which robust data processing tools are not easily available.
	In this paper, we present ANNE, a new kind of markup language designed
	to help users generate documentation and data processing tools for
	ad hoc text data. More specifically, given a new ad hoc data source,
	an ANNE programmer edits the document to add a number of simple annotations,
	which serve to specify its syntactic structure. Annotations include
	elements that specify constants, optional data, alternatives, enumerations,
	sequences, tabular data, and recursive patterns. The ANNE system
	uses a combination of user annotations and the raw data itself to
	extract a context-free grammar from the document. This context-free
	grammar can then be used to parse the data and transform it into
	an XML parse tree, which may be viewed through a browser for analysis
	or debugging purposes. In addition, the ANNE system generates a PADS/ML
	description, which may be saved as lasting documentation of the data
	format or compiled into a host of useful data processing tools. In
	addition to designing and implementing ANNE, we have devised a semantic
	theory for the core elements of the language. This semantic theory
	describes the editing process, which translates a raw, unannotated
	text document into an annotated document, and the grammar extraction
	process, which generates a context-free grammar from an annotated
	document. We also present an alternative characterization of system
	behavior by drawing upon ideas from the field of relevance logic.
	This secondary characterization, which we call relevance analysis,
	specifies a direct relationship between unannotated documents and
	the context-free grammars that our system can generate from them.
	Relevance analysis allows us to prove important theorems concerning
	the expressiveness and utility of our system. © 2010 ACM.},
  affiliation = {Princeton University, United States},
  author_keywords = {ad hoc data; ANNE; domain-specific languages; PADS; tool generation},
  document_type = {Conference Paper},
  journal = {Proceedings of the ACM SIGPLAN Conference on Programming Language
	Design and Implementation (PLDI)},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-77954730878&partnerID=40&md5=ad51e0b3e7866d46568f0192c872d63a}
}

@ARTICLE{Xi2010221,
  author = {Xi, Q., Walker, D.},
  title = {A context-free markup language for semi-structured text},
  journal = {ACM SIGPLAN Notices},
  year = {2010},
  volume = {45},
  pages = {221-232},
  number = {6},
  note = {cited By (since 1996) 2},
  abstract = {Format for which robust data processing tools are not easily available.
	In this paper, we present ANNE, a new kind of markup language designed
	to help users generate documentation and data processing tools for
	ad hoc text data. More specifically, given a new ad hoc data source,
	an ANNE programmer edits the document to add a number of simple annotations,
	which serve to specify its syntactic structure. Annotations include
	elements that specify constants, optional data, alternatives, enumerations,
	sequences, tabular data, and recursive patterns. The ANNE system
	uses a combination of user annotations and the raw data itself to
	extract a context-free grammar from the document. This context-free
	grammar can then be used to parse the data and transform it into
	an XML parse tree, which may be viewed through a browser for analysis
	or debugging purposes. In addition, the ANNE system generates a PADS/ML
	description [19], which may be saved as lasting documentation of
	the data format or compiled into a host of useful data processing
	tools. In addition to designing and implementing ANNE, we have devised
	a semantic theory for the core elements of the language. This semantic
	theory describes the editing process, which translates a raw, unannotated
	text document into an annotated document, and the grammar extraction
	process, which generates a context-free grammar from an annotated
	document. We also present an alternative characterization of system
	behavior by drawing upon ideas from the field of relevance logic.
	This secondary characterization, which we call relevance analysis,
	specifies a direct relationship between unannotated documents and
	the context-free grammars that our system can generate from them.
	Relevance analysis allows us to prove important theorems concerning
	the expressiveness and utility of our system. Copyright © 2010 ACM.},
  affiliation = {Princeton University, United States},
  author_keywords = {Ad Hoc Data; ANNE; Domain-specific Languages; PADS; Tool Generation},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-77957582338&partnerID=40&md5=22c738ae9b3ca9756e67330cee80476f}
}

@CONFERENCE{Xia201069,
  author = {Xia, W.a b , Yao, Y.a , Mu, X.b , Wang, B.a , Xing, F.a },
  title = {Research on technologies of event graph based parallel discrete event
	simulation},
  year = {2010},
  pages = {69-74},
  note = {cited By (since 1996) 0},
  abstract = {Event Graph (EG) formalism is a simple, powerful and language-independent
	way of representing Discrete Event Simulation (DES) models. Parallel
	Discrete Event Simulation (PDES), which leverages the power of parallel
	processing, can significantly improve the performance and capacity
	of DES. However, most of the state-of-the-art parallel simulators
	are based on the logical process (LP) paradigm, and implemented in
	general purpose programming language like Java. This makes the modeling
	process more prone to error and untraceable for domain experts to
	benefit from this field. The paper presents an approach to transforming
	an EG model of a DES to an equivalent LP based model, in order to
	combine the benefit from a modeling language that uses the graphical
	advantages and the PDES of LP paradigm with performance gain. This
	work is done on a flexible modeling and simulation platform JAMES
	II. The experiments show that EG models are successfully transformed
	to LP models with domain-specific languages recognizer ANTLR, and
	this approach endows JAMES II's LP paradigm with the capacity to
	support EG based model.},
  affiliation = {School of Computer Science, National University of Defense Technology,
	Changsha, China; Xi'an Hi-tech Institute, Xi'an, China},
  art_number = {5572346},
  author_keywords = {Event graph; Logical process; Parallel discrete event simulation;
	Transformation},
  document_type = {Conference Paper},
  journal = {Proceeding - 6th International Conference on Networked Computing
	and Advanced Information Management, NCM 2010},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-77958562864&partnerID=40&md5=a9b9b4c614c232875b519336e98d1d97}
}

@ARTICLE{Xu2010192,
  author = {Xu, H.},
  title = {EriLex: An embedded domain specific language generator},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2010},
  volume = {6141 LNCS},
  pages = {192-212},
  note = {cited By (since 1996) 0},
  abstract = {EriLex is a software tool for generating support code for embedded
	domain specific languages (EDSLs). It supports specifying syntax,
	static semantics, and dynamic semantics of an EDSL, mixing the method
	chaining style and the functional nesting style in the EDSL embedding,
	and using native types and values in the EDSL. The EriLex approach
	to EDSL embedding assumes only basic object-oriented features and
	generics in the host language and does not require any particular
	technology in the definition or implementation of host languages
	and tools. The generated support code allows the EDSLs to reuse not
	only host language compilers but also host language semantic editors.
	© 2010 Springer-Verlag.},
  affiliation = {University of North Carolina at Chapel Hill, Chapel Hill, NC 27599,
	United States},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-77954754608&partnerID=40&md5=e288b8c545ab62fd3087a985da3f2329}
}

@CONFERENCE{Xu2007856,
  author = {Xu, L., Jennings, B.},
  title = {Automating the generation, deployment and application of charging
	schemes for composed IMS services},
  year = {2007},
  pages = {856-859},
  note = {cited By (since 1996) 3},
  abstract = {Providers of communications services aim to specify, realise and deploy
	services as quickly as possible in order to gain a competitive edge
	in meeting evolving consumer demands. One means of creating new service
	offerings is the composition of pre-existing services which, when
	orchestrated in a particular manner, provide novel functionality.
	Indeed, many industry analysts predict the emergence of virtual services
	providers, who do not themselves deploy and offer individual services,
	but instead orchestrate services offered by other providers. Crucial
	to the success of providers offering composed services is an efficient,
	automated process by which such services are charged and billed for.
	In this paper we present a process for automated generation of charging
	schemes for composed IMS services, based on analysis of the charging
	schemes associated with services comprising those composed services.
	Charging schemes are specified using a Domain Specific Language (DSL),
	so that they can then be mapped to platform specific representations
	that can be deployed onto one or more rating engines. Semiautomated
	configuration of charging schemes in this manner obviates the need
	for expensive manual configuration of accounting components every
	time a new composed services is specified and activated. © 2007 IEEE.},
  affiliation = {Telecommunications Software and Systems Group, Waterford Institute
	of Technology, Waterford, Ireland},
  art_number = {4258619},
  author_keywords = {Charging; Domain specific language; IMS; Multi-provider composed services;
	Service composition},
  document_type = {Conference Paper},
  journal = {10th IFIP/IEEE International Symposium on Integrated Network Management
	2007, IM '07},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-34748924579&partnerID=40&md5=3f1cf87aef8c4c994f6664b625d4a048}
}

@CONFERENCE{Xu2010815,
  author = {Xu, T.a , Santos, O.M.b , Ge, X.b , Woodcock, J.b },
  title = {Use of model transformation for the formal analysis of railway interlocking
	models},
  year = {2010},
  volume = {114},
  pages = {815-826},
  note = {cited By (since 1996) 0},
  abstract = {Model transformation is at the heart of Model-Driven Engineering (MDE).
	In MDE, the system model is specified using a modelling language,
	such as UML (Unified Modelling Language) or a DSL (Domain-Specific
	Language). Once a model is specified, executable code for a computing
	platform can be automatically generated by means of model transformation
	(code generation). Besides the support for incremental model development,
	MDE also enables the formal verification of system properties. In
	the context of safety-critical systems, such as railway interlockings,
	the system model (e.g., specified in terms of UML) can be translated
	to a formal (mathematical) language more amendable to rigorous analysis.
	This paper presents a model transformation that takes a railway interlocking
	model (specified in Executable UML (xUML)) as input and outputs a
	formal model that can be mathematically analysed. This can potentially
	bridge the gap between well-known modelling languages (such as xUML)
	and formal languages, which facilitates the systematic development
	of safety-critical systems in terms of MDE. A small xUML railway
	interlocking model is used to illustrate the proposed method. © 2010
	WIT Press.},
  affiliation = {State Key Laboratory of Rail Traffic Control and Safety, Beijing Jiaotong
	University, China; Department of Computer Science, University of
	York, United Kingdom},
  author_keywords = {executable UML (xUML); formal analysis; formal languages; model driven
	engineering (MDE); railway interlocking systems},
  document_type = {Conference Paper},
  journal = {WIT Transactions on the Built Environment},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-78649399877&partnerID=40&md5=e459219810aa70c753e5055cd8f40b97}
}

@CONFERENCE{Yamamoto2007514,
  author = {Yamamoto, H., Sumita, E.},
  title = {Bilingual cluster based models for statistical machine translation},
  year = {2007},
  pages = {514-523},
  note = {cited By (since 1996) 1},
  abstract = {We propose a domain specific model for statistical machine translation.
	It is well-known that domain specific language models perform well
	in automatic speech recognition. We show that domain specific language
	and translation models also benefit statistical machine translation.
	However, there are two problems with using domain specific models.
	The first is the data sparseness problem. We employ an adaptation
	technique to overcome this problem. The second issue is domain prediction.
	In order to perform adaptation, the domain must be provided, however
	in many cases, the domain is not known or changes dynamically. For
	these cases, not only the translation target sentence but also the
	domain must be predicted. This paper focuses on the domain prediction
	problem for statistical machine translation. In the proposed method,
	a bilingual training corpus, is automatically clustered into sub-corpora.
	Each sub-corpus is deemed to be a domain. The domain of a source
	sentence is predicted by using its similarity to the sub-corpora.
	The predicted domain (sub-corpus) specific language and translation
	models are then used for the translation decoding. This approach
	gave an improvement of 2.7 in BLEU (Papineni et al., 2002) score
	on the IWSLT05 Japanese to English evaluation corpus (improving the
	score from 52.4 to 55.1). This is a substantial gain and indicates
	the validity of the proposed bilingual cluster based models. © 2007
	Association for Computational Linguistics.},
  affiliation = {National Institute of Information and Communications Technology, ATR
	Spoken Language Communication Research Labs., 2-2-2 Hikaridai Seika-cho,
	Soraku-gun Kyoto, Japan},
  document_type = {Conference Paper},
  journal = {EMNLP-CoNLL 2007 - Proceedings of the 2007 Joint Conference on Empirical
	Methods in Natural Language Processing and Computational Natural
	Language Learning},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-77950190345&partnerID=40&md5=9c1d32670f8ba04e28c8730d24769eed}
}

@ARTICLE{Yamamoto2008588,
  author = {Yamamoto, H.a b , Sumita, E.a b },
  title = {Bilingual cluster based models for statistical machine translation},
  journal = {IEICE Transactions on Information and Systems},
  year = {2008},
  volume = {E91-D},
  pages = {588-597},
  number = {3},
  note = {cited By (since 1996) 0},
  abstract = {We propose a domain specific model for statistical machine translation.
	It is well-known that domain specific language models perform well
	in automatic speech recognition. We show that domain specific language
	and translation models also benefit statistical machine translation.
	However, there are two problems with using domain specific models.
	The first is the data sparseness problem. We employ an adaptation
	technique to overcome this problem. The second issue is domain prediction.
	In order to perform adaptation, the domain must be provided, however
	in many cases, the domain is not known or changes dynamically. For
	these cases, not only the translation target sentence but also the
	domain must be predicted. This paper focuses on the domain prediction
	problem for statistical machine translation. In the proposed method,
	a bilingual training corpus, is automatically clustered into sub-corpora.
	Each sub-corpus is deemed to be a domain. The domain of a source
	sentence is predicted by using its similarity to the sub-corpora.
	The predicted domain (sub-corpus) specific language and translation
	models are then used for the translation decoding. This approach
	gave an improvement of 2.7 in BLEU score on the IWSLT05 Japanese
	to English evaluation corpus (improving the score from 52.4 to 55.1).
	This is a substantial gain and indicates the validity of the proposed
	bilingual cluster based models. Copyright © 2008 The Institute of
	Electronics, Information and Communication Engineers.},
  affiliation = {National Institute of Communications Technology, Kyoto-fu, 619-0288,
	Japan; ATR Spoken Language Translation Research Laboratories, Kyoto-fu,
	619-0288, Japan},
  author_keywords = {Domain estimation; Domain specific model; Sentence clustering; Statistical
	machine translation},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-68149159839&partnerID=40&md5=6e1449c635e254f0ac807e49c9c37990}
}

@CONFERENCE{Yao200516,
  author = {Yao, D., Neema, S., Nordstrom, S., Ahuja, S., Shetty, S., Bapty,
	T.},
  title = {Specification and implementation of autonomic large-scale system
	behaviors using domain specific modeling language tools},
  year = {2005},
  volume = {1},
  pages = {16-22},
  note = {cited By (since 1996) 0},
  abstract = {Space applications are often highly complex systems composed of a
	large number of hardware and software components. The harsh environments
	in which the hardware operates and long mission lifetime make this
	class of systems susceptible to component failures, jeopardizing
	the success of space missions. Embedding autonomic fault-mitigation
	behaviors in the system can greatly increase the chance of mission
	success and decrease catastrophic consequences. Work at Vanderbilt
	University has resulted in a tool for designing fault-adaptive, autonomic
	systems. The tool provides an environment that supports specification
	of custom fault-adaptive behaviors and automated generation of behavior
	code. These behaviors are defined to perform application-specific
	adaptations in response to external and internal fault events. This
	paper describes the application of the tool in managing faults on
	large-scale embedded computing clusters for a high-energy physics
	instrumentation application and how this tool can be extended to
	space applications.},
  affiliation = {Institute for Software Integrated Systems, Vanderbilt University},
  author_keywords = {Autonomic systems; Fault tolerant; Large-scale embedded systems; Model
	integrated computing; Real-time; Software generation},
  document_type = {Conference Paper},
  journal = {Proceedings of the 2005 International Conference on Software Engineering
	Research and Practice, SERP'05},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-60749089010&partnerID=40&md5=bec8babca95c3dd2423f4ee297ad058f}
}

@CONFERENCE{Yazdanshenas2009146,
  author = {Yazdanshenas, A.R., Khosravi, R.},
  title = {Using domain-specific languages to describe the development viewpoint
	of software architectures},
  year = {2009},
  pages = {146-151},
  note = {cited By (since 1996) 0},
  abstract = {The developers of a system are accepted as one of the most important
	stakeholders of an Architecture Description. The Development Viewpoint
	is suggested to satisfy the needs of the developers throughout the
	development process via codeline organization descriptions, programming
	models, etc. However, the available models for such purposes, if
	any, barely cross informal natural language descriptions and checklists.
	This paper introduces the idea of enhancing the description of the
	Development viewpoint using lightweight Domain-Specific Languages
	and presents the application of such languages in two industrial
	case studies. This language enables the architect to provide the
	necessary guidelines that constrains the implementers during the
	development process and it is also used as a means to discover the
	deviation of the code from the architecture as the development goes
	on. ©2009 IEEE.},
  affiliation = {School of Electrical and Computer Engineering, University of Tehran,
	Tehran, Iran},
  art_number = {5349322},
  author_keywords = {Architectural views; Architecture conformance; Architecture description},
  document_type = {Conference Paper},
  journal = {2009 14th International CSI Computer Conference, CSICC 2009},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-74549144384&partnerID=40&md5=f275d935560cc838a69efb2d296ebe82}
}

@CONFERENCE{Yazdanshenas20091595,
  author = {Yazdanshenas, A.R., Kosravi, R.},
  title = {Using domain-specific languages to describe the development viewpoint
	of software architectures},
  year = {2009},
  pages = {1595-1596},
  note = {cited By (since 1996) 0},
  affiliation = {School of Electrical and Computer Engineering, University of Tehran,
	Iran},
  art_number = {5070863},
  document_type = {Conference Paper},
  journal = {ITNG 2009 - 6th International Conference on Information Technology:
	New Generations},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-77951105283&partnerID=40&md5=48a50703df10189e94a46841236a8a13}
}

@CONFERENCE{Ye2004221,
  author = {Ye, J.a , Loyall, J.a , Shapiro, R.a , Schantz, R.a , Neema, S.b
	, Abdelwahed, S.b , Mahadevan, N.b , Koets, M.c , Varner, D.c },
  title = {A model-based approach to designing QoS adaptive applications},
  year = {2004},
  pages = {221-230},
  note = {cited By (since 1996) 3},
  abstract = {In this paper we present a model-based approach for designing Quality
	of Service adaptive applications. We have developed a prototype Distributed
	QoS Modeling Environment (DQME) that captures important elements
	of dynamic QoS adaptation at the model level. This modeling environment
	is designed independent of, and can be integrated with, specific
	application domains to capture their QoS features and adaptation
	strategies. It combines the domain-specific modeling capability of
	the Generic Modeling Environment with the QoS adaptation mechanisms
	of the Quality Objects middleware framework. DQME captures both the
	QoS and the functional concerns of distributed real-time embedded
	systems, and provides clear separation of these two. Integrated code-synthesis
	tools facilitate code generation and model refinement. We present
	a signal analyzer case study to demonstrate the use of the DQME modeling
	tool in real world applications. © 2004 IEEE.},
  affiliation = {BBN Technologies, Cambridge, MA; Vanderbilt University, Nashville,
	TN; Southwest Research Institute, San Antonio, TX},
  document_type = {Conference Paper},
  journal = {Proceedings - Real-Time Systems Symposium},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-21644437388&partnerID=40&md5=c885b2558097e5c62f8d4c96cac6d93a}
}

@ARTICLE{Yie2010225,
  author = {Yie, A.a b , Casallas, R.a , Deridder, D.b , Wagelaar, D.b },
  title = {Deriving correspondence relationships to guide a multi-view heterogeneous
	composition},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2010},
  volume = {6002 LNCS},
  pages = {225-239},
  note = {cited By (since 1996) 0},
  abstract = {The use of several view models is a common practice to specify diverse
	concerns of a complex system. It is advantageous to use appropriate
	Domain-Specific Modeling Languages, at high-level of abstraction,
	to specify each concern. To actually produce the running application,
	it is necessary not only to transform the view-models into code,
	but also to compose them. We can establish at the high-level correspondence
	relationships between the concepts in the different concerns, but
	it is a complex task to compose the models at this level because
	we face a heterogeneous composition problem. Therefore, our strategy
	is to independently transform each view model into a common low-level
	language to perform a homogeneous composition. We create a mechanism
	to automatically derive correspondence relationships between the
	generated low-level models. These new correspondences contain the
	information to guide a homogeneous composition. © Springer-Verlag
	Berlin Heidelberg 2010.},
  affiliation = {Grupo de Construcción de Software, Universidad de los Andes, Colombia;
	Software Languages Lab., Vrije Universiteit Brussel, Belgium},
  author_keywords = {Model composition; Model driven engineering; Model transformation;
	Multi-paradigm modeling},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-78650332139&partnerID=40&md5=e88aedb798389a227ed03670611d10a3}
}

@CONFERENCE{Yoder201157,
  author = {Yoder, J.},
  title = {Rulemakers and toolmakers: Adaptive object-models as an agile division
	of labor: Ultimate Agility: Let your users do your work!},
  year = {2011},
  pages = {57-58},
  note = {cited By (since 1996) 0},
  abstract = {Agile practices liberate us from the straightjackets of top-down design.
	But, the ease with which requirements can change encourages users
	to overwhelm us with requests for features. The result: Featuritis,
	which promotes hasty construction of poorly designed software to
	support those features. The design of an expressive domain model
	might get lost in the rush to write working code. Adaptive Object-Models
	support changeable domain modules by casting business rules as interpreted
	data and representing objects, properties and relationships in external
	declarations. Now users can change the system domain models themselves
	as their business dictates without having to deal with programmers
	at all. It's the ultimate in agility!.},
  affiliation = {Refactory, Inc., 7 Florida Drive, Urbana, IL 61801, United States},
  author_keywords = {Adapting; Adaptive object-models; Agile; Architecture; Design; Domain
	specific languages; Patterns},
  document_type = {Conference Paper},
  journal = {Proceedings of the 10th International Conference on Aspect-Oriented
	Software Development Companion, AOSD.11},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-79955152717&partnerID=40&md5=ce9c4fd3cbbe9164a5ec636dc593f29c}
}

@CONFERENCE{Yoder2010319,
  author = {Yoder, J.a , Wirfs-Brock, R.b },
  title = {Rulemakers and toolmakers: Adaptive object-models as an agile division
	of labor},
  year = {2010},
  pages = {319-320},
  note = {cited By (since 1996) 0},
  abstract = {Agile practices liberate us from the straightjackets of top-down design.
	But, the ease with which requirements can change encourages users
	to overwhelm us with requests for features. The result: featuritis,
	which promotes hasty construction of poorly designed software to
	support those features. The design of an expressive domain model
	might get lost in the rush to write working code. Adaptive Object-Models
	support changeable domain modules by casting business rules as interpreted
	data and representing objects, properties and relationships in external
	declarations. Now users can change the system domain models themselves
	as their business dictates without having to deal with programmers
	at all. It's the ultimate in agility!},
  affiliation = {Refactory, Inc., United States; Wirfs-Brock Associates, United States},
  author_keywords = {Adapting; Adaptive object-models; Agile; Architecture; Design; Domain
	specific languages; Patterns},
  document_type = {Conference Paper},
  journal = {Proceedings of the ACM International Conference Companion on Object
	Oriented Programming Systems Languages and Applications Companion,
	SPLASH '10},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-78650077656&partnerID=40&md5=8313d39b3117926bdc17381cade54ddf}
}

@ARTICLE{Zanibbi2009295,
  author = {Zanibbi, R.a , Blostein, D.b , Cordy, J.R.b },
  title = {White-box evaluation of computer vision algorithms through explicit
	decision-making},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2009},
  volume = {5815 LNCS},
  pages = {295-304},
  note = {cited By (since 1996) 0},
  abstract = {Traditionally computer vision and pattern recognition algorithms are
	evaluated by measuring differences between final interpretations
	and ground truth. These black-box evaluations ignore intermediate
	results, making it difficult to use intermediate results in diagnosing
	errors and optimization. We propose "opening the box," representing
	vision algorithms as sequences of decision points where recognition
	results are selected from a set of alternatives. For this purpose,
	we present a domain-specific language for pattern recognition tasks,
	the Recognition Strategy Language (RSL). At run-time, an RSL interpreter
	records a complete history of decisions made during recognition,
	as it applies them to a set of interpretations maintained for the
	algorithm. Decision histories provide a rich new source of information:
	recognition errors may be traced back to the specific decisions that
	caused them, and intermediate interpretations may be recovered and
	displayed. This additional information also permits new evaluation
	metrics that include false negatives (correct hypotheses that the
	algorithm generates and later rejects), such as the percentage of
	ground truth hypotheses generated (historical recall), and the percentage
	of generated hypotheses that are correct(historical precision). We
	illustrate the approach through an analysis of cell detection in
	two published table recognition algorithms. © 2009 Springer-Verlag
	Berlin Heidelberg.},
  affiliation = {Dept. Computer Science, Rochester Institute of Technology, Rochester,
	NY 14623-5608, United States; School of Computing, Queen's University,
	Kingston, ON K7L 3N6, Canada},
  author_keywords = {Document Recognition; Domain-Specific Languages; Performance Evaluation;
	Scripting Languages; Table Recognition},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-71549128414&partnerID=40&md5=8e429be0ff62724a7c9d1e5206f82f49}
}

@ARTICLE{Zanolin2010473,
  author = {Zanolin, L.a , Mascolo, C.b , Emmerich, W.c },
  title = {Model checking programmable router configurations},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2010},
  volume = {5765 LNCS},
  pages = {473-491},
  note = {cited By (since 1996) 0},
  abstract = {Programmable networks offer the ability to customize router behaviour
	at run time, thus increasing flexibility of network administration.
	Programmable network routers are configured using domain-specific
	languages. In this paper, we describe our approach to defining the
	syntax and semantics of such a domain-specific language. The ability
	to evolve router programs dynamically creates potential for misconfigurations.
	By exploiting domain-specific abstractions, we are able to translate
	router configurations into Promela and validate them using the Spin
	model checker, thus providing reasoning support for our domain-specific
	language. To evaluate our approach we use our configuration language
	to express the IETF's Differentiated Services specification and show
	that industrial-sized DiffServ router configurations can be validated
	using Spin on a standard PC. © 2010 Springer-Verlag Berlin Heidelberg.},
  affiliation = {Google UK Ltd, 76 Buckingham Palace Road, London SW1W 9TQ, United
	Kingdom; Computer Laboratory, University of Cambridge, 15 JJ Thomson
	Avenue, Cambridge CB3 0FD, United Kingdom; Dept. of Computer Science,
	University College London, Gower Street, London WC1E 6BT, United
	Kingdom},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-78649515112&partnerID=40&md5=b501dd29b9bca484479481d6bc35d1d6}
}

@CONFERENCE{Zarraonandia200945,
  author = {Zarraonandia, T., Díaz, P., Guerra, E., Vargas, M.R.R., Aedo, I.},
  title = {A framework for the multi-disciplinary design of Web-based educational
	systems},
  year = {2009},
  pages = {45-49},
  note = {cited By (since 1996) 0},
  abstract = {The communication and the collaboration in a multi-disciplinary team
	can be diminished due to the different specification tools and languages
	used by the diverse members of the team. The MODUWEB approach tackles
	this problem allowing the integration of different design perspectives
	through Model-Driven Development (MDD) techniques. Such integration
	is completely transparent to the users of the modeling languages,
	that is, the designers of the web-based educational systems, and
	in this way their productivity is not affected. This paper describes
	a prototype of a system which implements the MODUWEB approach to
	combine two domain specific languages dealing with different perspectives
	of the design of a Web-based educational system: IMS Learning Design
	for educational design and Labyrinth for web design. © 2009 IEEE.},
  affiliation = {Computer Science Department, Universidad Carlos III de Madrid, Spain},
  art_number = {5194159},
  document_type = {Conference Paper},
  journal = {Proceedings - 2009 9th IEEE International Conference on Advanced
	Learning Technologies, ICALT 2009},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-70449381411&partnerID=40&md5=c5f1d8c13477460ab958bfd6a61298da}
}

@CONFERENCE{Zave2009,
  author = {Zave, P., Bond, G.W., Cheung, E., Smith, T.M.},
  title = {Abstractions for programming SIP back-to-back user agents},
  year = {2009},
  note = {cited By (since 1996) 0},
  abstract = {In SIP services, back-to-back user agents (B2BUAs) are powerful but
	difficult to program correctly. StratoSIP is a highlevel, domain-specific
	language for programming SIP B2BUAs safely. This paper describes
	the four major abstractions on which the language is based. It explains
	how each abstraction is used in programming, and how it is implemented
	in SIP. Because the abstractions are derived from the Distributed
	Feature Composition (DFC) architecture, StratoSIP programs compose
	easily with each other at runtime. The implementation of StratoSIP
	runs in SIP Servlet containers. Copyright 2009 ACM.},
  affiliation = {AT and T Laboratories-Research, United States},
  art_number = {11},
  document_type = {Article},
  journal = {IPTComm 2009: Services and Security for Next Generation Networks
	- Proceedings of the 3rd International Conference on Principles,
	Systems and Applications of IP Telecommunications},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-77953789324&partnerID=40&md5=b3261e10bb6a4f6f76ed207daefa859d}
}

@CONFERENCE{Zein2009,
  author = {Zein, O.K.a , Champeau, J.a , Kerjean, D.a , Auffret, Y.b },
  title = {Smart sensor metamodel for deep sea observatory},
  year = {2009},
  note = {cited By (since 1996) 0},
  abstract = {Deep sea observatories, based on sensor networks, provide new features
	to the ocean survey like a continuous observation of the ocean. The
	sensors used in these observatories provide environment data and
	also insure new functionalities or services due to the permanent
	running of this network. The nominal behavior of each sensor must
	be extended to feet with this concept of deep sea observatory. So
	in this paper, we present our smart sensor metamodeling approach
	for deep sea-observatory. This work aims at specifying a Domain Specific
	Language (DSL) dedicated to smart sensor networks in a goal to model
	the behavior of the sensor and to produce automaticaly the software
	which is embedded in the network infrastructure. This DSL includes
	three modeling levels of smart sensor: static properties, interface
	and behavior. The sensor interface provides to observers and scientific
	researchers a set of services dedicated to ocean measures that the
	sensor can do, based on internal or external event detections. The
	sensor behavior permits observers to know how the sensor behaves.
	©2009 IEEE.},
  affiliation = {ENSIETA, 2 rue Francois Verny, 29806 Brest Cedex, France; IFREMER,
	Centre de Brest, BP 70, 29280 Plouzane Cedex, France},
  art_number = {5278105},
  author_keywords = {Deep-sea observatory; Event detection; Sensor description; Sensor
	metamodeling},
  document_type = {Conference Paper},
  journal = {OCEANS '09 IEEE Bremen: Balancing Technology with Future Needs},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-71249135911&partnerID=40&md5=66552158eeb2edaf7302775504084b96}
}

@ARTICLE{Zeng2006103,
  author = {Zeng, J.a , Mitchell, C.b , Edwards, S.A.c },
  title = {A Domain-Specific Language for Generating Dataflow Analyzers},
  journal = {Electronic Notes in Theoretical Computer Science},
  year = {2006},
  volume = {164},
  pages = {103-119},
  number = {2 SPEC. ISS.},
  note = {cited By (since 1996) 2},
  abstract = {Dataflow analysis is a well-understood and very powerful technique
	for analyzing programs as part of the compilation process. Virtually
	all compilers use some sort of dataflow analysis as part of their
	optimization phase. However, despite being well-understood theoretically,
	such analyses are often difficult to code, making it difficult to
	quickly experiment with variants. To address this, we developed a
	domain-specific language, Analyzer Generator (AG), that synthesizes
	dataflow analysis phases for Microsoft's Phoenix compiler framework.
	AG hides the fussy details needed to make analyses modular, yet generates
	code that is as efficient as the hand-coded equivalent. One key construct
	we introduce allows IR object classes to be extended without recompiling.
	Experimental results on three analyses show that AG code can be one-tenth
	the size of the equivalent handwritten C++ code with no loss of performance.
	It is our hope that AG will make developing new dataflow analyses
	much easier. © 2006 Elsevier B.V. All rights reserved.},
  affiliation = {Department of Computer Science, Columbia University, NY, United States;
	Microsoft Corporation, Redmond, WA, United States; Department of
	Computer Science, Columbia University, NY, United States},
  author_keywords = {compiler; Dataflow analysis; Domain-specific language; dynamic class
	extension; Phoenix compiler framework},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-33750054397&partnerID=40&md5=6f3aea01f8f5aa6505e3cf4f1d5e73d1}
}

@CONFERENCE{Zhang2006545,
  author = {Zhang, C.a , Bakshi, A.a , Prasanna, V.a , Da Sie, W.b },
  title = {Towards a model-based application integration framework for smart
	oilfields},
  year = {2006},
  pages = {545-550},
  note = {cited By (since 1996) 1},
  abstract = {The increasing demand for cost-effective oil and gas production has
	led to an industry-wide push to develop smart oilfields for the future.
	Applications for smart oilfields are characterized with heterogeneous
	data and resources, complicated business processes, and changing
	business requirements from users. Existing software development process
	and techniques have become increasingly incapable of managing such
	complex software systems. Model-based integration frameworks are
	based on a domain-specific modeling language and a common model database.
	They offer the benefits of extensibility, modularity, and resuability
	of both code and design to the applications. In this paper, we describe
	a prototype integration framework for a class of oilfield applications.
	To demonstrate the advantages of the integration framework, we will
	show how applications are developed and integrated in the framework
	in a systematic manner. © 2006 IEEE.},
  affiliation = {EE-Systems, USC, Los Angeles, CA 90089; Chevron, San Ramon, CA 94583},
  art_number = {4018549},
  document_type = {Conference Paper},
  journal = {Proceedings of the 2006 IEEE International Conference on Information
	Reuse and Integration, IRI-2006},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-34547443912&partnerID=40&md5=e3cb08c7f6b4d2d450cfd79d4e8981a9}
}

@ARTICLE{Zhang2006209,
  author = {Zhang, H., Bradbury, J.S., Cordy, J.R., Dingel, J.},
  title = {Using source transformation to test and model check implicit-invocation
	systems},
  journal = {Science of Computer Programming},
  year = {2006},
  volume = {62},
  pages = {209-227},
  number = {3},
  note = {cited By (since 1996) 1},
  abstract = {In this paper we present a source transformation-based framework to
	support uniform testing and model checking of implicit-invocation
	software systems. The framework includes a new domain-specific programming
	language, the Implicit-Invocation Language (IIL), explicitly designed
	for directly expressing implicit-invocation software systems, and
	a set of formal rule-based source transformation tools that allow
	automatic generation of both executable and formal verification artifacts.
	We provide details of these transformation tools, evaluate the framework
	in practice, and discuss the benefits of formal automatic transformation
	in this context. Our approach is designed not only to advance the
	state-of-the-art in validating implicit-invocation systems, but also
	to further explore the use of automated source transformation as
	a uniform vehicle to assist in the implementation, validation and
	verification of programming languages and software systems in general.
	© 2006.},
  affiliation = {School of Computing, Queen's University, Kingston, Canada},
  author_keywords = {Domain-specific language; Implicit invocation; Model checking; Source
	transformation; Testing; Verification},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-33746596176&partnerID=40&md5=bd03251c57f3a2070d20584dde99d9e2}
}

@ARTICLE{Zhang200360,
  author = {Zhang, Q.-L.a , Zhu, M.-Y.a , Chen, S.-Y.b },
  title = {Automatic generation of device drivers},
  journal = {ACM SIGPLAN Notices},
  year = {2003},
  volume = {38},
  pages = {60-69},
  number = {6},
  note = {cited By (since 1996) 5},
  abstract = {This paper proposes a new approach to resolve the problem of device
	driver development: To design a domain specific language, named DEVIL+.
	With this language, users can write a complete device driver, including:
	interrupt handler, timer controller, logic controller and so on.
	DEVIL+ allows a description to be checked for consistency and completeness.
	This not only improves the safety of the device driver but also uncovers
	bugs as early as possible in the development process.},
  affiliation = {CoreTek Systems, Inc., 1107B CEC Bldg. 6 S. Zhongguancun St, Beijing
	100086, China; Department of Computer Science, Beijing Institute
	of Technology, 7 South Zhongguancun Street, Beijing 100081, China},
  author_keywords = {Automatic generation of device driver; Language design},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-1442264259&partnerID=40&md5=649e6d89872a43d298d0641418b2f0c4}
}

@CONFERENCE{Zhang2008113,
  author = {Zhang, T.a b c , Jouault, F.c , Bézivin, J.c , Zhao, J.a b },
  title = {A MDE based approach for bridging formal models},
  year = {2008},
  pages = {113-116},
  note = {cited By (since 1996) 2},
  abstract = {Different formal methods have presented plenty of formal models for
	system specification and proof Hence the problem of bridging these
	formal models rises. MDE is a new paradigm in software engineering,
	which implements software by (meta-) modeling and model transforming.
	In this paper, we provide a MDE based approach for bridging heterogeneous
	formal models: Firstly, the heterogeneous formal models are introduced
	into MDE as domain specific languages by metamodeling. Then, transformation
	rules are built for semantics mapping. At last, model-text syntax
	rules are developed, so as to map models to programs. Our approach
	could be applied on formal models in both graphical style and grammatical
	style. A case study of bridging MARTE to LOTOS is also illustrated
	showing the validity and practicability of our approach. © 2008 IEEE.},
  affiliation = {State Key Laboratory for Novel Software Technology, Nanjing University,
	210093 Nanjing, China; Department of Computer Science and Technology,
	Nanjing University, 210093 Nanjing, China; ATLAS Team, INRIA and
	LINA, Nantes University, 44300 Nantes, France},
  art_number = {4549893},
  document_type = {Conference Paper},
  journal = {Proceedings - 2nd IFIP/IEEE International Symposium on Theoretical
	Aspects of Software Engineering, TASE 2008},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-51749119853&partnerID=40&md5=32a0653c993f31b3b6f327339209829d}
}

@CONFERENCE{Zhang200923,
  author = {Zhang, X.a , Lin, Y.b , Haugen, Ø.a c },
  title = {APRiL: A DSL for payroll reporting},
  year = {2009},
  pages = {23-32},
  note = {cited By (since 1996) 0},
  abstract = {The highly diverse payroll reporting structures within and between
	organizations pose challenges to enterprise information system vendors.
	Producing the database scripts for customized configuration of payroll
	reporting has been traditionally a costly manual process. We show
	how this process can be automated and made less error-prone and more
	user-friendly by introducing a combination of Model-Driven Development
	(MDD) and a Domain Specific Language (DSL). This paper addresses
	the development of Agresso Payroll Reporting Language (APRiL), a
	DSL to describe payroll structures and hierarchies. The language
	is supported by tailored tools created with open source technologies
	on Eclipse. We look at the potential implications of our approach
	on the development of payroll reporting system, along with its advantages
	and challenges. We also explore possible improvements and application
	of our approach in other areas of enterprise information systems.},
  affiliation = {SINTEF, Blindern, NO-0314, Oslo, Norway; Agresso R and D, Pb.4244
	Nydalen, NO-0401, Oslo, Norway; University of Oslo, Oslo, Norway},
  document_type = {Conference Paper},
  journal = {Future Trends of Model-Driven Development - Proceedings of the 1st
	International Workshop on Future Trends of Model-Driven Development
	- FTMDD 2009 In Conjunction with ICEIS 2009},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-74549155061&partnerID=40&md5=0e3d5ca2adfdaa986645b6d0baad4488}
}

@CONFERENCE{Zhang2009368,
  author = {Zhang, Z., Hu, X.},
  title = {Efficient application specification for network-on-chip exploration},
  year = {2009},
  volume = {2},
  pages = {368-371},
  note = {cited By (since 1996) 0},
  abstract = {To specify dataflow applications efficiently is one of the greatest
	challenges facing Network-on-Chip (NoC) simulation and exploration.
	BTS (Behavior-level Traffic Simulation) was proposed to specify behavior-level
	applications more efficiently than conventional message-passing programming
	model does. To alleviate the complexity in parallel programming,
	BTS has the computation tasks implemented as sequential modules with
	data shared among them. Also parameterization was proposed in BTS
	to produce pseudo messages pointing to the shared data, and to fulfill
	data-driven scheduling. As substitute for the conventional parallel
	applications, BTS-based ones inherit their computation-models and
	the underlying scheduling schemes. The pseudo messages are consistent
	with those in the ancestors in function and size. Then BTS-based
	applications and conventional ones will produce identical traffic
	and identical results for NoC simulation. Case studies showed that
	BTS may boost the application specification by reusing the existing
	sequential codes, especially domainspecific languages implemented
	as libraries of sequential subroutines. © 2009 IEEE.},
  affiliation = {School of Computer and Information, Shanghai Second Polytechnic University,
	Shanghai, China},
  art_number = {5368697},
  author_keywords = {Behavior level; Dataflow application; Network-on-chip; Simulation},
  document_type = {Conference Paper},
  journal = {3rd International Symposium on Intelligent Information Technology
	Application, IITA 2009},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-77649309928&partnerID=40&md5=23e6ebf7311b8f6eafeb505bbdd853c1}
}

@CONFERENCE{Zhao2010,
  author = {Zhao, D.-Z., Li, W., Yang, J.-Z.},
  title = {An XML-based process definition language for medical image understanding},
  year = {2010},
  volume = {1},
  pages = {V1679-V1683},
  note = {cited By (since 1996) 0},
  abstract = {Medical image understanding is a computing process of object recognition
	in medical image using computer vision, applied mathematics, signal
	analysis and artificial intelligence. This paper provides a medical
	image understanding process definition language (MPDL) which aims
	at solving the problem of object recognition in medical image and
	satisrying the requisition of stable and high precision medical image
	analysis software engineering. MPDL supports coding, debugging, maintenance
	and share of medical image understanding algorithm. A software component
	model of medical image understanding algorithm and a mechanism of
	mapping and synchronization between component and process node in
	medical image understanding process are represented. The method of
	validating a medical image understanding process definition is showed
	in addition. The rationality and applicability of this language is
	validated by a platform of medical image understanding algorithm
	development which uses MPDL. © 2010 IEEE.},
  affiliation = {Key Laboratory of Medical Image Computing, Ministry of Education,
	University of Northeastern, Shenyang, China},
  art_number = {5619267},
  author_keywords = {Algorithm component; Domain specific language; Medical image understanding;
	Process definition},
  document_type = {Conference Paper},
  journal = {ICCASM 2010 - 2010 International Conference on Computer Application
	and System Modeling, Proceedings},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-78649552818&partnerID=40&md5=9ff4b45d096cb8bebbc80d998b3dbccd}
}

@CONFERENCE{Zhao2011120,
  author = {Zhao, X., Li, X., Xu, J.},
  title = {Design of a multiple modeling language supported workflow architecture
	in educational information system},
  year = {2011},
  pages = {120-125},
  note = {cited By (since 1996) 0},
  abstract = {Using workflow system to manage some business processes is an essential
	work to do in educational information system. In this paper, the
	author bring forward a solution for building a lightweight workflow
	component in some educational information systems based on J2EE technology.
	This workflow component has general function modules of workflow
	system such as workflow engine, process manager, and application
	extensible interface. The process modeling mechanism of this workflow
	component can help us extend different process description languages
	to model business processes in different domain. So, we can build
	some specific modeling languages suitable for modeling business processes
	in educational information system. All business process models described
	by different modeling languages can be translated into execution
	models owning a kind of unified structure to be executed. Rollback
	operation of the business process also can be supported by the way
	of backward resuming the execution track of process. © 2011 IEEE.},
  affiliation = {School of Computer Science and Technology, Shandong University, Jinan,
	Shandong Province, China},
  art_number = {6028598},
  author_keywords = {business process modeling; domain specific language; workflow},
  document_type = {Conference Paper},
  journal = {ICCSE 2011 - 6th International Conference on Computer Science and
	Education, Final Program and Proceedings},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-80054018269&partnerID=40&md5=232774f158938b8efeeedcfd5ee6bba4}
}

@CONFERENCE{Zhou2008133,
  author = {Zhou, H.a , Sun, X.b , Liang, Z.a , Kang, H.a , Duan, Q.a , Yang,
	H.c },
  title = {XMML: A visual metamodeling language for domain-specific modeling
	and its application in distributed systems},
  year = {2008},
  pages = {133-139},
  note = {cited By (since 1996) 0},
  abstract = {As a practical method to simplify construction of distributed systems,
	Domain-Specific Modeling raises the level of abstraction beyond programming
	by specifying the solution directly using visual models to express
	domain concepts [1]. This paper gives a visual metamodeling language
	which is suitable for specific domain modeling, namely XMML. It supports
	development and design of Domain-Specific Modeling languages (DSMLs)
	and domain model. A formal definition method of domain rules based
	on events is proposed for domain rules modeling. The paper also gives
	a loose coupling, scalable implementation schema for visual design
	of DSMLs. Finally, gives an example used XMML for metamodeling of
	a distributed application. © 2008 IEEE.},
  affiliation = {Yunnan University, Kunming, Yunnan, 650091, China; Honghe University,
	Mengzi, Yunnan, 661100, China; De Montfort University, LE1 9BH, United
	Kingdom},
  art_number = {4683126},
  document_type = {Conference Paper},
  journal = {Proceedings of the IEEE Computer Society Workshop on Future Trends
	of Distributed Computing Systems},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-58049145169&partnerID=40&md5=0712f4a8706ce454d982e74e147536c9}
}

@ARTICLE{Zhou2011351,
  author = {Zhou, J.a b , Zhao, D.a b , Liu, J.a b },
  title = {A domain specific language for interactive enterprise application
	development},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2011},
  volume = {6988 LNCS},
  pages = {351-360},
  number = {PART 2},
  note = {cited By (since 1996) 0},
  abstract = {Web-based enterprise applications (EAs) have become the mainstream
	for business systems; however, there are enormous challenges for
	EAs development to meet the software quality and delivery deadline.
	In this paper, we propose a domain specific language, called WL4EA,
	which combines components with generative reuse and targets for popular
	application frameworks (or platform) and supports high interactivity.
	With WL4EA, an EA can be declaratively specified as some sets of
	entities, views, business objects, and data access objects. Such
	language elements will be composed according to known EA architecture
	and patterns. Such a DSL and code generation can lower the development
	complexity and error proneness and improve efficiency. © 2011 Springer-Verlag.},
  affiliation = {College of Information Science and Engineering, Northeastern University,
	110004, Shenyang, China; State Key Laboratory of Advanced Software
	Architecture (Neusoft Corporation), 110179, Shenyang, China},
  author_keywords = {Domain Specific Language; Enterprise Application; Generative Programming;
	Web Application},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-80053403955&partnerID=40&md5=c993d6cf095cd86c56c57d9eda618903}
}

@CONFERENCE{Zhu2009243,
  author = {Zhu, K.Q.a , Dantas, D.S.b , Fisher, K.c , Jia, L.b , Mandelbaum,
	Y.c , Pai, V.b , Walker, D.b },
  title = {Language support for processing distributed ad hoc data},
  year = {2009},
  pages = {243-254},
  note = {cited By (since 1996) 0},
  abstract = {This paper presents the design, theory and implementation of GLOVES1,
	a domain-specific language that allows users to specify the provenance
	(the derivation history starting from the origins), syntax and semantic
	properties of collections of distributed data sources. In particular,
	GLOVES specifications indicate where to locate desired data, how
	to obtain it, when to get it or to give up trying, and what format
	it will be in on arrival. The GLOVES system compiles such specification
	into a suite of data-processing tools including an archiver, a provenance
	tracking system, a database loading tool, an alert system, an RSS
	feed generator and a debugging tool. In addition, the system generates
	description-specific libraries so that developers can create their
	own applications. GLOVES also provides a generic infrastructure so
	that advanced users can build new tools applicable to any data source
	with a GLOVES description. We show how GLOVES may be used to specify
	data sources from two domains: CoMon, a monitoring system for PlanetLab's
	800+ nodes, and Arrakis, a monitoring system for an AT&T web hosting
	service. We show experimentally that our system can scale to distributed
	systems the size of CoMon. Finally, we provide a de-notational semantics
	for GLOVES and use this semantics to prove two important theorems.
	The first shows that our denotational semantics respects the typing
	rules for the language, while the second demonstrates that our system
	correctly maintains the provenance. Copyright © 2009 ACM.},
  affiliation = {Shanghai Jiao Tong University; Princeton University; AT and T Labs
	Research},
  author_keywords = {Languages},
  document_type = {Conference Paper},
  journal = {PPDP'09 - Proceedings of the 11th International ACM SIGPLAN Symposium
	on Principles and Practice of Declarative Programming},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-70450265495&partnerID=40&md5=15bfae1a53b975a7a9820c497ed8eceb}
}

@CONFERENCE{Zhu201085,
  author = {Zhu, K.Q.a , Fisher, K.b , Walker, D.c },
  title = {Incremental learning of system log formats},
  year = {2010},
  volume = {44},
  number = {1},
  pages = {85-90},
  note = {cited By (since 1996) 2},
  abstract = {System logs come in a large and evolving variety of formats, many
	of which are semi-structured and/or non-standard. As a consequence,
	off-the-shelf tools for processing such logs often do not exist,
	forcing analysts to develop their own tools, which is costly and
	timeconsuming. In this paper, we present an incremental algorithm
	that automatically infers the format of system log files. From the
	resulting format descriptions, we can generate a suite of data processing
	tools automatically. The system can handle large-scale data sources
	whose formats evolve over time. Furthermore, it allows analysts to
	modify inferred descriptions as desired and incorporates those changes
	in future revisions.},
  affiliation = {Shanghai Jiao Tong University, China; AT and T Labs Research, United
	States; Princeton University, United States},
  author_keywords = {Ad hoc data; Analysis of system logs; Domain-specific languages; Grammar
	induction; PADS; Parsing; Tool generation},
  document_type = {Article},
  journal = {Operating Systems Review (ACM)},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-77958144057&partnerID=40&md5=09f231b4c9cd3fd2224e1a3c926fab6e}
}

@CONFERENCE{Zhu2007797,
  author = {Zhu, L.a b , Liu, Y.a b , Bui, N.B.a b , Gorton, I.c },
  title = {Revel8or: Model driven capacity planning tool suite},
  year = {2007},
  pages = {797-800},
  note = {cited By (since 1996) 5},
  abstract = {Designing complex multi-tier applications that must meet strict performance
	requirements is a challenging software engineering problem. Ideally,
	the application architect could derive accurate performance predictions
	early in the project life-cycle, leveraging initial application design-level
	models and a description of the target software and hardware platforms.
	To this end, we have developed a capacity planning tool suite for
	component-based applications, called Revel8tor. The tool adheres
	to the model driven development paradigm and supports benchmarking
	and performance prediction for J2EE, .Net and Web services platforms.
	The suite is composed of three different tools: MDAPerf MDABench
	and DSLBench. MDAPerf allows annotation of design diagrams and derives
	performance analysis models. MDABench allows a customized benchmark
	application to be modeled in the UML 2.0 Testing Profile and automatically
	generates a deployable application, with measurement automatically
	conducted. DSLBench allows the same benchmark modeling and generation
	to be conducted using a simple performance engineering Domain Specific
	Language (DSL) in Microsoft Visual Studio. DSLBench integrates with
	Visual Studio and reuses its load testing infrastructure. Together,
	the tool suite can assist capacity planning across platforms in an
	automated fashion. © 2007 IEEE.},
  affiliation = {Empirical Software Engineering Program, National ICT Australia Ltd.;
	School of Computer Science and Engineering, University of New South
	Wales, Australia; Pacific Northwest National Laboratory},
  art_number = {4222650},
  document_type = {Conference Paper},
  journal = {Proceedings - International Conference on Software Engineering},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-34548729675&partnerID=40&md5=7ba0f810f0acf86a8ebaf3880cf98c35}
}

@ARTICLE{Zhu20071390,
  author = {Zhu, N., Grundy, J., Hosking, J., Liu, N., Cao, S., Mehra, A.},
  title = {Pounamu: A meta-tool for exploratory domain-specific visual language
	tool development},
  journal = {Journal of Systems and Software},
  year = {2007},
  volume = {80},
  pages = {1390-1407},
  number = {8},
  note = {cited By (since 1996) 7},
  abstract = {Domain-specific visual language tools have become important in many
	domains of software engineering and end user development. However
	building such tools is very challenging with a need for multiple
	views of information and multi-user support, the ability for users
	to change tool diagram and meta-model specifications while in use,
	and a need for an open architecture for tool integration. We describe
	Pounamu, a meta-tool for realising such visual design environments.
	We describe the motivation for Pounamu, its architecture and implementation
	and illustrate examples of domain-specific visual language tools
	that we have developed with Pounamu. © 2006 Elsevier Inc. All rights
	reserved.},
  affiliation = {Department of Computer Science, Department of Electrical and Computer
	Engineering, University of Auckland, Private Bag 92019, Auckland,
	New Zealand},
  author_keywords = {Domain-specific languages; Meta-CASE; Meta-tools; Visual design environments},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-34248545078&partnerID=40&md5=02c9e5be5186878a4c017f84d939ea7e}
}

@ARTICLE{Zhu2004325,
  author = {Zhu, Q.a , Gonçalves, M.A.a , Shen, R.a , Cassell, L.b , Fox, E.A.a
	},
  title = {Visual semantic modeling of digital libraries},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2004},
  volume = {2769},
  pages = {325-337},
  note = {cited By (since 1996) 0},
  abstract = {The current interest from non-experts who wish to build digital libraries
	(DLs) is strong worldwide. However, since DLs are complex systems,
	it usually takes considerable time and effort to create and tailor
	a DL to satisfy specific needs and requirements of target communities/societies.
	What is needed is a simplified modeling process and rapid generation
	of DLs. To enable this, DLs can be modeled with descriptive domain-specific
	languages. A visual tool would be helpful to non-experts so they
	may model a DL without knowing the theoretical foundations and the
	syntactic details of the descriptive language. In this paper, we
	present a domain-specific visual DL modeling tool, 5SGraph. It employs
	a metamodel that describes DLs using the 5S theory. The output from
	5SGraph is a DL model that is an instance of the metamodel, expressed
	in the 5S description language. Furthermore, 5SGraph maintains semantic
	constraints specified by the 5S metamodel and enforces these constraints
	over the instance model to ensure semantic consistency and correctness.
	5SGraph enables component reuse to reduce the time and effort of
	designers. 5SGraph also is designed to accommodate and integrate
	several other complementary tools reflecting the interdisciplinary
	nature of DLs. Thus, tools based on concept maps to fulfill those
	roles are introduced. The 5SGraph tool has been tested with real
	users and several modeling tasks in a usability experiment, and its
	usefulness and learnability have been demonstrated. © Springer-Verlag
	2003.},
  affiliation = {Department of Computer Science, Virginia Tech., Blacksburg, VA 24061,
	United States; Villanova University, Villanova, PA 19085-1699, United
	States},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-35048861396&partnerID=40&md5=1b8327f25a2878dccefaa437f56b7355}
}

@ARTICLE{Zook20041,
  author = {Zook, D., Huang, S.S., Smaragdakis, Y.},
  title = {Generating AspectJ programs with Meta-AspectJ},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2004},
  volume = {3286},
  pages = {1-18},
  note = {cited By (since 1996) 12},
  abstract = {Meta-AspectJ (MAJ) is a language tool for generating AspectJ programs
	using code templates. MAJ itself is an extension of Java, so users
	can interleave arbitrary Java code with AspectJ code templates. MAJ
	is a structured meta-programming tool: a well-typed generator implies
	a syntactically correct generated program. MAJ promotes a methodology
	that combines aspect-oriented and generative programming. Potential
	applications range from implementing domain-specific languages with
	AspectJ as a back-end to enhancing AspectJ with more powerful general-purpose
	constructs. In addition to its practical value, MAJ offers valuable
	insights to meta-programming tool designers. It is a mature meta-programming
	tool for AspectJ (and, by extension, Java): a lot of emphasis has
	been placed on context-sensitive parsing and error-reporting. As
	a result, MAJ minimizes the number of meta-programming (quote/unquote)
	operators and uses type inference to reduce the need to remember
	type names for syntactic entities. © Springer-Verlag 2004.},
  affiliation = {College of Computing, Georgia Institute of Technology, Atlanta, GA
	30332, United States},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-35048855974&partnerID=40&md5=5bf3655f3c74ba6cf558fe21904982ab}
}

@ARTICLE{Zschaler2010334,
  author = {Zschaler, S.a , Kolovos, D.S.b , Drivalos, N.b , Paige, R.F.b , Rashid,
	A.a },
  title = {Domain-specific metamodelling languages for software language engineering},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2010},
  volume = {5969 LNCS},
  pages = {334-353},
  note = {cited By (since 1996) 1},
  abstract = {Domain-specific languages are constructed to provide modelling capabilities
	tailored to a specific domain. Sometimes, languages are developed
	many times, typically to support application in a new context. In
	doing so, recurring patterns and commonalities as well as variations
	across the evolving set of languages can be identified. This paper
	introduces the concept of a domain-specific metamodelling language,
	which codifies such commonalities and provides concepts and logic
	for expressing the variations. The challenges and difficulties of
	using domain-specific metamodelling languages are identified. We
	illustrate the concept with examples from different domains. © 2010
	Springer-Verlag.},
  affiliation = {Computing Department, Lancaster University, United Kingdom; Department
	of Computer Science, University of York, United Kingdom},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-77951542786&partnerID=40&md5=c641ee78b022af55b4c2d942057597bb}
}

@ARTICLE{Zschaler201082,
  author = {Zschaler, S.a , Sánchez, P.b , Santos, J.c , Alférez, M.c , Rashid,
	A.a , Fuentes, L.b , Moreira, A.c , Araújo, J.c , Kulesza, U.c },
  title = {VML* - A family of languages for variability management in software
	product lines},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2010},
  volume = {5969 LNCS},
  pages = {82-102},
  note = {cited By (since 1996) 2},
  abstract = {Managing variability is a challenging issue in software-product-line
	engineering. A key part of variability management is the ability
	to express explicitly the relationship between variability models
	(expressing the variability in the problem space, for example using
	feature models) and other artefacts of the product line, for example,
	requirements models and architecture models. Once these relations
	have been made explicit, they can be used for a number of purposes,
	most importantly for product derivation, but also for the generation
	of trace links or for checking the consistency of a product-line
	architecture. This paper bootstraps techniques from product-line
	engineering to produce a family of languages for variability management
	for easing the creation of new members of the family of languages.
	We show that developing such language families is feasible and demonstrate
	the flexibility of our language family by applying it to the development
	of two variability-management languages. © 2010 Springer-Verlag.},
  affiliation = {Computing Department, Lancaster University, Lancaster, United Kingdom;
	Dpto. de Lenguajes Y Ciencias de la Computación, Universidad de Málaga,
	Málaga, Spain; Computer Science Department, Universidade Nova de
	Lisboa, Lisbon, Portugal},
  author_keywords = {Domain-specific languages; Family of languages; Software product lines;
	Variability management},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-77951610216&partnerID=40&md5=7503950999de4f4074bba3c5ae654e2a}
}

@ARTICLE{Zumbusch2007890,
  author = {Zumbusch, G.},
  title = {Data dependence analysis for the parallelization of numerical tree
	codes},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2007},
  volume = {4699 LNCS},
  pages = {890-899},
  note = {cited By (since 1996) 1},
  abstract = {Data dependence analysis for automatic parallelization of sequential
	tree codes is discussed. Hierarchical numerical algorithms often
	use tree data structures for unbalanced, adaptively and dynamically
	created trees. Moreover, such codes often do not follow a strict
	divide and conquer concept, but introduce some geometric neighborhood
	data dependence in addition to parent-children dependencies. Hence,
	recognition mechanisms and hierarchical partition strategies of trees
	are not sufficient for automatic parallelization. Generic tree traversal
	operators are proposed as a domain specific language. Additional
	geometric data dependence can be specified by code annotation. A
	code transformation system with data dependence analysis is implemented,
	which generates several versions of parallel codes for different
	programming models. © Springer-Verlag Berlin Heidelberg 2007.},
  affiliation = {Friedrich-Schiller-Universität Jena, Institut für Angewandte Mathematik,
	Ernst-Abbe-Platz 2, 07743 Jena, Germany},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-38049058486&partnerID=40&md5=c9cbab7156ffef62ba9cd6727052112e}
}

@CONFERENCE{Zuzarte2003652,
  author = {Zuzarte, C.a , Pirahesh, H.b , Ma, W.a , Cheng, Q.a , Liu, L.a ,
	Wong, K.a },
  title = {WinMagic: Subquery Elimination Using Window Aggregation},
  year = {2003},
  pages = {652-656},
  note = {cited By (since 1996) 3},
  abstract = {Database queries often take the form of correlated SQL queries. Correlation
	refers to the use of values from the outer query block to compute
	the inner subquery. This is a convenient paradigm for SQL programmers
	and closely mimics a function invocation paradigm in a typical computer
	programming language. Queries with correlated subqueries are also
	often created by SQL generators that translate queries from application
	domain-specific languages into SQL. Another significant class of
	queries that use this correlated subquery form is that involving
	temporal databases using SQL. Performance of these queries is an
	important consideration particularly in large databases. Several
	proposals to improve the performance of SQL queries containing correlated
	subqueries can be found in database literature. One of the main ideas
	in many of these proposals is to suitably decorrelate the subquery
	internally to avoid a tuple-at-a-time invocation of the subquery.
	Magic decorrelation is one method that has been successfully used.
	Another proposal is to cache the portion of the subquery that is
	invariant with the changing values of the outer query block. What
	we propose here is a new technique to handle some typical correlated
	queries. We go a step further than to simply decorrelate the subquery.
	By making use of extended window aggregation capabilities, we eliminate
	redundant access to common tables referenced in the outer query block
	and the subquery. This technique can be exploited even for non-correlated
	subqueries. It is possible to get a huge boost in performance for
	queries that can exploit this technique, which we call WinMagic.
	This technique was implemented in IBM® DB2® Universal Database™ Version
	7 and Version 8. In addition to improving DB2 customer queries that
	contain aggregation subqueries, it has provided significant improvements
	in a number of TPCH benchmarks that IBM has published since late
	in 2001.},
  affiliation = {IBM, 8200 Warden Ave., Markham, Ont., Canada; IBM, 650 Harry Road,
	San Jose, CA},
  document_type = {Conference Paper},
  journal = {Proceedings of the ACM SIGMOD International Conference on Management
	of Data},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-1142303673&partnerID=40&md5=38a15472d2b07d8751432937d8c9cc2d}
}

@ARTICLE{Álvarez2010601,
  author = {Álvarez, M.Á., G-Bustelo, B.C.P., Sanjuán-Martínez, O., Lovelle,
	J.M.C.},
  title = {Bridging together semantic web and model-driven engineering},
  journal = {Advances in Intelligent and Soft Computing},
  year = {2010},
  volume = {79},
  pages = {601-604},
  note = {cited By (since 1996) 0},
  abstract = {Ontologies are part of Semantic Web as models are part of Model-Driven
	Engineering, they can be seen as abstract, simplified views of the
	world. The possibility of transforming ontologies into software models,
	and vice versa, will bring both spaces together helping to achieve
	knowledge reuse. Both ontologies and models can assist in the domain
	analysis for the development of Domain-Specific Languages, so new
	transformations can be built to derivate DSLs from ontologies or
	models. This paper shows the current work in progress to build all
	these transformations and the concepts involved. © 2010 Springer-Verlag
	Berlin Heidelberg.},
  affiliation = {Department of Computer Science, Sciences Building, University of Oviedo,
	C/Calvo Sotelo s/n, Oviedo, Asturias 33007, Spain},
  author_keywords = {Domain-Specific Language; Model; Model-Driven Engineering; Ontology;
	OWL; Semantic Web; UML},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-80053010006&partnerID=40&md5=41b9fd282016568f60d647bd9df89c0e}
}

@CONFERENCE{Ålind20087,
  author = {Ålind, M., Eriksson, M.V., Kessler, C.W.},
  title = {BlockLib: A skeleton library for Cell Broadband Engine},
  year = {2008},
  pages = {7-14},
  note = {cited By (since 1996) 2},
  abstract = {Cell Broadband Engine is a heterogeneous multicore processor for high-performance
	computing and gaming. Its architecture allows for an impressive peak
	performance but, at the same time, makes it very hard to write efficient
	code. The need to simultaneously exploit SIMD instructions, coordinate
	parallel execution of the slave processors, overlap DMA memory traffic
	with computation, keep data properly aligned in memory, and explicitly
	manage the very small onchip memory buffers of the slave processors,
	leads to very complex code. In this work, we adopt the skeleton programming
	approach to abstract from much of the complexity of Cell programming
	while maintaining high performance. The abstraction is achieved through
	a library of parallel generic building blocks, called BlockLib. Macro-based
	generative programming is used to reduce the overhead of genericity
	in skeleton functions and control code size expansion. We demonstrate
	the library usage with a parallel ODE solver application. Our experimental
	results show that BlockLib code achieves performance close to hand-written
	code and even outperforms the native IBM BLAS library in cases where
	several slave processors are used. Copyright 2008 ACM.},
  affiliation = {PELAB, Dept. of Computer and Information Science, Linköping University,
	S-58183 Linköping, Sweden},
  author_keywords = {Algorithms; Languages; Performance},
  document_type = {Conference Paper},
  journal = {Proceedings - International Conference on Software Engineering},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-79959474539&partnerID=40&md5=13ddbf909ea2ce9f81089713a7cc226d}
}

@ARTICLE{Čeh2011317,
  author = {Čeh, I., Črepinšek, M., Kosar, T., Mernik, M.},
  title = {Ontology driven development of domain-specific languages},
  journal = {Computer Science and Information Systems},
  year = {2011},
  volume = {8},
  pages = {317-342},
  number = {2},
  note = {cited By (since 1996) 0},
  abstract = {Domain-specific languages (DSLs) are computer (programming, modeling,
	specification) languages devoted to solving problems in a specific
	domain. The development of a DSL includes the following phases: decision,
	analysis, design, implementation, testing, deployment, and maintenance.
	The least-known and least examined are analysis and design. Although
	various formal methodologies exist, domain analysis is still done
	informally most of the time. A common reason why formal methodologies
	are not used as often as they could be is that they are very demanding.
	Instead of developing a new, less complex methodology, we propose
	that domain analysis could be replaced with a previously existing
	analysis in another form. A particularly suitable form is the use
	of ontologies. This paper focuses on ontology-based domain analysis
	and how it can be incorporated into the DSL design phase. We will
	present the preliminary results of the Ontology2DSL framework, which
	can be used to help transform ontology to a DSL grammar incorporating
	concepts from a domain.},
  affiliation = {Faculty of Electrical Engineering and Computer Science, Smetanova
	17, 2000 Maribor, Slovenia},
  author_keywords = {Domain analysis; Domain-specific language; Ontology},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-80755163676&partnerID=40&md5=427603057c729a48ca15997ac0425671}
}

@ARTICLE{Črepinšek2010309,
  author = {Črepinšek, M.a , Kosar, T.a , Mernik, M.a , Cervelle, J.b , Forax,
	R.b , Roussel, G.b },
  title = {On automata and language based grammar metrics},
  journal = {Computer Science and Information Systems},
  year = {2010},
  volume = {7},
  pages = {309-330},
  number = {2},
  note = {cited By (since 1996) 0},
  abstract = {Grammar metrics have been introduced to measure the quality and the
	complexity of the formal grammars. The aim of this paper is to explore
	the meaning of these notions and to experiment, on several grammars
	of domain specific languages and of general-purpose languages, existing
	grammar metrics together with the new metrics that are based on grammar
	LR automaton and on the language recognized. We discuss the results
	of this experiment and focus on the comparison between grammars of
	domain specific languages as well as of general-purpose languages
	and on the evolution of the metrics between several versions of the
	same language.},
  affiliation = {University of Maribor, Faculty of Electrical Engineering and Computer
	Science, Smetanova 17, 2000 Maribor, Slovakia; Université Paris-Est,
	Laboratoire d'Informatique Gaspard-Monge, 77454 Marne-la-Vallée,
	France},
  author_keywords = {Grammar engineering; Grammar metrics; Grammarware; Software language
	engineering},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-77953900372&partnerID=40&md5=806a765d61a1c9c701dd12a9028bbc07}
}

@ARTICLE{Črepinšek200599,
  author = {Črepinšek, M.a , Mernik, M.a , Bryant, B.R.b , Javed, F.b , Sprague,
	A.b },
  title = {Inferring context-free grammars for domain-specific languages},
  journal = {Electronic Notes in Theoretical Computer Science},
  year = {2005},
  volume = {141},
  pages = {99-116},
  number = {4 SPEC. ISS.},
  note = {cited By (since 1996) 0},
  abstract = {In the area of programming languages, context-free grammars (CFGs)
	are of special importance since almost all programming languages
	employ CFG's in their design. Recent approaches to CFG induction
	are not able to infer context-free grammars for general-purpose programming
	languages. In this paper it is shown that syntax of a small domain-specific
	language can be inferred from positive and negative programs provided
	by domain experts. In our work we are using the genetic programming
	approach in grammatical inference. Grammar-specific heuristic operators
	and nonrandom construction of the initial population are proposed
	to achieve this task. Suitability of the approach is shown by examples
	where underlying context-free grammars are successfully inferred.
	© 2005 Elsevier B.V. All rights reserved.},
  affiliation = {University of Maribor, Faculty of Electrical Engineering and Computer
	Science, Smetanova 17, 2000 Maribor, Slovenia; University of Alabama
	at Birmingham, Department of Computer and Information Sciences, Birmingham,
	AL 35294-1170, United States},
  author_keywords = {Exhaustive search; Genetic programming; Grammar induction; Grammar
	inference; Learning from positive and negative examples},
  document_type = {Conference Paper},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-28444497845&partnerID=40&md5=47923afc09eaaad323e6f8b9ed3f8b76}
}

@ARTICLE{Črepinšek200539,
  author = {Črepinšek, M.a , Mernik, M.a , Javed, F.b , Bryant, B.R.b , Sprague,
	A.b },
  title = {Extracting grammar from programs: Evolutionary approach},
  journal = {ACM SIGPLAN Notices},
  year = {2005},
  volume = {40},
  pages = {39-46},
  number = {4},
  note = {cited By (since 1996) 12},
  abstract = {The paper discusses context-free grammar (CFG) inference using genetic-programming
	with application to inducing grammars from programs written in simple
	domain-specific languages. Grammar-specific heuristic operators and
	non-random construction of the initial population are proposed to
	achieve this task. Suitability of the approach is shown by small
	examples where the underlying CFG's are successfully inferred.},
  affiliation = {University of Maribor, Faculty of Electrical Engineering and Computer
	Science, Smetanova 17, 2000 Maribor, Slovenia; University of Alabama
	at Birmingham, Department of Computer and Information Sciences, Birmingham,
	AL 35294-1170, United States},
  author_keywords = {Genetic programming; Grammar induction; Grammar inference; Learning
	from positive and negative examples},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-33745174271&partnerID=40&md5=ca6d7ca1511ac82f4236f6625b73f6e7}
}

@ARTICLE{Štuikys2000325,
  author = {Štuikys, V., Ziberkas, G., Damaševičius, R.},
  title = {The Language-Centric Program Generator Models: 3L Paradigm},
  journal = {Informatica},
  year = {2000},
  volume = {11},
  pages = {325-348},
  number = {3},
  note = {cited By (since 1996) 1},
  abstract = {In this paper we suggest a three-language (3L) paradigm for building
	the program generator models. The basis of the paradigm is a relationship
	model of the specification, scripting and target languages. It is
	not necessary that all three languages would be the separate ones.
	We consider some internal relationship (roles) between the capabilities
	of a given language for specifying, scripting (gluing) and describing
	the domain functionality. We also assume that a target language is
	basic. We introduce domain architecture (functionality) with the
	generic components usually composed using the scripting and target
	languages. The specification language is for describing user's needs
	for the domain functionality to be extracted from the system. We
	present the framework for implementing the 3L paradigm and some results
	from the experimental systems developed for a validation of the approach.},
  affiliation = {Kaunas University of Technology, Studentu̧ 50, 3031 Kaunas, Lithuania},
  author_keywords = {Application domain; Domain-specific language; Generative reuse; Generic
	component; Program generator; Scripting language; Specification language;
	Target language; VHDL},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-0008396031&partnerID=40&md5=25f1929174ed39238ee135da1bac0417}
}

@ARTICLE{Živanov200841,
  author = {Živanov, Ž., Rakić, P., Hajduković, M.},
  title = {Using code generation approach in developing kiosk applications},
  journal = {Computer Science and Information Systems},
  year = {2008},
  volume = {5},
  pages = {41-59},
  number = {1},
  note = {cited By (since 1996) 3},
  abstract = {Today, kiosk automata (kiosks, for short) are used for variety of
	services: from all sort of kiosks for providing informations, to
	kiosks for paying tickets and ATM's. Kiosks are usually programmed
	either using high level programming languages, like C++, or using
	HTML in conjunction with web browser. In this paper, we analyzed
	a vast range of kiosk automata and derived common characteristics.
	We present approach for programming kiosk applications based on Domain
	Specific Language (DSL), designed specifically to meet the needs
	of developing kiosk applications that are usually programmed using
	high level programming languages and are deployed on kiosks with
	touch-screen monitors. Our goal is to make development of such kiosk
	applications more rapid, while minimizing number of programming errors.},
  affiliation = {Faculty of Technical Sciences, Trg D. Obradovića 6, 21000 Novi Sad,
	Serbia},
  author_keywords = {Code generation; Domain specific language; Kiosks; Rapid application
	development},
  document_type = {Article},
  source = {Scopus},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-70349607870&partnerID=40&md5=5601978d8c50dcb5c5245f6687dbfa85}
}

